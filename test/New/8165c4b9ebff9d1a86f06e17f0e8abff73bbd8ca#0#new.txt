[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Simulating Asteroid Impacts with a Poisson Process\n", "\n", "In this notebook, we will simulate impacts of near Earth asteroids into Earth using a Poisson process. Through this method, we can come up with a likely number of impacts during an individual's life and figure out how long it will be until the Earth is hit by a massive asteroid! "]}, {"block": 1, "type": "code", "linesLength": 23, "startIndex": 3, "lines": ["import pandas as pd\n", "import numpy as np\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 20\n", "pd.options.display.max_rows = 10\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "# Interactive plotting\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.go_offline(connected=True)\n", "cf.set_config_file(theme='pearl')\n", "\n", "# Used for calculating theoretical value\n", "from scipy.special import factorial"]}, {"block": 2, "type": "markdown", "linesLength": 15, "startIndex": 26, "lines": ["## Data on Impacts\n", "\n", "The data on impact frequency, impact energy, and number of objects is from the NASA 2017 Report of the Near Earth Object Science Definition Team. It is available [online here](https://cneos.jpl.nasa.gov/doc/2017_neo_sdt_final_e-version.pdf).\n", "\n", "![](images/impact_frequency.PNG)\n", "\n", "The average impact frequency for all asteriods is $1.66 x 10^{-9} yr^{-1}$. To get the rate per size category per year, we just multiple the impact frequency times the number of asteroids in the size category. \n", "\n", "According to the overall frequency rate, a single Near Earth Asteroid (NEA) will impact the Earth once in 600 million years. Or, if there are 600 million NEAs, there should be one collison every year. The impact frequency in a category is the rate is the Poisson equation. To get the expected number of impacts in a time period, we multiple the rate per year times the number of years. For example, we can use 100 years as a standard human lifetime and then find the number of expected asteriods in one human lifetime. We can also use the rates to find the expected waiting time between asteriod impacts in each class.\n", "\n", "### Acronyms\n", "\n", "* NEA: Near Earth Asteroid\n", "* NEO: Near Earth Object\n", "* PHA = Potentially Hazardous Asteroids"]}, {"block": 3, "type": "code", "linesLength": 5, "startIndex": 41, "lines": ["import warnings; warnings.filterwarnings('ignore', category=FutureWarning)\n", "\n", "# Read in the data\n", "df = pd.read_parquet('https://github.com/WillKoehrsen/Data-Analysis/blob/master/poisson/data/asteroid-impact-data?raw=true')\n", "df.head()"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["Let's make a quick plot of the impact energy by the range diameter. The diameters are given in kilometers. Impact energy is in Megaton Equivalent of TNT. For comparison, the Little Boy bomb dropped on Hiroshima had 15 kilotons of TNT equivalent. The largest human bomb ever developed was about 100 Megatons. (See [this Wikipedia article](https://en.wikipedia.org/wiki/TNT_equivalent#Examples))"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["### Impact Energy vs Diameter"]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 48, "lines": ["df.set_index('range_diameter')['impact_energy'].iplot(kind='bar', xTitle='Range of Diameters (KM)', \n", "                                                      yTitle='Megatons Equivalent TNT', title=\"Impact Energy vs Diameter\")"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Here's the same graph with a log scale on the y axis."]}, {"block": 8, "type": "code", "linesLength": 4, "startIndex": 51, "lines": ["df.set_index('range_diameter')['impact_energy'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(type='log', title='Megatons Equivalent TNT'),\n", "                                                                 xaxis=dict(title='Range of Diameters (KM)'),\n", "                                                      title=\"Impact Energy vs Diameter Log Scale\"))"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["That is some serious firepower. We can also look at some of the other columns, such as the number in each category."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["### Number of Asteroid in Each Category"]}, {"block": 11, "type": "code", "linesLength": 4, "startIndex": 57, "lines": ["df.set_index('range_diameter')['number'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(title='Count'),\n", "                                                                 xaxis=dict(title='Range of Diameters (KM)'),\n", "                                                      title=\"Number of Asteroids vs Diameter\"))"]}, {"block": 12, "type": "code", "linesLength": 4, "startIndex": 61, "lines": ["df.set_index('range_diameter')['number'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(type='log', title='Count'),\n", "                                                                 xaxis=dict(title='Range of Diameters (KM)'),\n", "                                                      title=\"Number of Asteroids vs Diameter Log Scale\"))"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 65, "lines": ["df['min_diameter', 'max_diameter'] = df['range_diameter'].str.split('\u2013', n=2)\n", "df"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["df['range_diameter'].iloc[0]"]}, {"block": 15, "type": "markdown", "linesLength": 5, "startIndex": 68, "lines": ["# Simulations of Impacts\n", "\n", "Here we will run 10000 simluations of a human lifetime (at 100 years). For each impact frequency, we can calculate the expected number of impacts. \n", "\n", "This is made simple through the `np.random.poisson` function which takes an expected value (`lambda`) and a `size` and returns the counts in each process. "]}, {"block": 16, "type": "code", "linesLength": 20, "startIndex": 73, "lines": ["np.random.seed(100)\n", "\n", "# Each simulation is a human lifetime\n", "simulations = 10000\n", "years = 100\n", "\n", "def simulate_impacts(years, simulations=10000):\n", "    # Empty array to hold simulations\n", "    impacts = np.zeros((len(df), simulations))\n", "    lambdas = np.zeros(len(df))\n", "\n", "    # Iterate through each frequency\n", "    for i, freq in enumerate(df['impact_frequency']):\n", "        # The expected number of impacts is the frequency times the length of time\n", "        lam = freq * years\n", "        lambdas[i] = lam\n", "        # Run simulations with a poisson process\n", "        impacts[i] = np.random.poisson(lam, simulations)\n", "        \n", "    return impacts, lambdas"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["impacts, lambdas = simulate_impacts(years, simulations)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["If we take the average value across the 10,000 simulations, we come up with an estimated number of impacts. These should be close to `lambda` for each impact frequency as `lambda` is the expected number of impacts."]}, {"block": 19, "type": "code", "linesLength": 8, "startIndex": 95, "lines": ["def plot_mean_data_and_theoretical(impacts, lambdas, ds=df['range_diameter']):\n", "    data = [go.Bar(dict(x=ds, y=impacts.mean(axis=1), name='Observed')),\n", "            go.Bar(dict(x=ds, y=lambdas, name='Theoretical'))]\n", "    layout = go.Layout(xaxis=dict(title='Diameter Range (km)'),\n", "                       yaxis=dict(title='Mean Impacts'),\n", "                      title=f'Simulated and Theoretical Asteroid Impacts in {years} Years')\n", "    figure = go.Figure(data=data, layout=layout)\n", "    return figure"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["figure = plot_mean_data_and_theoretical(impacts, lambdas)\n", "iplot(figure)"]}, {"block": 21, "type": "markdown", "linesLength": 3, "startIndex": 105, "lines": ["## Number of Impacts\n", "\n", "Let's inspect the results to see the average number of impacts per human lifetime in each diameter range. We will take the mean across all 10,000 simulations."]}, {"block": 22, "type": "code", "linesLength": 5, "startIndex": 108, "lines": ["impact_df = pd.DataFrame(impacts.T, columns=list(df['range_diameter']))\n", "\n", "# Plot the mean value in each column\n", "impact_df.mean().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Average Impacts',\n", "                      title='Average Impacts per Human Lifetime')"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["There you are! You can expect an average of 0.46 impacts of the smallest asteroid in your lifetime and 0.23 of the next largest. Remember, these are still objects that can do quite some damage."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Let's look at the maximum number of expected impacts per lifetime."]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 115, "lines": ["impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Number of Impacts per Human Lifetime')"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 117, "lines": ["If you are extremely unlucky, you might see five asteroids impacts of the smallest variey! \n", "\n", "We can also show the frequency distributions in a single category. For these, we'll show the theoretical curve derived from the Poisson Probability Mass Function (PMF because the number of events is discrete)."]}, {"block": 27, "type": "code", "linesLength": 20, "startIndex": 120, "lines": ["def plot_data_and_theoretical(diameter_range):\n", "    freq = float(df.loc[df['range_diameter'] == diameter_range, 'impact_frequency'])\n", "    lam = freq * years\n", "    \n", "    # Extract the data\n", "    data = impact_df[diameter_range]\n", "    num_events = np.arange(0, data.max() + 10, step=0.5)\n", "    \n", "    # Find the probability according to the Poisson PMF\n", "    prob_num_events = 100 * np.exp(-lam) * np.power(lam, num_events) / factorial(num_events)\n", "    \n", "    data = [go.Scatter(x=num_events, y=prob_num_events, mode='markers+lines'), \n", "            go.Histogram(dict(x=data, histnorm='percent'))]\n", "    \n", "    layout = go.Layout(xaxis=dict(title='Number of Events'), \n", "                       yaxis=dict(title='Probability (%)'),\n", "                       title=f\"Observed and Theoretical Probability of Impacts for Asteroids {diameter_range} km in Diameter\")\n", "    \n", "    figure = go.Figure(data=data, layout=layout)\n", "    return figure"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 140, "lines": ["impact_df.columns"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 141, "lines": ["figure = plot_data_and_theoretical('.0316\u2013.0398')\n", "iplot(figure)"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 143, "lines": ["figure = plot_data_and_theoretical('.0200\u2013.0251')\n", "iplot(figure)"]}, {"block": 31, "type": "markdown", "linesLength": 3, "startIndex": 145, "lines": ["# Increase Length of Simulation\n", "\n", "That is all well and good, but say we are concerned with the well-being of the entire human race. Let's increase the length of time to 2 million years, about as long as the genus homo has been around. (See [this Wikipedia article](https://en.wikipedia.org/wiki/Homo))"]}, {"block": 32, "type": "code", "linesLength": 7, "startIndex": 148, "lines": ["np.random.seed(100)\n", "\n", "# Each simulation is the entire history of the genus homo\n", "simulations = 10000\n", "years = 2000000\n", "\n", "impacts, lambdas = simulate_impacts(years, simulations)"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["Let's check the mean values against the theoretical (the expected number from lambda)."]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 156, "lines": ["figure = plot_mean_data_and_theoretical(impacts, lambdas)\n", "iplot(figure)"]}, {"block": 35, "type": "markdown", "linesLength": 3, "startIndex": 158, "lines": ["## Mean Impacts over 2 Million Years\n", "\n", "Let's again take a look at the mean number of impacts."]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 161, "lines": ["impact_df = pd.DataFrame(impacts.T, columns=list(df['range_diameter']))\n", "impact_df.mean().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Average Impacts',\n", "                      title='Average Impacts per 2 Million Years')"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 164, "lines": ["Now let's see if there are any impacts of the largest asteroids in any of the simulations."]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 165, "lines": ["impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Impacts per Million Years')"]}, {"block": 39, "type": "markdown", "linesLength": 5, "startIndex": 167, "lines": ["We do see at least one occasion in 10,000 simulations where the largest asteroid hits. This shows how lucky we humans are to be herewith no asteroids! \n", "\n", "### Simulated Data vs Theoretical \n", "\n", "Once again, we can plot the simluations of 2 million years versus the theoretical values."]}, {"block": 40, "type": "markdown", "linesLength": 6, "startIndex": 172, "lines": ["Index(['.0200\u2013.0251', '.0251\u2013.0316', '.0316\u2013.0398', '.0398\u2013.0501',\n", "       '.0501\u2013.0631', '.0631\u2013.0794', '.0784\u2013.1000', '.100\u2013.126', '.126\u2013.158',\n", "       '.158\u2013.200', '.200\u2013.251', '.251\u2013.316', '.316\u2013.398', '.398\u2013.501',\n", "       '.501\u2013.631', '.632\u2013.794', '.794\u20131.00', '1.00\u20131.26', '1.26\u20131.58',\n", "       '1.58\u20132.00', '2.00\u20132.51', '2.51\u20133.16', '3.16\u20133.98', '3.98\u20135.01',\n", "       '5.01\u20136.31', '6.31\u20137.94', '7.94\u201310.0'],"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 178, "lines": ["figure = plot_data_and_theoretical('1.58\u20132.00')\n", "iplot(figure)"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 180, "lines": ["figure = plot_data_and_theoretical('2.51\u20133.16')\n", "iplot(figure)"]}, {"block": 43, "type": "markdown", "linesLength": 3, "startIndex": 182, "lines": ["# How Long We Have to Wait for An Asteroid (Awaiting Time)\n", "\n", "Next we'll look at the average number of years between asteroid impacts of different sizes. We'll simulate 100,000,000 (100 million) years and then find the average time between impacts."]}, {"block": 44, "type": "code", "linesLength": 14, "startIndex": 185, "lines": ["# Smallest asteroids\n", "freq = df['impact_frequency'].iloc[0]\n", "lam = freq * years\n", "\n", "np.random.seed(100)\n", "\n", "# Simulate 100 million years\n", "years = 100_000_000\n", "wait_times = {}\n", "\n", "# Simulate each year individually\n", "for freq, diameter_range in zip(df['impact_frequency'], df['range_diameter']):\n", "    a = np.random.choice([0, 1], size=1000000, p=[1-freq, freq])\n", "    wait_times[diameter_range] = np.diff(np.where(a == 1)[0])"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 199, "lines": ["The wait times currently has the time between successive impacts for each size of asteroid."]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 200, "lines": ["wait_times.keys()"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 201, "lines": ["wait_times['.0200\u2013.0251']"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 202, "lines": ["wait_times['6.31\u20137.94']"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 203, "lines": ["There are zero impacts in 100 million years in that category."]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 204, "lines": ["wait_times['.0784\u2013.1000']"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 205, "lines": ["Let's take a look at plotting these wait times. We'll use a simple histogram and we can compare the simulated values to the theoretical values."]}, {"block": 52, "type": "code", "linesLength": 6, "startIndex": 206, "lines": ["diameter_range = '.0251\u2013.0316'\n", "wt_data = wait_times[diameter_range]\n", "freq = float(df.loc[df['range_diameter'] == diameter_range, \n", "                    'impact_frequency'])\n", "sim_wt = np.arange(1, wt_data.max(), step=1)\n", "expected = 100 * np.exp(-sim_wt * freq)"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 212, "lines": ["sim_wt"]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 213, "lines": ["100 * expected / expected.sum()"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 214, "lines": ["(expected / expected.sum()).sum()"]}, {"block": 56, "type": "code", "linesLength": 1, "startIndex": 215, "lines": ["1 / freq"]}, {"block": 57, "type": "code", "linesLength": 27, "startIndex": 216, "lines": ["def plot_wait_times(diameter_range, binwidth=50):\n", "    wt_data = wait_times[diameter_range]\n", "    freq = float(df.loc[df['range_diameter'] == diameter_range, \n", "                        'impact_frequency'])\n", "    \n", "    sim_wt = np.arange(0, wt_data.max(), step=1)\n", "    expected = np.exp(-sim_wt * freq)\n", "    \n", "    bins = np.arange(0, wt_data.max(), step=binwidth)\n", "    \n", "    probs = []\n", "        \n", "    for bin in bins:\n", "        probs.append(1 - (expected[sim_wt <= bin].sum() / expected.sum()))\n", "    \n", "    probs=np.array(probs)\n", "    probs /= probs.sum()\n", "    \n", "    data = [go.Histogram(dict(x=wt_data, histnorm='percent', name='Simulated', \n", "                              xbins=dict(start=0, end=wt_data.max(), size=binwidth))),\n", "            go.Scatter(dict(x=bins, y=100 * probs, name='Theoretical'))]\n", "    \n", "    layout = go.Layout(xaxis=dict(title='Waiting Time in Years'), \n", "                       yaxis=dict(title='Probability (%)'),\n", "                       title=f'Waiting Time Probabilities Observed and Theoretical for Asteroids {diameter_range} KM in Diameter')\n", "    figure = go.Figure(data=data, layout=layout)\n", "    return figure, probs"]}, {"block": 58, "type": "code", "linesLength": 3, "startIndex": 243, "lines": ["from collections import Counter\n", "counts = Counter(wait_times['.0251\u2013.0316'])\n", "counts.most_common(10)"]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["figure, probs = plot_wait_times('.0251\u2013.0316')\n", "iplot(figure)"]}, {"block": 60, "type": "code", "linesLength": 2, "startIndex": 248, "lines": ["figure, probs = plot_wait_times('.0398\u2013.0501', binwidth=200)\n", "iplot(figure)"]}]
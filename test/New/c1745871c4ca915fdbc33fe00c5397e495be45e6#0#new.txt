[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Results of Time Feature Engineering\n", "\n", "In this notebook, we'll look at the results of the time feature engineering. The purpose is to determine (if possible) the best way for encoding time and date features in a time-series problem."]}, {"block": 1, "type": "code", "linesLength": 20, "startIndex": 3, "lines": ["# Standard Data Science Helpers\n", "import numpy as np\n", "import pandas as pd\n", "import scipy\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.set_config_file(world_readable=True, theme=\"pearl\")\n", "cf.go_offline(connected=True)\n", "\n", "# Extra options\n", "pd.options.display.max_rows = 10\n", "pd.options.display.max_columns = 25\n", "# Show all code cells outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["results = pd.read_csv('results/complete_results.csv', index_col=0)\n", "results = results[(results['score'] > 0) & (np.isfinite(results['score']))]\n", "results.shape\n", "results.head()"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 27, "lines": ["building_counts = results.groupby('building_id')['method'].count()\n", "results = results.loc[~results['building_id'].isin(building_counts.index[building_counts != 10])]\n", "\n", "results.shape"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["lr = results.query('model == \"LinearRegression\"')\n", "rr = results.query('model == \"RandomForestRegressor\"')"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["lr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 34, "lines": ["rr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score').iplot(mode='markers', size=7, title=\"Random Forest Results\")"]}, {"block": 8, "type": "code", "linesLength": 7, "startIndex": 36, "lines": ["best = []\n", "for building_id, grouped in rr.groupby('building_id'):\n", "    best.append(grouped.loc[grouped['score'].idxmax(), 'method'])\n", "    \n", "    \n", "from collections import Counter\n", "Counter(best)"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["pivoted = rr.pivot_table(index='building_id', columns='method', values='score')"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 44, "lines": ["counts = np.argmax(pivoted.values, axis=1)\n", "npc = Counter(counts)"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["{pivoted.columns[key]: value for key, value in npc.items()}"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["np.isfinite(rr['score']).all()"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["np.isfinite(results['score']).all()"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["pd.isna(results['score']).sum()"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["pivoted"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["results['score']"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["rr.head()"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["lr.pivot_table(index='building_id', columns='method', values='score').iplot(mode='markers', size=7, title='Linear Regression Results')"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 54, "lines": ["lr_maxes = lr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax()])\n", "rr_maxes = rr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax()])\n", "\n", "maxes = pd.concat([lr_maxes, rr_maxes], axis=0)"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["maxes.pivot(columns='model', values='score').iplot(mode='markers', size=7, title='Random Forest vs Linear Regression Best Scores')"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["rr_maxes['freq_name'] = rr_maxes['freq'].apply(lambda x: f'{x} min')\n", "\n", "rr_maxes.iplot(x='building_id', y='score', categories='freq_name', title='Random Forest Best Results by Frequency')"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["rr_maxes.pivot(columns='freq_name', values='score').iplot(kind='box')"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["maxes.melt(id_vars='model', value_vars='score')"]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 64, "lines": ["lr = pd.read_csv('results/linear_model.csv', index_col=0).reset_index(drop=True)\n", "rr= pd.read_csv('results/random_forest_model.csv', index_col=0).reset_index(drop=True)\n", "\n", "lr = lr.loc[(np.isfinite(lr['score'])) & (lr['score'] > 0)]\n", "rr = rr.loc[(np.isfinite(rr['score'])) & (rr['score'] > 0)]"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 69, "lines": ["lr.describe()"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["rr.describe()"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 71, "lines": ["rr.pivot_table(index='building_id', values='score', columns='method')"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 72, "lines": ["rr.pivot_table(index='building_id', values='score', columns='method').iplot(mode='markers', size=6)"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 73, "lines": ["rr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 74, "lines": ["rr.groupby('method')['score'].describe()"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["# Fractional Cyclical Encoding Works Best"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["rr['score'].idxmax()"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["rr.loc[rr['score'].idxmax()]"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 78, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score').iplot(kind='box')"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 79, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score')"]}, {"block": 36, "type": "code", "linesLength": 0, "startIndex": 80, "lines": []}]
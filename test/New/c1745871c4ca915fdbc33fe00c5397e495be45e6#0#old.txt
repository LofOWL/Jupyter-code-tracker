[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Results of Time Feature Engineering\n", "\n", "In this notebook, we'll look at the results of the time feature engineering. The purpose is to determine (if possible) the best way for encoding time and date features in a time-series problem."]}, {"block": 1, "type": "code", "linesLength": 20, "startIndex": 3, "lines": ["# Standard Data Science Helpers\n", "import numpy as np\n", "import pandas as pd\n", "import scipy\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.set_config_file(world_readable=True, theme=\"pearl\")\n", "cf.go_offline(connected=True)\n", "\n", "# Extra options\n", "pd.options.display.max_rows = 10\n", "pd.options.display.max_columns = 25\n", "# Show all code cells outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n"]}, {"block": 2, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["results = pd.read_csv('results/results.csv', index_col=0)\n", "results = results[(results['score'] > 0) & (np.isfinite(results['score']))]\n", "results.head()"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["building_counts = results.groupby('building_id')['method'].count()\n", "results = results.loc[~results['building_id'].isin(building_counts.index[building_counts != 10])]"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["lr = results.query('model == \"LinearRegression\"')\n", "rr = results.query('model == \"RandomForestRegressor\"')"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["lr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["rr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 32, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score').iplot(mode='markers', size=7, title=\"Random Forest Results\")"]}, {"block": 8, "type": "code", "linesLength": 7, "startIndex": 33, "lines": ["best = []\n", "for building_id, grouped in rr.groupby('building_id'):\n", "    best.append(grouped.loc[grouped['score'].idxmax(), 'method'])\n", "    \n", "    \n", "from collections import Counter\n", "Counter(best)"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["pivoted = rr.pivot_table(index='building_id', columns='method', values='score')"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 41, "lines": ["counts = np.argmax(pivoted.values, axis=1)\n", "npc = Counter(counts)"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["{pivoted.columns[key]: value for key, value in npc.items()}"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["np.isfinite(pivoted.values)"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["np.isfinite(rr['score']).all()"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["np.isfinite(results['score']).all()"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["pd.isna(results['score']).sum()"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["pivoted"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["results['score']"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["rr.head()"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["lr.pivot_table(index='building_id', columns='method', values='score').iplot(mode='markers')"]}, {"block": 20, "type": "code", "linesLength": 5, "startIndex": 52, "lines": ["lr = pd.read_csv('results/linear_model.csv', index_col=0).reset_index(drop=True)\n", "rr= pd.read_csv('results/random_forest_model.csv', index_col=0).reset_index(drop=True)\n", "\n", "lr = lr.loc[(np.isfinite(lr['score'])) & (lr['score'] > 0)]\n", "rr = rr.loc[(np.isfinite(rr['score'])) & (rr['score'] > 0)]"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["lr.describe()"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["rr.describe()"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["rr.pivot_table(index='building_id', values='score', columns='method')"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["rr.pivot_table(index='building_id', values='score', columns='method').iplot(mode='markers', size=6)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["rr.groupby('building_id').apply(lambda x: x.loc[x['score'].idxmax(), 'method']).value_counts()"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["rr.groupby('method')['score'].describe()"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["# Fractional Cyclical Encoding Works Best"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["rr['score'].idxmax()"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["rr.loc[rr['score'].idxmax()]"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score').iplot(kind='box')"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["rr.pivot_table(index='building_id', columns='method', values='score')"]}, {"block": 32, "type": "code", "linesLength": 0, "startIndex": 68, "lines": []}]
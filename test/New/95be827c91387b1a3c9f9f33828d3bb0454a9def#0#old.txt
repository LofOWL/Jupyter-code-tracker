[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Stock Price Predictions\n", "\n", "We can also make testable predictions by restricting our model to a subset of the data, and then using the forecasted values to see how correct our model is. We will restrict data up until the end of 2016, and then try to make predictions for 2017."]}, {"block": 1, "type": "code", "linesLength": 7, "startIndex": 3, "lines": ["import quandl \n", "import pandas as pd\n", "import numpy as np\n", "import fbprophet\n", "\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["## Retrieve Data from Quandl"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 11, "lines": ["quandl.ApiConfig.api_key = 'rFsSehe51RLzREtYhLfo'\n", "\n", "# Using Tesla data\n", "tesla_stocks = quandl.get('WIKI/TSLA')"]}, {"block": 4, "type": "code", "linesLength": 6, "startIndex": 15, "lines": ["# Set the index (with dates) to a column \n", "tesla_stocks.reset_index(level=0, inplace=True)\n", "\n", "# Rename the columns for prophet and create a year column\n", "tesla_stocks.rename(columns={'Date': 'ds', 'Adj. Close': 'y'}, inplace=True)\n", "tesla_stocks['Year'] = [date.year for date in tesla_stocks['ds']]"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["tesla_stocks.head()"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 22, "lines": ["# Create a new dataframe with the relevant information\n", "tesla_data = tesla_stocks[['ds', 'Year', 'y']]\n", "\n", "# Training and testing data\n", "tesla_train = tesla_data[tesla_data['Year'] < 2017]\n", "tesla_test = tesla_data[tesla_data['Year'] > 2016]"]}, {"block": 7, "type": "code", "linesLength": 14, "startIndex": 28, "lines": ["# Create a new model \n", "tesla_prophet = fbprophet.Prophet(changepoint_prior_scale=0.2)\n", "\n", "# Train the model\n", "tesla_prophet.fit(tesla_train)\n", "\n", "# Number of days to make predictions \n", "days = (max(tesla_test['ds']) - min(tesla_test['ds'])).days\n", "\n", "# Future dataframe\n", "tesla_forecast = tesla_prophet.make_future_dataframe(periods = days, freq = 'D')\n", "\n", "# Make forecasts\n", "tesla_forecast = tesla_prophet.predict(tesla_forecast)"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 42, "lines": ["tesla_results = tesla_forecast.merge(tesla_test, how = 'inner', on = 'ds')\n", "tesla_results = tesla_results[['ds', 'y', 'yhat']]\n", "\n", "# Predicted difference between stock prices\n", "tesla_results['pred_diff'] = (tesla_results['yhat']).diff()\n", "\n", "# Actual difference between stock prices\n", "tesla_results['real_diff'] = (tesla_results['y']).diff()"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 50, "lines": ["# Correct direction column\n", "tesla_results['correct'] = (np.sign(tesla_results['pred_diff']) == np.sign(tesla_results['real_diff'])) * 1"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["tesla_results.head()"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["np.mean(tesla_results['correct'])"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["### Value of Predictions"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["tesla_results = tesla_results.merge(tesla_stocks[['ds', 'Adj. Open']], how = 'left', on = 'ds')"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["tesla_results[tesla_results['correct'] == 1].head()"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["tesla_results['daily_diff'] = abs(tesla_results['y'] - tesla_results['Adj. Open'])"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["tesla_results['profit'] = [tesla_results.ix[i, 'daily_diff'] if tesla_results.ix[i, 'correct'] == 1 else tesla_results.ix[i, 'daily_diff'] * -1 for i in range(len(tesla_results))]"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["1000 * np.sum(tesla_results['profit'])"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 60, "lines": ["tesla_prophet.plot(tesla_forecast)\n", "plt.title('Tesla Stock Forecast'); plt.ylabel('Stock Price ($)'); plt.xlabel('Year');\n", "plt.plot(tesla_test['ds'], tesla_test['y'], 'k', label = 'actual')\n", "plt.legend();"]}, {"block": 19, "type": "code", "linesLength": 25, "startIndex": 64, "lines": ["def plot_predictions(stock, predictions):\n", "     xvalues = list(range(len(results['Date'])))\n", "\n", "    xlabels = list(range(13))\n", "    xlabels.append(1)\n", "    \n", "    \n", "    fig, ax = plt.subplots(1, 1, figsize=(10, 8));\n", "    ax.plot(xvalues, results['Adj. Close'], 'b-', label = 'Actual');\n", "    ax.plot(xvalues, results['yhat'], 'r*', label = 'Predicted');\n", "    ax.fill_between(xvalues, results['yhat_upper'], results['yhat_lower'], alpha=0.6, edgecolor = 'k');\n", "    ax.set_xticks(ticks = list(range(0, max(xvalues), int(max(xvalues) / 12))));\n", "    ax.set_xticklabels(labels = xlabels);\n", "    plt.legend();\n", "    plt.xlabel('2017'); plt.ylabel('Billions $'); plt.title('Stock Price Prediction for %s' % ticker)\n", "    plt.show()\n", "                  \n", "    \n", "    \n", "    # Plot actual and predicted difference\n", "    plt.figure(figsize = (10, 8))\n", "    plt.plot(results['Date'], results['actual_diff'], 'bo-', label = 'Actual')\n", "    plt.plot(results['Date'], results['pred_diff'], 'r*-', label = 'Predicted')\n", "    plt.legend(); plt.xlabel('Date'); plt.ylabel('Change (US $)'); plt.title('Actual vs. Predicted Daily Change');\n", "    plt.show();"]}, {"block": 20, "type": "code", "linesLength": 92, "startIndex": 89, "lines": ["def stock_predictor(ticker='TSLA'):\n", "    try:\n", "        stock = quandl.get('WIKI/%s' % ticker.upper())\n", "    except Exception as e:\n", "        print('Invalid Stock Ticker')\n", "        print(e)\n", "        return\n", "    \n", "    # Change the index to a Date column\n", "    stock_clean = stock.reset_index()[['Date', 'Adj. Close', 'Adj. Open']]\n", "    \n", "    # Create a year column\n", "    stock_clean['Year'] = [date.year for date in stock_clean['Date']]\n", "    \n", "    # Only using years past 2010\n", "    stock_clean = stock_clean[stock_clean['Year'] > 2010]\n", "    \n", "    # Rename for prophet training\n", "    stock_clean = stock_clean.rename(columns={'Date': 'ds', 'Adj. Close': 'y'})\n", "    \n", "    # Training and Testing Sets\n", "    stock_train = stock_clean[stock_clean['Year'] < 2017]\n", "    stock_test = stock_clean[stock_clean['Year'] > 2016]\n", "    \n", "    # Create the prophet model and fit on training set\n", "    stock_prophet = fbprophet.Prophet(changepoint_prior_scale=0.15)\n", "    stock_prophet.fit(stock_train)\n", "    \n", "    # Number of days to predict\n", "    days = (max(stock_test['ds']) - min(stock_test['ds'])).days\n", "    \n", "    # Make forecasts for entire length of test set + one week\n", "    stock_forecast = stock_prophet.make_future_dataframe(periods=days + 7, freq = 'D')\n", "    stock_forecast = stock_prophet.predict(stock_forecast)\n", "    \n", "    # Plot the entire series\n", "    stock_prophet.plot(stock_forecast); plt.xlabel('Year'); plt.ylabel('Price (US $)');\n", "    plt.title('%s Stock Price and Predictions' % ticker)\n", "    \n", "    # Dataframe for predictions and test values\n", "    results = stock_forecast[['ds', 'yhat', 'yhat_upper', 'yhat_lower']]\n", "    \n", "    # Merge to get acutal values (y)\n", "    results = pd.merge(results, stock_test[['ds', 'y']], on = 'ds', how='right')\n", "    \n", "    # Merge to get daily opening values (Adj. Open)\n", "    results = results.merge(stock_clean[['ds', 'Adj. Open']], on = 'ds', how ='inner')\n", "    \n", "    # Columns of daily changes\n", "    results['pred_diff'] = results['yhat'].diff()\n", "    results['real_diff'] = results['y'].diff()\n", "    \n", "    # Whether the prediction was right or wrong\n", "    # Multiply by 1 to convert to an integer\n", "    results['correct'] = (np.sign(results['pred_diff']) == np.sign(results['real_diff'])) * 1\n", "    \n", "    # Calculate daily change in price\n", "    results['daily_change'] = abs(results['y'] - results['Adj. Open'])\n", "    \n", "    # Only buy if predicted to increase\n", "    results_pred_increase = results[results['pred_diff'] > 0]\n", "        \n", "    # Calculate profits or losses\n", "    profits = []\n", "    for i, correct in enumerate(results_pred_increase['correct']):\n", "        if correct == 1:\n", "            profits.append(results.ix[i, 'daily_change'])\n", "        else:\n", "            profits.append(results.ix[i, 'daily_change'] * - 1)\n", "    \n", "    results_pred_increase['profits'] = profits\n", "    \n", "    # Calculate total profit if buying 1000 shares every day\n", "    total_profit = int(1000 * np.sum(profits))\n", "    \n", "    # Calculate total profit if buying and holding 1000 shares for entire time\n", "    first_price = int(results[results['ds'] == min(results['ds'])]['y'])\n", "    last_price = int(results[results['ds'] == max(results['ds'])]['y'])\n", "\n", "    # Smart profit\n", "    smart_profit = (last_price - first_price) * 1000\n", "    \n", "    # Total accuracy is percentage of correct predictions\n", "    accuracy = np.mean(results['correct']) *  100\n", "    \n", "    performance = {'pred_profit': total_profit, 'smart_profit': smart_profit, 'accuracy': accuracy}\n", "    \n", "    print('Your profit from playing the stock market in {}: {:.0f} $.'.format(ticker, total_profit))\n", "    print('The buy and hold profit (smart strategy)  in {}: {:.0f} $.'.format(ticker, smart_profit))\n", "    print('Thanks for playing the stock market!')\n", "    \n", "    return performance"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 181, "lines": ["stock_predictor('TSLA')"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 182, "lines": ["stock_predictor('CAT')"]}, {"block": 23, "type": "code", "linesLength": 0, "startIndex": 183, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 11, "startIndex": 0, "lines": ["# Introduction: Simulating Asteroid Impacts with a Poisson Process\n", "\n", "In this notebook, we will simulate impacts of Near Earth Asteroids on Earth using a Poisson process. Asteroid impacts can be modeled as a Poisson process because they are independent of one another, the chance of an impact occurring does not change over time, and two events (asteroid impacts) do not occur at the same time. We know the average time between impacts for each size of asteroid (we'll get into this) but not the exact time between impacts and moveover, one impact does not affect the chance of the next. \n", "\n", "We can use a Poisson Process model to calculate the expected number of impacts over an individual's life for each size of asteroid. We can also use the same model to calculate the expected waiting time between asteroid impacts. Although this model - like all models - is an approximation and the data are based on limited observations, we can still get real practice using a Poisson process.\n", "\n", "## Poisson Process and Poisson Distribution\n", "\n", "The Poisson Process and Poisson Distribution are explained in [this article](https://towardsdatascience.com/the-poisson-distribution-and-poisson-process-explained-4e2cb17d459). Basically, a Poisson process is an appropriate model for events that occur with limited frequency where we know the average frequency (or equivalently the average time between events). The Poisson Distribution allows us to calculate the expected number of events in a time period given the average time between events. The Poisson distribution is a special case of the Binomial Distribution where the number of trials is much greater than the expected number of successes. As asteroid impacts are relatively rare, this assumption fits well. For more on the Poisson Distribution, see [the Wikipedia article](https://en.wikipedia.org/wiki/Poisson_distribution#Basics). \n", "\n", "We'll get into the equations where needed and compare the theoretical values to our values derived from actual data and simulations. "]}, {"block": 1, "type": "code", "linesLength": 23, "startIndex": 11, "lines": ["import pandas as pd\n", "import numpy as np\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 20\n", "pd.options.display.max_rows = 10\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "# Interactive plotting\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.go_offline(connected=True)\n", "cf.set_config_file(theme='pearl')\n", "\n", "# Used for calculating theoretical value\n", "from scipy.special import factorial"]}, {"block": 2, "type": "markdown", "linesLength": 23, "startIndex": 34, "lines": ["## Data on Asteroid Impacts\n", "\n", "Data on Asteroid impact frequency, impact energy, and number of asteroids is from the NASA 2017 Report of the Near Earth Object Science Definition Team. It is available [online here](https://cneos.jpl.nasa.gov/doc/2017_neo_sdt_final_e-version.pdf). The actual data on asteroid impacts is limited, so most of the numbers derived in the report are from simulations. \n", "\n", "#### Main Data Table\n", "\n", "The main data we'll use is shown in this table (we have it as a dataframe). To find out the units and meanings of all the columns, go to Table 2-1 in the linked report (on page 26). \n", "\n", "![](images/impact_frequency.PNG)\n", "\n", "The main column we are concerned with is the impact frequency $f(n) yr^{-1}$. This is the number of impacts per year for the size of asteroids indicated by $<D>$, the mean diameter in KM. This information is all we will need for a Poisson process! \n", "\n", "The average overall impact frequency for all asteriods is $1.66 x 10^{-9} yr^{-1}$. The rate $f(n) yr^{-1}$ per size category $<D>$ is calculated by multiplying this frequency by the number of objects in the category given by $<N(D_2-D_1)>$. \n", "\n", "According to the overall frequency rate, a single Near Earth Asteroid (NEA) will impact the Earth once in 600 million years. Or, if there are 600 million NEAs, there should be one collison every year. \n", "\n", "__Acronyms__\n", "\n", "* NEA: Near Earth Asteroid\n", "* NEO: Near Earth Object\n", "* PHA = Potentially Hazardous Asteroids\n", "\n", "With that basic background, let's look at the data."]}, {"block": 3, "type": "code", "linesLength": 5, "startIndex": 57, "lines": ["import warnings; warnings.filterwarnings('ignore', category=FutureWarning)\n", "\n", "# Read in the data\n", "df = pd.read_parquet('https://github.com/WillKoehrsen/Data-Analysis/blob/master/poisson/data/asteroid-impact-data-cleaned?raw=true')\n", "df.head()"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["I've cleaned things up so we can understand each column. The impact frequency is in impacts per year. To get the average time between impacts, we can take $\\frac{1}{\\text{impact frequency}}$."]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 63, "lines": ["df['time_between_impacts'] = 1 / df['impact_frequency']\n", "df.head()"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 65, "lines": ["# Data Exploration\n", "\n", "Before we get to modeling, we'll do a little exploration of the data. This is not strictly necessary, but it's a fun exercise."]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 68, "lines": ["### Impact Energy vs Diameter\n", "\n", "Let's make a plot of the impact energy by the diameter. The diameters are given in kilometers. Impact energy is in Megatons Equivalent of TNT. For comparison, the Little Boy bomb dropped on Hiroshima had 15 kilotons of TNT equivalent. The largest human bomb ever developed was about 100 Megatons. (See [this Wikipedia article](https://en.wikipedia.org/wiki/TNT_equivalent#Examples))"]}, {"block": 8, "type": "code", "linesLength": 4, "startIndex": 71, "lines": ["df.set_index('range_diameter')['impact_energy'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(title='Megatons Equivalent TNT'),\n", "                                                                 xaxis=dict(title='Diameters (KM)'),\n", "                                                      title=\"Impact Energy vs Diameter Log Scale\"))"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Here's the same graph with a log scale on the y axis."]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["df.set_index('range_diameter')['impact_energy'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(type='log', title='Megatons Equivalent TNT'),\n", "                                                                 xaxis=dict(title='Range of Diameters (KM)'),\n", "                                                      title=\"Impact Energy vs Diameter Log Scale\"))"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 80, "lines": ["The relationship between the size of an asteroid and the impact energy is almost exactly linear on a log scale. \n", "\n", "We can see that asteroids have some serious destructive potential. We can also look at some of the other columns, such as the number of asteroids in each size category."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["### Number of Asteroid in Each Category"]}, {"block": 13, "type": "code", "linesLength": 4, "startIndex": 84, "lines": ["df.set_index('range_diameter')['number'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(title='Count'),\n", "                                                                 xaxis=dict(title='Diameter (KM)'),\n", "                                                      title=\"Number of Asteroids vs Diameter\"))"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Again, a log y axis is probably a better representation of the data."]}, {"block": 15, "type": "code", "linesLength": 4, "startIndex": 89, "lines": ["df.set_index('range_diameter')['number'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(type='log', title='Count'),\n", "                                                                 xaxis=dict(title='Diameter (KM)'),\n", "                                                      title=\"Number of Asteroids vs Diameter Log Scale\"))"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["There are only 2 known NEA each in the 2 largest size categories. That's probably a good thing as these have the most desctructive potential! "]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["### Time Between Impacts"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 95, "lines": ["df.set_index('range_diameter')['time_between_impacts'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(title='Time between Impacts (yrs)'),\n", "                                                                 xaxis=dict(title='Diameter (KM)'),\n", "                                                      title=\"Time between Impacts vs Diameter Log Scale\"))"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 99, "lines": ["df.set_index('range_diameter')['time_between_impacts'].iplot(kind='bar',\n", "                                                      layout=dict(yaxis=dict(type='log', title='Time between Impacts (yrs)'),\n", "                                                                 xaxis=dict(title='Diameter (KM)'),\n", "                                                      title=\"Time between Impacts vs Diameter Log Scale\"))"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["The cell below is just for making colorscales in plotly."]}, {"block": 21, "type": "code", "linesLength": 14, "startIndex": 104, "lines": ["import cmocean\n", "\n", "# Making colorscales\n", "def cmocean_to_plotly(cmap, pl_entries):\n", "    h = 1.0/(pl_entries-1)\n", "    pl_colorscale = []\n", "\n", "    for k in range(pl_entries):\n", "        C = list(map(np.uint8, np.array(cmap(k*h)[:3])*255))\n", "        pl_colorscale.append('rgb'+str((C[0], C[1], C[2])))\n", "\n", "    return pl_colorscale\n", "\n", "colorscales = {cmap_name: cmocean_to_plotly(cmap, len(df)) for cmap_name, cmap in cmocean.cm.cmap_d.items()}"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 118, "lines": ["## Interactive Plot for Exploring Data\n", "\n", "Here is an interactive plot made with IPython widgets and plotly we can use for exploring the dataset. We are able to choose the variable to plot against the diameter range, whether or not to use a log scale, and the colorscale."]}, {"block": 23, "type": "code", "linesLength": 32, "startIndex": 121, "lines": ["from ipywidgets import interact\n", "\n", "@interact\n", "def plot_by_diameter(cscale_name=list(colorscales.keys()), \n", "                     variable=['impact_frequency', 'impact_energy', 'time_between_impacts',\n", "                               'absolute_magnitude', 'number'],\n", "                    log=True):\n", "    \n", "    colors = colorscales[cscale_name]\n", "    \n", "    # Create the data to plot\n", "    data = [\n", "        go.Scatter(\n", "            x=[row['min_diameter'], row['max_diameter']],\n", "            y=[row[variable], row[variable]],\n", "            name=f'{row[\"diameter\"]:.3f} KM',\n", "            line=dict(color=colors[i]),\n", "        marker=dict(color=colors[i])) for i, row in df.iterrows()\n", "    ]\n", "\n", "    variable = variable.replace('_', ' ').title()\n", "    \n", "    # Setup the plot layout\n", "    layout = go.Layout(font=dict(size=16), width=900, height=700,\n", "        xaxis=dict(title='Diameter Range (KM)'),\n", "                      yaxis=dict(title=variable, \n", "                                 type='log' if log else 'linear'),\n", "                      title=f'Asteroid {variable} vs Range of Diameters')\n", "\n", "    # Make the plot and display\n", "    figure = go.Figure(data=data, layout=layout)\n", "    iplot(figure)"]}, {"block": 24, "type": "markdown", "linesLength": 25, "startIndex": 153, "lines": ["# Asteroid Impact Simulation\n", "\n", "Now, let's get to work with the Poisson Process. Here we will run 10000 simluations of a human lifetime (at 100 years) and for each size of asteroid, calculate the expected number of impacts over a lifetime. \n", "\n", "For each size, we have the frequency in asteroids/year, which we can convert into the expected number of impacts by multiplying by the number of years in the period. This gives us $\\lambda$, the rate parameter of the Poisson Distribution. $\\lambda$ is best described as the expected number of events in the period. \n", "\n", "## Expected Number of Events in a Poisson Process\n", "\n", "The expected number of events is given by the following equation.\n", "\n", "$$P(n) = \\frac{(\\lambda)^n e^{-\\lambda}}{n!}$$\n", "\n", "Where $n$ is the number of events and $\\lambda$ is the rate parameter. We can think of the rate parameter as being a product of the frequency and the length of time:\n", "\n", "$$\\lambda = \\frac{events}{time} * {time}$$\n", "\n", "In our case, $\\frac{events}{time} = \\text{impact frequency}$ given in number of impacts per year.\n", "\n", "### Simulation in Python\n", "\n", "Actually running a Poisson Process simulation is simple in Python with the `np.random.poisson` function which takes an expected value (`lambda`) and a `size` and returns the counts in each process. If our size is 10,000, then it will give us the count of events in each of 10,000 simulations.  \n", "\n", "#### Simple Example\n", "\n", "To show how the equations work, we'll run a simple example first."]}, {"block": 25, "type": "code", "linesLength": 11, "startIndex": 178, "lines": ["# Simulate 1 lifetime 10,000 times\n", "years = 100\n", "trials = 10_000\n", "\n", "# Extract the first frequency and calculate rate parameter\n", "freq = df['impact_frequency'].iloc[0]\n", "lam = freq * years\n", "\n", "# Run simulation\n", "impacts = np.random.poisson(lam, size=trials)\n", "impacts"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 189, "lines": ["print(f'The most likely number of impacts is {lam:.2f}.')"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 190, "lines": ["The best way to visualize the results is with a histogram showing the number of impacts in each simluation."]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 191, "lines": ["pd.DataFrame(impacts)[0].value_counts().iplot(kind='bar', \n", "                                               xTitle='Impacts', yTitle='Count', theme='white',\n", "                                              title=f\"Distribution of Impacts for {df['diameter'].iloc[0]} km Asteroids over 100 Years\")"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 194, "lines": ["## All Asteroid Sizes\n", "\n", "We can quickly carry out the same procedure for all sizes of asteroids using numpy. In this cell, we get the number of impacts in 10,000 trials of 100 years for all asteroid sizes."]}, {"block": 30, "type": "code", "linesLength": 7, "startIndex": 197, "lines": ["# Each trial is a human lifetime\n", "trials = 10000\n", "years = 100\n", "\n", "lambdas = years * df['impact_frequency'].values\n", "impacts = np.random.poisson(lambdas, size=(10000, len(lambdas)))\n", "impacts.shape"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["We expect the average number of impacts for each asteroid size to be close to `lambda` for that asteriod size. The rate parameter is the expected number of events in the interval. "]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 205, "lines": ["impacts.mean(axis=0)\n", "lambdas"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 207, "lines": ["### Observed and Theoretical Average Values\n", "\n", "To make sure we are on the right track, we can plot the observed average values and the theoretical average values for each size of asteroid. We expect the resulting averages to be relatively close."]}, {"block": 34, "type": "code", "linesLength": 15, "startIndex": 210, "lines": ["def plot_mean_data_and_expected(impact_df, lambdas, years, ds=df['range_diameter'], log=False):\n", "    \"\"\"Plot the expected number of impacts and the observed average number of impacts\"\"\"\n", "    \n", "    # Extract the data for average number of impacts\n", "    observed = impact_df.mean(axis=0)\n", "    data = [go.Bar(dict(x=ds, y=observed, name='Observed')),\n", "            go.Bar(dict(x=ds, y=lambdas, name='Theoretical'))]\n", "    \n", "    # Set up the layout\n", "    layout = go.Layout(xaxis=dict(title='Diameter Range (km)'), margin=dict(b=100),\n", "                       yaxis=dict(title='Mean Impacts', type='log' if log else 'linear'),\n", "                       title=f'Simulated and Theoretical Average Asteroid Impacts in {years:,} Years')\n", "    \n", "    figure = go.Figure(data=data, layout=layout)\n", "    iplot(figure)"]}, {"block": 35, "type": "markdown", "linesLength": 3, "startIndex": 225, "lines": ["If we take the average value across the 10,000 simulations, we come up with an estimated number of impacts per human lifetime. The estimated number from the simluations should be close to `lambda` for each impact frequency as `lambda` is the expected number of impacts (in other words, the most likely number of impacts).\n", "\n", "We can plot both the expected number of impacts and the average number of impacts from the simulations."]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 228, "lines": ["impact_df = pd.DataFrame(impacts, columns=df['range_diameter'])\n", "plot_mean_data_and_expected(impact_df, lambdas, years, ds=df['range_diameter'], log=False)"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 230, "lines": ["The theoretical and observed values are in close agreement. We can see that the average number of impacts across a human lifetime is less than 1 for all asteroid sizes. \n", "\n", "This might be easier to view with a log scale y axis."]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 233, "lines": ["plot_mean_data_and_expected(impact_df, lambdas, years, ds=df['range_diameter'], log=True)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 234, "lines": ["You can expect an average of 0.46 impacts of the smallest asteroid in your lifetime and 0.23 of the next largest. For the largest asteroids, we observed 0 impacts even in 10,000 simulations which agree with the miniscule theoretical chances of around 1 in 1 billion."]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 235, "lines": ["Let's look at the maximum number of impacts per lifetime. This isn't exactly the best approach because if we increase the number of simulations, we would expect these numbers to increase. Nonetheless, it's fun to look at the worst-case scenarios.\n", "\n", "If you are extremely unlucky, you might see five asteroids impacts of the smallest variey! "]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 238, "lines": ["impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Number of Impacts per Human Lifetime')"]}, {"block": 42, "type": "markdown", "linesLength": 3, "startIndex": 240, "lines": ["# Theoretical PMF\n", "\n", "To view all the Theoretical PMF, we simply evaluate the Poisson Distribution equation across the asteroid categories for a range of different number of events. What we are left with is the PMF for each size of asteroid."]}, {"block": 43, "type": "code", "linesLength": 6, "startIndex": 243, "lines": ["# Number of impacts\n", "events = np.arange(0.25, impacts.max() + 10, 0.25)\n", "\n", "# Calculate the theoretical value for each size of asteroid\n", "theoretical = np.exp(-lambdas) * np.power(lambdas, events.reshape(-1, 1)) / factorial(events).reshape((-1, 1))\n", "theoretical.shape"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 249, "lines": ["To visualize the Theoretical PMF, we'll put them all on the same plot. Each column is a different category of asteroids."]}, {"block": 45, "type": "code", "linesLength": 5, "startIndex": 250, "lines": ["t_df = pd.DataFrame(theoretical, columns=df['diameter'].round(3), \n", "                    index=events)\n", "\n", "t_df.iplot(kind='scatter', mode='lines+markers', xTitle='Number of Events', size=6,\n", "           yTitle='Probability', title='Theoretical PMF for all Asteroid Sizes')"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 255, "lines": ["This is pretty uninterseting since the most likely number of asteroids for all cases is 0. "]}, {"block": 47, "type": "markdown", "linesLength": 9, "startIndex": 256, "lines": ["## Probability Mass Function for Each Asteroid Category\n", "\n", "As a useful visualization, we can look at the probability mass function for each size category. This is bascially a historgram of the number of events in each trial. \n", "\n", "For these, we'll show the theoretical curve derived from the Poisson Probability Mass Function (PMF because the number of events is discrete). The theoretical curve is derived from the equation discussed above, \n", "\n", "$$P(n) = \\frac{(\\lambda)^n e^{-\\lambda}}{n!}$$\n", "\n", "Where $\\lambda$ is the rate parameter derived by multiplying the frequency by the length of the time period."]}, {"block": 48, "type": "code", "linesLength": 34, "startIndex": 265, "lines": ["def plot_pmf_data_and_theoretical(df, impact_df, diameter, years):\n", "    \"\"\"Plot the observed and theoretical probability mass function (PMF)\"\"\"\n", "    \n", "    # Calculate lambda\n", "    freq = float(df.loc[df['diameter'] == diameter, 'impact_frequency'])\n", "    lam = freq * years\n", "    \n", "    diameter_range = (df.loc[df['diameter'] == diameter, 'range_diameter']).values[0]\n", "    \n", "    # Extract the data\n", "    data = 100 * impact_df[diameter_range].value_counts(normalize=True)\n", "    \n", "    max_events = impact_df[diameter_range].max() +  3\n", "    \n", "    # Number of events for theoretical distribution\n", "    num_events = np.arange(0, max_events, step=0.25)\n", "    \n", "    # Find the probability according to the Poisson PMF\n", "    prob_num_events = 100 * np.exp(-lam) * np.power(lam, num_events) / factorial(num_events)\n", "    \n", "    # Make the data\n", "    data = [go.Scatter(x=num_events, y=prob_num_events, \n", "                       mode='lines', name='Theoretical'), \n", "            go.Bar(dict(x=data.index, y=data.values, name='Observed', \n", "                              marker=dict(line=dict(width=2)))),\n", "                             ]\n", "    \n", "    # Set up the plot layout\n", "    layout = go.Layout(xaxis=dict(title='Number of Impacts'), \n", "                       yaxis=dict(title='Probability (%)'),\n", "                       title=f\"Observed and Theoretical PMF of Asteroid Impacts with Diameter {diameter} km over {years} Years\")\n", "    \n", "    figure = go.Figure(data=data, layout=layout)\n", "    iplot(figure)"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 299, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 0.0224, years=years)"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 300, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 0.0447, years=years)"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 301, "lines": ["The simulated data agree nearly exactly with the data. Even for the smallest asteroids, the most likely number of impacts is zero."]}, {"block": 52, "type": "markdown", "linesLength": 3, "startIndex": 302, "lines": ["## Function for Simulation\n", "\n", "Let's make this into a function we can use for any period of years and number of simulations."]}, {"block": 53, "type": "code", "linesLength": 17, "startIndex": 305, "lines": ["def simulate_impacts(df, years, trials=10000):\n", "    \"\"\"Simulate a Poisson process for asteroid impacts\"\"\"\n", "    \n", "    np.random.seed(100)\n", "    \n", "    lambdas = years * df['impact_frequency'].values\n", "    impacts = np.random.poisson(lambdas, size=(trials, len(lambdas)))\n", "    \n", "    # Number of impacts\n", "    events = np.arange(0.25, impacts.max() + 10, 0.25)\n", "\n", "    # Calculate the theoretical value for each size of asteroid\n", "    theoretical = np.exp(-lambdas) * np.power(lambdas, events.reshape(-1, 1)) / factorial(events).reshape((-1, 1))\n", "    theoretical_df = pd.DataFrame(theoretical, columns=df['diameter'].round(3), \n", "                    index=events)\n", "    impact_df = pd.DataFrame(impacts, columns=df['range_diameter'])\n", "    return impact_df, lambdas, theoretical_df"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 322, "lines": ["Now we can look at the theoretical number of impacts for all asteroid sizes for more years. This should result in more impacts."]}, {"block": 55, "type": "code", "linesLength": 9, "startIndex": 323, "lines": ["years = 2500\n", "\n", "# Generate data\n", "impact_df, lambdas, theo = simulate_impacts(df, years, trials=10000)\n", "\n", "\n", "# Plot Theoretical PMF of impacts\n", "theo.iloc[:80].iplot(kind='scatter', mode='lines+markers', xTitle='Number of Events', size=6,\n", "           yTitle='Probability', title=f'Theoretical PMF for all Asteroid Sizes for {years} Years')"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 332, "lines": ["Now, if we live 2500 years, we can expect significantly more asteroid impacts! "]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 333, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 0.0355, years=years)"]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 334, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 0.0224, years=years)"]}, {"block": 59, "type": "markdown", "linesLength": 3, "startIndex": 335, "lines": ["# Asteroid Impacts for all of Human History\n", "\n", "Running a simulation for the length of one human life is interesting, but say we are concerned with the well-being of the entire human race. Let's increase the length of time to 2 million years, about as long as the genus Homo (See [this Wikipedia article](https://en.wikipedia.org/wiki/Homo)) has been around and calculate the resulting expected number of impacts. All this requires is increasing the number of years and running the simulation function again."]}, {"block": 60, "type": "code", "linesLength": 1, "startIndex": 338, "lines": ["df['diameter'].iloc[20:]"]}, {"block": 61, "type": "code", "linesLength": 7, "startIndex": 339, "lines": ["# Each simulation is the entire history of the genus homo\n", "trials = 10_000\n", "years = 2_000_000\n", "\n", "with warnings.catch_warnings():\n", "    warnings.simplefilter('ignore', category=RuntimeWarning)\n", "    impact_df, lambdas, theo = simulate_impacts(df, years, trials)"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 346, "lines": ["Let's check the mean values against the theoretical (the expected number from lambda)."]}, {"block": 63, "type": "code", "linesLength": 1, "startIndex": 347, "lines": ["plot_mean_data_and_expected(impact_df, lambdas, years)"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 348, "lines": ["plot_mean_data_and_expected(impact_df, lambdas, years, log=True)"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 349, "lines": ["Now let's see if there are any impacts of the largest asteroids in any of the simulations. Again, this is the maximum number of impacts in any simulation which we could artificially increase simply by running more simulations."]}, {"block": 66, "type": "code", "linesLength": 2, "startIndex": 350, "lines": ["impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Impacts per 2 Million Years')"]}, {"block": 67, "type": "markdown", "linesLength": 5, "startIndex": 352, "lines": ["We do see at least one occasion in 10,000 simulations where the largest asteroid hits. This shows how lucky we humans are to be here so show a little appreciation and kindness to your fellow Earthmates! \n", "\n", "### Simulated Data vs Theoretical \n", "\n", "Once again, we can plot the simluations of 2 million years versus the theoretical values."]}, {"block": 68, "type": "code", "linesLength": 1, "startIndex": 357, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 1.780, years)"]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 358, "lines": ["plot_pmf_data_and_theoretical(df, impact_df, 2.82, years)"]}, {"block": 70, "type": "markdown", "linesLength": 3, "startIndex": 359, "lines": ["### Theoretical Distribution\n", "\n", "We can again plot the theoretical Probability Mass Function for each asteroid size. While the most likely number of impacts is still zero for some sizes, we see a noticeable rightward shift in the graph as more impacts become more likely."]}, {"block": 71, "type": "code", "linesLength": 3, "startIndex": 362, "lines": ["# Plot Theoretical PMF of impacts\n", "theo.iloc[:120].iplot(kind='scatter', mode='lines+markers', xTitle='Number of Events', size=6,\n", "           yTitle='Probability', title=f'Theoretical PMF for all Asteroid Sizes for {years} Years')"]}, {"block": 72, "type": "markdown", "linesLength": 3, "startIndex": 365, "lines": ["# Time Between Asteroid Impacts\n", "\n", "Next, we'll look at the average number of years between asteroid impacts of different sizes. We'll simulate 100,000,000 (100 million) years and then find the average time between impacts for the different categories."]}, {"block": 73, "type": "markdown", "linesLength": 7, "startIndex": 368, "lines": ["__Waiting Time Equation__\n", "\n", "The waiting time between events in a Poisson process is\n", "\n", "$$P(X > time) = e^{-\\frac{events}{time} * time}$$\n", "\n", "The $\\frac{events}{time}$ is the frequency of impacts. The probability of waiting an amount of time decreases exponentially as time increases."]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 375, "lines": ["In the cell below, we are simulation each year individually as a Bernoulli variable: either an asteroid hits or it does not. We repeat this 100 million times for each size of asteroid to simluate 100 million years. Then we find the time between asteroid impacts to derive the waiting time."]}, {"block": 75, "type": "code", "linesLength": 9, "startIndex": 376, "lines": ["# Frequency for smallest asteroids\n", "freq = df['impact_frequency'].iloc[0]\n", "\n", "waiting_times = np.arange(0, 2500)\n", "p_waiting_times = np.exp(-freq * waiting_times)\n", "\n", "pd.DataFrame(p_waiting_times, index=waiting_times).iplot(kind='scatter', theme='solar',\n", "                                                         xTitle='Waiting Time (yrs)', yTitle='P (T > t)',\n", "                                                         title='Probability of Time between Impacts')"]}, {"block": 76, "type": "code", "linesLength": 13, "startIndex": 385, "lines": ["np.random.seed(100)\n", "\n", "# Simulate 100 million years\n", "years = 100_000_000\n", "wait_times = {}\n", "\n", "# Simulate each year individually\n", "for freq, diameter in zip(df['impact_frequency'], df['range_diameter']):\n", "    # Each year is a bernoulli trial with probability of success equal to frequency\n", "    a = np.random.choice([0, 1], size=years, p=[1-freq, freq])\n", "    \n", "    # Find the time between impacts\n", "    wait_times[diameter] = np.diff(np.where(a == 1)[0])"]}, {"block": 77, "type": "markdown", "linesLength": 1, "startIndex": 398, "lines": ["The wait times currently has the time between successive impacts for each size of asteroid."]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 399, "lines": ["wait_times['.0200\u2013.0251']"]}, {"block": 79, "type": "code", "linesLength": 3, "startIndex": 400, "lines": ["pd.DataFrame(wait_times['.0200\u2013.0251'])[0].value_counts().iplot(kind='bar', xTitle='Waiting Time',\n", "                                                                yTitle='Counts', \n", "                                                                title='Observed Waiting Time between Impacts')"]}, {"block": 80, "type": "code", "linesLength": 1, "startIndex": 403, "lines": ["wait_times['6.31\u20137.94']"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 404, "lines": ["There are zero impacts in 100 million years in that category."]}, {"block": 82, "type": "markdown", "linesLength": 3, "startIndex": 405, "lines": ["## Waiting Time Distribution\n", "\n", "Let's plot the distribution of wait times for a single size of asteroids. We'll use a simple histogram and we can compare the simulated values to the theoretical values."]}, {"block": 83, "type": "code", "linesLength": 46, "startIndex": 408, "lines": ["def plot_wait_times_observed_and_theoretical(df, wait_times, diameter, binwidth=100, log=False):\n", "    \"\"\"Plot the expected waiting time observed and theoretical for asteroid impacts\"\"\"\n", "    \n", "    freq = float(df.loc[df['diameter'] == diameter, \n", "                        'impact_frequency'])\n", "    diameter_range = (df.loc[df['diameter'] == diameter, 'range_diameter']).values[0]\n", "    \n", "    # Extract the data and put into a dataframe\n", "    wt_df = pd.DataFrame({'wt': wait_times[diameter_range]})\n", "    \n", "    # Bins for dividing waiting times\n", "    bins = np.arange(0, max(wt_df['wt']), binwidth)\n", "    \n", "    # Create binned wait times\n", "    wt_df['binned_wait_time'] = pd.cut(wt_df['wt'], bins=bins)\n", "    # Count number in each bin and divide by the total\n", "    binned_df = wt_df.groupby('binned_wait_time').count() / len(wt_df)\n", "    \n", "    # Required for plotting\n", "    binned_df.index = binned_df.index.astype(str)\n", "\n", "    theoretical_binned_probs = []\n", "    wts = np.arange(0, bins.max() + 1, 1)\n", "\n", "    # Theoretical probabilities for each waiting time\n", "    theoretical_probs = np.exp(-freq * wts)\n", "    midpoints = []\n", "    \n", "    # Bin the theoretical waiting times\n", "    for x1, x2 in zip(bins[:-1], bins[1:]):\n", "         theoretical_binned_probs.append(100 * (theoretical_probs[wts == x1] - theoretical_probs[wts == x2])[0])\n", "         midpoints.append((x1 + x2) / 2)\n", "        \n", "    # Create the plot data\n", "    data = [go.Bar(x=binned_df.index if not log else midpoints, y=100 * binned_df['wt'], name='observed'),\n", "            go.Scatter(x=binned_df.index if not log else midpoints, y=theoretical_binned_probs, \n", "                       mode='markers+lines', \n", "                       name='Theoretical')]\n", "    # Set up the plot\n", "    layout = go.Layout(xaxis=dict(title='Waiting Time (years)', type='log' if log else 'category'),\n", "                       yaxis=dict(title='Probability (%)'), margin=dict(b=100),\n", "                       title=f\"Waiting Time between Asteroid Impacts for {diameter} KM Diameter\")\n", "\n", "    # Show the plot\n", "    figure = go.Figure(data=data, layout=layout)\n", "    iplot(figure)"]}, {"block": 84, "type": "code", "linesLength": 1, "startIndex": 454, "lines": ["plot_wait_times_observed_and_theoretical(df, wait_times, 0.0224, binwidth=150, log=False)"]}, {"block": 85, "type": "code", "linesLength": 1, "startIndex": 455, "lines": ["plot_wait_times_observed_and_theoretical(df, wait_times, 0.0355, binwidth=500)"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 456, "lines": ["The theoretical and observed waiting time frequency distributions match up well. For all asteroid sizes, the mean waiting time is the 1 / frequency of impacts."]}, {"block": 87, "type": "code", "linesLength": 1, "startIndex": 457, "lines": ["plot_wait_times_observed_and_theoretical(df, wait_times, 0.0708, binwidth=5000)"]}, {"block": 88, "type": "markdown", "linesLength": 3, "startIndex": 458, "lines": ["## Mean Waiting Time \n", "\n", "The average weight time should be equal to the frequency of impact. We can plot the weight times and the time between impacts to determine if the observed values match the theoretical."]}, {"block": 89, "type": "code", "linesLength": 9, "startIndex": 461, "lines": ["for key, values in wait_times.items():\n", "    df.loc[df['range_diameter'] == key, 'observed_time_between_impacts'] = values.mean()\n", "    \n", "df.set_index('range_diameter')[['time_between_impacts', 'observed_time_between_impacts']].iplot(kind='bar', \n", "                                                                                               layout=dict(yaxis=dict(type='log',\n", "                                                                                                                     title='Time Between Impacts (Years)'),\n", "                                                                                                          xaxis=dict(title='Diameter Range (KM)'),\n", "                                                                                                           margin=dict(b=120),\n", "                                                                                                          title='Average Time between Impacts'))"]}, {"block": 90, "type": "markdown", "linesLength": 1, "startIndex": 470, "lines": ["For most of the largest asteroid diameters, there were no waiting times because there were no or only one impact! This shows how rare these events are."]}, {"block": 91, "type": "markdown", "linesLength": 1, "startIndex": 471, "lines": ["To view the most common impacts, we can use the `Counter` object from the `collections` library."]}, {"block": 92, "type": "code", "linesLength": 3, "startIndex": 472, "lines": ["from collections import Counter\n", "counts = Counter(wait_times['.0251\u2013.0316'])\n", "counts.most_common(10)"]}, {"block": 93, "type": "code", "linesLength": 2, "startIndex": 475, "lines": ["counts = Counter(wait_times['.0200\u2013.0251'])\n", "counts.most_common(10)"]}, {"block": 94, "type": "markdown", "linesLength": 3, "startIndex": 477, "lines": ["# Interactive Analysis\n", "\n", "For the final part, we can put together a number of the functions in order to create an interactive analysis of asteroid impacts. We'll let the user choose the number of years, the number of simulations and then explore the results."]}, {"block": 95, "type": "code", "linesLength": 16, "startIndex": 480, "lines": ["from ipywidgets import interact_manual\n", "\n", "@interact_manual\n", "def interactive_asteroid_impact_analysis(years=(1, 1000, 10), trials=(10, 100_000, 1_000),\n", "                                         diameter=list(df['diameter']),\n", "                                         log=False):\n", "    # Run simulation\n", "    impact_df, lambdas, theo = simulate_impacts(df, years, trials)\n", "    # Plot the average values and expected\n", "    plot_mean_data_and_expected(impact_df, lambdas, years, log=log)\n", "    \n", "    # Plot the theoretical nad obserebe PMF for the category of interest\n", "    plot_pmf_data_and_theoretical(df, impact_df, diameter, years)\n", "    # Plot Theoretical PMF of impacts\n", "    theo.iloc[:80].iplot(kind='scatter', mode='lines+markers', xTitle='Number of Events', size=6,\n", "           yTitle='Probability', title=f'Theoretical PMF for all Asteroid Sizes for {years} Years')"]}, {"block": 96, "type": "markdown", "linesLength": 3, "startIndex": 496, "lines": ["# Conclusions\n", "\n", "In this notebook, we used a Poisson process to simulate asteroid impacts on Earth. Using a Poisson Process model and the Poisson Distribution, we are able to calculate the expected number of impacts over a time period and the waiting time between impacts. While this may be a somewhat theoretical exercise (because of the limited data), it shows how we can apply a statistical concept to arrive at plausible answers. Furthermore, it gives us a chance to get familiar with running simulations and comparing actual results to expected results from theory. Data science often involves comparing reality with theory and exercises like these can help us learn the basics and how to interpret the outcomes."]}, {"block": 97, "type": "code", "linesLength": 0, "startIndex": 499, "lines": []}]
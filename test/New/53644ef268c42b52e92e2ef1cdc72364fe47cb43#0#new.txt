[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Intermediate Time Series methods with Plotly\n", "\n", "In this notebook, we will move beyond the basic plots in the `plotly-time-series` notebook and make plots with range sliders, update menus, and even animations. Although still not using the full capabilities of plotly, making these plots will show us how to take advantage of this powerful library to create effective visualizations. "]}, {"block": 1, "type": "code", "linesLength": 14, "startIndex": 3, "lines": ["# Standard data science libraries\n", "import pandas as pd\n", "import numpy as np\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "# Visualization\n", "import matplotlib.pyplot as plt\n", "import seaborn as sns\n", "plt.style.use('bmh')\n", "\n", "from collections import defaultdict"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Authenticate with plotly in the below cell."]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 18, "lines": ["## Replace with your credentials.\n", "\n", "# import plotly\n", "# plotly.tools.set_credentials_file(username='########', api_key='******')"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["These are the standard plotly imports. We set up the notebook to run offline which means our plots are not uploaded to the plot web interface."]}, {"block": 5, "type": "code", "linesLength": 10, "startIndex": 23, "lines": ["# Plot imports\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "\n", "## Offline mode\n", "from plotly.offline import init_notebook_mode, iplot\n", "init_notebook_mode(connected=True)\n", "\n", "import warnings\n", "warnings.filterwarnings('ignore', category=UserWarning)"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 33, "lines": ["## Data Series\n", "\n", "As before, we are using real-world building energy, steam, and static pressure measurements. The data is in a dataframe with a _multi-index_ on the columns. This means we have to use _multi-dimensional_ indexing to select one column."]}, {"block": 7, "type": "code", "linesLength": 6, "startIndex": 36, "lines": ["# Read in data and convert index to a datetime\n", "df = pd.read_csv('building_one.csv', \n", "                 header=[0, 1], index_col=0)\n", "df.index = pd.to_datetime(df.index)\n", "df.sort_index(inplace=True)\n", "df.head()"]}, {"block": 8, "type": "code", "linesLength": 5, "startIndex": 42, "lines": ["import cufflinks\n", "\n", "df['Steam'].iplot(xTitle='Date', yTitle='Steam (Mlbs/hr)', \n", "                  theme='white', title=\"Steam Plot\",\n", "                  xrange=(pd.datetime(2018, 1, 1), pd.datetime(2018, 1, 15)))"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Next we create several data series, spanning both the entire range of data, and subsetting out one week."]}, {"block": 10, "type": "code", "linesLength": 11, "startIndex": 48, "lines": ["energy_series = df.loc[:, ('Energy', '3')].copy()\n", "steam_series = df.loc[:, ('Steam', '4')].copy()\n", "pressure_series = df.loc[:, ('StaticPressure', '2')].copy()\n", "\n", "df_short = df[df.index.week == 8].copy()\n", "\n", "steam_series_four = df_short.loc[:, ('Steam', '4')].copy()\n", "steam_series_five = df_short.loc[:, ('Steam', '5')].copy()\n", "\n", "static_series_one = df_short.loc[:, ('StaticPressure', '1')].copy()\n", "static_series_two = df_short.loc[:, ('StaticPressure', '2')].copy()"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 59, "lines": ["# Time Scale and Time Window Selection with Range Select and Range Slider\n", "\n", "One way to add interactivity to our time-series plots and let users dig into the data is by adjusting the time scale and the time window. We can do this using a `rangeselect` and `rangslider` respectively. "]}, {"block": 12, "type": "code", "linesLength": 32, "startIndex": 62, "lines": ["# Create a layout with a rangeselector and rangeslider on the xaxis\n", "layout = go.Layout(\n", "    height=600,\n", "    width=900,\n", "    font=dict(size=16),\n", "    title='Energy Plot with Range Selection',\n", "    xaxis=dict(\n", "        title='Date',\n", "        # Range selector with buttons\n", "        rangeselector=dict(\n", "            font=dict(size=12),\n", "            # Buttons for selecting time scale\n", "            buttons=list([\n", "                # 1 month\n", "                dict(count=1, label='1m', step='month', stepmode='backward'),\n", "                # 1 week\n", "                dict(count=7, label='1w', step='day', stepmode='backward'),\n", "                # 1 day\n", "                dict(count=1, label='1d', step='day', stepmode='backward'),\n", "                # 12 hours\n", "                dict(count=12, label='12h', step='hour', stepmode='backward'),\n", "                # 4 hours\n", "                dict(count=4, label='4h', step='hour', stepmode='backward'),\n", "                # Entire scale\n", "                dict(step='all')\n", "            ])),\n", "        # Sliding for selecting time window\n", "        rangeslider=dict(visible=True),\n", "        # Type of xaxis\n", "        type='date'),\n", "    # yaxis is unchanged\n", "    yaxis=dict(title='Energy (kWh)'))"]}, {"block": 13, "type": "code", "linesLength": 11, "startIndex": 94, "lines": ["# Create the same data object\n", "energy_data = go.Scatter(x=energy_series.index,\n", "                        y=energy_series.values,\n", "                        line=go.scatter.Line(color='red', width = 0.6),\n", "                        opacity=0.8,\n", "                        name='energy',\n", "                        text=[f'Energy: {x:.0f} kWh' for x in energy_series.values])\n", "\n", "# Create the figure and display\n", "fig = go.Figure(data=[energy_data], layout=layout)\n", "iplot(fig)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["## Time Select with Double Y-Axis"]}, {"block": 15, "type": "code", "linesLength": 7, "startIndex": 106, "lines": ["steam_data = go.Scatter(x=steam_series.index,\n", "                        y=steam_series.values,\n", "                        line=dict(color='blue', width=0.8),\n", "                        opacity=0.8,\n", "                        name='Steam',\n", "                        yaxis='y2',\n", "                        text=[f'Steam: {x:.1f} Mlbs/hr' for x in steam_series.values])"]}, {"block": 16, "type": "code", "linesLength": 37, "startIndex": 113, "lines": ["# Create a layout with interactive elements and two yaxes\n", "layout = go.Layout(\n", "    height=600,\n", "    width=900,\n", "    font=dict(size=16),\n", "    title='Energy Plot with Range Selection',\n", "    xaxis=dict(\n", "        title='Date',\n", "        # Range selector with buttons\n", "        rangeselector=dict(\n", "            font=dict(size=12),\n", "            # Buttons for selecting time scale\n", "            buttons=list([\n", "                # 1 month\n", "                dict(count=1, label='1m', step='month', stepmode='backward'),\n", "                # 1 week\n", "                dict(count=7, label='1w', step='day', stepmode='backward'),\n", "                # 1 day\n", "                dict(count=1, label='1d', step='day', stepmode='backward'),\n", "                # 12 hours\n", "                dict(count=12, label='12h', step='hour', stepmode='backward'),\n", "                # 4 hours\n", "                dict(count=4, label='4h', step='hour', stepmode='backward'),\n", "                # Entire scale\n", "                dict(step='all')\n", "            ])),\n", "        # Sliding for selecting time window\n", "        rangeslider=dict(visible=True),\n", "        # Type of xaxis\n", "        type='date'),\n", "    yaxis=dict(title='Energy (kWh)', color='red'),\n", "    # Add a second yaxis to the right of the plot\n", "    yaxis2=dict(\n", "        title='Steam (Mlbs/hr)', color='blue', overlaying='y', side='right'))\n", "\n", "fig = go.Figure(data=[energy_data, steam_data], layout=layout)\n", "iplot(fig)"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 150, "lines": ["# Update Menu\n", "\n", "Next, we will add a dropdown menu to the plot allowing users to select the steam series they want to view. This is an `update` because it changes the data shown. We just need to create an `updatemenus` object that specify the actions to take when the button is selected in the `args` parameter. In this case, we change the data by setting the `visible` parameters and we change the title with the `title` parameter."]}, {"block": 18, "type": "code", "linesLength": 31, "startIndex": 153, "lines": ["updatemenus = list([\n", "    dict(\n", "        active=2,\n", "        buttons=list([\n", "            dict(\n", "                label='Sensor 4',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [True, False]\n", "                }, {\n", "                    'title': 'Sensor 4'\n", "                }]),\n", "            dict(\n", "                label='Sensor 5',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [False, True]\n", "                }, {\n", "                    'title': 'Sensor 5'\n", "                }]),\n", "            dict(\n", "                label='Both',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [True, True]\n", "                }, {\n", "                    'title': 'Sensor Sensors'\n", "                }])\n", "        ]),\n", "    )\n", "])"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Once we make the `updatemenus`, we pass in to the `layout`."]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 185, "lines": ["layout = go.Layout(\n", "    height=800, width=1000, title='Steam Sensors', updatemenus=updatemenus)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 187, "lines": ["Now we need to make our data. We will use two different steam series over the course of one week."]}, {"block": 22, "type": "code", "linesLength": 15, "startIndex": 188, "lines": ["steam_data_four = go.Scatter(\n", "    x=steam_series_four.index,\n", "    y=steam_series_four.values,\n", "    line=dict(color='blue', width=1.1),\n", "    opacity=0.8,\n", "    name='Steam: Sensor 4',\n", "    text = [f'Sensor 4: {x:.1f} Mlbs/hr' for x in steam_series_four.values])\n", "\n", "steam_data_five = go.Scatter(\n", "    x=steam_series_five.index,\n", "    y=steam_series_five.values,\n", "    line=dict(color='orange', width=1.1),\n", "    opacity=0.8,\n", "    name='Steam: Sensor 5',\n", "    text=[f'Sensor 5: {x:.1f} Mlbs/hr' for x in steam_series_five.values])"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 203, "lines": ["Finally, we pass in the layout with the `updatemenus` to the figure."]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 204, "lines": ["fig = go.Figure(data=[steam_data_four, steam_data_five], layout=layout)\n", "iplot(fig)"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 206, "lines": ["## Update Menu with Annotations\n", "\n", "Now we will add in the annotations when the user selects a sensor. This is simply a matter of changing the visible annotations when a different sensor is selected using the `annotations` parameter."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 209, "lines": ["First, we format all of the data. We are using weekly series and adding in annotations that show the maximum value on each day."]}, {"block": 27, "type": "code", "linesLength": 21, "startIndex": 210, "lines": ["def find_daily_maxes(x):\n", "    \"\"\"Return maximum measurement on each day and when it occurred in a dataframe\"\"\"\n", "    x = x.copy().to_frame()\n", "    x['day'] = x.index.day\n", "    result =pd.concat([x.groupby('day').max(), \n", "                      x.groupby('day').idxmax()], axis = 1).iloc[:, [0, 1]]\n", "    result.columns = ['value', 'date']\n", "    return result.set_index('date')\n", "\n", "four_highs = find_daily_maxes(steam_series_four)\n", "five_highs = find_daily_maxes(steam_series_five)\n", "\n", "from datetime import datetime\n", "\n", "def format_time(dt):\n", "    if pd.isnull(dt):\n", "        return \"NaT\"\n", "    else:\n", "        return datetime.strftime(dt, \"%a <br> %H:%M %p\")\n", "    \n", "four_highs"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 231, "lines": ["The annotations are made using a list comprehension."]}, {"block": 29, "type": "code", "linesLength": 23, "startIndex": 232, "lines": ["four_annotations = [\n", "    dict(\n", "        x=date,\n", "        y=value[0],\n", "        xref='x',\n", "        yref='y',\n", "        font=dict(color='blue'),\n", "        text=f'{format_time(date)}<br> {value[0]:.1f} Mlbs/hr')\n", "    for date, value in zip(four_highs.index, four_highs.values)\n", "]\n", "\n", "five_annotations = [\n", "    dict(\n", "        x=date,\n", "        y=value[0],\n", "        xref='x',\n", "        yref='y',\n", "        font=dict(color='orange'),\n", "        text=f'{format_time(date)}<br> {value[0]:.1f} Mlbs/hr')\n", "    for date, value in zip(five_highs.index, five_highs.values)\n", "]\n", "\n", "four_annotations[:2]"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 255, "lines": ["In the `updatemenus` is where we specify the `annotations` that appear when a button is selected. We will only show annotations when an individual sensor is selected."]}, {"block": 31, "type": "code", "linesLength": 40, "startIndex": 256, "lines": ["updatemenus = list([\n", "    dict(\n", "        active=2,\n", "        buttons=list([\n", "            dict(\n", "                label='Sensor 4',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [True, False]\n", "                }, {\n", "                    'title': 'Sensor 4',\n", "                    'annotations': four_annotations\n", "                }]),\n", "            dict(\n", "                label='Sensor 5',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [False, True]\n", "                }, {\n", "                    'title': 'Sensor 5',\n", "                    'annotations': five_annotations\n", "                }]),\n", "            dict(\n", "                label='Both',\n", "                method='update',\n", "                args=[{\n", "                    'visible': [True, True]\n", "                }, {\n", "                    'title': 'Sensor Sensors'\n", "                }])\n", "        ]),\n", "    )\n", "])\n", "\n", "layout = go.Layout(\n", "    height=600,\n", "    width=800,\n", "    title='Steam Sensors',\n", "    xaxis=dict(tickformat='%a %b %d'),\n", "    updatemenus=updatemenus)"]}, {"block": 32, "type": "code", "linesLength": 4, "startIndex": 296, "lines": ["fig = go.Figure(data = [steam_data_four, steam_data_five], \n", "                layout=layout)\n", "\n", "iplot(fig)"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 300, "lines": ["# Animations\n", "\n", "Finally, we will work on producing animated plots. This allows us to see how a figure may change over time."]}, {"block": 34, "type": "code", "linesLength": 9, "startIndex": 303, "lines": ["spring = [3, 4, 5]\n", "summer = [6, 7, 8]\n", "fall = [9, 10, 11]\n", "winter = [12, 1, 2]\n", "\n", "int_to_days = {0: 'Mon', 1: 'Tues', 2: 'Wed', 3: 'Thurs',\n", "               4: 'Fri', 5: 'Sat', 6: 'Sun'}\n", "\n", "color_mapping = {'spring': 'green', 'summer': 'orange', 'fall': 'brown', 'winter':' blue'}"]}, {"block": 35, "type": "code", "linesLength": 24, "startIndex": 312, "lines": ["def format_season(season_months, season_name, indexer = ('Energy', '3'), name = 'Energy', units = 'kWh'):\n", "    \"\"\"Format data for one season\"\"\"\n", "    data = df[df.index.month.isin(season_months)].copy()\n", "    data_x = defaultdict(list)\n", "    data_y = defaultdict(list)\n", "    \n", "    color = color_mapping[season_name]\n", "    \n", "    for (time, dow), grouped in data.groupby([data.index.time, data.index.dayofweek]):\n", "        x = pd.datetime(2018, 3, 5 + dow, 0 + time.hour, 0 + time.minute)\n", "        y = grouped[indexer].mean()\n", "        data_x[dow].append(x)\n", "        data_y[dow].append(y)\n", "    \n", "    data_obj = []\n", "    for dow, x in data_x.items():\n", "        y = data_y[dow]\n", "        text = [f'{season_name} <br> {name}: {m:.2f} {units}' for m in y]\n", "        data_obj.append(go.Scatter(x = x, y = y, text = text,\n", "                                   hoverinfo='text',\n", "                                   line = dict(color=color, width=0.75),\n", "                                   name = season_name))\n", "    \n", "    return data_obj"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 336, "lines": ["winter_data_source = format_season(winter, 'winter')\n", "winter_data_source[0]['name']"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 338, "lines": ["summer_data_source = format_season(summer, 'summer')\n", "fall_data_source = format_season(fall, 'fall')\n", "spring_data_source = format_season(spring, 'spring')"]}, {"block": 38, "type": "code", "linesLength": 6, "startIndex": 341, "lines": ["layout = go.Layout(title = 'Seasonal Average Energy Use', \n", "                   xaxis=dict(nticks = 7, tickformat = '%A'))\n", "\n", "fig = go.Figure(data = summer_data_source + winter_data_source + fall_data_source + spring_data_source, \n", "                layout = layout)\n", "iplot(fig)"]}, {"block": 39, "type": "code", "linesLength": 9, "startIndex": 347, "lines": ["spring_data['hours'] = spring_data.index.hour\n", "spring_data['minutes'] = spring_data.index.minute\n", "\n", "spring_weekly = spring_data.groupby([spring_data.index.time, \n", "                                     spring_data.index.dayofweek]).\\\n", "                            mean().\\\n", "                            reset_index().loc[:, ['level_0', 'measured_at', 'Energy', 'hours', 'minutes']]\n", "spring_weekly.columns = ['Time', 'Day of Week', 'Energy', 'hours', 'minutes']\n", "spring_weekly.head()"]}, {"block": 40, "type": "code", "linesLength": 3, "startIndex": 356, "lines": ["spring_data_object = [go.Scatter(x = pd.datetime(2018, 3, 5 + row['Day of Week'], \n", "                                                 0 + row['hours'], 0 + row['minutes']),\n", "                                 y = row['Energy'])]"]}, {"block": 41, "type": "code", "linesLength": 15, "startIndex": 359, "lines": ["figure = {'data': [{'x': [0, 1], 'y': [0, 1]}],\n", "          'layout': {'xaxis': {'range': [0, 5], 'autorange': False},\n", "                     'yaxis': {'range': [0, 5], 'autorange': False},\n", "                     'title': 'Start Title',\n", "                     'updatemenus': [{'type': 'buttons',\n", "                                      'buttons': [{'label': 'Play',\n", "                                                   'method': 'animate',\n", "                                                   'args': [None]}]}]\n", "                    },\n", "          'frames': [{'data': [{'x': [1, 2], 'y': [1, 2]}]},\n", "                     {'data': [{'x': [1, 4], 'y': [1, 4]}]},\n", "                     {'data': [{'x': [3, 4], 'y': [3, 4]}],\n", "                      'layout': {'title': 'End Title'}}]}\n", "\n", "iplot(figure)"]}, {"block": 42, "type": "code", "linesLength": 0, "startIndex": 374, "lines": []}]
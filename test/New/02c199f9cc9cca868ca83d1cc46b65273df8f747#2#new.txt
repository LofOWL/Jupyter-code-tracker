[{"block": 0, "type": "markdown", "linesLength": 2, "startIndex": 0, "lines": ["# Introduction\n", "The objective of this notebook is to explore the solar power potential data. Of primary emphasis is visualizing the data on geographic maps."]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 2, "lines": ["### Imports\n", "Import libraries and write settings here."]}, {"block": 2, "type": "code", "linesLength": 5, "startIndex": 4, "lines": ["import numpy as np\n", "import pandas as pd\n", "import holoviews as hv\n", "from holoviews import opts\n", "hv.extension('bokeh', 'matplotlib')"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["df = pd.read_csv('solar-power_solar_potential_by_postal_code.csv')\n", "df.info()"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 11, "lines": ["from shapely import wkt\n", "df['geometry'] = df['center_point'].apply(wkt.loads)"]}, {"block": 5, "type": "code", "linesLength": 7, "startIndex": 13, "lines": ["df = df[['region_name', 'state_name', 'count_qualified', 'percent_covered', 'percent_qualified',\n", "         'number_of_panels_median', 'number_of_panels_total', 'kw_median', 'kw_total',\n", "         'install_size_kw_buckets', 'carbon_offset_metric_tons',\n", "        'existing_installs_count', 'geometry', 'lat_avg', 'lng_avg']]\n", "\n", "df['state_name'] = df['state_name'].astype('category')\n", "df.info()"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["df.kw_total.isna().sum()"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["df = pd.read_csv('air-quality_real_time.csv')\n", "df.info()"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 23, "lines": ["px.scatter_geo(df.query('value > 0 and pollutant==\"pm25\"'), lat='latitude', lon='longitude', \n", "               size='value')"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["df.pollutant.unique()"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["data = pd.read_csv('C:/Users/willk/Downloads/world_development_indicators_data_subset.csv')\n", "data.info()"]}, {"block": 11, "type": "code", "linesLength": 7, "startIndex": 28, "lines": ["from ipywidgets import interact\n", "\n", "@interact\n", "def plot_geo(pollutant=list(df['pollutant'].unique())):\n", "    return (px.scatter_geo(df.query(f'value > 0 and pollutant==@pollutant'), lat='latitude', lon='longitude', \n", "               size='value', hover_name='city', height=600, width=800,\n", "                  title=f'Worldwide {pollutant} Pollution'))"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["data.columns"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 36, "lines": ["cols = data.columns[5:]\n", "\n", "@interact\n", "def plot_scatter(x=cols, y=cols[1:], year=data['year'].unique()):\n", "    return px.scatter(data.query('year == @year'), x=x, y=y, title=f'{y.title()} vs {x.title()}')"]}, {"block": 14, "type": "code", "linesLength": 8, "startIndex": 41, "lines": ["cols = data.columns[5:]\n", "\n", "@interact\n", "def plot_scatter(x=cols, y=cols[1:]):\n", "    return px.scatter(data, hover_name='country_name',\n", "                      animation_frame='year', \n", "                      animation_group='country_name',\n", "                      x=x, y=y, title=f'{y.title()} vs {x.title()}')"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["df.head()"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["px.scatter(df, 'carbon_offset_metric_tons', 'count_qualified')"]}, {"block": 17, "type": "code", "linesLength": 6, "startIndex": 51, "lines": ["import plotly_express as px\n", "px.scatter_geo(df.dropna(subset=['kw_total']).sample(1000), \n", "               lat='lat_avg', lon='lng_avg',\n", "               color='percent_qualified', size='kw_total', \n", "               hover_name='state_name',\n", "               scope='usa', height=800, width=600)"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["adf.head()"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 58, "lines": ["import geopandas\n", "\n", "gdf = geopandas.GeoDataFrame(df, geometry='geometry')\n", "world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["world.head()"]}, {"block": 21, "type": "code", "linesLength": 4, "startIndex": 63, "lines": ["ax = world[world.name == 'United States'].plot(color='white', figsize=(12, 9), \n", "                                               edgecolor='black')\n", "_ = gdf.plot(ax=ax, markersize=1, \n", "         legend=True, column='percent_qualified')"]}, {"block": 22, "type": "code", "linesLength": 7, "startIndex": 67, "lines": ["import cartopy.crs as ccrs\n", "import holoviews as hv\n", "from holoviews import opts\n", "import geoviews as gv\n", "import geoviews.feature as gf\n", "\n", "hv.extension('bokeh', 'matplotlib')"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 74, "lines": ["df = df[(df['state_name'] != 'Hawaii') & (df['state_name'] != 'Alaska')].copy()\n", "df = df[~(df['region_name'].apply(lambda x:len(str(x)) == 3))]"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 76, "lines": ["gdata = gv.Dataset(df, kdims=['lng_avg', 'lat_avg'], \n", "                   vdims=[c for c in df if c not in ['lat_avg', 'lng_avg', 'geometry']])\n", "gdata"]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 79, "lines": ["points = gv.Points([(lng, lat, percent_covered) for lng, lat, \n", "                   percent_covered in zip(df['lng_avg'], \n", "                                          df['lat_avg'],\n", "                                          df['percent_covered'])], \n", "                   vdims=['Percent Covered'])"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 84, "lines": ["type(gdata.to(hv.Points))"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 85, "lines": ["type(gdata.to(gv.Points))"]}, {"block": 28, "type": "code", "linesLength": 5, "startIndex": 86, "lines": ["import datashader as ds\n", "from holoviews.operation.datashader import datashade, rasterize\n", "\n", "graph = datashade(gdata, aggregator=ds.mean('percent_qualified'))\n", "graph.opts(height=600, width=800, tools=['hover'])"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 91, "lines": ["df.drop(columns=['geometry']).to_parquet('solar_potential_by_postal_code_formatted.parquet')"]}, {"block": 30, "type": "code", "linesLength": 3, "startIndex": 92, "lines": ["rast = rasterize(gdata, aggregator=ds.mean('percent_qualified'))\n", "rast.opts(bgcolor='white', logz=True, cmap='cividis',\n", "          tools=['hover'], height=500, width=700, colorbar=True) * gf.coastline * gf.rivers * gf.borders"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 95, "lines": ["gdata.to(gv.Points, groupby='state_name') * gf.coastline"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 96, "lines": ["gdata.to(gv.Points, \n", "         vdims='percent_covered').opts(cmap='viridis') * gf.coastline"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 98, "lines": ["points.opts(tools=['hover'], cmap='inferno', projection=ccrs.Robinson\n", "            ()) * gf.coastline"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 100, "lines": ["df['state_name'].unique()"]}, {"block": 35, "type": "code", "linesLength": 7, "startIndex": 101, "lines": ["import holoviews as hv\n", "from holoviews import opts\n", "import dask.dataframe as dd\n", "import datashader as ds\n", "import geoviews as gv\n", "\n", "from holoviews.operation.datashader import datashade, rasterize"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 108, "lines": ["from datashader.colors import viridis"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 109, "lines": ["datashade(gdata, cmap=viridis, color_key=True,\n", "          aggregator=ds.mean('percent_covered')).opts(tools=['hover'],\n", "                                                            height=500, width=800)"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["rasterize(gdata)"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 113, "lines": ["world['geometry'].iloc[1]"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 114, "lines": ["df.columns"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 115, "lines": ["df['region_name'].unique()"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 116, "lines": ["df['percent_covered'].plot.hist()"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["df[df['percent_qualified'] > 100]"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 118, "lines": ["df2 = pd.read_csv('solar-power_solar_potential_by_postal_code.csv')\n", "df2.describe()"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 120, "lines": ["df = pd.read_csv('solar-power_solar_potential_by_census_tract.csv')\n", "df.describe()"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 122, "lines": ["df.shape"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 123, "lines": ["df[df['percent_covered'] > 100]"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["print(f\"{df['kw_total'].sum():,f}\")"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 125, "lines": ["gdata.to(gv.Points).opts(height=600, width=900, \n", "                         tools=['hover'], cmap='inferno') * gf.borders"]}, {"block": 50, "type": "code", "linesLength": 3, "startIndex": 127, "lines": ["points = gv.Points([nyc, london, beijing], vdims=['City'], extents=(-180, -90, 180, 90))\n", "print('Default projection:', points.crs.__class__.__name__)\n", "points.opts(size=6, width=600, height=500) * gf.borders * gf.coastline"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 130, "lines": ["df.describe()"]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 131, "lines": ["gdf.head()"]}, {"block": 53, "type": "code", "linesLength": 0, "startIndex": 132, "lines": []}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 132, "lines": ["df['center_point'].plot()"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 133, "lines": ["import geopandas `"]}, {"block": 56, "type": "code", "linesLength": 30, "startIndex": 134, "lines": ["# Data manipulation\n", "import pandas as pd\n", "import numpy as np\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 50\n", "pd.options.display.max_rows = 30\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "from IPython import get_ipython\n", "ipython = get_ipython()\n", "\n", "# autoreload extension\n", "if 'autoreload' not in ipython.extension_manager.loaded:\n", "    %load_ext autoreload\n", "\n", "%autoreload 2\n", "\n", "# Visualizations\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.go_offline(connected=True)\n", "cf.set_config_file(theme='white')"]}, {"block": 57, "type": "markdown", "linesLength": 2, "startIndex": 164, "lines": ["# Analysis/Modeling\n", "Do work here"]}, {"block": 58, "type": "markdown", "linesLength": 2, "startIndex": 166, "lines": ["# Results\n", "Show graphs and stats here"]}, {"block": 59, "type": "markdown", "linesLength": 2, "startIndex": 168, "lines": ["# Conclusions and Next Steps\n", "Summarize findings here"]}, {"block": 60, "type": "code", "linesLength": 0, "startIndex": 170, "lines": []}]
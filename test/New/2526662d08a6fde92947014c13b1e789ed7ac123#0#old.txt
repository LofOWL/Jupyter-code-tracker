[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Pairplots in Python\n", "\n", "In this notebook we will explore making pairplots in Python using the seaborn visualization library. We'll start with the default `sns.pairplot` and then look at customizing our plots using `sns.PairGrids`."]}, {"block": 1, "type": "code", "linesLength": 3, "startIndex": 3, "lines": ["# Pandas and numpy for data manipulation\n", "import pandas as pd\n", "import numpy as np"]}, {"block": 2, "type": "code", "linesLength": 11, "startIndex": 6, "lines": ["# matplotlib for plotting\n", "import matplotlib.pyplot as plt\n", "import matplotlib\n", "\n", "# Set text size\n", "matplotlib.rcParams['font.size'] = 18\n", "\n", "# Seaborn for pairplots\n", "import seaborn as sns\n", "\n", "sns.set_context('talk', font_scale=1.2);"]}, {"block": 3, "type": "markdown", "linesLength": 10, "startIndex": 17, "lines": ["# Gapminder Socioeconomic Data\n", "\n", "We will be using [GapMinder socioeconomic data](https://cran.r-project.org/web/packages/gapminder/README.html) that is available in the R package `gapminder`. The data has been saved to a csv file which we will read into a dataframe. There are six columns in the data:\n", "\n", "1. Country\n", "2. Continent: useful for grouping data\n", "3. Year: data coveres 1952-2007\n", "4. life_exp: the life expectancy at birth \n", "5. pop: population\n", "6. gdp_per_cap: the per capita (per person) GDP in [international dollars](https://en.wikipedia.org/wiki/Geary%E2%80%93Khamis_dollar)"]}, {"block": 4, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["df = pd.read_csv('data/gapminder_data.csv')\n", "df.columns = ['country', 'continent', 'year', 'life_exp', 'pop', 'gdp_per_cap']\n", "df.head()"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["We can quickly find summary stats for the data using the `describe` method of a dataframe."]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["df.describe()"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["The main data transformation we will perform is to create a column showing the decade. This can be used for grouping the data and seeing how trends have changed by decade. This is easily done using the `cut` method in pandas."]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 33, "lines": ["df['decade'] = pd.cut(df['year'], bins = range(1950, 2010, 10))\n", "df.head()"]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 35, "lines": ["# Default Pair Plot with All Data\n", "\n", "Let's use the entire dataset and `sns.pairplot` to create a simple, yet useful plot. "]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 38, "lines": ["sns.pairplot(df);"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 39, "lines": ["The default pairplot shows scatter plots between variables on the upper and lower triangle and histograms along the diagonal. Already, we can see some trends such as a positive correlation between `gdp_per_cap` and `life_exp` and `year` and `life_exp` which suggests that people in richer countries live longer and that in general, people have been living longer as time increases. We can't say what causes theses trends, only that there is a correlation. \n", "\n", "We can also see that the distribution of `pop` and `gdp_per_cap` is heavily skewed to the right. To better represent the data, we can take the log transform of those columns. "]}, {"block": 12, "type": "code", "linesLength": 4, "startIndex": 42, "lines": ["df['log_pop'] = np.log10(df['pop'])\n", "df['log_gdp_per_cap'] = np.log10(df['gdp_per_cap'])\n", "\n", "df_log = df.drop(columns = ['pop', 'gdp_per_cap'])"]}, {"block": 13, "type": "markdown", "linesLength": 3, "startIndex": 46, "lines": ["## Group and Color by a Variable\n", "\n", "In order to better understand the data, we can color the `pairplot` using a categorical variable and the `hue` keyword. First, we will color the plots by the continent. "]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 49, "lines": ["matplotlib.rcParams['font.size'] = 40\n", "sns.pairplot(df_log, hue = 'continent');\n", "plt.suptitle('Pairplot Colored by Continent');"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["I don't find stacked histograms (on the diagonal) to be very useful, and there are some issues with overlapping data points (known as overplotting). We can fix these by adding in a few customizations to the `pairplot` call. "]}, {"block": 16, "type": "markdown", "linesLength": 3, "startIndex": 53, "lines": ["## Customizing `pairplot`\n", "\n", "First, let's change the diagonal from a histogram to a kde which can better show the differences between continents. We can also adjust the alpha (intensity) of the scatter plots to better show all the data and change the size of the markers on the scatter plot. Finally, I increase the size of all the plots to better show the data."]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["sns.pairplot(df_log, hue = 'continent', diag_kind = 'kde', plot_kws = {'alpha': 0.6, 's': 80, 'edgecolor': 'k'}, size = 4);\n", "plt.suptitle('Pairplot Colored by Continent', size = 28, y = 1.02);"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["That makes some of the trends more clear. We can see that Oceania and Europe tend to have the highest life expectancy and highest GDP with Asian countries tending to have the greatest population. The density plots on the diagonal are better for when we have data in multiple categories to make comparisons. We can color the plot by any variable we like. For example, here is a plot colored by the decade categorical variable we created earlier. "]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 59, "lines": ["sns.pairplot(df_log, hue = 'decade', diag_kind = 'kde', plot_kws = {'alpha': 0.6, 's': 80, 'edgecolor': 'k'}, size = 4);\n", "plt.suptitle('Pairplot Colored by Decade', size = 28);"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["In this case, we can know see that life expectancy has increased over the decades as has population. Retaining the year variable might not make much sense when we are already coloring by the decade."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["There is still quite a lot of noise on the scatter plots, mostly because we are plotting many years at once. Let's limit ourselves to the most recent year in the data. Notice how we must now use the `vars` keyword to specify the variables we want to plot. It does not make sense to plot the year variable since it no longer varies. We will limit the plot to the three remaining numerical variables. "]}, {"block": 22, "type": "code", "linesLength": 3, "startIndex": 63, "lines": ["sns.pairplot(df_log[df_log['year'] == 2007], vars = ['life_exp', 'log_pop', 'log_gdp_per_cap'], \n", "             hue = 'continent', diag_kind = 'kde', plot_kws = {'alpha': 0.6, 's': 80, 'edgecolor': 'k'}, size = 4);\n", "plt.suptitle('Pair Plot of Socioeconomic Data for 2007', size = 28);"]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 66, "lines": ["# More Customization with `sns.PairGrid` \n", "\n", "When the options offered by pairplot are not enough, we can move on to more powerful PairGrid. This allows us to define our own functions to map to the lower and upper triangles and the diagonal. For example, we might want a plot that instead of showing two instaces of the scatter plots, shows the [Pearson Correlation coefficient](http://www.statisticshowto.com/probability-and-statistics/correlation-coefficient-formula/) (a measure of a linear trend) on one of the triangles. To do this, we can just write a function to calculate the statistic and then map it to the appropriate part of the plot."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["First, we will show the basic usage of `sns.PairGrid`. Here, we map a scatter plot to the upper triangle, a density plot to the diagonal, and a 2D density plot to the lower triangle. `PairGrid` is a class and not a function, which means that we need to create an instance and then use methods of that instance to build a plot. Then, after we have added all the methods to the instance, we can show the resulting plot."]}, {"block": 25, "type": "code", "linesLength": 6, "startIndex": 70, "lines": ["# Create an instance of the PairGrid class.\n", "grid = sns.PairGrid(data= df_log[df_log['year'] == 2007],\n", "                    vars = ['life_exp', 'log_pop', 'log_gdp_per_cap'], size = 4)\n", "grid = grid.map_upper(plt.scatter, color = 'red')\n", "grid = grid.map_lower(sns.kdeplot, cmap = 'Reds')\n", "grid = grid.map_diag(plt.hist, bins = 10, color = 'red', edgecolor = 'k');"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Now that we see how to map different functions to the different elements, we can write out own function to put on the plot. We'll use a simple function to show the correlation coffient on the lower triangle. [Thanks to this Stack Overflow answer!](https://stackoverflow.com/questions/30942577/seaborn-correlation-coefficient-on-pairgrid) "]}, {"block": 27, "type": "code", "linesLength": 12, "startIndex": 77, "lines": ["def corr(x, y, **kwargs):\n", "    label = r'$\\rho$ = ' + str(round((np.corrcoef(x, y)[0][1]), 2))\n", "    ax = plt.gca()\n", "    ax.annotate(label, xy = (0.2, 0.9), size = 20, xycoords = ax.transAxes)\n", "    \n", "grid = sns.PairGrid(data= df_log[df_log['year'] == 2007],\n", "                    vars = ['life_exp', 'log_pop', 'log_gdp_per_cap'], size = 4)\n", "\n", "grid = grid.map_upper(plt.scatter, color = 'red')\n", "grid = grid.map_upper(corr)\n", "grid = grid.map_lower(sns.kdeplot, cmap = 'Reds')\n", "grid = grid.map_diag(plt.hist, bins = 10, edgecolor =  'k', color = 'red');"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["We can map any function we would like to any of the areas. For example, maybe we would like to show the summary stats on the diagonal."]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["x  = pd.Series(df_log.log_gdp_per_cap)\n", "y = pd.Series(x.describe()[['mean', 'std', 'min', '50%', 'max']])"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 92, "lines": ["10 ** y"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["pd.DataFrame(y)"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["import pprint\n", "pprint.pprint(y.to_string())"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 96, "lines": ["labels = [print(name, value) for name, value in zip(y.index, y.values)]"]}, {"block": 34, "type": "code", "linesLength": 20, "startIndex": 97, "lines": ["def summary(x, **kwargs):\n", "    x = pd.Series(x)\n", "    label = x.describe()[['mean', 'std', 'min', '50%', 'max']]\n", "    \n", "    if 'log' in label.name:\n", "        label = 10 ** label\n", "        \n", "    label = label.round()\n", "    ax = plt.gca()\n", "    \n", "    ax.annotate(pd.DataFrame(label),\n", "               xy = (0.1, 0.2), size = 20, xycoords = ax.transAxes)\n", "\n", "grid = sns.PairGrid(data= df_log[df_log['year'] == 2007],\n", "                    vars = ['life_exp', 'log_pop', 'log_gdp_per_cap'], size = 4)\n", "\n", "grid = grid.map_upper(plt.scatter, color = 'red')\n", "grid = grid.map_upper(corr)\n", "grid = grid.map_lower(sns.kdeplot, cmap = 'Reds')\n", "grid = grid.map_diag(summary);"]}, {"block": 35, "type": "code", "linesLength": 0, "startIndex": 117, "lines": []}]
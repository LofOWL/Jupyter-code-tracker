[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Load in Data"]}, {"block": 1, "type": "code", "linesLength": 5, "startIndex": 1, "lines": ["# Pandas is used for data manipulation\n", "import pandas as pd\n", "\n", "# Read in data as a dataframe\n", "features = pd.read_csv('data/temps_extended.csv')"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["# Data Preparation"]}, {"block": 3, "type": "code", "linesLength": 21, "startIndex": 7, "lines": ["# One Hot Encoding\n", "features = pd.get_dummies(features)\n", "\n", "# Extract features and labels\n", "labels = features['actual']\n", "features = features.drop('actual', axis = 1)\n", "\n", "# List of features for later use\n", "feature_list = list(features.columns)\n", "\n", "# Convert to numpy arrays\n", "import numpy as np\n", "\n", "features = np.array(features)\n", "labels = np.array(labels)\n", "\n", "# Training and Testing Sets\n", "from sklearn.model_selection import train_test_split\n", "\n", "train_features, test_features, train_labels, test_labels = train_test_split(features, labels, \n", "                                                                            test_size = 0.25, random_state = 42)"]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 28, "lines": ["print('Training Features Shape:', train_features.shape)\n", "print('Training Labels Shape:', train_labels.shape)\n", "print('Testing Features Shape:', test_features.shape)\n", "print('Testing Labels Shape:', test_labels.shape)"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["print('{:0.1f} years of data in the training set'.format(train_features.shape[0] / 365.))\n", "print('{:0.1f} years of data in the test set'.format(test_features.shape[0] / 365.))"]}, {"block": 6, "type": "markdown", "linesLength": 4, "startIndex": 34, "lines": ["## Restrict to the Most Important Features\n", "\n", "These were the six features required to reach a total feature importance of 95% in the first improving random forest notebook.\n", "We will use only these features in order to speed up the model."]}, {"block": 7, "type": "code", "linesLength": 13, "startIndex": 38, "lines": ["# Names of five importances accounting for 95% of total importance\n", "important_feature_names = ['temp_1', 'average', 'ws_1', 'temp_2', 'friend', 'year']\n", "\n", "# Find the columns of the most important features\n", "important_indices = [feature_list.index(feature) for feature in important_feature_names]\n", "\n", "# Create training and testing sets with only the important features\n", "important_train_features = train_features[:, important_indices]\n", "important_test_features = test_features[:, important_indices]\n", "\n", "# Sanity check on operations\n", "print('Important train features shape:', important_train_features.shape)\n", "print('Important test features shape:', important_test_features.shape)"]}, {"block": 8, "type": "code", "linesLength": 6, "startIndex": 51, "lines": ["# Use only the most important features\n", "train_features = important_train_features[:]\n", "test_features = important_test_features[:]\n", "\n", "# Update feature list for visualizations\n", "feature_list = important_feature_names[:]"]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 57, "lines": ["### Examine the Default Random Forest to Determine Parameters\n", "\n", "We will use these parameters as a starting point. I relied on the [sklearn random forest documentation](http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html) to determine which features to change and the available options."]}, {"block": 10, "type": "code", "linesLength": 9, "startIndex": 60, "lines": ["from sklearn.ensemble import RandomForestRegressor\n", "\n", "rf = RandomForestRegressor(random_state = 42)\n", "\n", "from pprint import pprint\n", "\n", "# Look at parameters used by our current forest\n", "print('Parameters currently in use:\\n')\n", "pprint(rf.get_params())"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["# Random Search with Cross Validation"]}, {"block": 12, "type": "code", "linesLength": 23, "startIndex": 70, "lines": ["from sklearn.model_selection import RandomizedSearchCV\n", "\n", "# Number of trees in random forest\n", "n_estimators = [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)]\n", "# Number of features to consider at every split\n", "max_features = ['auto', 'sqrt']\n", "# Maximum number of levels in tree\n", "max_depth = [int(x) for x in np.linspace(10, 100, num = 10)]\n", "max_depth.append(None)\n", "# Minimum number of samples required to split a node\n", "min_samples_split = [2, 5, 10]\n", "# Minimum number of samples required at each leaf node\n", "min_samples_leaf = [1, 2, 4]\n", "# Method of selecting samples for training each tree\n", "bootstrap = [True, False]\n", "\n", "# Create the random grid\n", "random_grid = {'n_estimators': n_estimators,\n", "               'max_features': max_features,\n", "               'max_depth': max_depth,\n", "               'min_samples_split': min_samples_split,\n", "               'min_samples_leaf': min_samples_leaf,\n", "               'bootstrap': bootstrap}"]}, {"block": 13, "type": "code", "linesLength": 11, "startIndex": 93, "lines": ["# Use the random grid to search for best hyperparameters\n", "# First create the base model to tune\n", "rf = RandomForestRegressor()\n", "# Random search of parameters, using 3 fold cross validation, \n", "# search across 100 different combinations, and use all available cores\n", "rf_random = RandomizedSearchCV(estimator=rf, param_distributions=random_grid,\n", "                              n_iter = 100, scoring='neg_mean_absolute_error', \n", "                              cv = 3, verbose=2, random_state=42, n_jobs=-1)\n", "\n", "# Fit the random search model\n", "rf_random.fit(train_features, train_labels)"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["rf_random.best_params_"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["## Evaluation Function"]}, {"block": 16, "type": "code", "linesLength": 8, "startIndex": 106, "lines": ["def evaluate(model, test_features, test_labels):\n", "    predictions = model.predict(test_features)\n", "    errors = abs(predictions - test_labels)\n", "    mape = 100 * np.mean(errors / test_labels)\n", "    accuracy = 100 - mape\n", "    print('Model Performance')\n", "    print('Average Error: {:0.4f} degrees.'.format(np.mean(errors)))\n", "    print('Accuracy = {:0.2f}%.'.format(accuracy))"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["#### Evaluate the Default Model"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 115, "lines": ["base_model = RandomForestRegressor(n_estimators = 1000, random_state = 42)\n", "base_model.fit(train_features, train_labels)\n", "evaluate(base_model, test_features, test_labels)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 118, "lines": ["#### Evaluate the Best Random Search Model"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 119, "lines": ["best_random = rf_random.best_estimator_\n", "evaluate(best_random, test_features, test_labels)"]}, {"block": 21, "type": "markdown", "linesLength": 4, "startIndex": 121, "lines": ["# Grid Search \n", "\n", "We can now perform grid search building on the result from the random search. \n", "We will test a range of hyperparameters around the best values returend by random search. "]}, {"block": 22, "type": "code", "linesLength": 19, "startIndex": 125, "lines": ["from sklearn.model_selection import GridSearchCV\n", "\n", "# Create the parameter grid based on the results of random search \n", "param_grid = {\n", "    'bootstrap': [True],\n", "    'max_depth': [80, 90, 100, 110],\n", "    'max_features': [2, 3],\n", "    'min_samples_leaf': [3, 4, 5],\n", "    'min_samples_split': [8, 10, 12],\n", "    'n_estimators': [100, 200, 300, 1000]\n", "}\n", "\n", "# Create a based model\n", "rf = RandomForestRegressor()\n", "\n", "# Instantiate the grid search model\n", "grid_search = GridSearchCV(estimator = rf, param_grid = param_grid, \n", "                           scoring = 'neg_mean_absolute_error', cv = 3, \n", "                           n_jobs = -1, verbose = 2)"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 144, "lines": ["# Fit the grid search to the data\n", "grid_search.fit(train_features, train_labels)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 146, "lines": ["grid_search.best_params_"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["best_grid = grid_search.best_estimator_\n", "evaluate(best_grid, test_features, test_labels)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 149, "lines": ["## Another Round of Grid Search"]}, {"block": 27, "type": "code", "linesLength": 18, "startIndex": 150, "lines": ["param_grid = {\n", "    'bootstrap': [True],\n", "    'max_depth': [110, 120, None],\n", "    'max_features': [3, 4],\n", "    'min_samples_leaf': [5, 6, 7],\n", "    'min_samples_split': [10],\n", "    'n_estimators': [75, 100, 125]\n", "}\n", "\n", "# Create a based model\n", "rf = RandomForestRegressor()\n", "\n", "# Instantiate the grid search model\n", "grid_search_ad = GridSearchCV(estimator = rf, param_grid = param_grid, \n", "                           scoring = 'neg_mean_absolute_error', cv = 3, \n", "                           n_jobs = -1, verbose = 2)\n", "\n", "grid_search_ad.fit(train_features, train_labels)"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 168, "lines": ["grid_search_ad.best_params_"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 169, "lines": ["best_grid_ad = grid_search_ad.best_estimator_\n", "evaluate(best_grid_ad, test_features, test_labels)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 171, "lines": ["This time our performance slightly decreased. Therefore, we will go back to the best model returned by the first grid search."]}, {"block": 31, "type": "markdown", "linesLength": 3, "startIndex": 172, "lines": ["## Final Model\n", "\n", "The final model from hyperparameter tuning is as follows."]}, {"block": 32, "type": "code", "linesLength": 4, "startIndex": 175, "lines": ["print('Model Parameters:\\n')\n", "pprint(best_grid.get_params())\n", "print('\\n')\n", "evaluate(best_grid, test_features, test_labels)"]}, {"block": 33, "type": "code", "linesLength": 0, "startIndex": 179, "lines": []}]
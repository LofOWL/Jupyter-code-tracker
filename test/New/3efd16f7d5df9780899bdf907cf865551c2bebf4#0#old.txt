[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Stock Price Predictions\n", "\n", "We can also make testable predictions by restricting our model to a subset of the data, and then using the forecasted values to see how correct our model is. We will restrict data up until the end of 2016, and then try to make predictions for 2017."]}, {"block": 1, "type": "code", "linesLength": 14, "startIndex": 3, "lines": ["import quandl \n", "import pandas as pd\n", "import numpy as np\n", "import fbprophet\n", "\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "\n", "import matplotlib\n", "matplotlib.rcParams['axes.labelsize'] = 16\n", "matplotlib.rcParams['xtick.labelsize'] = 14\n", "matplotlib.rcParams['ytick.labelsize'] = 14\n", "matplotlib.rcParams['axes.titlesize'] = 22\n", "matplotlib.rcParams['text.color'] = 'k'"]}, {"block": 2, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["matplotlib.rcParams.keys()"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["## Retrieve Data from Quandl"]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 19, "lines": ["quandl.ApiConfig.api_key = 'rFsSehe51RLzREtYhLfo'\n", "\n", "# Using Tesla data\n", "tesla_stocks = quandl.get('WIKI/TSLA')"]}, {"block": 5, "type": "code", "linesLength": 6, "startIndex": 23, "lines": ["# Set the index (with dates) to a column \n", "tesla_stocks.reset_index(level=0, inplace=True)\n", "\n", "# Rename the columns for prophet and create a year column\n", "tesla_stocks.rename(columns={'Date': 'ds', 'Adj. Close': 'y'}, inplace=True)\n", "tesla_stocks['Year'] = [date.year for date in tesla_stocks['ds']]"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["tesla_stocks.head()"]}, {"block": 7, "type": "code", "linesLength": 6, "startIndex": 30, "lines": ["# Create a new dataframe with the relevant information\n", "tesla_data = tesla_stocks[['ds', 'Year', 'y']]\n", "\n", "# Training and testing data\n", "tesla_train = tesla_data[tesla_data['Year'] < 2017]\n", "tesla_test = tesla_data[tesla_data['Year'] > 2016]"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["## Prophet Model"]}, {"block": 9, "type": "code", "linesLength": 14, "startIndex": 37, "lines": ["# Create a new model \n", "tesla_prophet = fbprophet.Prophet(changepoint_prior_scale=0.2)\n", "\n", "# Train the model\n", "tesla_prophet.fit(tesla_train)\n", "\n", "# Number of days to make predictions \n", "days = (max(tesla_test['ds']) - min(tesla_test['ds'])).days\n", "\n", "# Future dataframe\n", "tesla_forecast = tesla_prophet.make_future_dataframe(periods = days, freq = 'D')\n", "\n", "# Make forecasts\n", "tesla_forecast = tesla_prophet.predict(tesla_forecast)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["## Accuracy and Profits (or losses)"]}, {"block": 11, "type": "code", "linesLength": 8, "startIndex": 52, "lines": ["tesla_results = tesla_forecast.merge(tesla_test, how = 'inner', on = 'ds')\n", "tesla_results = tesla_results[['ds', 'y', 'yhat']]\n", "\n", "# Predicted difference between stock prices\n", "tesla_results['pred_diff'] = (tesla_results['yhat']).diff()\n", "\n", "# Actual difference between stock prices\n", "tesla_results['real_diff'] = (tesla_results['y']).diff()"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 60, "lines": ["# Correct direction column\n", "tesla_results['correct'] = (np.sign(tesla_results['pred_diff']) == np.sign(tesla_results['real_diff'])) * 1\n", "print('Correct direction predicted: {:0.2f}% of days.'.format(100 * np.mean(tesla_results['correct'])))"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["### Value of Predictions"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 64, "lines": ["# Need to include the adjusted open to calculate profits or losses\n", "tesla_results = tesla_results.merge(tesla_stocks[['ds', 'Adj. Open']], how = 'left', on = 'ds')\n", "tesla_results['daily_change'] = abs(tesla_results['y'] - tesla_results['Adj. Open'])"]}, {"block": 15, "type": "code", "linesLength": 12, "startIndex": 67, "lines": ["tesla_pred_increase = tesla_results[tesla_results['pred_diff'] > 0]\n", "tesla_pred_increase.reset_index(inplace=True)\n", "\n", "profits = []\n", "\n", "for i, correct in enumerate(tesla_pred_increase['correct']):\n", "    if correct == 1:\n", "        profits.append(1000 * tesla_pred_increase.ix[i, 'daily_change'])\n", "    else:\n", "        profits.append(-1 * 1000 * tesla_pred_increase.ix[i, 'daily_change'])\n", "        \n", "tesla_pred_increase['profit'] = profits"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 79, "lines": ["print('Predicted profits: {:.0f} $.'.format(np.sum(tesla_pred_increase['profit'])))"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 80, "lines": ["smart_profit = 1000 * (tesla_results.ix[len(tesla_results) - 1, 'y'] - tesla_results.ix[0, 'Adj. Open'])\n", "print('Buy and Hold profits: {:.0f} $.'.format(smart_profit))"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["# Visualizations"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 83, "lines": ["tesla_plot = pd.merge(tesla_stocks, tesla_forecast, on = 'ds', how = 'inner')"]}, {"block": 20, "type": "code", "linesLength": 17, "startIndex": 84, "lines": ["# Set up the plot\n", "fig, ax = plt.subplots(1, 1, figsize=(10, 8))\n", "\n", "# Plot the actual values\n", "ax.plot(tesla_plot['ds'], tesla_plot['y'], 'ko-', linewidth = 1.4, alpha = 0.8, ms = 1.8, label = 'Observations')\n", "ax.plot(tesla_plot['ds'], tesla_plot['yhat'], 'darkslateblue',linewidth = 3, label = 'Predicted');\n", "\n", "# Plot the uncertainty interval\n", "ax.fill_between(tesla_plot['ds'].dt.to_pydatetime(), tesla_plot['yhat_upper'], tesla_plot['yhat_lower'], alpha = 0.6, \n", "               facecolor = 'gold', edgecolor = 'k', linewidth = 1.2, label = 'Uncertainty')\n", "\n", "# Put a vertical line at the start of predictions\n", "plt.vlines(x='2017-01-01', ymin=0, ymax=max(tesla_plot['y']), colors = 'r',\n", "           linestyles='dashed')\n", "plt.legend(loc = 2, prop={'size': 14}); plt.xlabel('Date'); plt.ylabel('Price $');\n", "plt.grid(linewidth=0.6, alpha = 0.6)\n", "plt.title('Tesla Stock Price Observed and Predicted');"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 101, "lines": ["# Merge results with the predicted increase containing profits\n", "tesla_results = pd.merge(tesla_results, tesla_pred_increase[['ds', 'profit']], on = 'ds', how='left')"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["# Total predicted profit at each day\n", "tesla_results['total_profit'] = tesla_results['profit'].cumsum()"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 105, "lines": ["# Forward fill the total profits\n", "tesla_results.ix[0, 'total_profit'] = 0\n", "tesla_results['total_profit'] = tesla_results['total_profit'].ffill()"]}, {"block": 24, "type": "code", "linesLength": 9, "startIndex": 108, "lines": ["# Calculate the profits from buying and holding\n", "smart_profits = []\n", "first_open = tesla_results.ix[0, 'Adj. Open']\n", "\n", "for i, close in enumerate(tesla_results['y']):\n", "    smart_profits.append(1000 * (close - first_open))\n", "   \n", "# No need for cumulative sum because smart profits are unrealized\n", "tesla_results['total_smart'] = smart_profits"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["tesla_results.head()"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["plt.plot(tesla_results['ds'], tesla_results['total_profit'], 'g')"]}, {"block": 27, "type": "code", "linesLength": 32, "startIndex": 119, "lines": ["from matplotlib.collections import LineCollection\n", "from matplotlib.colors import ListedColormap, BoundaryNorm\n", "\n", "\n", "x = np.array(list(range(len(tesla_results))))\n", "xlabels = [entry.date() for entry in (pd.date_range(start = min(tesla_results['ds']),\n", "                         periods = 10, freq = 'm'))]\n", "y = np.array(tesla_results['total_profit'])\n", "\n", "# Create a colormap for red, green and blue and a norm to color\n", "# f' < -0.5 red, f' > 0.5 blue, and the rest green\n", "cmap = ListedColormap(['r', 'g'])\n", "norm = BoundaryNorm([0], cmap.N)\n", "\n", "# Create a set of line segments so that we can color them individually\n", "# This creates the points as a N x 1 x 2 array so that we can stack points\n", "# together easily to get the segments. The segments array for line collection\n", "# needs to be numlines x points per line x 2 (x and y)\n", "points = np.array([x, y]).T.reshape(-1, 1, 2)\n", "segments = np.concatenate([points[:-1], points[1:]], axis=1)\n", "\n", "# Create the line collection object, setting the colormapping parameters.\n", "# Have to set the actual values used for colormapping separately.\n", "lc = LineCollection(segments, cmap=cmap, norm=norm)\n", "lc.set_array(y)\n", "lc.set_linewidth(3)\n", "\n", "fig1 = plt.figure()\n", "plt.gca().add_collection(lc)\n", "plt.xlim(x.min(), x.max())\n", "plt.ylim(y.min(), y.max())\n", "plt.xlabel(xlabels)"]}, {"block": 28, "type": "code", "linesLength": 21, "startIndex": 151, "lines": ["def plot_predictions(stock_df, forecast_df, ticker='TSLA'):\n", "    # merge the two dataframes\n", "    stock_plot = pd.merge(stock_df, forecast_df, on = 'ds', how = 'inner')\n", "    \n", "    # Set up the plot\n", "    fig, ax = plt.subplots(1, 1, figsize=(10, 8))\n", "\n", "    # Plot the actual values\n", "    ax.plot(stock_plot['ds'], stock_plot['y'], 'ko-', linewidth = 1.4, alpha = 0.8, ms = 1.8, label = 'Observed')\n", "    ax.plot(stock_plot['ds'], stock_plot['yhat'], 'darkslateblue',linewidth = 3, label = 'Predicted');\n", "\n", "    # Plot the uncertainty interval\n", "    ax.fill_between(stock_plot['ds'].dt.to_pydatetime(), stock_plot['yhat_upper'], stock_plot['yhat_lower'], alpha = 0.6, \n", "                   facecolor = 'gold', edgecolor = 'k', linewidth = 1.2, label = 'Uncertainty')\n", "\n", "    # Put a vertical line at the start of predictions\n", "    plt.vlines(x='2017-01-01', ymin=0, ymax=max(stock_plot['y']), colors = 'r',\n", "               linestyles='dashed')\n", "    plt.legend(loc = 2, prop={'size': 14}); plt.xlabel('Date'); plt.ylabel('Price $');\n", "    plt.grid(linewidth=0.6, alpha = 0.6)\n", "    plt.title('%s Price Observed and Predicted' % ticker);"]}, {"block": 29, "type": "code", "linesLength": 18, "startIndex": 172, "lines": ["def plot_profits(results, ticker):\n", "    # Total predicted profit at each day\n", "    results['total_profit'] = results['profit'].cumsum()\n", "    \n", "    # Forward fill the total predicted profits\n", "    tesla_results.ix[0, 'total_profit'] = 0\n", "    tesla_results['total_profit'] = tesla_results['total_profit'].ffill()\n", "    \n", "    # Calculate the profits from buying and holding\n", "    smart_profits = []\n", "    first_open = tesla_results.ix[0, 'Adj. Open']\n", "\n", "    for i, close in enumerate(tesla_results['y']):\n", "        smart_profits.append(1000 * (close - first_open))\n", "    \n", "    # Column with daily profits\n", "    # No need for cumulative total because smart profits are unrealized\n", "    tesla_results['total_smart'] = smart_profits"]}, {"block": 30, "type": "code", "linesLength": 93, "startIndex": 190, "lines": ["def stock_predictor(ticker='TSLA'):\n", "    try:\n", "        # Using years from 2011 onwards\n", "        stock = quandl.get('WIKI/%s' % ticker.upper(), start_date = '2011-01-01')\n", "    except Exception as e:\n", "        print('Invalid Stock Ticker')\n", "        print(e)\n", "        return\n", "    \n", "    # Change the index to a Date column\n", "    stock_clean = stock.reset_index()[['Date', 'Adj. Close', 'Adj. Open']]\n", "    \n", "    # Create a year column\n", "    stock_clean['Year'] = [date.year for date in stock_clean['Date']]\n", "    \n", "    # Rename for prophet training\n", "    stock_clean = stock_clean.rename(columns={'Date': 'ds', 'Adj. Close': 'y'})\n", "    \n", "    # Training and Testing Sets\n", "    stock_train = stock_clean[stock_clean['Year'] < 2017]\n", "    stock_test = stock_clean[stock_clean['Year'] > 2016]\n", "    \n", "    # Create the prophet model and fit on training set\n", "    stock_prophet = fbprophet.Prophet(daily_seasonality=False,\n", "                                      changepoint_prior_scale=0.2)\n", "    stock_prophet.fit(stock_train)\n", "    \n", "    # Number of days to predict\n", "    days = (max(stock_test['ds']) - min(stock_test['ds'])).days\n", "    \n", "    # Make forecasts for entire length of test set + one week\n", "    stock_forecast = stock_prophet.make_future_dataframe(periods=days + 7, freq = 'D')\n", "    stock_forecast = stock_prophet.predict(stock_forecast)\n", "    \n", "    # Plot the entire series\n", "    plot_predictions(stock_clean, stock_forecast, ticker)\n", "    \n", "    # Dataframe for predictions and test values\n", "    results = stock_forecast[['ds', 'yhat', 'yhat_upper', 'yhat_lower']]\n", "    \n", "    # Merge to get acutal values (y)\n", "    results = pd.merge(results, stock_test[['ds', 'y']], on = 'ds', how='right')\n", "    \n", "    # Merge to get daily opening values (Adj. Open)\n", "    results = results.merge(stock_clean[['ds', 'Adj. Open']], on = 'ds', how ='inner')\n", "    \n", "    # Columns of daily changes\n", "    results['pred_diff'] = results['yhat'].diff()\n", "    results['real_diff'] = results['y'].diff()\n", "    \n", "    # Whether the prediction was right or wrong\n", "    # Multiply by 1 to convert to an integer\n", "    results['correct'] = (np.sign(results['pred_diff']) == np.sign(results['real_diff'])) * 1\n", "    \n", "    # Calculate daily change in price\n", "    results['daily_change'] = abs(results['y'] - results['Adj. Open'])\n", "    \n", "    # Only buy if predicted to increase\n", "    results_pred_increase = results[results['pred_diff'] > 0]\n", "        \n", "    # Calculate profits or losses\n", "    profits = []\n", "    for i, correct in enumerate(results_pred_increase['correct']):\n", "        if correct == 1:\n", "            profits.append(1000 * results.ix[i, 'daily_change'])\n", "        else:\n", "            profits.append(-1 * 1000 * results.ix[i, 'daily_change'])\n", "    \n", "    results_pred_increase['profit'] = profits\n", "    \n", "    # Dataframe for plottings profits\n", "    results = pd.merge(results, results_pred_increase[['ds', 'profit']], on = 'ds', how = 'left')\n", "    \n", "    plot_profits(results, ticker)\n", "    \n", "    # Calculate total profit if buying 1000 shares every day\n", "    total_profit = int(np.sum(profits))\n", "    \n", "    # Calculate total profit if buying and holding 1000 shares for entire time\n", "    first_price = int(results[results['ds'] == min(results['ds'])]['y'])\n", "    last_price = int(results[results['ds'] == max(results['ds'])]['y'])\n", "\n", "    # Smart profit\n", "    smart_profit = (last_price - first_price) * 1000\n", "    \n", "    # Total accuracy is percentage of correct predictions\n", "    accuracy = np.mean(results['correct']) *  100\n", "    \n", "    performance = {'pred_profit': total_profit, 'smart_profit': smart_profit, 'accuracy': accuracy}\n", "    \n", "    print('Your profit from playing the stock market in {}: {:.0f} $.'.format(ticker, total_profit))\n", "    print('The buy and hold profit (smart strategy) for {}: {:.0f} $.'.format(ticker, smart_profit))\n", "    print('Thanks for playing the stock market!')"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 283, "lines": ["stock_predictor('TSLA')"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 284, "lines": ["stock_predictor('CAT')"]}, {"block": 33, "type": "code", "linesLength": 0, "startIndex": 285, "lines": []}]
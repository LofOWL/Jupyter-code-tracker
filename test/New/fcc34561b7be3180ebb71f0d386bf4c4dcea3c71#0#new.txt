[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Purpose\n", "\n", "In an earlier notebook, I attemped to make a stock prediction model. This failed to say the least. However, I think there is still much to be salvaged from the attempt. Python code written for a foolish task (predicting the stock market) is not written in vain, but an ideal opportunity to learn some new skills. I had a ton of fun making the stock model, and I wanted to still show the process which ultimately is more important than the end result. After writing a ton of separate functions to act on stock data, I realized a much better approach was to make a class that could hold data and also had different functions for prediction, plotting, analysis and anything else that might be needed. Having already developed all of these functions separately, I thought it made a lot of sense to combine them into a single class. This notebook will build up the class, covering many data manipulation, plotting, and even modeling concepts in a single example! "]}, {"block": 1, "type": "code", "linesLength": 12, "startIndex": 3, "lines": ["# Quandl for financial analysis, pandas and numpy for data manipulation\n", "# fbprophet for additive models\n", "import quandl\n", "import pandas as pd\n", "import numpy as np\n", "import fbprophet\n", "\n", "# matplotlib pyplot for plotting\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "\n", "import matplotlib"]}, {"block": 2, "type": "code", "linesLength": 399, "startIndex": 15, "lines": ["# Class for analyzing and (attempting) to predict future prices\n", "# Contains a number of visualizations and analysis methods\n", "class Stocker():\n", "    \n", "    # Initialization requires a ticker symbol\n", "    def __init__(self, ticker):\n", "        # Symbol is used for labeling plots\n", "        self.symbol = ticker.split('/')[1]\n", "        # Retrieval the financial data\n", "        stock = quandl.get(ticker)\n", "        \n", "        # Set the index to a column called Date\n", "        stock = stock.reset_index(level=0)\n", "        \n", "        # Columns required for prophet\n", "        stock['ds'] = stock['Date']\n", "        stock['y'] = stock['Adj. Close']\n", "        \n", "        # Data assigned as class attribute\n", "        self.stock = stock.copy()\n", "        \n", "        # Minimum and maximum date in range\n", "        self.min_date = min(stock['Date'])\n", "        self.max_date = max(stock['Date'])\n", "        \n", "        # Find max and min prices and dates on which they occurred\n", "        self.max_price = np.max(self.stock['y'])\n", "        self.min_price = np.min(self.stock['y'])\n", "        self.max_price_date = self.stock['Date'][np.argmax(self.stock['y'])]\n", "        self.min_price_date = self.stock['Date'][np.argmin(self.stock['y'])]\n", "        \n", "        # The starting price (starting with the opening price)\n", "        self.starting_price = float(self.stock.ix[0, 'Adj. Open'])\n", "        \n", "        # The most recent price\n", "        self.most_recent_price = float(self.stock.ix[len(self.stock) - 1, 'y'])\n", "        \n", "        # This can be changed by user\n", "        self.changepoint_prior_scale = 0.2\n", "        \n", "    # Basic Historical Plot and Basic Statistics\n", "    def plot_stock(self):\n", "        self.reset_plot()\n", "        \n", "        # Useful statistics\n", "        print('Maximum price = ${:.2f} on {}.'.format(self.max_price, self.max_price_date.date()))\n", "        print('Minimum price = ${:.2f} on {}.'.format(self.min_price, self.min_price_date.date()))\n", "        print('Current price = ${:.2f}.'.format(self.most_recent_price))\n", "        \n", "        # Simple Plot \n", "        plt.style.use('fivethirtyeight');\n", "        plt.plot(self.stock['Date'], self.stock['Adj. Close'], 'r-', linewidth = 3)\n", "        plt.xlabel('Date'); plt.ylabel('Closing Price ($)'); plt.title('%s Stock Price History' % self.symbol); \n", "        plt.grid(color = 'k', alpha = 0.4); plt.show()\n", "      \n", "    # Reset the plotting parameters to clear style formatting\n", "    # Not sure if this should be a static method\n", "    @staticmethod\n", "    def reset_plot():\n", "        \n", "        # Restore default parameters\n", "        matplotlib.rcParams.update(matplotlib.rcParamsDefault)\n", "        \n", "        # Adjust a few parameters to liking\n", "        matplotlib.rcParams['figure.figsize'] = (8, 5)\n", "        matplotlib.rcParams['axes.labelsize'] = 10\n", "        matplotlib.rcParams['xtick.labelsize'] = 8\n", "        matplotlib.rcParams['ytick.labelsize'] = 8\n", "        matplotlib.rcParams['axes.titlesize'] = 14\n", "        matplotlib.rcParams['text.color'] = 'k'\n", "        \n", "    # Remove weekends from a dataframe\n", "    def remove_weekends(self, dataframe):\n", "        \n", "        # Reset index to use ix\n", "        dataframe = dataframe.reset_index(drop=True)\n", "        \n", "        weekends = []\n", "        \n", "        # Find all of the weekends\n", "        for i, date in enumerate(dataframe['ds']):\n", "            if (date.weekday) == 5 | (date.weekday == 6):\n", "                weekends.append(i)\n", "            \n", "        # Drop the weekends\n", "        dataframe = dataframe.drop(weekends, axis=0)\n", "        \n", "        return dataframe\n", "    \n", "    # Calculate and plot profit from buying and holding shares for specified date range\n", "    def hold_profit(self, start_date=None, end_date=None, nshares=1):\n", "        self.reset_plot()\n", "        \n", "        # Default start and end date are the beginning and end of data\n", "        if start_date is None:\n", "            start_date = self.start_date\n", "        if end_date is None:\n", "            end_date = self.end_date\n", "            \n", "        # Convert to pandas datetime for indexing dataframe\n", "        start_date = pd.to_datetime(start_date)\n", "        end_date = pd.to_datetime(end_date)\n", "        \n", "        # Check to make sure dates are in the data\n", "        if (start_date not in list(self.stock['Date'])):\n", "            print('Start Date not in data (either out of range or not a trading day.)')\n", "            return\n", "        elif (end_date not in list(self.stock['Date'])):\n", "            print('End Date not in data (either out of range or not a trading day.)')\n", "            return \n", "        \n", "        # Find starting and ending price of stock\n", "        start_price = float(self.stock[self.stock['Date'] == start_date]['Adj. Open'])\n", "        end_price = float(self.stock[self.stock['Date'] == end_date]['Adj. Close'])\n", "        \n", "        # Make a profit dataframe and calculate profit column\n", "        profits = self.stock[(self.stock['Date'] >= start_date) & (self.stock['Date'] <= end_date)]\n", "        profits['hold_profit'] = nshares * (profits['Adj. Close'] - start_price)\n", "        \n", "        # Total profit\n", "        total_hold_profit = nshares * (end_price - start_price)\n", "        \n", "        print('{} Total buy and hold profit from {} to {} for {} shares = ${:.2f}'.format\n", "              (self.symbol, start_date.date(), end_date.date(), nshares, total_hold_profit))\n", "        \n", "        # Plot the total profits \n", "        plt.style.use('dark_background')\n", "        \n", "        # Location for number of profit\n", "        text_location = (end_date - pd.DateOffset(months = 1)).date()\n", "        \n", "        # Plot the profits over time\n", "        plt.plot(profits['Date'], profits['hold_profit'], 'b', linewidth = 3)\n", "        plt.ylabel('Profit ($)'); plt.xlabel('Date'); plt.title('Buy and Hold Profits for {} {} to {}'.format(\n", "                                                                self.symbol, start_date.date(), end_date.date()))\n", "        \n", "        # Display final value on graph\n", "        plt.text(x = text_location, \n", "             y =  total_hold_profit + (total_hold_profit / 40),\n", "             s = '$%d' % total_hold_profit,\n", "            color = 'w' if total_hold_profit > 0 else 'r',\n", "            size = 14)\n", "        \n", "        plt.grid(alpha=0.2)\n", "        plt.show();\n", "        \n", "    # Create a prophet model without training\n", "    def create_model(self):\n", "\n", "        # Make the model\n", "        model = fbprophet.Prophet(daily_seasonality=False, weekly_seasonality=False, \n", "                                  changepoint_prior_scale=self.changepoint_prior_scale)\n", "        \n", "        # Add monthly seasonality\n", "        model.add_seasonality(name = 'monthly', period = 30.5, fourier_order = 5)\n", "        \n", "        return model\n", "    \n", "    # Graph the effects of altering the changepoint prior scale (cps)\n", "    def changepoint_effect(self, changepoints = [0.001, 0.05, 0.1, 0.2], colors = ['b', 'r', 'grey', 'gold']):\n", "    \n", "        # Training and plotting with 4 years of data\n", "        train = self.stock[(self.stock['Date'] > (max(self.stock['Date']) - pd.DateOffset(years=4)).date())]\n", "        \n", "        # Iterate through all the changepoints and make models\n", "        for i, changepoint in enumerate(changepoints):\n", "            # Select the changepoint\n", "            self.changepoint_prior_scale = changepoint\n", "            \n", "            # Create and train a model with the specified cps\n", "            model = self.create_model()\n", "            model.fit(train)\n", "            future = model.make_future_dataframe(periods=180, freq='D')\n", "            \n", "            # Make a dataframe to hold predictions\n", "            if i == 0:\n", "                predictions = future.copy()\n", "                \n", "            future = model.predict(future)\n", "            \n", "            # Fill in prediction dataframe\n", "            predictions['%.3f_yhat_upper' % changepoint] = future['yhat_upper']\n", "            predictions['%.3f_yhat_lower' % changepoint] = future['yhat_lower']\n", "            predictions['%.3f_yhat' % changepoint] = future['yhat']\n", "         \n", "        # Remove the weekends\n", "        predictions = self.remove_weekends(predictions)\n", "        \n", "        # Plot set-up\n", "        self.reset_plot()\n", "        plt.style.use('fivethirtyeight')\n", "        fig, ax = plt.subplots(1, 1)\n", "        \n", "        # Actual observations\n", "        ax.plot(train['ds'], train['y'], 'ko', ms = 4, label = 'Observations')\n", "        color_dict = {changepoint: color for changepoint, color in zip(changepoints, colors)}\n", "\n", "        # Plot each of the changepoint predictions\n", "        for changepoint in changepoints:\n", "            # Plot the predictions themselves\n", "            ax.plot(predictions['ds'], predictions['%.3f_yhat' % changepoint], linewidth = 1.2,\n", "                     color = color_dict[changepoint], label = '%.3f prior scale' % changepoint)\n", "            \n", "            # Plot the uncertainty interval\n", "            ax.fill_between(predictions['ds'].dt.to_pydatetime(), predictions['%.3f_yhat_upper' % changepoint],\n", "                            predictions['%.3f_yhat_lower' % changepoint], facecolor = color_dict[changepoint],\n", "                            alpha = 0.4, edgecolor = 'k', linewidth = 0.6)\n", "                            \n", "        # Plot labels\n", "        plt.legend(prop={'size': 10})\n", "        plt.xlabel('Date'); plt.ylabel('Stock Price ($)'); plt.title('Effect of Changepoint Prior Scale');\n", "        plt.show()\n", "            \n", "            \n", "    # Basic prophet model for the next 365 days   \n", "    def prophet_model(self):\n", "        \n", "        self.reset_plot()\n", "        \n", "        model = self.create_model()\n", "        \n", "        # Fit on the stock history for past 3 years\n", "        stock_history = self.stock[self.stock['Date'] > (self.max_date - pd.DateOffset(years = 3)).date()]\n", "        model.fit(stock_history)\n", "        \n", "        # Make and predict for next year with future dataframe\n", "        future = model.make_future_dataframe(periods = 365, freq='D')\n", "        future = model.predict(future)\n", "        \n", "        # Print the predicted price\n", "        print('Predicted Price on {} = ${:.2f}'.format(\n", "            future.ix[len(future) - 1, 'ds'].date(), future.ix[len(future) - 1, 'yhat']))\n", "        \n", "        # Set up the plot\n", "        fig, ax = plt.subplots(1, 1)\n", "\n", "        # Plot the actual values\n", "        ax.plot(stock_history['ds'], stock_history['y'], 'ko-', linewidth = 1.4, alpha = 0.8, ms = 1.8, label = 'Observations')\n", "        \n", "        # Plot the predicted values\n", "        ax.plot(future['ds'], future['yhat'], 'forestgreen',linewidth = 2.4, label = 'Predicted');\n", "\n", "        # Plot the uncertainty interval as ribbon\n", "        ax.fill_between(future['ds'].dt.to_pydatetime(), future['yhat_upper'], future['yhat_lower'], alpha = 0.5, \n", "                       facecolor = 'g', edgecolor = 'k', linewidth = 1.4, label = 'Uncertainty')\n", "\n", "        # Put a vertical line at the start of predictions\n", "        plt.vlines(x=max(self.stock['Date']).date(), ymin=min(future['yhat_lower']), \n", "                   ymax=max(future['yhat_upper']), colors = 'r',\n", "                   linestyles='dashed')\n", "\n", "        # Plot formatting\n", "        plt.legend(loc = 2, prop={'size': 10}); plt.xlabel('Date'); plt.ylabel('Price $');\n", "        plt.grid(linewidth=0.6, alpha = 0.6)\n", "        plt.title('%s Historical and Predicted Stock Price'  % self.symbol);\n", "        plt.show()\n", "        \n", "        # Show the model components\n", "        model.plot_components(future)\n", "        plt.show()\n", "      \n", "    # Evaluate prediction model for one year\n", "    def evaluate_prophet(self, nshares = 1000):\n", "        \n", "        # Select three years of training data starting 4 years ago and going until 3 years ago\n", "        train = self.stock[(self.stock['Date'] < (max(self.stock['Date']) - pd.DateOffset(years=1)).date()) & \n", "                           (self.stock['Date'] > (max(self.stock['Date']) - pd.DateOffset(years=4)).date())]\n", "        \n", "        # Testing data used for answers\n", "        test = self.stock[(self.stock['Date'] >= (max(self.stock['Date']) - pd.DateOffset(years=1)).date())]\n", "        \n", "        # Create and train the model\n", "        model = self.create_model()\n", "        model.fit(train)\n", "        \n", "        # Make a future dataframe and predictions\n", "        future = model.make_future_dataframe(periods = 365, freq='D')\n", "        future = model.predict(future)\n", "        \n", "        # Remove the weekends from the predictions\n", "        future = self.remove_weekends(future)\n", "        \n", "        # Merge predictions with the known values\n", "        test = pd.merge(test, future, on = 'ds', how = 'left')\n", "        \n", "        # Calculate the differences between consecutive measurements\n", "        test['pred_diff'] = test['yhat'].diff()\n", "        test['real_diff'] = test['y'].diff()\n", "        \n", "        # Correct is when we predicted the correct direction\n", "        test['correct'] = (np.sign(test['pred_diff']) == np.sign(test['real_diff'])) * 1\n", "        \n", "        # Accuracy is percentage of the time we predicted the correct direction\n", "        accuracy = 100 * np.mean(test['correct'])\n", "        \n", "        # Only playing the stocks when we predict the stock will increase\n", "        test_pred_increase = test[test['pred_diff'] > 0]\n", "        \n", "        test_pred_increase.reset_index(inplace=True)\n", "        prediction_profit = []\n", "        \n", "        # Iterate through all the predictions and calculate profit from playing\n", "        for i, correct in enumerate(test_pred_increase['correct']):\n", "            \n", "            # If we predicted up and the price goes up, we gain the difference\n", "            if correct == 1:\n", "                prediction_profit.append(nshares * test_pred_increase.ix[i, 'real_diff'])\n", "            # If we predicted up and the price goes down, we lose the difference\n", "            else:\n", "                prediction_profit.append(nshares * test_pred_increase.ix[i, 'real_diff'])\n", "        \n", "        test_pred_increase['pred_profit'] = prediction_profit\n", "        \n", "        # Put the profit into the test dataframe\n", "        test = pd.merge(test, test_pred_increase[['ds', 'pred_profit']], on = 'ds', how = 'left')\n", "        test.ix[0, 'pred_profit'] = 0\n", "    \n", "        # Profit for either method at all dates\n", "        test['pred_profit'] = test['pred_profit'].cumsum().ffill()\n", "        test['hold_profit'] = nshares * (test['y'] - float(test.ix[0, 'y']))\n", "        \n", "        # Display some friendly information about the perils of playing the stock market\n", "        print('You played the stock market in {} from {} to {} with {} shares.'.format(\n", "            self.symbol, min(test['Date']).date(), max(test['Date']).date(), nshares))\n", "        print('Using the Prophet model, your accuracy was {:.2f}% for a total profit of ${:.2f}.'.format(\n", "            accuracy, np.sum(prediction_profit)))\n", "        print('The Buy and Hold (smart) strategy yielded a profit of ${:.2f}.'.format(\n", "            float(test.ix[len(test) - 1, 'hold_profit'])))\n", "        print('Thanks for playing the stock market!\\n')\n", "        \n", "        # Reset the plot\n", "        self.reset_plot()\n", "        \n", "        # Set up the plot\n", "        fig, ax = plt.subplots(1, 1)\n", "\n", "        # Plot the actual values\n", "        ax.plot(train['ds'], train['y'], 'ko-', linewidth = 1.4, alpha = 0.8, ms = 1.8, label = 'Observations')\n", "        ax.plot(test['ds'], test['y'], 'ko-', linewidth = 1.4, alpha = 0.8, ms = 1.8, label = 'Observations')\n", "        \n", "        # Plot the predicted values\n", "        ax.plot(future['ds'], future['yhat'], 'navy', linewidth = 2.4, label = 'Predicted');\n", "\n", "        # Plot the uncertainty interval as ribbon\n", "        ax.fill_between(future['ds'].dt.to_pydatetime(), future['yhat_upper'], future['yhat_lower'], alpha = 0.6, \n", "                       facecolor = 'gold', edgecolor = 'k', linewidth = 1.4, label = 'Uncertainty')\n", "\n", "        # Put a vertical line at the start of predictions\n", "        plt.vlines(x=min(test['ds']).date(), ymin=min(future['yhat_lower']), ymax=max(future['yhat_upper']), colors = 'r',\n", "                   linestyles='dashed', label = 'Prediction Start')\n", "\n", "        # Plot formatting\n", "        plt.legend(loc = 2, prop={'size': 8}); plt.xlabel('Date'); plt.ylabel('Price $');\n", "        plt.grid(linewidth=0.6, alpha = 0.6)\n", "                   \n", "        plt.title('%s Prophet Evaluation for Past Year' % self.symbol);\n", "        plt.show();\n", "        \n", "        # Plot the predicted and actual profits over time\n", "        self.reset_plot()\n", "        \n", "        # Final profit and final smart used for locating text\n", "        final_profit = test.ix[len(test) - 1, 'pred_profit']\n", "        final_smart = test.ix[len(test) - 1, 'hold_profit']\n", "\n", "        # text location\n", "        last_date = test.ix[len(test) - 1, 'ds']\n", "        text_location = (last_date - pd.DateOffset(months = 1)).date()\n", "\n", "        plt.style.use('dark_background')\n", "\n", "        # Plot smart profits\n", "        plt.plot(test['ds'], test['hold_profit'], 'b',\n", "                 linewidth = 1.8, label = 'Smart Profits') \n", "\n", "        # Plot prediction profits\n", "        plt.plot(test['ds'], test['pred_profit'], \n", "                 color = 'g' if final_profit > 0 else 'r',\n", "                 linewidth = 1.8, label = 'Prediction Profits')\n", "\n", "        # Display final values on graph\n", "        plt.text(x = text_location, \n", "                 y =  final_profit + (final_profit / 40),\n", "                 s = '$%d' % final_profit,\n", "                color = 'w' if final_profit > 0 else 'r',\n", "                size = 18)\n", "        \n", "        plt.text(x = text_location, \n", "                 y =  final_smart + (final_smart / 40),\n", "                 s = '$%d' % final_smart,\n", "                color = 'w' if final_smart > 0 else 'r',\n", "                size = 18);\n", "\n", "        # Plot formatting\n", "        plt.ylabel('Profit  (US $)'); plt.xlabel('Date'); \n", "        plt.title('Predicted versus Smart (Buy and Hold) Profits');\n", "        plt.legend(loc = 2, prop={'size': 10});\n", "        plt.grid(alpha=0.2); \n", "        plt.show()\n"]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 414, "lines": ["tesla = Stocker(ticker='WIKI/TSLA')"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 415, "lines": ["tesla.plot_stock()"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 416, "lines": ["tesla.changepoint_effect()"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 417, "lines": ["tesla.evaluate_prophet()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 418, "lines": ["tesla.prophet_model()"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 419, "lines": ["tesla.hold_profit('2016-01-05', '2018-01-03', nshares = 20)"]}, {"block": 9, "type": "code", "linesLength": 0, "startIndex": 420, "lines": []}]
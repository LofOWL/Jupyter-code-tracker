[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Stats for Medium Articles\n", "\n", "In this notebook, we will explore my medium article statistics. We'll work with the raw HTML of the stats page."]}, {"block": 1, "type": "code", "linesLength": 27, "startIndex": 3, "lines": ["# Data science imports\n", "import pandas as pd\n", "import numpy as np\n", "\n", "%load_ext autoreload\n", "%autoreload 2\n", "\n", "import sys\n", "sys.path.append('../..')\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 20\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "import cufflinks\n", "cufflinks.go_offline()\n", "\n", "from bs4 import BeautifulSoup\n", "from collections import Counter, defaultdict\n", "\n", "import requests\n", "import re"]}, {"block": 2, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["soup = BeautifulSoup(open('data/stats.html', 'r'), 'html.parser')\n", "soup.text[:100]"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["table_rows = soup.find_all(attrs={'class':\"sortableTable-row js-statsTableRow\"})\n", "print(f'Found {len(table_rows)} table entries.')"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["entry = table_rows[3]\n", "entry"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 36, "lines": ["entry.find_all(text=' Unlisted')"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["entry.get('data-timestamp')"]}, {"block": 7, "type": "code", "linesLength": 4, "startIndex": 38, "lines": ["def convert_timestamp(ts: int):\n", "    return pd.to_datetime(ts, origin='unix', unit='ms')\n", "\n", "convert_timestamp(entry.get('data-timestamp'))"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 42, "lines": ["for i in entry.find_all(attrs={'class':'sortableTable-value'}):\n", "    print(i)"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 44, "lines": ["for i in entry.find_all(attrs={'class':'u-sm-show'}):\n", "    print(i) "]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["int(entry.find_all(attrs={'class':'readingTime'})[0].get('title').split(' ')[0])"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["entry.find_all(text='View story', attrs={'class': 'sortableTable-link'})"]}, {"block": 12, "type": "code", "linesLength": 10, "startIndex": 48, "lines": ["entry_dict = {}\n", "for value, key in zip(entry.find_all(attrs={'class':'sortableTable-value'}),\n", "            ['published_timestamp', 'views', 'reads', 'ratio', 'fans']):\n", "    entry_dict[key] = float(value.text) if key == 'ratio' else int(value.text)\n", "    \n", "entry_dict['published_timestamp'] = convert_timestamp(entry_dict['published_timestamp'])\n", "entry_dict['started_timestamp'] = convert_timestamp(entry.get('data-timestamp'))\n", "entry_dict['read_time'] = int(entry.find_all(attrs={'class':'readingTime'})[0].get('title').split(' ')[0])\n", "\n", "print(entry_dict)"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 58, "lines": ["table = soup.find_all(attrs={'class': 'js-statsTableBody'})\n", "type(table[0])"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["type(entry)"]}, {"block": 15, "type": "code", "linesLength": 71, "startIndex": 61, "lines": ["def process_table_entry(entry, parallel=True):\n", "    \"\"\"\n", "    Extract data from one entry in table\n", "    \n", "    :param entry: BeautifulSoup tag\n", "    \n", "    :return entry_dict: dictionary with data about entry\n", "    \n", "    \"\"\"\n", "    if parallel:\n", "        entry = BeautifulSoup(entry, 'html.parser')\n", "        \n", "    entry_dict = {}\n", "    for value, key in zip(entry.find_all(attrs={'class':'sortableTable-value'}),\n", "            ['published_timestamp', 'views', 'reads', 'ratio', 'fans']):\n", "        entry_dict[key] = float(value.text) if key == 'ratio' else int(value.text)\n", "    \n", "    entry_dict['published_timestamp'] = convert_timestamp(entry_dict['published_timestamp'])\n", "    entry_dict['started_timestamp'] = convert_timestamp(entry.get('data-timestamp'))\n", "    entry_dict['read_time'] = int(entry.find_all(attrs={'class':'readingTime'})[0].get('title').split(' ')[0])\n", "    entry_dict['unlisted'] = True if len(entry.find_all(text=' Unlisted')) > 0 else False\n", "    \n", "    link = entry.find_all(text='View story', \n", "                               attrs={'class': 'sortableTable-link'})[0].get('href')\n", "    \n", "    # Retrieve the article and create a soup\n", "    entry = requests.get(link).content\n", "    entry_soup = BeautifulSoup(entry)\n", "    \n", "    # Find the title header (determines if an article or a response)\n", "    if entry_soup.h1 is not None:\n", "        title = entry_soup.h1.text\n", "    else:\n", "        title = f'response-{t}'\n", "\n", "    # Text as single long string\n", "    entry_text = [p.text for p in entry_soup.find_all('p')]\n", "    entry_text = ' '.join(entry_text)\n", "\n", "    # Word count\n", "    word_count = len(entry_text.split(' '))\n", "\n", "    # Reading time in minutes\n", "    read_time = entry_soup.find_all(attrs={'class': 'readingTime'})\n", "    read_mins = int(read_time[0].get('title').split(' ')[0])\n", "\n", "    # Number of claps\n", "    clap_pattern = re.compile('^[0-9]{1,} claps|^[0-9]{1,}.[0-9]{1,}K claps|^[0-9]{1,}K claps')\n", "    claps = entry_soup.find_all(text = clap_pattern)\n", "\n", "    if len(claps) > 0:\n", "        if 'K' in claps[0]:\n", "            clap_number = int(1e3 * float(claps[0].split('K')[0]))\n", "        else:\n", "            clap_number = int(claps[0].split(' ')[0])\n", "    else:\n", "        clap_number = 0\n", "\n", "    # Post tags\n", "    tags = entry_soup.find_all(attrs={'class': 'tags tags--postTags tags--borderless'})\n", "    tags = [li.text for li in tags[0].find_all('li')]\n", "        \n", "    # Store in dictionary with title as key\n", "    entry_dict['title'] = title\n", "    entry_dict['text'] = entry_text\n", "    entry_dict['word_count'] = word_count\n", "    entry_dict['read_time'] = read_mins\n", "    entry_dict['claps'] = clap_number\n", "    entry_dict['tags'] = tags\n", "    \n", "    return entry_dict"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 132, "lines": ["entry_dict = process_table_entry(entry)"]}, {"block": 17, "type": "code", "linesLength": 8, "startIndex": 133, "lines": ["r = []\n", "for i, e in enumerate(table_rows):\n", "    print(f'{100 * i / len(table_rows):.2f}% complete. Total read time: {sum([t[\"read_time\"] for t in r])}', \n", "          end = '\\r')\n", "    r.append(process_table_entry(e))\n", "\n", "df = pd.DataFrame(r)\n", "df.head()"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 141, "lines": ["df.corr()"]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 142, "lines": ["colorscales = ['Greys', 'YlGnBu', 'Greens', 'YlOrRd', 'Bluered', 'RdBu',\n", "            'Reds', 'Blues', 'Picnic', 'Rainbow', 'Portland', 'Jet',\n", "            'Hot', 'Blackbody', 'Earth', 'Electric', 'Viridis', 'Cividis']"]}, {"block": 20, "type": "code", "linesLength": 9, "startIndex": 145, "lines": ["import plotly.figure_factory as ff\n", "from plotly.offline import iplot \n", "\n", "corrs = df.corr()\n", "figure = ff.create_annotated_heatmap(z = corrs.values, x =list(corrs.columns), \n", "                            y=list(corrs.index), showscale=True, \n", "                                     colorscale='Picnic',\n", "                                     annotation_text=corrs.round(2).values)\n", "iplot(figure)"]}, {"block": 21, "type": "code", "linesLength": 14, "startIndex": 154, "lines": ["# Add extra columns with more data\n", "df['response'] = ['response' if x == True else 'article' for x in df['title'].str.contains('response')]\n", "df['claps_per_word'] = df['claps'] / df['word_count']\n", "df['words_per_minute'] = df['word_count'] / df['read_time']\n", "\n", "# Add 10 most common tags with flag if data has it\n", "n = 10\n", "all_tags = list(chain(*df['tags'].tolist()))\n", "tag_counts = Counter(all_tags)\n", "tags = tag_counts.most_common(n)\n", "\n", "for tag, count in tags:\n", "    flag = [1 if tag in tags else 0 for tags in df['tags']]\n", "    df.loc[:, f'<tag>{tag}'] = flag"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 168, "lines": ["df.dtypes"]}, {"block": 23, "type": "code", "linesLength": 10, "startIndex": 169, "lines": ["from multiprocessing import Pool\n", "import sys\n", "\n", "table_rows_str = [str(r) for r in table_rows]\n", "\n", "pool = Pool(processes=10)\n", "r = pool.map(process_table_entry, \n", "             table_rows_str)\n", "pool.close()\n", "pool.join()"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 179, "lines": ["df = pd.DataFrame(r)\n", "df.head()"]}, {"block": 25, "type": "code", "linesLength": 16, "startIndex": 181, "lines": ["from itertools import chain\n", "\n", "# Add extra columns with more data\n", "df['response'] = ['response' if x == True else 'article' for x in df['title'].str.contains('response')]\n", "df['claps_per_word'] = df['claps'] / df['word_count']\n", "df['words_per_minute'] = df['word_count'] / df['read_time']\n", "\n", "# Add 10 most common tags with flag if data has it\n", "n = 10\n", "all_tags = list(chain(*df['tags'].tolist()))\n", "tag_counts = Counter(all_tags)\n", "tags = tag_counts.most_common(n)\n", "\n", "for tag, count in tags:\n", "    flag = [1 if tag in tags else 0 for tags in df['tags']]\n", "    df.loc[:, f'<tag>{tag}'] = flag"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 197, "lines": ["df.corr()"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 198, "lines": ["from timeit import default_timer as timer"]}, {"block": 28, "type": "code", "linesLength": 40, "startIndex": 199, "lines": ["def process_in_parallel(table_rows, processes):\n", "    \"\"\"\n", "    Process all the stats in a table in parallel\n", "    \n", "    :param table_rows: BeautifulSoup table rows\n", "    \n", "    :return df: dataframe of information about each post\n", "    \n", "    \"\"\"\n", "    table_rows_str = [str(r) for r in table_rows]\n", "    \n", "    pool = Pool(processes=processes)\n", "    results = [] \n", "    start = timer()\n", "    for i, r in enumerate(pool.imap_unordered(process_table_entry, table_rows_str)):\n", "        print(f'{100 * i / len(table_rows_str):.2f}% complete.', end = '\\r')\n", "        results.append(r)\n", "    pool.close()\n", "    pool.join()\n", "    end = timer()\n", "    print(f'Processed {len(table_rows_str)} articles in {end-start:.2f} seconds.')\n", "    df = pd.DataFrame(results)\n", "    \n", "    # Add extra columns with more data\n", "    df['response'] = ['response' if x == True else 'article' for x in df['title'].str.contains('response')]\n", "    df['claps_per_word'] = df['claps'] / df['word_count']\n", "    df['words_per_minute'] = df['word_count'] / df['read_time']\n", "\n", "    # Add 10 most common tags with flag if data has it\n", "    n = 10\n", "    all_tags = list(chain(*df['tags'].tolist()))\n", "    tag_counts = Counter(all_tags)\n", "    tags = tag_counts.most_common(n)\n", "\n", "    for tag, count in tags:\n", "        flag = [1 if tag in tags else 0 for tags in df['tags']]\n", "        df.loc[:, f'<tag>{tag}'] = flag\n", "    \n", "\n", "    return df"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 239, "lines": ["df = process_in_parallel(table_rows, processes=20)"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 240, "lines": ["df['unlisted'] = df['unlisted'].astype(str)"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 241, "lines": ["df.iplot(x = 'published_timestamp', y = 'word_count', categories='unlisted');"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 242, "lines": ["df[df['unlisted'] == 'False'].iplot(x = 'published_timestamp', y = 'read_time',\n", "                                    mode = 'markers')"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 244, "lines": ["df.head()"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 245, "lines": ["df.shape"]}, {"block": 35, "type": "code", "linesLength": 0, "startIndex": 246, "lines": []}]
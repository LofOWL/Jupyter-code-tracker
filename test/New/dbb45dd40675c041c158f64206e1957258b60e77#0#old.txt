[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: IPython Widgets\n", "\n", "In this notebook, we will get an introduction to IPython widgets. These are tools that allow us to build interactivity into our notebooks often with a single line of code. These widgets are very useful for data exploration and analysis, for example, selecting certain data or updating charts. In effect, Widgets allow you to make Jupyter Notebooks into an interactive dashboard instead of a static document."]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Run the below cell if needed. You can also do this from the command line. If in Jupyter lab, [check out the instructions for that environment](https://ipywidgets.readthedocs.io/en/stable/user_install.html). "]}, {"block": 2, "type": "code", "linesLength": 2, "startIndex": 4, "lines": ["!pip install -U -q ipywidgets\n", "!jupyter nbextension enable --py widgetsnbextension"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["These are the other imports will use. "]}, {"block": 4, "type": "code", "linesLength": 21, "startIndex": 7, "lines": ["# Standard Data Science Helpers\n", "import numpy as np\n", "import pandas as pd\n", "import scipy\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.go_offline(connected=True)\n", "cf.set_config_file(colorscale='plotly', world_readable=True)\n", "\n", "# Extra options\n", "pd.options.display.max_rows = 30\n", "pd.options.display.max_columns = 25\n", "\n", "# Show all code cells outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["import os\n", "from IPython.display import Image, display, HTML"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 30, "lines": ["## Data\n", "\n", "For this project, we'll work with my medium stats data. You can grab your own data or just use mine! "]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 33, "lines": ["df = pd.read_parquet('https://github.com/WillKoehrsen/Data-Analysis/blob/master/medium/data/2019-01-26_stats?raw=true')\n", "df.head()"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["df.describe()"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 36, "lines": ["df_orig = df.copy()\n", "df = df.loc[:, ['title', 'published_date', 'publication', 'reads', 'views', 'word_count', 'claps', 'fans', 'read_time']]"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 38, "lines": ["# Simple Widgets\n", "\n", "Let's get started using some widgets! We'll start off pretty simple just to see how the interface works."]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 41, "lines": ["import ipywidgets as widgets\n", "from ipywidgets import interact, interact_manual"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["df.tail()"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["To make a function interactive, all we have to do is use the `interact` decorator. This will automatically infer the input types for us! "]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 45, "lines": ["@interact\n", "def show_articles_more_than(column='claps', x=5000):\n", "    return df.loc[df[column] > x]"]}, {"block": 15, "type": "code", "linesLength": 0, "startIndex": 48, "lines": []}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 48, "lines": ["# Interact with specification of arguments\n", "@interact\n", "def show_articles_more_than(x=(10, 100000, 10), column=['claps', 'views', 'fans', 'reads']):\n", "    return df.loc[df[column] > x]"]}, {"block": 17, "type": "code", "linesLength": 0, "startIndex": 52, "lines": []}, {"block": 18, "type": "code", "linesLength": 0, "startIndex": 52, "lines": []}, {"block": 19, "type": "code", "linesLength": 0, "startIndex": 52, "lines": []}, {"block": 20, "type": "code", "linesLength": 0, "startIndex": 52, "lines": []}, {"block": 21, "type": "code", "linesLength": 4, "startIndex": 52, "lines": ["@interact\n", "def show_articles_more_than(column='claps', x=5000):\n", "    display(HTML(f'<h2>Showing articles with more than {x} {column}<h2>'))\n", "    display(df.loc[df[column] > x, ['title', 'published_date', 'read_time', 'tags', 'views', 'reads']])"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["The `interact` decorator automatically inferred we want a `text` box for the `column` and an `int` slider for `x`! This makes it incredibly simple to add interactivity. We can also set the options how we want."]}, {"block": 23, "type": "code", "linesLength": 5, "startIndex": 57, "lines": ["@interact\n", "def show_titles_more_than(column=list(df.select_dtypes('number').columns), \n", "                          x=(1000, 5000, 100)):\n", "    display(HTML(f'<h2>Showing articles with more than {x} {column}<h2>'))\n", "    display(df.loc[df[column] > x, ['title', 'published_date', 'read_time', 'tags', 'views', 'reads']])"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["This now gives us a `dropdown` for the `column` selection and still an `int` slider for `x`, but with limits. This can be useful when we need to enforce certains constraints on the interaction."]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 63, "lines": ["# Image Explorer\n", "\n", "Let's see another quick example of creating an interactive function. This one allows us to display images from a folder."]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 66, "lines": ["fdir = 'nature/'\n", "\n", "@interact\n", "def show_images(file=os.listdir(fdir)):\n", "    display(Image(fdir+file))"]}, {"block": 27, "type": "code", "linesLength": 0, "startIndex": 71, "lines": []}, {"block": 28, "type": "code", "linesLength": 0, "startIndex": 71, "lines": []}, {"block": 29, "type": "code", "linesLength": 0, "startIndex": 71, "lines": []}, {"block": 30, "type": "code", "linesLength": 0, "startIndex": 71, "lines": []}, {"block": 31, "type": "code", "linesLength": 0, "startIndex": 71, "lines": []}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["You could use this for example if you have a training set of images that you'd quickly like to run through."]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["# File Browser\n", "\n", "We can do a similar operation to create a very basic file browser. Instead of having to manually run the command every time, we just can use this function to look through our files."]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 75, "lines": ["!ls -a -t -r -l"]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 76, "lines": ["import subprocess\n", "import pprint\n", "\n", "root_dir = '../../Data-Analysis/'\n", "\n", "@interact\n", "def show_dir(dir=os.listdir(root_dir)):\n", "    x = subprocess.check_output(f\"cd {root_dir}{dir} && ls -a -t -r -l -h\", shell=True).decode()\n", "    print(x)"]}, {"block": 36, "type": "markdown", "linesLength": 3, "startIndex": 85, "lines": ["# Dataframe Explorer\n", "\n", "Let's look at a few more examples of using widgets to explore data. Here we create a widget that quickly lets us find correlations between columns."]}, {"block": 37, "type": "code", "linesLength": 4, "startIndex": 88, "lines": ["@interact\n", "def correlations(column1=list(df.select_dtypes('number').columns), \n", "                 column2=list(df.select_dtypes('number').columns)):\n", "    print(f\"Correlation: {df[column1].corr(df[column2])}\")"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Here's one to describe a specific column."]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 93, "lines": ["@interact\n", "def describe(column=list(df.columns)):\n", "    print(df[column].describe())"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 96, "lines": ["# Interactive Widgets for Plots\n", "\n", "We can use the same basic approach to create interactive widgets for plots. This expands the capabilities of the already powerful plotly visualization library."]}, {"block": 41, "type": "code", "linesLength": 8, "startIndex": 99, "lines": ["@interact\n", "def scatter_plot(x=list(df.select_dtypes('number').columns), \n", "                 y=list(df.select_dtypes('number').columns)[1:]):\n", "    df.iplot(kind='scatter', x=x, y=y, \n", "             mode='markers', \n", "             xTitle=x.title(), \n", "             yTitle=y.title(), \n", "             title=f'{y.title()} vs {x.title()}')"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["Let's add some options to control the column scheme."]}, {"block": 43, "type": "code", "linesLength": 14, "startIndex": 108, "lines": ["import cufflinks as cf\n", "\n", "@interact\n", "def scatter_plot(x=list(df.select_dtypes('number').columns), \n", "                 y=list(df.select_dtypes('number').columns)[1:],\n", "                 theme=list(cf.themes.THEMES.keys()), \n", "                 colorscale=list(cf.colors._scales_names.keys())):\n", "    \n", "    df.iplot(kind='scatter', x=x, y=y, mode='markers', \n", "             xTitle=x.title(), yTitle=y.title(), \n", "             text='title',\n", "             title=f'{y.title()} vs {x.title()}',\n", "            theme=theme, colorscale=colorscale,\n", "            dimensions=(1000, 750))"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 122, "lines": ["The next plot lets us choose the grouping category for the plot. "]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 123, "lines": ["df = df_orig.copy()"]}, {"block": 46, "type": "code", "linesLength": 20, "startIndex": 124, "lines": ["df['binned_read_time'] = pd.cut(df['read_time'], bins=range(0, 56, 5))\n", "df['binned_read_time'] = df['binned_read_time'].astype(str)\n", "\n", "df['binned_word_count'] = pd.cut(df['word_count'], bins=range(0, 100001, 1000))\n", "df['binned_word_count'] = df['binned_word_count'].astype(str)\n", "\n", "@interact\n", "def scatter_plot(x=list(df.select_dtypes('number').columns), \n", "                 y=list(df.select_dtypes('number').columns)[1:],\n", "                 color_var=['binned_read_time', 'binned_word_count', 'publication', 'type'],\n", "                 theme=list(cf.themes.THEMES.keys()), \n", "                 colorscale=list(cf.colors._scales_names.keys())):\n", "    \n", "    df.iplot(kind='scatter', x=x, y=y, mode='markers', \n", "             categories=color_var, \n", "             xTitle=x.replace('_', ' ').title(), yTitle=y.replace('_', ' ').title(), \n", "             text='title',\n", "             title=f\"{y.replace('_', ' ').title()} vs {x.replace('_', ' ').title()}\",\n", "             theme=theme, colorscale=colorscale, \n", "             dimensions=(950, 650))"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["You may have noticed this plot was a little slow to update. When that is the case, we can use `interact_manual` which only updates the function when the button is pressed."]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 145, "lines": ["from ipywidgets import interact_manual"]}, {"block": 49, "type": "code", "linesLength": 13, "startIndex": 146, "lines": ["@interact_manual\n", "def scatter_plot(x=list(df.select_dtypes('number').columns), \n", "                 y=list(df.select_dtypes('number').columns)[1:],\n", "                 # categories=['binned_read_time', 'binned_word_count', 'publication', 'type'],\n", "                 theme=list(cf.themes.THEMES.keys()), \n", "                 colorscale=list(cf.colors._scales_names.keys())):\n", "    \n", "    df.iplot(kind='scatter', x=x, y=y, mode='markers', \n", "             # categories=categories, \n", "             xTitle=x.title(), yTitle=y.title(), \n", "             text='title',\n", "             title=f'{y.title()} vs {x.title()}',\n", "             theme=theme, colorscale=colorscale)"]}, {"block": 50, "type": "markdown", "linesLength": 3, "startIndex": 159, "lines": ["# Making Our Own Widgets\n", "\n", "The decorator `interact` (or `interact_manual`) is not the only way to use widgets. We can also explicity create our own. One of the most useful I've found is the `DataPicker`."]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 162, "lines": ["df.set_index('published_date', inplace=True)"]}, {"block": 52, "type": "code", "linesLength": 15, "startIndex": 163, "lines": ["# Print articles published between two dates\n", "def stats_for_article_published_between(start_date, end_date):\n", "    start_date = pd.Timestamp(start_date)\n", "    end_date = pd.Timestamp(end_date)\n", "    stat_df = df.loc[(df.index >= start_date) & (df.index <= end_date)].copy()\n", "    total_words = stat_df['word_count'].sum()\n", "    total_read_time = stat_df['read_time'].sum()\n", "    num_articles = len(stat_df)\n", "    print(f'You published {num_articles} articles between {start_date.date()} and {end_date.date()}.')\n", "    print(f'These articles totalled {total_words:,} words and {total_read_time/60:.2f} hours to read.')\n", "    \n", "    \n", "_ = interact(stats_for_article_published_between,\n", "             start_date=widgets.DatePicker(value=pd.to_datetime('2018-01-01')),\n", "             end_date=widgets.DatePicker(value=pd.to_datetime('2019-01-01')))"]}, {"block": 53, "type": "code", "linesLength": 0, "startIndex": 178, "lines": []}, {"block": 54, "type": "code", "linesLength": 0, "startIndex": 178, "lines": []}, {"block": 55, "type": "code", "linesLength": 0, "startIndex": 178, "lines": []}, {"block": 56, "type": "code", "linesLength": 0, "startIndex": 178, "lines": []}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 178, "lines": ["For this function, we use a `Dropdown` and a `DatePicker` to plot one column cumulatively up to a certain time. Instead of having to write this ourselves, we can just let `ipywidgets` do all the work!"]}, {"block": 58, "type": "code", "linesLength": 11, "startIndex": 179, "lines": ["def plot_up_to(column, date, theme):\n", "    date = pd.Timestamp(date)\n", "    plot_df = df.loc[df.index <= date].copy()\n", "    plot_df[column].cumsum().iplot(mode='markers+lines', \n", "                                   xTitle='published date',\n", "                                   yTitle=column, theme=theme,\n", "                                  title=f'Cumulative {column.title()} Until {date.date()}')\n", "    \n", "_ = interact(plot_up_to, theme=widgets.Dropdown(options=list(cf.themes.THEMES.keys()), value='space'), \n", "             column=widgets.Dropdown(options=list(df.select_dtypes('number').columns)), \n", "             date = widgets.DatePicker(value=pd.to_datetime('2019-01-01')))"]}, {"block": 59, "type": "markdown", "linesLength": 5, "startIndex": 190, "lines": ["# Dependent Widgets\n", "\n", "How do we get a value of a widget to depend on that of another? Using the `observe` method.\n", "\n", "Going back to the Image Browser earlier, let's make a function that allows us to change the directory for the images to list."]}, {"block": 60, "type": "code", "linesLength": 16, "startIndex": 195, "lines": ["# Create widgets\n", "directory = widgets.Dropdown(options=['images', 'nature', 'assorted'])\n", "images = widgets.Dropdown(options=os.listdir(directory.value))\n", "\n", "# Updates the image options based on directory value\n", "def update_images(*args):\n", "    images.options = os.listdir(directory.value)[1:]\n", "\n", "# Tie the image options to directory value\n", "directory.observe(update_images, 'value')\n", "\n", "# Show the images\n", "def show_images(fdir, file):\n", "    display(Image(f'{fdir}/{file}'))\n", "\n", "_ = interact(show_images, fdir=directory, file=images)"]}, {"block": 61, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 62, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 63, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 64, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 65, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 66, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 67, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 68, "type": "code", "linesLength": 0, "startIndex": 211, "lines": []}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 211, "lines": ["We can also assign to the `interact` call and then reuse the widget. This has unintended affects though! "]}, {"block": 70, "type": "code", "linesLength": 1, "startIndex": 212, "lines": ["df = df_orig.copy()"]}, {"block": 71, "type": "code", "linesLength": 6, "startIndex": 213, "lines": ["def show_stats_by_tag(tag):\n", "    display(df.groupby(f'<tag>{tag}').describe()[['views', 'reads']])\n", "    \n", "stats = interact(show_stats_by_tag,\n", "                tag=widgets.Dropdown(options=['Towards Data Science', 'Education', \n", "                                              'Machine Learning', 'Python', 'Data Science']))"]}, {"block": 72, "type": "code", "linesLength": 1, "startIndex": 219, "lines": ["stats.widget"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 220, "lines": ["Now changing the value in one location changes it in both places! This can be a slight inconvenience, but on the plus side, now we can reuse the interactive element."]}, {"block": 74, "type": "markdown", "linesLength": 3, "startIndex": 221, "lines": ["# Linked Values\n", "\n", "We can link the value of two widgets to each other using the `jslink` function. This ties the values to be the same."]}, {"block": 75, "type": "code", "linesLength": 13, "startIndex": 224, "lines": ["def show_less_than(column1_value, column2_value):\n", "    display(df.loc[(df['views'] < column1_value) & \n", "                    (df['reads'] < column2_value), \n", "                   ['title', 'read_time', 'tags', 'views', 'reads']])\n", "        \n", "column1_value=widgets.IntText(value=100, label='First')\n", "column2_value=widgets.IntSlider(value=100, label='Second')\n", "\n", "linked = widgets.jslink((column1_value, 'value'),\n", "                        (column2_value, 'value'))\n", "\n", "less_than = interact(show_less_than, column1_value=column1_value,\n", "                 column2_value=column2_value)"]}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 237, "lines": ["I'm not exactly sure why you would want to link two widgets, but there you go! We can unlink them using the `unlink` command (sometimes syntax does make sense)."]}, {"block": 77, "type": "code", "linesLength": 1, "startIndex": 238, "lines": ["linked.unlink()"]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 239, "lines": ["less_than.widget"]}, {"block": 79, "type": "markdown", "linesLength": 3, "startIndex": 240, "lines": ["# Conclusions\n", "\n", "These widgets are not going to change your life, but they do make notebooks closer to interactive dashboards. I've only shown you some of the capabilities so be sure to look at the [documentation for the full details]. The Jupyter Notebook is useful by itself, but with additional tools, it can be an even better data exploration and analysis technology. Thanks to the efforts of many developers and contributors to open-source, we have these great technologies, so we might as well get the most from these libraries! "]}, {"block": 80, "type": "code", "linesLength": 3, "startIndex": 243, "lines": ["cscales = ['Greys', 'YlGnBu', 'Greens', 'YlOrRd', 'Bluered', 'RdBu',\n", "            'Reds', 'Blues', 'Picnic', 'Rainbow', 'Portland', 'Jet',\n", "            'Hot', 'Blackbody', 'Earth', 'Electric', 'Viridis', 'Cividis']"]}, {"block": 81, "type": "code", "linesLength": 1, "startIndex": 246, "lines": ["df = df.loc[:, ['claps', 'views', 'reads', 'read_time', 'word_count', 'fans']]"]}, {"block": 82, "type": "code", "linesLength": 12, "startIndex": 247, "lines": ["import plotly.figure_factory as ff\n", "\n", "corrs = df.corr()\n", "\n", "@interact_manual\n", "def plot_corrs(colorscale=cscales):\n", "    figure = ff.create_annotated_heatmap(z = corrs.round(2).values, \n", "                                     x =list(corrs.columns), \n", "                                     y=list(corrs.index), \n", "                                     colorscale=colorscale,\n", "                                     annotation_text=corrs.round(2).values)\n", "    iplot(figure)"]}, {"block": 83, "type": "code", "linesLength": 8, "startIndex": 259, "lines": ["@interact\n", "def plot_spread(column1=['claps', 'views', 'read', 'word_count'], \n", "                 column2=['views', 'claps', 'read', 'word_count']):\n", "    df.iplot(kind='ratio',\n", "                                                   y=column1,\n", "                                                   secondary_y=column2,\n", "                                                   title=f'{column1.title()} and {column2.title()} Spread Plot',\n", "                                 xTitle='Published Date')"]}, {"block": 84, "type": "code", "linesLength": 0, "startIndex": 267, "lines": []}]
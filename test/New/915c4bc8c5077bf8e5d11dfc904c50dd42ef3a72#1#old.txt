[{"block": 0, "type": "code", "linesLength": 5, "startIndex": 0, "lines": ["# Pandas is used for data manipulation\n", "import pandas as pd\n", "\n", "# Read in data as a dataframe\n", "features = pd.read_csv('data/temps_extended.csv')"]}, {"block": 1, "type": "code", "linesLength": 21, "startIndex": 5, "lines": ["# One Hot Encoding\n", "features = pd.get_dummies(features)\n", "\n", "# Extract features and labels\n", "labels = features['actual']\n", "features = features.drop('actual', axis = 1)\n", "\n", "# List of features for later use\n", "feature_list = list(features.columns)\n", "\n", "# Convert to numpy arrays\n", "import numpy as np\n", "\n", "features = np.array(features)\n", "labels = np.array(labels)\n", "\n", "# Training and Testing Sets\n", "from sklearn.model_selection import train_test_split\n", "\n", "train_features, test_features, train_labels, test_labels = train_test_split(features, labels, \n", "                                                                            test_size = 0.25, random_state = 42)"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 26, "lines": ["print('Training Features Shape:', train_features.shape)\n", "print('Training Labels Shape:', train_labels.shape)\n", "print('Testing Features Shape:', test_features.shape)\n", "print('Testing Labels Shape:', test_labels.shape)"]}, {"block": 3, "type": "code", "linesLength": 13, "startIndex": 30, "lines": ["# Names of five importances accounting for 95% of total importance\n", "important_feature_names = ['temp_1', 'average', 'ws_1', 'temp_2', 'friend']\n", "\n", "# Find the columns of the most important features\n", "important_indices = [feature_list.index(feature) for feature in important_feature_names]\n", "\n", "# Create training and testing sets with only the important features\n", "important_train_features = train_features[:, important_indices]\n", "important_test_features = test_features[:, important_indices]\n", "\n", "# Sanity check on operations\n", "print('Important train features shape:', important_train_features.shape)\n", "print('Important test features shape:', important_test_features.shape)"]}, {"block": 4, "type": "code", "linesLength": 9, "startIndex": 43, "lines": ["from sklearn.ensemble import RandomForestRegressor\n", "\n", "rf = RandomForestRegressor(n_estimators = 1000, random_state = 42)\n", "\n", "from pprint import pprint\n", "\n", "# Look at parameters used by our current forest\n", "print('Parameters currently in use:')\n", "pprint(rf.get_params())"]}, {"block": 5, "type": "code", "linesLength": 6, "startIndex": 52, "lines": ["# Use only the most important features\n", "train_features = important_train_features[:]\n", "test_features = important_test_features[:]\n", "\n", "# Update feature list for visualizations\n", "feature_list = important_feature_names[:]"]}, {"block": 6, "type": "code", "linesLength": 23, "startIndex": 58, "lines": ["from sklearn.model_selection import RandomizedSearchCV\n", "\n", "# Number of trees in random forest\n", "n_estimators = [int(x) for x in np.linspace(start = 100, stop = 2000, num = 5)]\n", "# Number of features to consider at every split\n", "max_features = ['auto', 'sqrt']\n", "# Maximum number of levels in tree\n", "max_depth = [int(x) for x in np.linspace(10, 100, num = 5)]\n", "max_depth.append(None)\n", "# Minimum number of samples required to split a node\n", "min_samples_split = [2, 5, 10]\n", "# Minimum number of samples required at each leaf node\n", "min_samples_leaf = [1, 2, 4]\n", "# Method of selecting samples for training each tree\n", "bootstrap = [True, False]\n", "\n", "# Create the random grid\n", "random_grid = {'n_estimators': n_estimators,\n", "               'max_features': max_features,\n", "               'max_depth': max_depth,\n", "               'min_samples_split': min_samples_split,\n", "               'min_samples_leaf': min_samples_leaf,\n", "               'bootstrap': bootstrap}"]}, {"block": 7, "type": "code", "linesLength": 10, "startIndex": 81, "lines": ["# Use the random grid to search for best hyperparameters\n", "# First create the base model to tune\n", "rf = RandomForestRegressor(random_state=42)\n", "# Random search of parameters\n", "rf_random = RandomizedSearchCV(estimator=rf, param_distributions=random_grid,\n", "                              n_iter = 20, scoring='neg_mean_absolute_error', \n", "                              cv = 3, verbose=2, random_state=42, n_jobs=-1)\n", "\n", "# Fit the random search model\n", "rf_random.fit(train_features, train_labels)"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 91, "lines": ["rf_random.best_params_"]}]
[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Plotting Bus Stops as Connected Graphs\n", "\n", "Using real-world data for learning graphs. The most effective way to learn is to apply a topic to actual data!"]}, {"block": 1, "type": "code", "linesLength": 3, "startIndex": 3, "lines": ["# import geopandas as gpd\n", "import pandas as pd\n", "import numpy as np"]}, {"block": 2, "type": "code", "linesLength": 1, "startIndex": 6, "lines": ["import os; os.listdir('.')"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 7, "lines": ["bus_stops = pd.read_csv('Bus_Stop_Shelter.csv')\n", "bus_stops.info()"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 9, "lines": ["bus_stops.head()"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 10, "lines": ["import plotly_express as px"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 11, "lines": ["px.scatter(bus_stops, 'LONGITUDE', 'LATITUDE')"]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 12, "lines": ["import geopandas as gpd\n", "\n", "gdf = gpd.read_file('Bus Stop Shelters/geo_export_513a402e-f182-4e3d-8b3c-554c8832cd37.shp')"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["%matplotlib inline\n", "gdf.plot()"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["bus_routes = gpd.read_file('routes_bk_bus_may2016.shp')\n", "bus_routes.head()"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["bus_routes.plot()"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 20, "lines": ["# Working with gtfs data\n", "\n", "Let's try another approach. This time we will attempt to link together the stations on the same routes."]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 23, "lines": ["import pandas as pd\n", "import numpy as np"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["import os; os.listdir('gtfs')"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["routes = pd.read_csv('gtfs/routes.txt')\n", "routes.tail()"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["stops = pd.read_csv('gtfs/stops.txt')\n", "stops.tail()"]}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 30, "lines": ["from shapely import geometry\n", "\n", "stop_points = [geometry.Point(lon, lat) for lon, lat in zip(stops['stop_lon'], stops['stop_lat'])]\n", "stops['geometry'] = stop_points"]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 34, "lines": ["%matplotlib inline\n", "\n", "import geopandas as gpd\n", "\n", "ax = gpd.GeoDataFrame(stops).plot(figsize=(12, 10))"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["stops.head()"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["routes.head()"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 41, "lines": ["trips = pd.read_csv('gtfs/trips.txt')\n", "trips.tail()"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["tt = pd.read_csv('gtfs/stop_times.txt')\n", "tt.head()"]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 45, "lines": ["paths = tt.merge(stops, on='stop_id')\n", "paths = paths.merge(trips, on='trip_id')\n", "paths = paths.sort_values(['trip_id', 'stop_sequence'])\n", "paths.head()"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 49, "lines": ["trip = paths[paths['trip_id'] == paths['trip_id'][0]]\n", "trip.tail()"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["(paths.groupby(['trip_id'])['route_id'].nunique() == 1).all()"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["paths['route_id'].unique()"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 53, "lines": ["b100 = paths[paths['route_id'] == 'B100']\n", "b100.tail()"]}, {"block": 27, "type": "code", "linesLength": 7, "startIndex": 55, "lines": ["from tqdm import tqdm_notebook\n", "\n", "longest_trips = []\n", "\n", "for route, grouped in tqdm_notebook(paths.groupby('route_id')):\n", "    trip_nums = grouped.groupby('trip_id')['trip_id'].count()\n", "    longest_trips.append(dict(route=route, longest_trip=trip_nums.sort_values().index[-1]))"]}, {"block": 28, "type": "code", "linesLength": 43, "startIndex": 62, "lines": ["def info_from_trip(trip):\n", "    \"\"\"\n", "    Extract info, nodes, positions, and travel times from a trip\n", "    \n", "    :param trip: dataframe of information from a single trip\n", "    \n", "    :return dict: a dictionary of information, nodes, positions, and edges\n", "    \"\"\"\n", "    trip = trip.copy()\n", "    trip = trip.sort_values('stop_sequence')\n", "    \n", "    # Get the next stop and previous stop\n", "    trip['stop_next'] = trip['stop_id'].shift(-1)\n", "    trip['stop_previous'] = trip['stop_id'].shift(1)\n", "    \n", "    # Convert the times to datetimes for finding travel time\n", "    trip['arrival_time'] = pd.to_datetime(trip['arrival_time'])\n", "    trip['departure_time'] = pd.to_datetime(trip['departure_time'])\n", "\n", "    # Calculate the travel time in minutes from the previous stop\n", "    trip['travel_time'] = (trip['arrival_time'] - trip['departure_time'].shift(1)) / pd.Timedelta(minutes=1)\n", "    \n", "    # Subset to the columns to keep\n", "    trip = trip[['trip_id', 'stop_id', 'stop_next', 'stop_previous', 'travel_time', \n", "                'arrival_time', 'departure_time', 'stop_sequence', 'stop_name', 'geometry', 'stop_lon', 'stop_lat']]\n", "    \n", "    # Nodes are the stops\n", "    nodes = list(trip['stop_id'])\n", "    \n", "    # Labels are a mapping from stop id to stop name\n", "    labels = {id: name for id, name in zip(trip['stop_id'], trip['stop_name'])}\n", "    \n", "    # Positions are a mapping from the stop to the longitude, latitude\n", "    positions = {node: (lon, lat) for node, lon, lat in zip(trip['stop_id'], trip['stop_lon'], trip['stop_lat'])}\n", "    \n", "    # Edges in a dictionary mapping from previous stop to stop with travel time from previous stop to stop\n", "    edges = {(previous, current): travel_time for previous, current, travel_time in zip(trip['stop_previous'], trip['stop_id'], trip['travel_time']) if \n", "            not np.isnan(previous)}\n", "    \n", "    return dict(trip_info=trip, nodes=nodes, positions=positions, labels=labels, edges=edges)\n", "\n", "d = info_from_trip(paths[paths['trip_id'] == longest_trips[0]['longest_trip']])\n", "d['trip_info'].head()"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 105, "lines": ["G = nx.DiGraph()\n", "G.add_nodes_from(d['nodes'])\n", "G.add_edges_from(d['edges'])"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 108, "lines": ["nx.draw(G, pos=d['positions'], with_labels=True)\n", "nx.draw_networkx_edge_labels(G, pos=d['positions'], edge_labels=d['edges'])"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 110, "lines": ["trip_nums.sort_values().tail()"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 111, "lines": ["b100.groupby('trip_id')['arrival_time'].count()"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["paths.groupby('route_id')['trip_id'].count()"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 113, "lines": ["single = paths[paths['trip_id'] == '23617854-BPPB9-BP_B9-Weekday-10']\n", "single.info()"]}, {"block": 35, "type": "code", "linesLength": 4, "startIndex": 115, "lines": ["single['stop_previous'] = single['stop_id'].shift(1).copy()\n", "single['stop_next'] = single['stop_id'].shift(-1).copy()\n", "\n", "single.head()"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 119, "lines": ["edges = [(previous, current) for previous, current in zip(single['stop_previous'], single['stop_id'])]\n", "edges = [(e[0], e[1]) for e in edges if not np.isnan(e[0]) or np.isnan(e[1])]\n", "edges"]}, {"block": 37, "type": "code", "linesLength": 4, "startIndex": 122, "lines": ["nodes = list(single['stop_id'])\n", "labels = {id: name for id, name in zip(single['stop_id'], single['stop_name'])}\n", "positions = {node: (lon, lat) for node, lon, lat in zip(single['stop_id'], single['stop_lon'], single['stop_lat'])}\n", "positions"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 126, "lines": ["labels"]}, {"block": 39, "type": "code", "linesLength": 5, "startIndex": 127, "lines": ["import networkx as nx\n", "\n", "G = nx.Graph()\n", "G.add_nodes_from(positions)\n", "G.add_edges_from(edges)"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 132, "lines": ["paths.head()"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 133, "lines": ["pd.Timestamp('00:00:00')"]}, {"block": 42, "type": "code", "linesLength": 5, "startIndex": 134, "lines": ["trip['arrival_time'] = pd.to_datetime(trip['arrival_time'])\n", "trip['departure_time'] = pd.to_datetime(trip['departure_time'])\n", "\n", "trip['travel_time'] = (trip['arrival_time'] - trip['departure_time'].shift(1)) / pd.Timedelta(minutes=1)\n", "trip.head()"]}, {"block": 43, "type": "code", "linesLength": 0, "startIndex": 139, "lines": []}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 139, "lines": ["edges = [{(previous, current): travel_time} for previous, current, travel_time in zip(trip['stop_previous'], trip['stop_id'], trip['travel_time'])]"]}, {"block": 45, "type": "code", "linesLength": 25, "startIndex": 140, "lines": ["def graph_from_trip(trip):\n", "    trip = trip.sort_values('stop_sequence')\n", "    trip['stop_next'] = trip['stop_id'].shift(-1)\n", "    trip['stop_previous'] = trip['stop_id'].shift(1)\n", "    \n", "    trip['arrival_time'] = pd.to_datetime(trip['arrival_time'])\n", "    trip['departure_time'] = pd.to_datetime(trip['departure_time'])\n", "\n", "    trip['travel_time'] = (trip['arrival_time'] - trip['departure_time'].shift(1)) / pd.Timedelta(minutes=1)\n", "    \n", "    nodes = list(trip['stop_id'])\n", "    \n", "    labels = {id: name for id, name in zip(trip['stop_id'], trip['stop_name'])}\n", "    positions = {node: (lon, lat) for node, lon, lat in zip(trip['stop_id'], trip['stop_lon'], trip['stop_lat'])}\n", "    \n", "    edges = [(previous, current, travel_time) for previous, current, travel_time in zip(trip['stop_previous'], trip['stop_id'], trip['travel_time'])]\n", "    edges = {(e[0], e[1]): e[2] for e in edges if not np.isnan(e[0]) or np.isnan(e[1])}\n", "    \n", "    G = nx.DiGraph()\n", "    G.add_nodes_from(nodes)\n", "    G.add_edges_from(edges)\n", "    \n", "    return G, positions, edges\n", "\n", "trip1, positions, edges = graph_from_trip(paths[paths['trip_id'] == paths['trip_id'][500]])"]}, {"block": 46, "type": "code", "linesLength": 2, "startIndex": 165, "lines": ["nx.draw(trip1, positions, with_labels=True)\n", "_ = nx.draw_networkx_edge_labels(trip1, positions, edge_labels=edges)"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 167, "lines": ["paths['route_id'].unique()"]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 168, "lines": ["nx.draw(trip1, pos=positions, withlabels=True, figsize=(20, 20), scale=5)\n", "_ = nx.draw_networkx_labels(G, pos=positions, labels=labels)"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 170, "lines": ["positions"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 171, "lines": ["list(G.edges)"]}, {"block": 51, "type": "code", "linesLength": 0, "startIndex": 172, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Stock Price Predictions\n", "\n", "We can also make testable predictions by restricting our model to a subset of the data, and then using the forecasted values to see how correct our model is. We will restrict data up until the end of 2016, and then try to make predictions for 2017."]}, {"block": 1, "type": "code", "linesLength": 7, "startIndex": 3, "lines": ["import quandl \n", "import pandas as pd\n", "import numpy as np\n", "import fbprophet\n", "\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["## Retrieve Data from Quandl"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 11, "lines": ["quandl.ApiConfig.api_key = 'rFsSehe51RLzREtYhLfo'\n", "\n", "# Using Tesla data\n", "tesla_stocks = quandl.get('WIKI/TSLA')"]}, {"block": 4, "type": "code", "linesLength": 6, "startIndex": 15, "lines": ["# Set the index (with dates) to a column \n", "tesla_stocks.reset_index(level=0, inplace=True)\n", "\n", "# Rename the columns for prophet and create a year column\n", "tesla_stocks.rename(columns={'Date': 'ds', 'Adj. Close': 'y'}, inplace=True)\n", "tesla_stocks['Year'] = [date.year for date in tesla_stocks['ds']]"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["tesla_stocks.head()"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 22, "lines": ["# Create a new dataframe with the relevant information\n", "tesla_data = tesla_stocks[['ds', 'Year', 'y']]\n", "\n", "# Training and testing data\n", "tesla_train = tesla_data[tesla_data['Year'] < 2017]\n", "tesla_test = tesla_data[tesla_data['Year'] > 2016]"]}, {"block": 7, "type": "code", "linesLength": 14, "startIndex": 28, "lines": ["# Create a new model \n", "tesla_prophet = fbprophet.Prophet(changepoint_prior_scale=0.2)\n", "\n", "# Train the model\n", "tesla_prophet.fit(tesla_train)\n", "\n", "# Number of days to make predictions \n", "days = (max(tesla_test['ds']) - min(tesla_test['ds'])).days\n", "\n", "# Future dataframe\n", "tesla_forecast = tesla_prophet.make_future_dataframe(periods = days, freq = 'D')\n", "\n", "# Make forecasts\n", "tesla_forecast = tesla_prophet.predict(tesla_forecast)"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 42, "lines": ["tesla_results = tesla_forecast.merge(tesla_test, how = 'inner', on = 'ds')\n", "tesla_results = tesla_results[['ds', 'y', 'yhat']]\n", "\n", "# Predicted difference between stock prices\n", "tesla_results['pred_diff'] = (tesla_results['yhat']).diff()\n", "\n", "# Actual difference between stock prices\n", "tesla_results['real_diff'] = (tesla_results['y']).diff()"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 50, "lines": ["# Correct direction column\n", "tesla_results['correct'] = (np.sign(tesla_results['pred_diff']) == np.sign(tesla_results['real_diff'])) * 1"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["tesla_results.head()"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["np.mean(tesla_results['correct'])"]}, {"block": 12, "type": "code", "linesLength": 4, "startIndex": 54, "lines": ["tesla_prophet.plot(tesla_forecast)\n", "plt.title('Tesla Stock Forecast'); plt.ylabel('Stock Price ($)'); plt.xlabel('Year');\n", "plt.plot(tesla_test['ds'], tesla_test['y'], 'k', label = 'actual')\n", "plt.legend();"]}, {"block": 13, "type": "code", "linesLength": 83, "startIndex": 58, "lines": ["def stock_predictor(ticker='TSLA'):\n", "    try:\n", "        stock = quandl.get('WIKI/%s' % ticker)\n", "    except Exception as e:\n", "        print('Invalid Stock Ticker')\n", "        print(e)\n", "        return\n", "    \n", "    # Change the index to a Date column\n", "    stock_clean = stock.reset_index()[['Date', 'Adj. Close']]\n", "    # Create a year column\n", "    stock_clean['Year'] = [date.year for date in stock_clean['Date']]\n", "    \n", "    # Training and Testing Sets\n", "    stock_train = stock_clean[stock_clean['Year'] < 2017].rename(columns={'Date': 'ds', 'Adj. Close': 'y'})\n", "    stock_test = stock_clean[stock_clean['Year'] > 2016]\n", "    \n", "    # Create the prophet model and fit on training set\n", "    stock_prophet = fbprophet.Prophet(changepoint_prior_scale=0.15)\n", "    stock_prophet.fit(stock_train)\n", "    \n", "    # Number of days to predict\n", "    days = (max(stock_test['ds']) - min(stock_test['ds'])).days\n", "    \n", "    # Make forecasts for entire length of test set + one week\n", "    stock_forecast = stock_prophet.make_future_dataframe(periods=days, freq = 'D')\n", "    stock_forecast = stock_prophet.predict(stock_forecast)\n", "    \n", "    # Plot the entire series\n", "    stock_prophet.plot(stock_forecast); plt.xlabel('Year'); plt.ylabel('Price (US $)');\n", "    plt.title('%s Stock Price and Predictions' % ticker)\n", "    \n", "    \n", "    # Dataframe for predictions and test values\n", "    results = stock_forecast[['ds', 'yhat', 'trend', 'seasonal', 'seasonalities', 'weekly', 'yearly', 'yhat_upper', 'yhat_lower']]\n", "    results = pd.merge(results, stock_test[['Date', 'Adj. Close']], left_on='ds', right_on='Date', how='right')\n", "    \n", "    all_pred = results[['trend', 'seasonal', 'seasonalities', 'weekly', 'yearly']]\n", "    # results['yhat'] = list(np.sum(np.array(all_pred), axis=1))\n", "    \n", "    \n", "    xvalues = list(range(len(results['Date'])))\n", "\n", "    xlabels = list(range(13))\n", "    xlabels.append(1)\n", "    \n", "    \n", "    fig, ax = plt.subplots(1, 1, figsize=(10, 8));\n", "    ax.plot(xvalues, results['Adj. Close'], 'b-', label = 'Actual');\n", "    ax.plot(xvalues, results['yhat'], 'r*', label = 'Predicted');\n", "    ax.fill_between(xvalues, results['yhat_upper'], results['yhat_lower'], alpha=0.6, edgecolor = 'k');\n", "    ax.set_xticks(ticks = list(range(0, max(xvalues), int(max(xvalues) / 12))));\n", "    ax.set_xticklabels(labels = xlabels);\n", "    plt.legend();\n", "    plt.xlabel('2017'); plt.ylabel('Billions $'); plt.title('Stock Price Prediction for %s' % ticker)\n", "    plt.show()\n", "                  \n", "    # Columns of daily changes\n", "    results['pred_diff'] = results['yhat'].diff()\n", "    results['actual_diff'] = results['Adj. Close'].diff()\n", "    \n", "    # Whether the prediction was right or wrong\n", "    results['pred_right'] = np.array((np.sign(results['pred_diff']) == np.sign(results['actual_diff'])).astype('int')).astype(int)\n", "    \n", "    plt.figure(figsize = (10, 8))\n", "    plt.plot(results['Date'], results['actual_diff'], 'bo-', label = 'Actual')\n", "    plt.plot(results['Date'], results['pred_diff'], 'r*-', label = 'Predicted')\n", "    plt.legend(); plt.xlabel('Date'); plt.ylabel('Change (US $)'); plt.title('Actual vs. Predicted Daily Change');\n", "    plt.show();\n", "    \n", "    # Percentage of time direction lined up\n", "    direction_accuracy = np.mean(results['pred_right'])\n", "                                         \n", "    # Performance metrics\n", "    errors = abs(results['yhat'] - results['Adj. Close'])\n", "    mean_error = np.mean(errors)\n", "    mape = np.mean(errors / results['Adj. Close'])\n", "    accuracy = 100 - (100 * mape)\n", "    \n", "    print('Actual and Predicted Difference Aligned {:0.2f}%.'.format(direction_accuracy * 100))\n", "    \n", "    performance = {'error': mean_error, 'accuracy': accuracy, 'dir_acc': direction_accuracy, 'predictions': results}\n", "    return performance"]}, {"block": 14, "type": "code", "linesLength": 0, "startIndex": 141, "lines": []}]
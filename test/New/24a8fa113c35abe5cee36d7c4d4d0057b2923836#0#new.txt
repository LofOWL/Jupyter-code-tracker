[{"block": 0, "type": "code", "linesLength": 26, "startIndex": 0, "lines": ["\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "\n", "from IPython.core.pylabtools import figsize\n", "import matplotlib.lines as mlines\n", "\n", "import seaborn as sns\n", "\n", "\n", "from sklearn.linear_model import LogisticRegressionCV\n", "from sklearn.ensemble import RandomForestClassifier\n", "from sklearn.svm import SVC\n", "\n", "from sklearn.preprocessing import StandardScaler\n", "from sklearn.model_selection import train_test_split\n", "from sklearn.metrics import f1_score, confusion_matrix, roc_auc_score, roc_curve\n", "\n", "import itertools\n", "\n", "pd.options.mode.chained_assignment = None\n", "\n", "import matplotlib as mpl\n", "\n", "from warnings import filterwarnings\n", "filterwarnings('ignore')"]}, {"block": 1, "type": "code", "linesLength": 7, "startIndex": 26, "lines": ["from sklearn.ensemble import RandomForestClassifier\n", "machine_learning_model = RandomForestClassifier()\n", "\n", "X = load_some_dataset10('dataold15_version5.csv')\n", "y = X['column']\n", "\n", "machine_learning_model.fit(X, y)"]}, {"block": 2, "type": "code", "linesLength": 17, "startIndex": 33, "lines": ["# Determine the roc curve and the auc and display\n", "def calc_roc(probs, y_test):\n", "  # Calculate the area under the roc curve\n", "  auc = roc_auc_score(y_test, probs)\n", "  # Calculate metrics for the roc curve\n", "  fpr, tpr, thresholds = roc_curve(y_test, probs)\n", "  \n", "  plt.style.use('bmh')\n", "  plt.figure(figsize = (8, 8))\n", "  \n", "  # Plot the roc curve\n", "  plt.plot(fpr, tpr, 'b')\n", "  plt.xlabel('False Positive Rate', size = 16)\n", "  plt.ylabel('True Positive Rate', size = 16)\n", "  plt.title('Receiver Operating Characteristic Curve, AUC = %0.4f' % auc, \n", "            size = 18)\n", "  "]}, {"block": 3, "type": "code", "linesLength": 8, "startIndex": 50, "lines": ["# Make logistic regression model and fit\n", "lr = LogisticRegressionCV(Cs= 20, cv = 3, scoring = 'f1', \n", "                          penalty = 'l2', random_state = 42)\n", "lr.fit(X, y)\n", "\n", "# Make predictions and evaluate\n", "lr_pred = lr.predict(X_test)\n", "calc_metrics(lr_pred, y_test)"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 58, "lines": ["edge_mat = graph_to_edge_matrix(G)\n", "edge_mat"]}, {"block": 5, "type": "code", "linesLength": 15, "startIndex": 60, "lines": ["k_clusters = 2\n", "results = []\n", "algorithms = {}\n", "\n", "algorithms['kmeans'] = cluster.KMeans(n_clusters=k_clusters, n_init=200)\n", "\n", "algorithms['agglom'] = cluster.AgglomerativeClustering(n_clusters=k_clusters, linkage=\"ward\")\n", "\n", "algorithms['spectral'] = cluster.SpectralClustering(n_clusters=k_clusters, affinity=\"precomputed\", n_init=200)\n", "\n", "algorithms['affinity'] = cluster.AffinityPropagation(damping=0.6)\n", "\n", "for model in algorithms.values():\n", "    model.fit(edge_mat)\n", "    results.append(list(model.labels_))"]}, {"block": 6, "type": "code", "linesLength": 4, "startIndex": 75, "lines": ["# Check to see how many cluster the affinity propagation algo thinks there is\n", "cluster_centers_indices = algorithms['affinity'].cluster_centers_indices_\n", "n_clusters_ = len(cluster_centers_indices)\n", "print(n_clusters_)"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# The resulting clubs\n", "algorithms['affinity'].labels_"]}, {"block": 8, "type": "code", "linesLength": 13, "startIndex": 81, "lines": ["# Need to scale features for support vector classifier\n", "scaler = StandardScaler()\n", "X_scaled = scaler.fit_transform(X)\n", "X_test_scaled = scaler.transform(X_test)\n", "\n", "# Create support vector classifier and fit\n", "svc = SVC(C = 10, gamma = 0.001, probability=True,\n", "          random_state = 42)\n", "svc.fit(X_scaled, y)\n", "\n", "# Make predictions and evaluate\n", "svc_pred = svc.predict(X_test_scaled)\n", "calc_metrics(svc_pred, y_test)"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 94, "lines": ["algorithms['kmeans'].labels_"]}, {"block": 10, "type": "code", "linesLength": 9, "startIndex": 95, "lines": ["nmi_results = []\n", "ars_results = []\n", "\n", "y_true_val = list(y_true.values()\n", "\n", "# Append the results into lists\n", "for y_pred in results:\n", "    nmi_results.append(normalized_mutual_info_score(y_true_val, y_pred))\n", "    ars_results.append(adjusted_rand_score(y_true_val, y_pred))"]}, {"block": 11, "type": "code", "linesLength": 11, "startIndex": 104, "lines": ["# Create the model in a context\n", "with pm.Model() as logistic_model:\n", "  \n", "    # Build the model using the formula and specify the data likelihood \n", "    pm.GLM.from_formula(formula, data = X_with_labels, family = pm.glm.families.Binomial())\n", "    \n", "    # Using the no-uturn sampler\n", "    sampler = pm.NUTS()\n", "    \n", "    # Sample from the posterior using NUTS\n", "    trace_log = pm.sample(draws=5000, step = sampler, chains=2, tune=1000, random_seed=100)"]}, {"block": 12, "type": "code", "linesLength": 0, "startIndex": 115, "lines": []}]
[{"block": 0, "type": "code", "linesLength": 4, "startIndex": 0, "lines": ["# quandly for financial data\n", "import quandl\n", "# pandas for data manipulation\n", "import pandas as pd"]}, {"block": 1, "type": "code", "linesLength": 11, "startIndex": 4, "lines": ["# Matplotlib for plotting\n", "import matplotlib.pyplot as plt\n", "import matplotlib\n", "import seaborn as sns\n", "%matplotlib inline\n", "\n", "plt.style.use('fivethirtyeight')\n", "matplotlib.rcParams['axes.labelsize'] = 14\n", "matplotlib.rcParams['xtick.labelsize'] = 12\n", "matplotlib.rcParams['ytick.labelsize'] = 12\n", "matplotlib.rcParams['text.color'] = 'k'"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 15, "lines": ["# Get Data from Quandl\n", "\n", "We will look at a number of different datasets in this exploration. To start, we will compare the market cap of General Motors and Tesla."]}, {"block": 3, "type": "code", "linesLength": 8, "startIndex": 18, "lines": ["quandl.ApiConfig.api_key = 'rFsSehe51RLzREtYhLfo'\n", "\n", "# Retrieve TSLA data from Quandl\n", "tesla = quandl.get('WIKI/TSLA')\n", "\n", "# Retrieve the GM data from Quandl\n", "gm = quandl.get('WIKI/GM')\n", "gm.head(5)"]}, {"block": 4, "type": "code", "linesLength": 10, "startIndex": 26, "lines": ["# The adjusted close accounts for stock splits, so that is what we should graph\n", "plt.plot(gm.index, gm['Adj. Close'])\n", "plt.title('GM Stock Price')\n", "plt.ylabel('Price ($)');\n", "plt.show()\n", "\n", "plt.plot(tesla.index, tesla['Adj. Close'], 'r')\n", "plt.title('Tesla Stock Price')\n", "plt.ylabel('Price ($)');\n", "plt.show();"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["In order to compare the companies, we need to compute their market capitalization. Quandl does not provide this data, but we can figure out the market cap ourselves by multiplying the number of shares outstanding times the share price. "]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 37, "lines": ["# Yearly average number of shares outstanding for Tesla and GM\n", "tesla_shares = {2018: 168e6, 2017: 162e6, 2016: 144e6, 2015: 128e6, 2014: 125e6, \n", "                2013: 119e6, 2012: 107e6, 2011: 100e6, 2010: 51e6}\n", "\n", "gm_shares = {2018: 1.42e9, 2017: 1.50e9, 2016: 1.54e9, 2015: 1.59e9, 2014: 1.61e9, \n", "                2013: 1.39e9, 2012: 1.57e9, 2011: 1.54e9, 2010: 1.50e9}"]}, {"block": 7, "type": "code", "linesLength": 14, "startIndex": 43, "lines": ["# Create a year column \n", "tesla['Year'] = tesla.index.year\n", "\n", "# Take Dates from index and move to Date column \n", "tesla.reset_index(level=0, inplace = True)\n", "tesla['cap'] = 0\n", "\n", "# Calculate market cap for all years\n", "for i, year in enumerate(tesla['Year']):\n", "    # Retrieve the shares for the year\n", "    shares = tesla_shares.get(year)\n", "    \n", "    # Update the cap column to shares times the price\n", "    tesla.ix[i, 'cap'] = shares * tesla.ix[i, 'Adj. Close']"]}, {"block": 8, "type": "code", "linesLength": 14, "startIndex": 57, "lines": ["# Create a year column \n", "gm['Year'] = gm.index.year\n", "\n", "# Take Dates from index and move to Date column \n", "gm.reset_index(level=0, inplace = True)\n", "gm['cap'] = 0\n", "\n", "# Calculate market cap for all years\n", "for i, year in enumerate(gm['Year']):\n", "    # Retrieve the shares for the year\n", "    shares = gm_shares.get(year)\n", "    \n", "    # Update the cap column to shares times the price\n", "    gm.ix[i, 'cap'] = shares * gm.ix[i, 'Adj. Close']"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 71, "lines": ["# Merge the two datasets and rename the columns\n", "cars = gm.merge(tesla, how='inner', on='Date')\n", "cars.rename(columns={'cap_x': 'gm_cap', 'cap_y': 'tesla_cap'}, inplace=True)"]}, {"block": 10, "type": "code", "linesLength": 8, "startIndex": 74, "lines": ["# Select only the relevant columns\n", "cars = cars.ix[:, ['Date', 'gm_cap', 'tesla_cap']]\n", "\n", "# Divide to get market cap in billions of dollars\n", "cars['gm_cap'] = cars['gm_cap'] / 1e9\n", "cars['tesla_cap'] = cars['tesla_cap'] / 1e9\n", "\n", "cars.head()"]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 82, "lines": ["plt.figure(figsize=(10, 8))\n", "plt.plot(cars['Date'], cars['gm_cap'], 'b-', label = 'GM')\n", "plt.plot(cars['Date'], cars['tesla_cap'], 'r-', label = 'TESLA')\n", "plt.xlabel('Date'); plt.ylabel('Market Cap (Billions $)'); plt.title('Market Cap of GM and Tesla')\n", "plt.legend();"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Tesla briefly surpassed GM in market cap in 2017. On what dates did this occur?"]}, {"block": 13, "type": "code", "linesLength": 7, "startIndex": 88, "lines": ["import numpy as np\n", "\n", "# Find the first and last time Tesla was valued higher than GM\n", "first_date = cars.ix[np.min(list(np.where(cars['tesla_cap'] > cars['gm_cap'])[0])), 'Date']\n", "last_date = cars.ix[np.max(list(np.where(cars['tesla_cap'] > cars['gm_cap'])[0])), 'Date']\n", "\n", "print(\"Tesla was valued higher than GM from {} to {}.\".format(first_date.date(), last_date.date()))"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["During Q2 2017, Tesla [sold](https://en.wikipedia.org/wiki/Tesla,_Inc.#Production_and_sales) 22026 cars while GM [sold](http://gmauthority.com/blog/gm/general-motors-sales-numbers/) 725000. In Q3 2017, Tesla sold 26137 cars and GM sold 808000. In all of 2017, Tesla sold 103084 cars and GM sold 3002237. That means GM was valued less than Tesla in a year during which it sold 29 times more cars than Tesla! Interesting to say the least."]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["## Prophet Models "]}, {"block": 16, "type": "code", "linesLength": 12, "startIndex": 97, "lines": ["import fbprophet\n", "\n", "# Prophet requires columns ds (Date) and y (value)\n", "gm = gm.rename(columns={'Date': 'ds', 'cap': 'y'})\n", "# Make the prophet models and fit on the data\n", "gm_prophet = fbprophet.Prophet()\n", "gm_prophet.fit(gm)\n", "\n", "# Repeat for the tesla data\n", "tesla =tesla.rename(columns={'Date': 'ds', 'cap': 'y'})\n", "tesla_prophet = fbprophet.Prophet()\n", "tesla_prophet.fit(tesla);"]}, {"block": 17, "type": "code", "linesLength": 6, "startIndex": 109, "lines": ["# Make a future dataframe for 2 years and then make predictions\n", "gm_forecast = gm_prophet.make_future_dataframe(periods=365 * 2, freq='D')\n", "gm_forecast = gm_prophet.predict(gm_forecast)\n", "\n", "tesla_forecast = tesla_prophet.make_future_dataframe(periods=365*2, freq='D')\n", "tesla_forecast = tesla_prophet.predict(tesla_forecast)"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 115, "lines": ["gm_prophet.plot(gm_forecast, xlabel = 'Date', ylabel = 'Market Cap (billions $)')\n", "plt.title('Market Cap of GM');"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 117, "lines": ["tesla_prophet.plot(tesla_forecast, xlabel = 'Date', ylabel = 'Market Cap (billions $)')\n", "plt.title('Market Cap of Tesla');"]}, {"block": 20, "type": "code", "linesLength": 10, "startIndex": 119, "lines": ["gm_names = ['gm_%s' % column for column in gm_forecast.columns]\n", "tesla_names = ['tesla_%s' % column for column in tesla_forecast.columns]\n", "\n", "# Dataframes to merge\n", "merge_gm_forecast = gm_forecast.copy()\n", "merge_tesla_forecast = tesla_forecast.copy()\n", "\n", "# Rename the columns\n", "merge_gm_forecast.columns = gm_names\n", "merge_tesla_forecast.columns = tesla_names"]}, {"block": 21, "type": "code", "linesLength": 6, "startIndex": 129, "lines": ["# Merge the two datasets\n", "forecast = pd.merge(merge_gm_forecast, merge_tesla_forecast, how = 'inner', left_on = 'gm_ds', right_on = 'tesla_ds')\n", "\n", "# Rename date column\n", "forecast = forecast.rename(columns={'gm_ds': 'Date'}).drop('tesla_ds', axis=1)\n", "forecast.head()"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 135, "lines": ["# Rescale values to be in billions of dollars\n", "forecast.ix[:, 1:] = forecast.ix[:, 1:] / 1e9"]}, {"block": 23, "type": "code", "linesLength": 5, "startIndex": 137, "lines": ["plt.figure(figsize=(10, 8))\n", "plt.plot(forecast['Date'], forecast['gm_trend'], 'b-')\n", "plt.plot(forecast['Date'], forecast['tesla_trend'], 'r-')\n", "plt.legend(); plt.xlabel('Date'); plt.ylabel('Market Cap ($)')\n", "plt.title('GM vs. Tesla Trend'); "]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 142, "lines": ["plt.figure(figsize=(10, 8))\n", "plt.plot(forecast['Date'], forecast['gm_yhat'], 'b-')\n", "plt.plot(forecast['Date'], forecast['tesla_yhat'], 'r-')\n", "plt.legend(); plt.xlabel('Date'); plt.ylabel('Market Cap (billions $)')\n", "plt.title('GM vs. Tesla Estimate'); "]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["# Only keep years 2011 onwards\n", "forecast = forecast[forecast['Date'] > '2010-12-31']"]}, {"block": 26, "type": "code", "linesLength": 12, "startIndex": 149, "lines": ["xvalues = list(range(len(forecast['Date'])))\n", "\n", "fig, ax = plt.subplots(1, 1, figsize=(10, 8));\n", "ax.plot(xvalues, forecast['gm_yhat'], label = 'gm prediction');\n", "ax.fill_between(xvalues, forecast['gm_yhat_upper'], forecast['gm_yhat_lower'], alpha=0.6, edgecolor = 'k');\n", "ax.plot(xvalues, forecast['tesla_yhat'], 'r', label = 'tesla prediction');\n", "ax.fill_between(xvalues, forecast['tesla_yhat_upper'], forecast['tesla_yhat_lower'], alpha=0.6, edgecolor = 'k');\n", "ax.set_xticks(ticks = list(range(0, 2600, 280)));\n", "ax.set_xticklabels(labels = list(range(2011, 2021, 1)));\n", "plt.legend();\n", "plt.xlabel('Date'); plt.ylabel('Billions $'); plt.title('Market Cap Prediction for GM and Tesla');\n", "\n"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 161, "lines": ["Now, we can use the Prophet Models to inspect different trends in the data. "]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 162, "lines": ["gm_prophet.plot_components(gm_forecast)"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 163, "lines": ["tesla_prophet.plot_components(tesla_forecast)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 164, "lines": ["These graphs show that Tesla tends to increase during the summer, and decrease during the winter, while GM plummets during the summer and increases during the winter. We could compare GM sales with these graphs to see if there is any correlation."]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 165, "lines": ["# Read in the sales data\n", "gm_sales = pd.read_csv('data/gm_sales.csv')\n", "gm_sales.head(5)"]}, {"block": 32, "type": "code", "linesLength": 3, "startIndex": 168, "lines": ["# Melt the sales data and rename columns\n", "gm_sales = gm_sales.melt(id_vars='Year', var_name = 'Month', value_name = 'Sales')\n", "gm_sales.head(8)"]}, {"block": 33, "type": "code", "linesLength": 11, "startIndex": 171, "lines": ["# Format the data for plotting\n", "gm_sales = gm_sales[gm_sales['Month'] != 'Total']\n", "gm_sales = gm_sales[gm_sales['Year'] > 2010]\n", "gm_sales['Date'] = ['-'.join([str(year), month]) for year, month in zip(gm_sales['Year'], gm_sales['Month'])]\n", "gm_sales['Date'] = pd.to_datetime(gm_sales['Date'], format = \"%Y-%b\")\n", "gm_sales.sort_values(by = 'Date', inplace=True)\n", "gm_sales['Month'] = [date.month for date in gm_sales['Date']]\n", "\n", "# Plot the sales over the period\n", "plt.plot(gm_sales['Date'], gm_sales['Sales'], 'r');\n", "plt.title('GM Monthly Sales 2011-2017'); plt.ylabel('Sales');"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 182, "lines": ["gm_sales_grouped = gm_sales.groupby('Month').mean()\n", "plt.plot(list(range(1, 13)), gm_sales_grouped['Sales']);\n", "plt.xlabel('Month'); plt.ylabel('Sales'); plt.title('GM Average Monthly Sales 2011-2017');"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 185, "lines": ["gm_prophet.plot_yearly(); plt.title('GM Yearly Component of Market Cap');"]}, {"block": 36, "type": "markdown", "linesLength": 3, "startIndex": 186, "lines": ["# Assessing Accuracy of Predictions\n", "\n", "We can also make testable predictions by restricting our model to a subset of the data, and then using the forecasted values to see how correct our model is. We will restrict data up until the end of 2016, and then try to make predictions for 2017."]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 189, "lines": ["gm.head()"]}, {"block": 38, "type": "code", "linesLength": 17, "startIndex": 190, "lines": ["# Create a new dataframe with the relevant information\n", "gm_stocks = gm[['ds', 'Year', 'Adj. Close']]\n", "gm_stocks.rename(columns={'Adj. Close': 'y'}, inplace=True)\n", "\n", "# Training and testing data\n", "gm_stocks_train = gm_stocks[gm_stocks['Year'] < 2017]\n", "gm_stocks_test = gm_stocks[gm_stocks['Year'] > 2016]\n", "\n", "# Create a new model \n", "gm_stock_prophet = fbprophet.Prophet()\n", "\n", "# Train the model\n", "gm_stock_prophet.fit(gm_stocks_train)\n", "gm_stock_forecast = gm_stock_prophet.make_future_dataframe(periods = gm_stocks_test.shape[0], freq = 'D')\n", "\n", "# Make forecasts\n", "gm_stock_forecast = gm_stock_prophet.predict(gm_stock_forecast)"]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 207, "lines": ["gm_stock_prophet.plot(gm_stock_forecast);\n", "plt.title('GM Stock Forecast'); plt.ylabel('Stock Price ($)'); plt.xlabel('Year');"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 209, "lines": ["plt.plot(gm_stocks_test['ds'], gm_stocks_test['y'])"]}, {"block": 41, "type": "code", "linesLength": 20, "startIndex": 210, "lines": ["# Create a new dataframe with the relevant information\n", "tesla_stocks = tesla[['ds', 'Year', 'Adj. Close']]\n", "tesla_stocks.rename(columns={'Adj. Close': 'y'}, inplace=True)\n", "\n", "# Training and testing data\n", "tesla_stocks_train = tesla_stocks[tesla_stocks['Year'] < 2017]\n", "tesla_stocks_test = tesla_stocks[tesla_stocks['Year'] > 2016]\n", "\n", "# Create a new model \n", "tesla_stock_prophet = fbprophet.Prophet()\n", "\n", "# Train the model\n", "tesla_stock_prophet.fit(tesla_stocks_train)\n", "tesla_stock_forecast = tesla_stock_prophet.make_future_dataframe(periods = tesla_stocks_test.shape[0], freq = 'D')\n", "\n", "# Make forecasts\n", "tesla_stock_forecast = tesla_stock_prophet.predict(tesla_stock_forecast)\n", "\n", "tesla_stock_prophet.plot(tesla_stock_forecast);\n", "plt.title('Tesla Stock Forecast'); plt.ylabel('Stock Price ($)'); plt.xlabel('Year');"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 230, "lines": ["plt.plot(gm_stocks_test['ds'], gm_stocks_test['y'])"]}, {"block": 43, "type": "code", "linesLength": 80, "startIndex": 231, "lines": ["def stock_predictor(ticker='TSLA'):\n", "    try:\n", "        stock = quandl.get('WIKI/%s' % ticker)\n", "    except Exception as e:\n", "        print('Invalid Stock Ticker')\n", "        print(e)\n", "        return\n", "    \n", "    # Change the index to a Date column\n", "    stock_clean = stock.reset_index()[['Date', 'Adj. Close']]\n", "    # Create a year column\n", "    stock_clean['Year'] = [date.year for date in stock_clean['Date']]\n", "    \n", "    # Training and Testing Sets\n", "    stock_train = stock_clean[stock_clean['Year'] < 2017].rename(columns={'Date': 'ds', 'Adj. Close': 'y'})\n", "    stock_test = stock_clean[stock_clean['Year'] > 2016]\n", "    \n", "    # Create the prophet model and fit on training set\n", "    stock_prophet = fbprophet.Prophet()\n", "    stock_prophet.fit(stock_train)\n", "    \n", "    # Make forecasts for entire length of test set + one week\n", "    stock_forecast = stock_prophet.make_future_dataframe(periods=400, freq = 'D')\n", "    stock_forecast = stock_prophet.predict(stock_forecast)\n", "    \n", "    # Plot the entire series\n", "    stock_prophet.plot(stock_forecast); plt.xlabel('Year'); plt.ylabel('Price (US $)');\n", "    plt.title('%s Stock Price and Predictions' % ticker)\n", "    \n", "    \n", "    # Dataframe for predictions and test values\n", "    results = stock_forecast[['ds', 'yhat', 'trend', 'seasonal', 'seasonalities', 'weekly', 'yearly', 'yhat_upper', 'yhat_lower']]\n", "    results = pd.merge(results, stock_test[['Date', 'Adj. Close']], left_on='ds', right_on='Date', how='right')\n", "    \n", "    all_pred = results[['trend', 'seasonal', 'seasonalities', 'weekly', 'yearly']]\n", "    # results['yhat'] = list(np.sum(np.array(all_pred), axis=1))\n", "    \n", "    \n", "    xvalues = list(range(len(results['Date'])))\n", "\n", "    xlabels = list(range(13))\n", "    xlabels.append(1)\n", "    \n", "    \n", "    fig, ax = plt.subplots(1, 1, figsize=(10, 8));\n", "    ax.plot(xvalues, results['Adj. Close'], 'b-', label = 'Actual');\n", "    ax.plot(xvalues, results['yhat'], 'r*', label = 'Predicted');\n", "    ax.fill_between(xvalues, results['yhat_upper'], results['yhat_lower'], alpha=0.6, edgecolor = 'k');\n", "    ax.set_xticks(ticks = list(range(0, max(xvalues), int(max(xvalues) / 12))));\n", "    ax.set_xticklabels(labels = xlabels);\n", "    plt.legend();\n", "    plt.xlabel('2017'); plt.ylabel('Billions $'); plt.title('Market Cap Prediction for GM and Tesla');\n", "    plt.show()\n", "                  \n", "    # Columns of daily changes\n", "    results['pred_diff'] = results['yhat'].diff()\n", "    results['actual_diff'] = results['Adj. Close'].diff()\n", "    \n", "    # Whether the prediction was right or wrong\n", "    results['pred_right'] = np.array((np.sign(results['pred_diff']) == np.sign(results['actual_diff'])).astype('int')).astype(int)\n", "    \n", "    plt.figure(figsize = (10, 8))\n", "    plt.plot(results['Date'], results['actual_diff'], 'bo-', label = 'Actual')\n", "    plt.plot(results['Date'], results['pred_diff'], 'r*-', label = 'Predicted')\n", "    plt.legend(); plt.xlabel('Date'); plt.ylabel('Change (US $)'); plt.title('Actual vs. Predicted Daily Change');\n", "    plt.show();\n", "    \n", "    # Percentage of time direction lined up\n", "    direction_accuracy = np.mean(results['pred_right'])\n", "                                         \n", "    # Performance metrics\n", "    errors = abs(results['yhat'] - results['Adj. Close'])\n", "    mean_error = np.mean(errors)\n", "    mape = np.mean(errors / results['Adj. Close'])\n", "    accuracy = 100 - (100 * mape)\n", "    \n", "    print('Actual and Predicted Difference Aligned {:0.2f}%.'.format(direction_accuracy * 100))\n", "    \n", "    performance = {'error': mean_error, 'accuracy': accuracy, 'dir_acc': direction_accuracy, 'predictions': results}\n", "    return performance"]}, {"block": 44, "type": "code", "linesLength": 7, "startIndex": 311, "lines": ["max_date = pd.datetime(2018, 2, 1)\n", "min_date = pd.datetime(2017, 1, 1)\n", "xlabels = []\n", "for date in list(pd.date_range(start = min_date, end = max_date, freq = 'm')):\n", "    xlabels.append(str(date.month))\n", "    \n", "xlabels"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 318, "lines": ["results = stock_predictor('TSLA')"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 319, "lines": ["results = stock_predictor('GM')"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 320, "lines": ["results = stock_predictor('MSFT')"]}, {"block": 48, "type": "code", "linesLength": 9, "startIndex": 321, "lines": ["tesla = quandl.get('WIKI/TSLA')\n", "tesla = tesla.reset_index()\n", "tesla = tesla.rename(columns={'Date': 'ds', 'Adj. Close': 'y'})\n", "tesla = tesla[['ds', 'y']]\n", "\n", "prophet = fbprophet.Prophet()\n", "prophet.fit(tesla)\n", "future = prophet.make_future_dataframe(periods=365)\n", "future = prophet.predict(future)"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 330, "lines": ["future['combination'] = future['trend'] + future['seasonal'] + future['weekly'] + future['yearly'] + future['seasonalities']\n", "print(future[['combination', 'yhat']].head())"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 332, "lines": ["results['predictions']"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 333, "lines": ["### US vs. China Gross Domestic Product"]}, {"block": 52, "type": "code", "linesLength": 11, "startIndex": 334, "lines": ["# My personal api key, use your own\n", "quandl.ApiConfig.api_key = 'rFsSehe51RLzREtYhLfo'\n", "\n", "# Get data from quandl for US and China GDP\n", "us_gdp = quandl.get('FRED/GDP', collapse='quarterly', start_date = '1950-12-31', end_date='2017-12-31')\n", "china_gdp = quandl.get('ODA/CHN_NGDPD', collapse='yearly', start_date = '1950-12-31', end_date='2017-12-31')\n", "\n", "us_gdp.plot(title = 'US Gross Domestic Product', legend=None);\n", "plt.ylabel('Billion $'); \n", "china_gdp.plot(title = 'China Gross Domestic Product', color = 'r', legend=None);\n", "plt.ylabel('Billion $');"]}, {"block": 53, "type": "code", "linesLength": 3, "startIndex": 345, "lines": ["# Change index to date column\n", "us_gdp = us_gdp.reset_index(level=0)\n", "us_gdp.head(5)"]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 348, "lines": ["china_gdp = china_gdp.reset_index(level=0)\n", "china_gdp.head(5)"]}, {"block": 55, "type": "code", "linesLength": 3, "startIndex": 350, "lines": ["# Merge the two gdp data frames and rename columns\n", "gdp = us_gdp.merge(china_gdp, on = 'Date', how = 'left').rename(columns={'Value_x': 'US', 'Value_y': 'China'})\n", "gdp.head(5)"]}, {"block": 56, "type": "code", "linesLength": 1, "startIndex": 353, "lines": ["round(gdp.describe(), 2)"]}, {"block": 57, "type": "code", "linesLength": 2, "startIndex": 354, "lines": ["# Fill in missing China observations using backward fill\n", "gdp = gdp.fillna(method='bfill')"]}, {"block": 58, "type": "code", "linesLength": 3, "startIndex": 356, "lines": ["plt.plot(gdp['Date'], gdp['US'], label = 'US', color =  'b')\n", "plt.plot(gdp['Date'], gdp['China'], label = 'China', color = 'r')\n", "plt.ylabel('Billions $'); plt.title('US and China GDP'); plt.xlabel('Date');"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 359, "lines": ["# Using Prophet"]}, {"block": 60, "type": "code", "linesLength": 8, "startIndex": 360, "lines": ["# Create a prophet object for each dataframe\n", "us_prophet = fbprophet.Prophet(growth='linear', n_changepoints = 5)\n", "china_prophet = fbprophet.Prophet(growth='linear', n_changepoints = 5)\n", "\n", "# Prophet needs dataframes with a ds (date) and y (variable) column\n", "# Use pandas rename functionality (format is dictionary with {'old': 'new'})\n", "us_gdp = us_gdp.rename(columns={'Date': 'ds', 'Value': 'y'})\n", "china_gdp = china_gdp.rename(columns={'Date': 'ds', 'Value': 'y'})"]}, {"block": 61, "type": "code", "linesLength": 2, "startIndex": 368, "lines": ["us_prophet.fit(us_gdp);\n", "china_prophet.fit(china_gdp);"]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 370, "lines": ["us_prophet.changepoints"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 371, "lines": ["The prophet object only selects changepoints from the first 80% of the data which is why the recent recession does not appear. We can try and correlate the identified changepoints with actual recessions."]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 372, "lines": ["recessions = pd.read_csv('data/recessions.csv', encoding='latin')"]}, {"block": 65, "type": "code", "linesLength": 1, "startIndex": 373, "lines": ["recessions[6:]"]}, {"block": 66, "type": "code", "linesLength": 8, "startIndex": 374, "lines": ["# Make a future dataframe with 50 years of observations \n", "# US dataframe and predictions\n", "us_forecast = us_prophet.make_future_dataframe(periods = 4 * 50, freq = '4 M')\n", "us_forecast = us_prophet.predict(us_forecast)\n", "\n", "# China dataframe and predictions\n", "china_forecast = china_prophet.make_future_dataframe(periods = 50, freq = 'Y')\n", "china_forecast = china_prophet.predict(china_forecast)"]}, {"block": 67, "type": "code", "linesLength": 1, "startIndex": 382, "lines": ["us_forecast"]}, {"block": 68, "type": "code", "linesLength": 1, "startIndex": 383, "lines": ["us_prophet.plot(us_forecast)"]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 384, "lines": ["china_prophet.plot_forecast_component(china_forecast, 'trend')"]}, {"block": 70, "type": "code", "linesLength": 1, "startIndex": 385, "lines": ["us_imports.plot(title = 'US Imports', legend = None)"]}, {"block": 71, "type": "code", "linesLength": 1, "startIndex": 386, "lines": ["china_gdp.shape"]}, {"block": 72, "type": "code", "linesLength": 1, "startIndex": 387, "lines": ["us_gdp.shape"]}, {"block": 73, "type": "code", "linesLength": 1, "startIndex": 388, "lines": ["print('Days between observations:', (gdp.index[1] - gdp.index[0]).days)"]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 389, "lines": ["gdp.plot(title = 'US Gross Domestic Product', label = 'US');\n", "plt.ylabel('GDP (Million $)'); "]}, {"block": 75, "type": "markdown", "linesLength": 1, "startIndex": 391, "lines": ["### US Imports vs Chinese Exports"]}, {"block": 76, "type": "code", "linesLength": 1, "startIndex": 392, "lines": ["cat = quandl.get('EOD/CAT')"]}, {"block": 77, "type": "code", "linesLength": 1, "startIndex": 393, "lines": ["cat.shape"]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 394, "lines": ["cat.head(5)"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 395, "lines": ["cat.plot(cat.index, 'Close')"]}, {"block": 80, "type": "code", "linesLength": 1, "startIndex": 396, "lines": ["micro = quandl.get('EOD/MSFT')"]}, {"block": 81, "type": "code", "linesLength": 1, "startIndex": 397, "lines": ["micro.plot(micro.index, 'Close')"]}, {"block": 82, "type": "code", "linesLength": 1, "startIndex": 398, "lines": ["micro.plot(micro.index, 'Adj_Close')"]}, {"block": 83, "type": "code", "linesLength": 1, "startIndex": 399, "lines": ["micro[micro['Split'] > 1.0]"]}, {"block": 84, "type": "code", "linesLength": 1, "startIndex": 400, "lines": ["prophet = fbprophet.Prophet(growth = 'linear')"]}, {"block": 85, "type": "code", "linesLength": 1, "startIndex": 401, "lines": ["micro_model.fit"]}]
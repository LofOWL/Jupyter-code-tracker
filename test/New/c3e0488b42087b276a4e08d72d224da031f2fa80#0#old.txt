[{"block": 0, "type": "markdown", "linesLength": 2, "startIndex": 0, "lines": ["<h1>Table of Contents<span class=\"tocSkip\"></span></h1>\n", "<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Introduction:-Data-Analysis-of-Medium-Articles\" data-toc-modified-id=\"Introduction:-Data-Analysis-of-Medium-Articles-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;</span>Introduction: Data Analysis of Medium Articles</a></span></li><li><span><a href=\"#Parsing-HTML-with-BeautifulSoup\" data-toc-modified-id=\"Parsing-HTML-with-BeautifulSoup-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;</span>Parsing HTML with BeautifulSoup</a></span><ul class=\"toc-item\"><li><span><a href=\"#Find-All-Articles\" data-toc-modified-id=\"Find-All-Articles-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;</span>Find All Articles</a></span></li><li><span><a href=\"#Find-Reading-Times\" data-toc-modified-id=\"Find-Reading-Times-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;</span>Find Reading Times</a></span></li><li><span><a href=\"#Retrieving-Articles\" data-toc-modified-id=\"Retrieving-Articles-2.3\"><span class=\"toc-item-num\">2.3&nbsp;&nbsp;</span>Retrieving Articles</a></span></li><li><span><a href=\"#Parsing-Articles\" data-toc-modified-id=\"Parsing-Articles-2.4\"><span class=\"toc-item-num\">2.4&nbsp;&nbsp;</span>Parsing Articles</a></span><ul class=\"toc-item\"><li><span><a href=\"#Number-of-Claps\" data-toc-modified-id=\"Number-of-Claps-2.4.1\"><span class=\"toc-item-num\">2.4.1&nbsp;&nbsp;</span>Number of Claps</a></span></li></ul></li><li><span><a href=\"#Determining-Responses-vs-Articles\" data-toc-modified-id=\"Determining-Responses-vs-Articles-2.5\"><span class=\"toc-item-num\">2.5&nbsp;&nbsp;</span>Determining Responses vs Articles</a></span></li><li><span><a href=\"#Finding-Published-Time\" data-toc-modified-id=\"Finding-Published-Time-2.6\"><span class=\"toc-item-num\">2.6&nbsp;&nbsp;</span>Finding Published Time</a></span></li><li><span><a href=\"#Number-of-Responses\" data-toc-modified-id=\"Number-of-Responses-2.7\"><span class=\"toc-item-num\">2.7&nbsp;&nbsp;</span>Number of Responses</a></span></li><li><span><a href=\"#Tags-for-Article\" data-toc-modified-id=\"Tags-for-Article-2.8\"><span class=\"toc-item-num\">2.8&nbsp;&nbsp;</span>Tags for Article</a></span></li></ul></li><li><span><a href=\"#Function-for-Parsing-Articles\" data-toc-modified-id=\"Function-for-Parsing-Articles-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;</span>Function for Parsing Articles</a></span><ul class=\"toc-item\"><li><span><a href=\"#Aside:-Parallelizing-Operation\" data-toc-modified-id=\"Aside:-Parallelizing-Operation-3.1\"><span class=\"toc-item-num\">3.1&nbsp;&nbsp;</span>Aside: Parallelizing Operation</a></span></li><li><span><a href=\"#Function-for-Parallel-Processing\" data-toc-modified-id=\"Function-for-Parallel-Processing-3.2\"><span class=\"toc-item-num\">3.2&nbsp;&nbsp;</span>Function for Parallel Processing</a></span></li><li><span><a href=\"#Dataframe-of-Results\" data-toc-modified-id=\"Dataframe-of-Results-3.3\"><span class=\"toc-item-num\">3.3&nbsp;&nbsp;</span>Dataframe of Results</a></span></li><li><span><a href=\"#Interactive-Plots\" data-toc-modified-id=\"Interactive-Plots-3.4\"><span class=\"toc-item-num\">3.4&nbsp;&nbsp;</span>Interactive Plots</a></span></li><li><span><a href=\"#Function-To-Make-Interactive-Plots\" data-toc-modified-id=\"Function-To-Make-Interactive-Plots-3.5\"><span class=\"toc-item-num\">3.5&nbsp;&nbsp;</span>Function To Make Interactive Plots</a></span></li><li><span><a href=\"#Exploring-Tags\" data-toc-modified-id=\"Exploring-Tags-3.6\"><span class=\"toc-item-num\">3.6&nbsp;&nbsp;</span>Exploring Tags</a></span></li><li><span><a href=\"#Exploring-Correlations\" data-toc-modified-id=\"Exploring-Correlations-3.7\"><span class=\"toc-item-num\">3.7&nbsp;&nbsp;</span>Exploring Correlations</a></span></li><li><span><a href=\"#Function-to-get-links-from-a-soup\" data-toc-modified-id=\"Function-to-get-links-from-a-soup-3.8\"><span class=\"toc-item-num\">3.8&nbsp;&nbsp;</span>Function to get links from a soup</a></span></li><li><span><a href=\"#Unlisted-Articles\" data-toc-modified-id=\"Unlisted-Articles-3.9\"><span class=\"toc-item-num\">3.9&nbsp;&nbsp;</span>Unlisted Articles</a></span></li></ul></li></ul></div>"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 2, "lines": ["# Introduction: Data Analysis of Medium Articles\n", "\n", "In this notebook, we'll do some basic data analysis of my medium articles. This is meant as a fun exercise that can also teach us a little about dealing with `HTML` files and making effective visuals."]}, {"block": 2, "type": "code", "linesLength": 28, "startIndex": 5, "lines": ["# Data science imports\n", "import pandas as pd\n", "import numpy as np\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 20\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "# Interactive plotting\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot\n", "import cufflinks\n", "cufflinks.go_offline()\n", "\n", "from timeit import default_timer as timer\n", "\n", "from collections import Counter, defaultdict\n", "from itertools import chain\n", "\n", "from bs4 import BeautifulSoup\n", "import re\n", "\n", "import requests\n", "from multiprocessing import Pool"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 33, "lines": ["# Parsing HTML with BeautifulSoup\n", "\n", "BeautifulSoup is the go-to method in Python for parsing HTML. To make a structured object (soup) out of HTML, we simply need to pass in the raw HTML. "]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 36, "lines": ["\n", "\n", "soup = BeautifulSoup(open('data/published.html', 'r').read())\n", "soup.text[:100]"]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 40, "lines": ["## Find All Articles\n", "\n", "Finding what we want from the soup is as easy as searching for different elements by the HTML tag or different attributes such as the `class`. Here we'll find all the entries on this page (which includes actual articles as well as responses). "]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["entries = soup.find_all(attrs = {'class': 'bq y br af bs ag db dc dd c de df dg'})\n", "print(f'Found {len(entries)} entries.')"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["entries[-1]"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["(The [above article](https://medium.com/@williamkoehrsen/screw-the-environment-but-consider-your-wallet-a4f7cd3d3161) is one of my favorites!)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Later, we'll be able to sort out the articles because their pages have an `h1` header tag. For now, let's scrape the page for the title text and the reading times of all entries."]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 48, "lines": ["titles = [e.text for e in entries]\n", "titles[-1]"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 50, "lines": ["## Find Reading Times\n", "\n", "The reading times can be extracted using a regular expression. We'll match the text to a regular expression."]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 53, "lines": ["pattern = re.compile('[0-9]{1,} min read')\n", "pattern.findall(string = '15 min read')"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 55, "lines": ["read_times = soup.find_all(text = pattern)\n", "print(f'Found {len(read_times)} read times.')"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Now for the best part: the total reading time of all articles. "]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 58, "lines": ["read_times = [int(x.split(' ')[0]) for x in read_times]\n", "total_read_time = sum(read_times)\n", "print(f'Total Read Time of Entries: {total_read_time} minutes.')"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["This is somewhat inflated because some of these are responses. Later, we'll be able to sort out the responses."]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 62, "lines": ["data = go.Histogram(x = read_times, xbins=dict(size=1), marker=dict(line=dict(color='black', width=1.2)))\n", "layout = go.Layout(title='Histogram of Read Times', \n", "                   yaxis=dict(title='Count'),\n", "                   xaxis=dict(title='Reading Time (minutes)'))\n", "figure = go.Figure(data=[data], layout=layout)"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["iplot(figure)"]}, {"block": 19, "type": "markdown", "linesLength": 3, "startIndex": 68, "lines": ["## Retrieving Articles\n", "\n", "Now that we have the basic metadata, we want to get the articles themselves. For this, we'll find the links associated with each entry. "]}, {"block": 20, "type": "code", "linesLength": 3, "startIndex": 71, "lines": ["entry_links = [entry.a.get_attribute_list('href')[0] for entry in entries]\n", "entry_links[-1]\n", "len(entry_links)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["We can use the great `requests` library to retrieve all of the information on each of these linked pages."]}, {"block": 22, "type": "code", "linesLength": 7, "startIndex": 75, "lines": ["\n", "\n", "entries = []\n", "for a in entry_links[:10]:\n", "    entries.append(requests.get(a).content)\n", "    \n", "entries[0][:10]"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["## Parsing Articles"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["We now have each entry as an HTML page. We can take the same approach as we did with the overall page to scrape whatever information we want. For example, we can find all the paragraphs on the page with the following:"]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 84, "lines": ["entry_soup = BeautifulSoup(entries[0])\n", "entry_text = [p.text for p in entry_soup.find_all('p')]\n", "entry_text[0]"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["We can convert this to a single string with `join`. A rough word count can be found by then splitting this on spaces."]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 88, "lines": ["entry_text = ' '.join(entry_text)\n", "word_count = len(entry_text.split(' '))\n", "print(f'There are {word_count} words in this article.')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["We can also get the reading time (again) with a little parsing."]}, {"block": 29, "type": "code", "linesLength": 4, "startIndex": 92, "lines": ["read_time = entry_soup.find_all(attrs={'class': 'readingTime'})\n", "read_time[0].get('title')\n", "\n", "read_mins = int(read_time[0].get('title').split(' ')[0])"]}, {"block": 30, "type": "markdown", "linesLength": 3, "startIndex": 96, "lines": ["### Number of Claps\n", "\n", "The number of claps is hidden within an obscure class, but we can get it using this:"]}, {"block": 31, "type": "code", "linesLength": 12, "startIndex": 99, "lines": ["clap_pattern = re.compile('^[0-9]{1,} claps|^[0-9]{1,}.[0-9]{1,}K claps|^[0-9]{1,}K claps')\n", "claps = entry_soup.find_all(text = clap_pattern)\n", "\n", "if len(claps) > 0:\n", "    if 'K' in claps[0]:\n", "        clap_number = int(1e3 * float(claps[0].split('K')[0]))\n", "    else:\n", "        clap_number = int(claps[0].split(' ')[0])\n", "else:\n", "    clap_number = 0\n", "    \n", "claps"]}, {"block": 32, "type": "markdown", "linesLength": 3, "startIndex": 111, "lines": ["## Determining Responses vs Articles\n", "\n", "The easiest way to figure out if an entry is a response or an article is to search for the `h1` header."]}, {"block": 33, "type": "code", "linesLength": 6, "startIndex": 114, "lines": ["if entry_soup.h1 is not None:\n", "    title = entry_soup.h1.text\n", "else:\n", "    title = 'response'\n", "    \n", "print(f'Found title: \"{title}\"')"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["To store all this information, let's use one of my favorite Python data types, a dictionary."]}, {"block": 35, "type": "code", "linesLength": 5, "startIndex": 121, "lines": ["entry_dict = defaultdict(dict)\n", "entry_dict[title]['text'] = entry_text\n", "entry_dict[title]['word_count'] = word_count\n", "entry_dict[title]['clap_count'] = clap_number\n", "entry_dict[title]['read_time'] = read_mins"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 126, "lines": ["entry_dict.keys()"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 127, "lines": ["## Finding Published Time\n", "\n", "Another piece of information we may want is the published time of the article. This is simple enough to get."]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 130, "lines": ["t = entry_soup.find_all('time')[0]\n", "t.get('datetime')"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 132, "lines": ["This is the time in UTC. We can use Pandas to convert to the local time of publication."]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 133, "lines": ["pd.to_datetime(t.get('datetime'), utc=True).tz_convert('America/New_York')"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["(I didn't publish all of my articles in the eastern time zone, most were published in the midwest. However, I'm not sure how to get geographic information from these pages, so for now we'll just localize using Eastern time)."]}, {"block": 42, "type": "markdown", "linesLength": 3, "startIndex": 135, "lines": ["## Number of Responses\n", "\n", "As another piece of information, let's find the number of responses to the article."]}, {"block": 43, "type": "code", "linesLength": 4, "startIndex": 138, "lines": ["responses = entry_soup.find_all(attrs={'class': 'button button--chromeless u-baseColor--buttonNormal u-marginRight12'})\n", "responses\n", "\n", "n_responses = int(responses[0].text)"]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 142, "lines": ["## Tags for Article\n", "\n", "The final piece of information we'll retrieve about the article is the tags associated with it. These are also easy to grab."]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 145, "lines": ["tags = entry_soup.find_all(attrs={'class': 'tags tags--postTags tags--borderless'})\n", "tags = [li.text for li in tags[0].find_all('li')]\n", "tags"]}, {"block": 46, "type": "code", "linesLength": 2, "startIndex": 148, "lines": ["entry_dict[title]['num_responses'] = n_responses\n", "entry_dict[title]['tags'] = tags"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 150, "lines": ["At this point we have quick a lot of information about each entry. In the case where the entry is a response, we won't be able to gather as much data, but we are mostly focused on the articles anyway."]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 151, "lines": ["import pprint\n", "pprint.pprint({key: value for key, value in entry_dict[title].items() if key != 'text'})"]}, {"block": 49, "type": "markdown", "linesLength": 3, "startIndex": 153, "lines": ["# Function for Parsing Articles\n", "\n", "We'll put all of the above steps into a single function that can grab the information from all the entries if passed a list of entry links. The return will be a dictionary containing the complete data about each entry."]}, {"block": 50, "type": "code", "linesLength": 75, "startIndex": 156, "lines": ["def get_entries(entry_links):\n", "    \"\"\"\n", "    Retrieve data of all entries in a list of links.\n", "    \n", "    :param entry_links: list of strings for links to entries\n", "    \n", "    :return entries: dictionary with information about each entry\n", "    \"\"\"\n", "    \n", "    entry_dict = defaultdict(dict)\n", "    n_words = 0\n", "    \n", "    response_count = 0\n", "    # Iterate through all links\n", "    for i, link in enumerate(entry_links):\n", "        \n", "        # Tracking progress\n", "        if (i + 1) % 5 == 0:\n", "            print(f'{100 * i / len(entry_links):.2f}% complete. Total words = {n_words}.', end = '\\r')\n", "        \n", "        # Retrieve the article and create a soup\n", "        entry = requests.get(link).content\n", "        entry_soup = BeautifulSoup(entry)\n", "        \n", "        # Publication time\n", "        t = entry_soup.find_all('time')[0]\n", "        t = pd.to_datetime(t.get('datetime'), utc=True).tz_convert('America/New_York')\n", "        \n", "        # Find the title header (determines if an article or a response)\n", "        if entry_soup.h1 is not None:\n", "            title = entry_soup.h1.text\n", "        else:\n", "            title = f'response-{t}'\n", "            response_count += 1\n", "            \n", "        # Text as single long string\n", "        entry_text = [p.text for p in entry_soup.find_all('p')]\n", "        entry_text = ' '.join(entry_text)\n", "        \n", "        # Word count\n", "        word_count = len(entry_text.split(' '))\n", "        n_words += word_count\n", "        \n", "        # Reading time in minutes\n", "        read_time = entry_soup.find_all(attrs={'class': 'readingTime'})\n", "        read_mins = int(read_time[0].get('title').split(' ')[0])\n", "        \n", "        # Number of claps\n", "        clap_pattern = re.compile('^[0-9]{1,} claps|^[0-9]{1,}.[0-9]{1,}K claps|^[0-9]{1,}K claps')\n", "        claps = entry_soup.find_all(text = clap_pattern)\n", "\n", "        if len(claps) > 0:\n", "            if 'K' in claps[0]:\n", "                clap_number = int(1e3 * float(claps[0].split('K')[0]))\n", "            else:\n", "                clap_number = int(claps[0].split(' ')[0])\n", "        else:\n", "            clap_number = 0\n", "            \n", "        # Post tags\n", "        tags = entry_soup.find_all(attrs={'class': 'tags tags--postTags tags--borderless'})\n", "        tags = [li.text for li in tags[0].find_all('li')]\n", "        \n", "        # Store in dictionary with title as key\n", "        entry_dict[title]['text'] = entry_text\n", "        entry_dict[title]['word_count'] = word_count\n", "        entry_dict[title]['read_time'] = read_mins\n", "        entry_dict[title]['claps'] = clap_number\n", "        entry_dict[title]['time_published'] = t\n", "        entry_dict[title]['tags'] = tags\n", "        \n", "    print(f'Found {len(entry_dict) - response_count} articles and {response_count} responses.')\n", "    print(f'Total words: {n_words}.')\n", "    \n", "    return entry_dict"]}, {"block": 51, "type": "code", "linesLength": 3, "startIndex": 231, "lines": ["entry_soup = BeautifulSoup(requests.get('https://medium.com/@williamkoehrsen/one-of-the-best-parts-about-featuretools-is-that-its-not-constrained-by-human-limits-on-creativity-daa0b40406d6').content)\n", "clap_pattern = re.compile('^[0-9]{1,} claps')\n", "entry_soup.find_all(text=clap_pattern)"]}, {"block": 52, "type": "code", "linesLength": 3, "startIndex": 234, "lines": ["start = timer()\n", "entry_dict = get_entries(entry_links=entry_links)\n", "end = timer()"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 237, "lines": ["print(f'This operation took {end - start:.0f} seconds.')"]}, {"block": 54, "type": "markdown", "linesLength": 3, "startIndex": 238, "lines": ["## Aside: Parallelizing Operation\n", "\n", "If we want to make this go a little faster, was can parallelize the function. Instead of writing a function that takes in all of the links at once, we write a function to take in a single link and then `map` this function to workers."]}, {"block": 55, "type": "code", "linesLength": 63, "startIndex": 241, "lines": ["def process_entry(link):\n", "    \"\"\"\n", "    Retrieve data of single entry.\n", "    \n", "    :param link: string for link to entry\n", "    \n", "    :return entry_dict: dictionary of data about entry\n", "    \"\"\"\n", "    \n", "    entry_dict = {}\n", "     \n", "    # Retrieve the article and create a soup\n", "    entry = requests.get(link).content\n", "    entry_soup = BeautifulSoup(entry)\n", "    \n", "    # Publication time\n", "    t = entry_soup.find_all('time')[0]\n", "    t = pd.to_datetime(t.get('datetime'), utc=True).tz_convert('America/New_York')\n", "\n", "    # Find the title header (determines if an article or a response)\n", "    if entry_soup.h1 is not None:\n", "        title = entry_soup.h1.text\n", "    else:\n", "        title = f'response-{t}'\n", "\n", "    # Text as single long string\n", "    entry_text = [p.text for p in entry_soup.find_all('p')]\n", "    entry_text = ' '.join(entry_text)\n", "\n", "    # Word count\n", "    word_count = len(entry_text.split(' '))\n", "\n", "    # Reading time in minutes\n", "    read_time = entry_soup.find_all(attrs={'class': 'readingTime'})\n", "    read_mins = int(read_time[0].get('title').split(' ')[0])\n", "\n", "    # Number of claps\n", "    clap_pattern = re.compile('^[0-9]{1,} claps|^[0-9]{1,}.[0-9]{1,}K claps|^[0-9]{1,}K claps')\n", "    claps = entry_soup.find_all(text = clap_pattern)\n", "\n", "    if len(claps) > 0:\n", "        if 'K' in claps[0]:\n", "            clap_number = int(1e3 * float(claps[0].split('K')[0]))\n", "        else:\n", "            clap_number = int(claps[0].split(' ')[0])\n", "    else:\n", "        clap_number = 0\n", "\n", "    # Post tags\n", "    tags = entry_soup.find_all(attrs={'class': 'tags tags--postTags tags--borderless'})\n", "    tags = [li.text for li in tags[0].find_all('li')]\n", "        \n", "    # Store in dictionary with title as key\n", "    entry_dict['title'] = title\n", "    entry_dict['text'] = entry_text\n", "    entry_dict['word_count'] = word_count\n", "    entry_dict['read_time'] = read_mins\n", "    entry_dict['claps'] = clap_number\n", "    entry_dict['time_published'] = t\n", "    entry_dict['tags'] = tags\n", "        \n", "    \n", "    return entry_dict"]}, {"block": 56, "type": "code", "linesLength": 15, "startIndex": 304, "lines": ["pool = Pool(processes=20)\n", "results = []\n", "\n", "start = timer()\n", "for i, result in enumerate(pool.imap_unordered(process_entry, entry_links)):\n", "    if (i + 1) % 5 == 0:\n", "        print(f'{100 * i / len(entry_links):.2f}% complete.', end='\\r')\n", "    results.append(result)\n", "    \n", "pool.close()\n", "pool.join()\n", "end = timer()\n", "\n", "results[0]['title']\n", "results[0]['word_count']"]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 319, "lines": ["print(f'With multiprocessing this operation took {end - start:.0f} seconds.')"]}, {"block": 58, "type": "markdown", "linesLength": 3, "startIndex": 320, "lines": ["## Function for Parallel Processing\n", "\n", "Considering how much faster processing these articles is in parallel, we probably want to do that from now on! "]}, {"block": 59, "type": "code", "linesLength": 27, "startIndex": 323, "lines": ["def process_in_parallel(links, processes=20):\n", "    \"\"\"\n", "    Process entries in parallel\n", "    \n", "    :param links: list of entry links\n", "    :param processes: integer number of processes (threads) to use in parallel\n", "    \n", "    :return results: list of dictionaries of entry data\n", "    \"\"\"\n", "    pool = Pool(processes=processes)\n", "    results = []\n", "\n", "    start = timer()\n", "    for i, result in enumerate(pool.imap_unordered(process_entry, links)):\n", "        if (i + 1) % 5 == 0:\n", "            print(f'{100 * i / len(links):.2f}% complete.', end='\\r')\n", "        results.append(result)\n", "\n", "    pool.close()\n", "    pool.join()\n", "    end = timer()\n", "    \n", "    print(f'Processed {len(results)} entries in {end-start:.0f} seconds.')\n", "    \n", "    df = pd.DataFrame.from_dict(results)\n", "    df['response'] = ['response' if x == True else 'article' for x in df['title'].str.contains('response')]\n", "    return df"]}, {"block": 60, "type": "code", "linesLength": 1, "startIndex": 350, "lines": ["entry_data = process_in_parallel(entry_links, processes=50)"]}, {"block": 61, "type": "markdown", "linesLength": 3, "startIndex": 351, "lines": ["## Dataframe of Results\n", "\n", "Converting this dictionary to a dataframe is relatively simple (and was done in the function). We just need to call `DataFrame.from_dict` and each of the rows will be an article with the columns containing the data. This puts the dataframe in the familiar wide format which is best for plotting. We can also make a column indicating if the entry was a response or an article."]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 354, "lines": ["entry_data.head()"]}, {"block": 63, "type": "code", "linesLength": 12, "startIndex": 355, "lines": ["data = [go.Histogram(x=list(entry_data.loc[entry_data['response'] == 'article', 'word_count']), \n", "                     name='article', marker=dict(color = 'blue', line=dict(color='black', width=1.1))),\n", "        go.Histogram(x=list(entry_data.loc[entry_data['response'] == 'response', 'word_count']), \n", "                     name='response', marker=dict(color = 'green', line=dict(color='black', width=1.1)))]\n", "        \n", "layout = go.Layout(title='Histogram of Word Counts', xaxis=dict(title='word count',\n", "                                                                tickfont=dict(size=14),\n", "                                                                titlefont=dict(size=16)),\n", "                   yaxis=dict(title='Count', tickfont=dict(size=14),\n", "                              titlefont=dict(size=16)))\n", "\n", "figure = go.Figure(data=data, layout=layout)"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 367, "lines": ["iplot(figure)"]}, {"block": 65, "type": "code", "linesLength": 2, "startIndex": 368, "lines": ["entry_data.iplot(x='time_published', y='word_count', opacity=0.75, mode='markers', xTitle='Date', yTitle='num_words',\n", "           title='Number of Words vs Date', text = 'title', categories='response')"]}, {"block": 66, "type": "markdown", "linesLength": 3, "startIndex": 370, "lines": ["## Interactive Plots\n", "\n", "With plotly, we can very easily add options to select `response` or `articles`."]}, {"block": 67, "type": "code", "linesLength": 28, "startIndex": 373, "lines": ["base_title = 'Word Counts'\n", "\n", "updatemenus = list([\n", "    dict(\n", "        buttons=list([\n", "            dict(\n", "                label='both', method='update', \n", "                args=[dict(visible=[True, True]), dict(title = base_title)]),\n", "            dict(\n", "                label='articles',\n", "                method='update',\n", "                args=[dict(visible=[True, False]), dict(title = 'Article ' + base_title)]),\n", "            dict(\n", "                label='responses',\n", "                method='update',\n", "                args=[dict(visible=[False, True]), dict(title='Response ' + base_title)])\n", "        ]))\n", "])\n", "\n", "layout = go.Layout(\n", "    title=base_title,\n", "    xaxis=dict(\n", "        title='word count', tickfont=dict(size=14), titlefont=dict(size=16)),\n", "    yaxis=dict(title='Count', tickfont=dict(size=14), titlefont=dict(size=16)),\n", "    updatemenus=updatemenus)\n", "\n", "figure = go.Figure(data=data, layout=layout)\n", "iplot(figure)"]}, {"block": 68, "type": "code", "linesLength": 4, "startIndex": 401, "lines": ["entry_data['claps_per_word'] = entry_data['claps'] / entry_data['word_count']\n", "entry_data['words_per_minute'] = entry_data['word_count'] / entry_data['read_time']\n", "responses = entry_data[entry_data['response'] == 'response'].copy()\n", "articles = entry_data[entry_data['response'] == 'article'].copy()"]}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 405, "lines": ["We can add this interactivity to any plot because the updatemenu was written to apply to all the data."]}, {"block": 70, "type": "code", "linesLength": 25, "startIndex": 406, "lines": ["def make_update_menu(base_title):\n", "    \"\"\"\n", "    Make an updatemenu for interative plot\n", "    \n", "    :param base_title: string for title of plot\n", "    \n", "    :return updatemenus: a updatemenus object for adding to a layout\n", "    \"\"\"\n", "    updatemenus = list([\n", "    dict(\n", "        buttons=list([\n", "            dict(\n", "                label='both', method='update', \n", "                args=[dict(visible=[True, True]), dict(title = base_title)]),\n", "            dict(\n", "                label='articles',\n", "                method='update',\n", "                args=[dict(visible=[True, False]), dict(title = 'Article ' + base_title)]),\n", "            dict(\n", "                label='responses',\n", "                method='update',\n", "                args=[dict(visible=[False, True]), dict(title='Response ' + base_title)])\n", "        ]))\n", "    ])\n", "    return updatemenus\n"]}, {"block": 71, "type": "markdown", "linesLength": 3, "startIndex": 431, "lines": ["## Function To Make Interactive Plots\n", "\n", "We can write a short function that will automatically make these interactive plots for us. All we have to do is pass in the `x` and `y` arguments along with a title. "]}, {"block": 72, "type": "code", "linesLength": 115, "startIndex": 434, "lines": ["def make_iplot(data, x, y, base_title, time=False):\n", "    \"\"\"\n", "    Make an interactive plot. Adds a dropdown to separate articles from responses\n", "    if there are responses in the data\n", "    \n", "    :param data: dataframe of entry data\n", "    :param x: string for xaxis of plot\n", "    :param y: sring for yaxis of plot\n", "    :param base_title: string for title of plot\n", "    :param time: boolean for whether the xaxis is a plot\n", "    \n", "    :return figure: an interactive plotly object for display\n", "    \n", "    \"\"\"\n", "\n", "    # Extract the relevant data\n", "    responses = data[data['response'] == 'response'].copy()\n", "    articles = data[data['response'] == 'article'].copy()\n", "\n", "    if not responses.empty:\n", "        # Create scatterplot data, articles must be first for menu selection\n", "        plot_data = [\n", "            go.Scatter(\n", "                x=articles[x],\n", "                y=articles[y],\n", "                mode='markers',\n", "                name='articles',\n", "                text=articles['title'],\n", "                marker=dict(color='blue', size=12)),\n", "            go.Scatter(\n", "                x=responses[x],\n", "                y=responses[y],\n", "                mode='markers',\n", "                name='responses',\n", "                marker=dict(color='green', size=12))\n", "        ]\n", "        \n", "        # Make a layout with update menus\n", "        layout = go.Layout(\n", "            height=600,\n", "            width=900,\n", "            title=base_title,\n", "            xaxis=dict(\n", "                title=x.title(),\n", "                tickfont=dict(size=14),\n", "                titlefont=dict(size=16)),\n", "            yaxis=dict(\n", "                title=y.title(),\n", "                tickfont=dict(size=14),\n", "                titlefont=dict(size=16)),\n", "            updatemenus=make_update_menu(base_title))\n", "\n", "    # If there are only articles\n", "    else:\n", "        plot_data = [\n", "            go.Scatter(\n", "                x=data[x],\n", "                y=data[y],\n", "                mode='markers',\n", "                text=data['title'],\n", "                marker=dict(color='blue', size=12))\n", "        ]\n", "\n", "        layout = go.Layout(\n", "            height=600,\n", "            width=900,\n", "            title=base_title,\n", "            xaxis=dict(\n", "                title=x.title(),\n", "                tickfont=dict(size=14),\n", "                titlefont=dict(size=16)),\n", "            yaxis=dict(\n", "                title=y.title(),\n", "                tickfont=dict(size=14),\n", "                titlefont=dict(size=16)))\n", "\n", "    # Add a rangeselector and rangeslider for a data xaxis\n", "    if time:\n", "        rangeselector = dict(\n", "            buttons=list([\n", "                dict(count=1, label='1m', step='month', stepmode='backward'),\n", "                dict(count=6, label='6m', step='month', stepmode='backward'),\n", "                dict(count=1, label='YTD', step='year', stepmode='todate'),\n", "                dict(count=1, label='1y', step='year', stepmode='backward'),\n", "                dict(step='all')\n", "            ]))\n", "        rangeslider = dict(visible=True)\n", "        layout['xaxis']['rangeselector'] = rangeselector\n", "        layout['xaxis']['rangeslider'] = rangeslider\n", "        \n", "        figure = go.FigureWidget(data=plot_data, layout=layout)\n", "        \n", "        # Sort data by the time\n", "        data = data.sort_values(x).reset_index()\n", "        \n", "        # Function for changing yaxis on zoom\n", "        def zoom(layout, xrange):\n", "            # Subset to data on the plot\n", "            in_view = data.loc[data[x].between(figure.layout.xaxis.range[0], \n", "                                               figure.layout.xaxis.range[1])].copy()\n", "            \n", "            min_value = in_view[y].min()\n", "            max_value = in_view[y].max()\n", "            # Set the yaxis range\n", "            figure.layout.yaxis.range = [0.8 * min_value, 1.25 * max_value]\n", "            \n", "        # Set figure to change on zoom\n", "        figure.layout.on_change(zoom, 'xaxis.range')\n", "            \n", "        return figure\n", "        \n", "    # Return the figure\n", "    figure = go.FigureWidget(data=plot_data, layout=layout)\n", "\n", "    return figure"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 549, "lines": ["https://community.plot.ly/t/y-axis-autoscaling-with-x-range-sliders/10245/4"]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 550, "lines": ["figure = make_iplot(entry_data, 'time_published', 'word_count', 'Word Count over Time')\n", "iplot(figure)"]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 552, "lines": ["figure = make_iplot(articles, 'time_published', 'word_count', 'Word Count over Time', time=True)\n", "iplot(figure)"]}, {"block": 76, "type": "code", "linesLength": 2, "startIndex": 554, "lines": ["figure = make_iplot(articles, 'time_published', 'claps', 'Claps over Time', time=True)\n", "iplot(figure)"]}, {"block": 77, "type": "code", "linesLength": 2, "startIndex": 556, "lines": ["figure = make_iplot(entry_data, 'read_time', 'claps', 'Number of Claps vs Read Time')\n", "iplot(figure)"]}, {"block": 78, "type": "code", "linesLength": 2, "startIndex": 558, "lines": ["figure = make_iplot(articles, 'read_time', 'word_count', 'Number of Words vs Read Time')\n", "iplot(figure)"]}, {"block": 79, "type": "code", "linesLength": 2, "startIndex": 560, "lines": ["figure = make_iplot(articles, 'time_published', 'claps_per_word', 'Claps Per Word')\n", "iplot(figure)"]}, {"block": 80, "type": "code", "linesLength": 3, "startIndex": 562, "lines": ["articles['words_per_minute'].iplot(kind='hist', \n", "                                   xTitle='Words per Minute', \n", "                                   title=\"Histogram of Words per Minute\")"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 565, "lines": ["## Exploring Tags"]}, {"block": 82, "type": "markdown", "linesLength": 1, "startIndex": 566, "lines": ["If we want to look at the tags, we'll need to create find all of them which we can do by flattening the list of lists for each entry."]}, {"block": 83, "type": "code", "linesLength": 3, "startIndex": 567, "lines": ["all_tags = list(chain(*entry_data['tags'].tolist()))\n", "tag_counts = Counter(all_tags)\n", "tag_counts.most_common(10)"]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 570, "lines": ["The most popular tags are not that surprising for my work! "]}, {"block": 85, "type": "code", "linesLength": 45, "startIndex": 571, "lines": ["def make_iplot_by_tag(data, x, y, title, n=10):\n", "    \"\"\"\n", "    Make an interactive plot colored by the post tag (with top `n` tags)\n", "    \n", "    :param data: dataframe of posts\n", "    :param x: string for the independent variable\n", "    :param y: string for the dependent variable\n", "    :param title: string for the title of plot\n", "    :param n: integer for number of most popular tags to display\n", "    \n", "    :return figure: a plotly figure for display\n", "    :return tag_plot: a plotly bar plot of tag counts\n", "    :return data: dataframe with tags included\n", "    \n", "    \"\"\"\n", "    data = data.copy()\n", "    all_tags = list(chain(*data['tags'].tolist()))\n", "    tag_counts = Counter(all_tags)\n", "    tags = tag_counts.most_common(n)\n", "    \n", "    plot_data = []\n", "    for tag, count in tags:\n", "        flag = [1 if tag in tags else 0 for tags in data['tags']]\n", "        data.loc[:, f'<tag>:{tag}'] = flag\n", "        \n", "        subset = data[data[f'<tag>:{tag}'] == 1].copy()\n", "        plot_data.append(go.Scatter(x=subset[x], y=subset[y], marker=dict(size = 12), \n", "                               name=tag, mode='markers'))\n", "        \n", "    layout = go.Layout(\n", "        title=title,\n", "        xaxis=dict(\n", "            title=x.title(), tickfont=dict(size=14), titlefont=dict(size=16)),\n", "        yaxis=dict(title=y.title(), tickfont=dict(size=14), titlefont=dict(size=16)))\n", "    \n", "    figure = go.FigureWidget(data=plot_data, layout=layout)\n", "    \n", "    tag_plot = go.FigureWidget(data=[go.Bar(x=[tag[0] for tag in tags],\n", "                                          y=[tag[1] for tag in tags])],\n", "                              layout=go.Layout(title='Bar Plot of Tag Counts', \n", "                                              xaxis=dict(\n", "            title='tag', tickfont=dict(size=14), titlefont=dict(size=16)),\n", "        yaxis=dict(title='count', tickfont=dict(size=14), titlefont=dict(size=16))))\n", "    \n", "    return figure, tag_plot, data"]}, {"block": 86, "type": "code", "linesLength": 2, "startIndex": 616, "lines": ["figure, tag_plot, articles_with_tags = make_iplot_by_tag(articles, 'word_count', 'claps', title='Claps vs Word Count')\n", "iplot(figure)"]}, {"block": 87, "type": "code", "linesLength": 2, "startIndex": 618, "lines": ["figure, tag_plot, articles_with_tags = make_iplot_by_tag(articles, 'read_time', 'claps', title='Claps vs Reading Time')\n", "iplot(figure)"]}, {"block": 88, "type": "markdown", "linesLength": 1, "startIndex": 620, "lines": ["You can highlight one tag by selecting it from the legend. "]}, {"block": 89, "type": "code", "linesLength": 1, "startIndex": 621, "lines": ["iplot(tag_plot)"]}, {"block": 90, "type": "markdown", "linesLength": 1, "startIndex": 622, "lines": ["## Exploring Correlations"]}, {"block": 91, "type": "code", "linesLength": 2, "startIndex": 623, "lines": ["article_corrs = articles_with_tags.corr()\n", "article_corrs"]}, {"block": 92, "type": "code", "linesLength": 11, "startIndex": 625, "lines": ["import plotly.figure_factory as ff\n", "\n", "figure = ff.create_annotated_heatmap(article_corrs.values, showscale=True, zmax=0.8, zmin=-0.4,\n", "                                     x = list(article_corrs.columns), y = list(article_corrs.index),\n", "                                     colorscale='Viridis', \n", "                                     annotation_text=article_corrs.round(2).values)\n", "\n", "figure.layout.width = 1000\n", "figure.layout.height = 600\n", "figure.layout.margin = dict(l=200)\n", "iplot(figure)"]}, {"block": 93, "type": "code", "linesLength": 0, "startIndex": 636, "lines": []}, {"block": 94, "type": "markdown", "linesLength": 3, "startIndex": 636, "lines": ["## Function to get links from a soup\n", "\n", "When we found the links, we manually extracted them, but we can also use a function to find the links from any html page. This makes it easier to rapidly examine the entries on a page."]}, {"block": 95, "type": "code", "linesLength": 19, "startIndex": 639, "lines": ["def get_links(soup):\n", "    \"\"\"\n", "    Retrieve all links to entries on webpage\n", "    \n", "    :param soup: BeautifulSoup of HTML for page\n", "    :return entry_links: list of links to entries\n", "    \n", "    \"\"\"    \n", "    titles = soup.find_all(attrs = {'class': 'bq y br af bs ag db dc dd c de df dg'})\n", "    pattern = re.compile('[0-9]{1,} min read')\n", "    read_times = soup.find_all(text = pattern)\n", "    read_times = [int(x.split(' ')[0]) for x in read_times]\n", "    total_read_time = sum(read_times)\n", "    \n", "    print(f'Found {len(titles)} entries.')\n", "    print(f'Total Read Time of Entries: {total_read_time} minutes.')\n", "    entry_links = [title.a.get_attribute_list('href')[0] for title in titles]\n", "    \n", "    return entry_links"]}, {"block": 96, "type": "markdown", "linesLength": 1, "startIndex": 658, "lines": ["## Unlisted Articles"]}, {"block": 97, "type": "code", "linesLength": 2, "startIndex": 659, "lines": ["unlisted_soup = BeautifulSoup(open('data/unlisted.html', 'r').read())\n", "unlisted_soup.text[:100]"]}, {"block": 98, "type": "code", "linesLength": 1, "startIndex": 661, "lines": ["unlisted_links = get_links(unlisted_soup)"]}, {"block": 99, "type": "code", "linesLength": 2, "startIndex": 662, "lines": ["unlisted_data = process_in_parallel(unlisted_links)\n", "unlisted_data.head()"]}, {"block": 100, "type": "code", "linesLength": 2, "startIndex": 664, "lines": ["figure = make_iplot(unlisted_data, 'word_count', 'claps', 'Claps vs Word Count for Unlisted Articles')\n", "figure"]}]
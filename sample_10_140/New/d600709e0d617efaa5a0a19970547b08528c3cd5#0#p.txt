[{"block": 0, "type": "markdown", "linesLength": 4, "startIndex": 0, "lines": ["ThinkDSP, by Allen Downey\n", "(think-dsp.com)\n", "\n", "This notebook contains code examples from Chapter 8: Filtering and convolution"]}, {"block": 1, "type": "code", "linesLength": 14, "startIndex": 4, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "import math\n", "import numpy\n", "import pandas\n", "import scipy.signal\n", "\n", "%precision 3\n", "%matplotlib inline\n", "\n", "PI2 = 2 * math.pi"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Read the daily price of bitcoins."]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 19, "lines": ["nrows = 1625\n", "df = pandas.read_csv('coindesk-bpi-USD-close.csv', nrows=nrows, parse_dates=[0])"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["Extract the closing prices from the dataframe and compute daily change and daily percent change."]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 22, "lines": ["ys = df.Close.values\n", "diff = numpy.diff(ys)\n", "changes = 100 * diff / ys[:len(diff)]"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Make a window to compute a 30-day moving average and convolve the window with the data."]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 26, "lines": ["window = numpy.ones(30)\n", "window /= sum(window)\n", "smoothed = numpy.convolve(changes, window, mode='same')"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Plot the original and smoothed signals."]}, {"block": 9, "type": "code", "linesLength": 8, "startIndex": 30, "lines": ["thinkplot.preplot(1)\n", "thinkplot.plot(changes, color='0.7', label='daily')\n", "thinkplot.plot(smoothed, label='30 day average')\n", "thinkplot.config(xlabel='time (days)', \n", "                 ylabel='% change',\n", "                 xlim=[0, nrows],\n", "                 ylim=[-60, 60],\n", "                 loc='lower right')"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Generate a 440 Hz square signal."]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 39, "lines": ["signal = thinkdsp.SquareSignal(freq=440)\n", "wave = signal.make_wave(duration=1, framerate=44100)\n", "wave.make_audio()"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Make a moving average window."]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 43, "lines": ["window = numpy.ones(11)\n", "window /= sum(window)\n", "thinkplot.plot(window)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["Plot the square wave."]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 47, "lines": ["segment = wave.segment(duration=0.01)\n", "segment.plot()\n", "thinkplot.config(ylim=[-1.05, 1.05], legend=False)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Pad the window so it's the same length as the signal, and plot it."]}, {"block": 17, "type": "code", "linesLength": 8, "startIndex": 51, "lines": ["def zero_pad(array, n):\n", "    res = numpy.zeros(n)\n", "    res[:len(array)] = array\n", "    return res\n", "\n", "N = len(segment)\n", "padded = zero_pad(window, N)\n", "thinkplot.plot(padded)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Apply the window to the signal (with lag=0)."]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["prod = padded * segment.ys\n", "print(sum(prod))"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Compute a convolution by rolling the window to the right."]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 63, "lines": ["smoothed = numpy.zeros(N)\n", "rolled = padded\n", "for i in range(len(segment.ys)):\n", "    smoothed[i] = sum(rolled * segment.ys)\n", "    rolled = numpy.roll(rolled, 1)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["Plot the result of the convolution and the original."]}, {"block": 23, "type": "code", "linesLength": 4, "startIndex": 69, "lines": ["segment.plot(color='0.7')\n", "smooth = thinkdsp.Wave(smoothed, framerate=wave.framerate)\n", "smooth.plot()\n", "thinkplot.config(ylim=[-1.05, 1.05], legend=False)"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Compute the same convolution using `numpy.convolve`."]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 74, "lines": ["segment.plot(color='0.7')\n", "ys = numpy.convolve(segment.ys, window, mode='valid')\n", "smooth2 = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "smooth2.plot()\n", "thinkplot.config(ylim=[-1.05, 1.05], legend=False)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Let's see what's happening in the frequency domain.  Compute the spectrum of the original square wave:"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 80, "lines": ["spectrum = wave.make_spectrum()"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Compute the spectrum of the smoothed wave:"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 82, "lines": ["ys = numpy.convolve(wave.ys, window, mode='same')\n", "smooth = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "spectrum2 = smooth.make_spectrum()"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["Plot spectrums of the original and smoothed waves:"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["spectrum2.plot()\n", "spectrum.plot(color='0.7')"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["For each harmonic, compute the ratio of the amplitudes before and after smoothing."]}, {"block": 33, "type": "code", "linesLength": 10, "startIndex": 89, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<560] = 0\n", "thinkplot.plot(ratio)\n", "\n", "thinkplot.config(xlabel='frequency (Hz)',\n", "                     ylabel='amplitude ratio',\n", "                     xlim=[0, 22050], \n", "                     legend=False)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["Plot the ratios again, but also plot the FFT of the window."]}, {"block": 35, "type": "code", "linesLength": 10, "startIndex": 100, "lines": ["padded = zero_pad(window, len(wave))\n", "dft_window = numpy.fft.rfft(padded)\n", "\n", "thinkplot.plot(abs(dft_window), color='0.7', label='boxcar filter')\n", "thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "thinkplot.config(xlabel='frequency (Hz)',\n", "                     ylabel='amplitude ratio',\n", "                     xlim=[0, 22050], \n", "                     legend=False)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["Let's start again and use a Gaussian window instead of a boxcar."]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 111, "lines": ["signal = thinkdsp.SquareSignal(freq=440)\n", "wave = signal.make_wave(duration=1, framerate=44100)\n", "spectrum = wave.make_spectrum()"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Make the boxcar window."]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 115, "lines": ["boxcar = numpy.ones(11)\n", "boxcar /= sum(boxcar)"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 117, "lines": ["Make the Gaussian window."]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 118, "lines": ["gaussian = scipy.signal.gaussian(M=11, std=2)\n", "gaussian /= sum(gaussian)"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Plot the two windows."]}, {"block": 43, "type": "code", "linesLength": 6, "startIndex": 121, "lines": ["thinkplot.preplot(2)\n", "thinkplot.plot(boxcar, label='boxcar')\n", "thinkplot.plot(gaussian, label='Gaussian')\n", "thinkplot.config(xlabel='index',\n", "                 ylabel='amplitude',\n", "                 loc='upper right')"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["Convolve the square wave with the Gaussian window."]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 128, "lines": ["ys = numpy.convolve(wave.ys, gaussian, mode='same')\n", "smooth = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "spectrum2 = smooth.make_spectrum()"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 131, "lines": ["Compute the ratio of the amplitudes."]}, {"block": 47, "type": "code", "linesLength": 4, "startIndex": 132, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<560] = 0"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 136, "lines": ["Compute the FFT of the window."]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 137, "lines": ["padded = zero_pad(gaussian, len(wave))\n", "dft_gaussian = numpy.fft.rfft(padded)"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["Plot the ratios and the FFT of the window."]}, {"block": 51, "type": "code", "linesLength": 7, "startIndex": 140, "lines": ["thinkplot.plot(abs(dft_gaussian), color='0.7', label='Gaussian filter')\n", "thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "thinkplot.config(xlabel='frequency (Hz)',\n", "                 ylabel='amplitude ratio',\n", "                 xlim=[0, 22050], \n", "                 legend=False)"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["Combine the preceding example into one big function so we can interact with it."]}, {"block": 53, "type": "code", "linesLength": 30, "startIndex": 148, "lines": ["def plot_filter(M=11, std=2):\n", "    signal = thinkdsp.SquareSignal(freq=440)\n", "    wave = signal.make_wave(duration=1, framerate=44100)\n", "    spectrum = wave.make_spectrum()\n", "\n", "    gaussian = scipy.signal.gaussian(M=M, std=std)\n", "    gaussian /= sum(gaussian)\n", "\n", "    ys = numpy.convolve(wave.ys, gaussian, mode='same')\n", "    smooth = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "    spectrum2 = smooth.make_spectrum()\n", "\n", "    # plot the ratio of the original and smoothed spectrum\n", "    amps = spectrum.amps\n", "    amps2 = spectrum2.amps\n", "    ratio = amps2 / amps    \n", "    ratio[amps<560] = 0\n", "\n", "    # plot the same ratio along with the FFT of the window\n", "    padded = zero_pad(gaussian, len(wave))\n", "    dft_gaussian = numpy.fft.rfft(padded)\n", "\n", "    thinkplot.plot(abs(dft_gaussian), color='0.7', label='Gaussian filter')\n", "    thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "    thinkplot.config(xlabel='frequency (Hz)',\n", "                     ylabel='amplitude ratio',\n", "                     xlim=[0, 22050],\n", "                     ylim=[0, 1.05],\n", "                     legend=False)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 178, "lines": ["Try out difference values of `M` and `std`."]}, {"block": 55, "type": "code", "linesLength": 7, "startIndex": 179, "lines": ["from IPython.html.widgets import interact, fixed\n", "from IPython.html import widgets\n", "\n", "slider = widgets.IntSliderWidget(min=2, max=100, value=11)\n", "slider2 = widgets.FloatSliderWidget(min=0, max=20, value=2)\n", "interact(plot_filter, M=slider, std=slider2)\n", "None"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 186, "lines": ["Let's use the Convolution theorem to compute convolutions using FFT.  Read the bitcoin data again, and smooth it using `numpy.convolve` and a 30-day Gaussian window."]}, {"block": 57, "type": "code", "linesLength": 5, "startIndex": 187, "lines": ["ys = df.Close.values\n", "window = scipy.signal.gaussian(M=30, std=6)\n", "window /= window.sum()\n", "smoothed = numpy.convolve(ys, window, mode='valid')\n", "len(smoothed)"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 192, "lines": ["Plot the original and smoothed data."]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 193, "lines": ["thinkplot.plot(ys, color='0.7')\n", "thinkplot.plot(smoothed)"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 195, "lines": ["Pad the window and compute its FFT."]}, {"block": 61, "type": "code", "linesLength": 3, "startIndex": 196, "lines": ["padded = zero_pad(window, len(ys))\n", "fft_window = numpy.fft.fft(padded)\n", "thinkplot.plot(numpy.absolute(fft_window))"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 199, "lines": ["Apply the convolution theorem."]}, {"block": 63, "type": "code", "linesLength": 4, "startIndex": 200, "lines": ["fft_signal = numpy.fft.fft(ys)\n", "smoothed2 = numpy.fft.ifft(fft_signal * fft_window)\n", "M = len(window)\n", "smoothed2 = smoothed2[M-1:]"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["Plot the two signals (smoothed with numpy and FFT)."]}, {"block": 65, "type": "code", "linesLength": 2, "startIndex": 205, "lines": ["thinkplot.plot(smoothed)\n", "thinkplot.plot(smoothed2.real)"]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 207, "lines": ["Confirm that the difference is small."]}, {"block": 67, "type": "code", "linesLength": 2, "startIndex": 208, "lines": ["diff = smoothed - smoothed2\n", "sum(abs(diff))"]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 210, "lines": ["`scipy.signal` provides `fftconvolve`, which computes convolutions using FFT."]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 211, "lines": ["smoothed3 = scipy.signal.fftconvolve(ys, window, mode='valid')"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 212, "lines": ["Confirm that it gives the same answer, at least approximately."]}, {"block": 71, "type": "code", "linesLength": 2, "startIndex": 213, "lines": ["diff = smoothed - smoothed3\n", "sum(abs(diff))"]}, {"block": 72, "type": "markdown", "linesLength": 1, "startIndex": 215, "lines": ["We can encapsulate the process in a function:"]}, {"block": 73, "type": "code", "linesLength": 4, "startIndex": 216, "lines": ["def fft_convolve(signal, window):\n", "    fft_signal = numpy.fft.fft(signal)\n", "    fft_window = numpy.fft.fft(window)\n", "    return numpy.fft.ifft(fft_signal * fft_window)"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 220, "lines": ["And confirm that it gives the same answer."]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 221, "lines": ["smoothed4 = fft_convolve(ys, padded)[M-1:]\n", "len(smoothed4)"]}, {"block": 76, "type": "code", "linesLength": 2, "startIndex": 223, "lines": ["diff = smoothed - smoothed4\n", "sum(abs(diff))"]}, {"block": 77, "type": "markdown", "linesLength": 1, "startIndex": 225, "lines": ["We can also use the convolution theorem to compute autocorrelation functions.  Load the bitcoin data one more time:"]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 226, "lines": ["ys = df.Close.values"]}, {"block": 79, "type": "markdown", "linesLength": 1, "startIndex": 227, "lines": ["Compute autocorrelation using `numpy.correlate`:"]}, {"block": 80, "type": "code", "linesLength": 4, "startIndex": 228, "lines": ["N = len(ys)\n", "corrs = numpy.correlate(ys, ys, mode='same')\n", "corrs = corrs[N//2:]\n", "corrs[:7]"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 232, "lines": ["Compute autocorrelation using my `fft_convolve`.  The window is a reversed copy of the signal.  We have to pad the window and signal with zeros and then select the middle half from the result."]}, {"block": 82, "type": "code", "linesLength": 9, "startIndex": 233, "lines": ["def fft_autocorr(signal):\n", "    N = len(signal)\n", "    window = signal[::-1]\n", "    signal = zero_pad(signal, 2*N)\n", "    window = zero_pad(window, 2*N)\n", "\n", "    corrs = fft_convolve(signal, window)\n", "    corrs = corrs[N//2: 3*N//2]\n", "    return corrs"]}, {"block": 83, "type": "markdown", "linesLength": 1, "startIndex": 242, "lines": ["Test the function."]}, {"block": 84, "type": "code", "linesLength": 3, "startIndex": 243, "lines": ["corrs2 = fft_autocorr(ys)\n", "corrs2 = corrs2[N//2:]\n", "corrs2[:7]"]}, {"block": 85, "type": "markdown", "linesLength": 1, "startIndex": 246, "lines": ["Plot the results."]}, {"block": 86, "type": "code", "linesLength": 5, "startIndex": 247, "lines": ["thinkplot.preplot(1)\n", "thinkplot.plot(corrs, color='0.7', linewidth=7, label='numpy.convolve')\n", "thinkplot.plot(corrs2.real, linewidth=2, label='fft_convolve')\n", "thinkplot.config(xlabel='lags', ylabel='correlation')\n", "len(corrs), len(corrs2)"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 252, "lines": ["Confirm that the difference is small."]}, {"block": 88, "type": "code", "linesLength": 2, "startIndex": 253, "lines": ["diff = corrs - corrs2\n", "sum(abs(diff))"]}, {"block": 89, "type": "markdown", "linesLength": 0, "startIndex": 255, "lines": []}, {"block": 90, "type": "code", "linesLength": 0, "startIndex": 255, "lines": []}, {"block": 91, "type": "code", "linesLength": 0, "startIndex": 255, "lines": []}]
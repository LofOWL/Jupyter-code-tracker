[{"block": 0, "type": "markdown", "linesLength": 9, "startIndex": 0, "lines": ["## PmagPy Online: Jupyter Notebooks, the PmagPy Software Package and the Magnetics Information Consortium (MagIC) Database\n", "\n", "Lisa Tauxe$^1$, Rupert Minnett$^2$, Nick Jarboe$^1$, Catherine Constable$^1$, Anthony Koppers$^2$, Lori Jonestrask$^1$, Nick Swanson-Hysell$^3$\n", "\n", "$^1$Scripps Institution of Oceanography, United States of America;  $^2$   Oregon State University; $^3$ University of California, Berkely; ltauxe@ucsd.edu\n", "\n", "The Magnetics Information Consortium (MagIC), hosted at http://earthref.org/MagIC is a database that serves as a Findable, Accessible, Interoperable, Reusable (FAIR) archive for paleomagnetic and rock magnetic data. It has a flexible, comprehensive data model that can accomodate most kinds of paleomagnetic data. The **PmagPy** software package is a cross-platform and open-source set of tools written in Python for the analysis of paleomagnetic data that serves as one interface to MagIC, accommodating various levels of user expertise. It is available through github.com/PmagPy. Because PmagPy requires installation of python and the software package, there is a speed bump for many practitioners on beginning to use the software. In order to make the software and MagIC more accessible to the broad spectrum of scientists interested in paleo and rock magnetism, we have prepared a set of Jupyter notebooks, hosted on [jupyterhub.earthref.org](https://jupyterhub.earthref.org) which serve a set of purposes. 1) There is a complete course in Python for Earth Scientists, 2) a set of notebooks that introduce PmagPy (drawing the software package from the github repository) and illustrate how it can be used to create data products and figures for typical papers, and 3) show how to prepare data from the laboratory to upload into the MagIC database. The latter will satisfy expectations from NSF for data archiving and for example the AGU publication data archiving requirements.\n", "\n", "\n"]}, {"block": 1, "type": "markdown", "linesLength": 11, "startIndex": 9, "lines": ["### Getting started\n", "\n", "- Go to the jupyter-hub website at https://jupyterhub.earthref.org/ to run this online.  You will have to log in to the earthref website with your ORCID, but then you will have a workspace to use this and the other PmagPy jupyter notebooks.\n", "\n", "- Alternatively, you can  install Python and the  PmagPy software package on your computer (see [https://earthref.org/PmagPy/cookbook](https://earthref.org/PmagPy/cookbook) for instructions).   Follow  the instructions for  \"Full PmagPy install and update\" through section 1.4 (Quickstart with PmagPy notebooks).  This notebook is in  the collection of PmagPy notebooks. \n", "\n", "- Click on the cell below and then click on 'Run' from the menu above to import the desired functionality\n", "\n", "- To avoid overwriting this notebook if you make changes, select File => Make a Copy.  You can rename it as you like. Be sure to click on the save file icon (little diskette) or under File => Save and checkpoint.  \n", "\n", "- To understand what a particular Python or **PmagPy** function expects as input and delivers, use the Python _help_ function, e.g., help(print)."]}, {"block": 2, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["help(print)"]}, {"block": 3, "type": "code", "linesLength": 26, "startIndex": 21, "lines": ["# Import PmagPy modules\n", "import pmagpy.pmag as pmag\n", "import pmagpy.pmagplotlib as pmagplotlib\n", "import pmagpy.ipmag as ipmag\n", "\n", "# Import plotting modules\n", "has_cartopy, Cartopy = pmag.import_cartopy() # import mapping module, if it is available\n", "import matplotlib.pyplot as plt # our plotting buddy\n", "# This allows you to make matplotlib plots inside the notebook.  \n", "%matplotlib inline \n", "\n", "# Import more useful modules\n", "import numpy as np # the fabulous NumPy package\n", "import pandas as pd # and  Pandas for data wrangling\n", "import os # some useful operating system functions\n", "from importlib import reload # for reloading module if they get changed after initial import\n", "from IPython.display import Image\n", "import imageio # for making animations\n", "\n", "# make a directory for use with this notebook\n", "dirs=os.listdir() # get a list of directories in this one\n", "if 'PmagPy_online' not in dirs:\n", "    os.mkdir(\"PmagPy_online\")\n", "    print ('PmagPy_online directory created')\n", "else:\n", "    print ('PmagPy_online directory already exists')"]}, {"block": 4, "type": "markdown", "linesLength": 15, "startIndex": 47, "lines": ["### Overview of   MagIC\n", "\n", " \n", "The Magnetics Information Consortium (MagIC), hosted at http://earthref.org/MagIC is a database that serves as a Findable, Accessible, Interoperable, Reusable (FAIR) archive for paleomagnetic and rock magnetic data. Its datamodel is fully described here: [https://www2.earthref.org/MagIC/data-models/3.0](https://www2.earthref.org/MagIC/data-models/3.0). Each contribution is associated with a publication via the DOI.  There are nine data tables:\n", "\n", "- contribution: metadata of the associated publication.\n", "- locations: metadata for locations, which are groups of sites (e.g., stratigraphic section, region, etc.)\n", "- sites: metadata and derived data at the site level (units with a common expectation)\n", "- samples: metadata and derived data at the sample level.\n", "- specimens: metadata and derived data at the specimen level.\n", "- criteria: criteria by which data are deemed acceptable\n", "- ages: ages and metadata for sites/samples/specimens\n", "- images: associated images and plots.  \n", "\n", "Here we will show examples of how to download and import MagIC data and make some useful plots."]}, {"block": 5, "type": "markdown", "linesLength": 21, "startIndex": 62, "lines": ["### Overview of   PmagPy\n", "\n", "The functionality of **PmagPy** is demonstrated within three other notebooks in the **PmagPy** repository:\n", "\n", "- [PmagPy_calculations.ipynb](PmagPy_calculations.ipynb):  demonstrates many of the PmagPy calculation functions such as those that rotate directions, return statistical parameters, and simulate data from specified distributions. \n", "- [PmagPy_plots_analysis.ipynb](PmagPy_plots_analysis.ipynb): demonstrates PmagPy functions that can be used to visual data as well as those that conduct statistical tests that have associated visualizations.\n", "- [PmagPy_MagIC.ipynb](PmagPy_MagIC.ipynb): demonstrates how PmagPy can be used to read and write data to and from the MagIC database format including conversion from many individual lab measurement file formats.\n", "\n", "Please see also our YouTube channel with more presentations from the 2020 MagIC workshop here: \n", "[https://www.youtube.com/playlist?list=PLirL2unikKCgUkHQ3m8nT29tMCJNBj4kj](https://www.youtube.com/playlist?list=PLirL2unikKCgUkHQ3m8nT29tMCJNBj4kj)\n", "\n", "The current notebook will highlight the link between **PmagPy** and the Findable Accessible Interoperable Reusabe (FAIR) database maintained by the Magnetics Information Consortium (MagIC) at [https://earthref.org/MagIC](https://eathref.org/MagIC).  There is also an example of how **PmagPy** can enhance paleomagnetic investigations. \n", "\n", "- [Importing data from MagIC](#Importing-data-directly-from-MagIC)\n", "\n", "- [Importing MagIC formatted data from desktop](#Importing-MagIC-format-data-from-desktop)\n", "\n", "- [PmagPy for getting geomagnetic vectors from IGRF-like tables]#(PmagPy-for-getting-geomagnetic-vectors-from-IGRF\\-like-tables)\n", "\n", "\n", "\n"]}, {"block": 6, "type": "markdown", "linesLength": 13, "startIndex": 83, "lines": ["### Importing data directly from MagIC\n", "\n", "- Hunt around the earthref.org/MagIC/search page for a data set you would like to look at. We will use the data of Behar et al., 2019,  DOI: 10.1029/2019GC008479 for this example.  \n", "- Once you have the DOI or the MagIC ID number (which in this case is 16676, there are two ways to import the contribution file: 1) with the MagIC ID (id=16676) using **ipmag.download_magic_from_id()** and one with the DOI using **ipmag.download_magic_from_doi()**. \n", "- create the data directory to store the data in.\n", "- import the magic contribution file, move it to your directory (in this example, MagIC\\_import), and unpack it with ipmag.download_magic().  \n", "- Use PmagPy functions to make the following plots:\n", "    - use _ipmag.eqarea_magic()_ to make an equal area plot\n", "    - use _ipmag.vgpmap_magic()_ to make a map of VGPs\n", "    - use _ipmag.reversal_test_bootstrap()_ for a bootstrap reversals test\n", "    - use _pmagplotlib.plot_map()_ to make a site map\n", "    \n", "- Execute (run) each of the cells below in turn.  "]}, {"block": 7, "type": "code", "linesLength": 7, "startIndex": 96, "lines": ["# set up the directory structure for this example, if not already present:\n", "dirs=os.listdir('PmagPy_online') # get a list of directories in this one\n", "if 'MagIC_import' not in dirs:\n", "    os.mkdir(\"MagIC_online/MagIC_import\")\n", "    print ('MagIC_import directory created')\n", "else:\n", "    print ('MagIC_import directory already exists')"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 103, "lines": ["Let's try the contribution ID way first:  \n", "\n", "First we need to learn how **ipmag.download_magic_from_id()** works. One way is with the python **help()** function: "]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 106, "lines": ["help(ipmag.download_magic_from_id)"]}, {"block": 10, "type": "code", "linesLength": 6, "startIndex": 107, "lines": ["dir_path='PmagPy_online/MagIC_import' # set the path to the correct working directory\n", "magic_id='16676' # set the magic ID number\n", "magic_contribution='magic_contribution_'+magic_id+'.txt' # set the file name string\n", "ipmag.download_magic_from_id(magic_id) # download the contribution from MagIC\n", "os.rename(magic_contribution, dir_path+'/'+magic_contribution) # move the contribution to the directory\n", "ipmag.download_magic(magic_contribution,dir_path=dir_path,print_progress=False) # unpack the file"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["Now let's try to do this with the API for DOIs:"]}, {"block": 12, "type": "code", "linesLength": 6, "startIndex": 114, "lines": ["dir_path='PmagPy_online/MagIC_import' # set the path to the correct working directory\n", "reference_doi='10.1029/2019GC008479'\n", "magic_contribution='magic_contribution.txt'\n", "ipmag.download_magic_from_doi(reference_doi)\n", "os.rename(magic_contribution, dir_path+'/'+magic_contribution)\n", "ipmag.download_magic(magic_contribution,dir_path=dir_path,print_progress=False)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Now we can get to the fun stuff of making plots.  "]}, {"block": 14, "type": "markdown", "linesLength": 2, "startIndex": 121, "lines": ["### Equal area net example\n", "- use ipmag.eqarea_magic()"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 123, "lines": ["# first get help on how to use it:\n", "help(ipmag.eqarea_magic)"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 125, "lines": ["# now we do it for real:\n", "ipmag.eqarea_magic(dir_path=dir_path,save_plots=False)"]}, {"block": 17, "type": "markdown", "linesLength": 2, "startIndex": 127, "lines": ["### Map of VGPs\n", "- use ipmag.vgpmap_magic() to plot the VGPs from the same data"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 129, "lines": ["# get help message for vgpmap_magic\n", "help(ipmag.vgpmap_magic)"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 131, "lines": ["ipmag.vgpmap_magic(dir_path=dir_path,size=50,flip=True,save_plots=False,lat_0=60,rsym='b^',rsize=50)"]}, {"block": 20, "type": "markdown", "linesLength": 2, "startIndex": 132, "lines": ["### Bootstrap reversals test\n", "- use ipmag.reversal_test_bootstrap() to do the reversals test"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 134, "lines": ["help(ipmag.reversal_test_bootstrap)"]}, {"block": 22, "type": "code", "linesLength": 7, "startIndex": 135, "lines": ["# read in the data into a Pandas DataFrame\n", "sites_df=pd.read_csv(dir_path+'/sites.txt',sep='\\t',header=1)\n", "# pick out the declinations and inclinations\n", "decs=sites_df.dir_dec.values\n", "incs=sites_df.dir_inc.values\n", "# call the function\n", "ipmag.reversal_test_bootstrap(dec=decs,inc=incs,plot_stereo=False)"]}, {"block": 23, "type": "markdown", "linesLength": 2, "startIndex": 142, "lines": ["### Make a site map\n", "- use pmagplotlib.plot_map() to make a site map"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 144, "lines": ["help(pmagplotlib.plot_map)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 145, "lines": ["NB: the most recent PmagPy version fixes the scale issue - but it is SLOW at high resolution... so set Opts\\['res'\\] to 'c' for crude for a quick look.  if you want to be dazzled - set it to 'h' but be prepared to wait for a while...  'i' for intermediate is probably good enough for most purposes (50m resolution)"]}, {"block": 26, "type": "code", "linesLength": 27, "startIndex": 146, "lines": ["# read in the data file:\n", "site_df=pd.read_csv(dir_path+'/sites.txt',sep='\\t',header=1)\n", "# pick out the longitudes and latitudes\n", "lons=site_df['lon'].values\n", "lats=site_df['lat'].values\n", "# set some options\n", "Opts={}\n", "Opts['sym']='r*' # sets the symbol to white dots\n", "Opts['symsize']=100 # sets symbol size to 3 pts\n", "Opts['proj']='lcc' # Lambert Conformal projection\n", "Opts['pltgrid']=True\n", "Opts['lat_0']=33\n", "Opts['lon_0']=35\n", "Opts['latmin']=29\n", "Opts['latmax']=35\n", "Opts['lonmin']=32\n", "Opts['lonmax']=37\n", "Opts['gridspace']=1\n", "Opts['details']={}\n", "Opts['details']['coasts']=True\n", "Opts['details']['ocean']=True\n", "Opts['details']['countries']=True\n", "Opts['global']=False\n", "Opts['res']='i'\n", "plt.figure(1,(10,10)) # optional - make a map\n", "\n", "pmagplotlib.plot_map(1, lats, lons, Opts)\n"]}, {"block": 27, "type": "markdown", "linesLength": 18, "startIndex": 173, "lines": ["## Importing MagIC format data from desktop\n", "\n", "- make a directory called MagIC\\_upload as in the first example. \n", "- download the data from Tauxe et al. (2015; DOI: 10.1016/J.EPSL.2014.12.034; MagIC id:16749) to your desktop by clicking on the 'Download' button next to the contribution. \n", "\n", "- upload the file (magic\\_contribution\\_16749.txt) to the jupyterhub site by:\n", "    - click on Open in the File menu.\n", "    - click on Upload and choose the datafile\n", "    - move the datafile to the MagIC\\_upload directory as in the first example. \n", "\n", "- Unpack it with ipmag.download_magic()\n", "- make a figure with these elements for the interval 40 m to 160 m:\n", "    - magstrat time scale plot from 2 to 7 Ma\n", "    - inclinations (dir\\_inc) from the 20mT step in the measurements table  against composite_depth as blue dots\n", "    - inclinations (dir\\_inc) from the specimens table against composite depth as red triangles. \n", "    - put on dotted lines for the GAD inclination\n", "- use ipmag.ani_depthplot to plot the anisotropy data against depth in the Hole.  \n", "- extract and plot the external\\_results data from the sites.txt file. "]}, {"block": 28, "type": "code", "linesLength": 13, "startIndex": 191, "lines": ["# set up the directory structure for this example, if not already present:\n", "dirs=os.listdir('PmagPy_online') # get a list of directories in this one\n", "if 'MagIC_upload' not in dirs:\n", "    os.mkdir(\"PmagPy_online/MagIC_upload\")\n", "    print ('MagIC_upload directory created')\n", "else:\n", "    print ('MagIC_upload directory already exists')\n", "magic_contribution='magic_contribution_16761.txt' # set the file name string  \n", "# move uploaded file to working directory\n", "files=os.listdir()\n", "print (files)\n", "if magic_contribution in files:\n", "    os.rename(magic_contribution, dir_path+'/'+magic_contribution) # move the contribution to the directory"]}, {"block": 29, "type": "markdown", "linesLength": 2, "startIndex": 204, "lines": ["### Download and unpack the data\n", "\n"]}, {"block": 30, "type": "code", "linesLength": 4, "startIndex": 206, "lines": ["dir_path='PmagPy_online/MagIC_upload' # set the path to your working directory\n", "depth_min, depth_max= 40, 160 # set the core depth bounds as required\n", "# First get the file from MagIC into your working directory:\n", "ipmag.download_magic(magic_contribution,dir_path=dir_path,print_progress=False) # unpack the file"]}, {"block": 31, "type": "markdown", "linesLength": 7, "startIndex": 210, "lines": ["## Magstrat figure\n", "- read in the data file as a Pandas DataFrame with pd.read_csv().  \n", "    - All MagIC .txt files are tab delimited.  This is indicated with a sep='\\t' keywork.  \n", "    - The column headers in the second row, hence (because Python counts from zero), header=1\n", "- the depth of a particular specimen/site in MagIC is stored in the sites.txt table.  You will have to merge the data from that table into the specimens/measurements tables.  To do that you need to do a few things:\n", "    - you need a common key.  Because the specimen/sample/site names are the same for an IODP record, make a column in the specimen/measurements dataframes labled 'site' that is the same as the specimen.  \n", "    - merge the two dataframes (sites and specimens/measurements) with pd.merge()"]}, {"block": 32, "type": "code", "linesLength": 28, "startIndex": 217, "lines": ["depth_min, depth_max= 40, 160 # set the core depth bounds as required\n", "# read in the required data tables:\n", "meas_df=pd.read_csv(dir_path+'/measurements.txt',sep='\\t',header=1)\n", "site_df=pd.read_csv(dir_path+'/sites.txt',sep='\\t',header=1)\n", "spec_df=pd.read_csv(dir_path+'/specimens.txt',sep='\\t',header=1)\n", "ages_df=pd.read_csv(dir_path+'/ages.txt',sep='\\t',header=1)\n", "# filter the ages table for method codes that indicate paleomagnetic reversals:\n", "ages_df=ages_df[ages_df['method_codes'].str.contains('PMAG')]\n", "# filter the measurements for the 20 mT (.02 T) step\n", "meas_df.dropna(subset=['treat_ac_field'],inplace=True)\n", "meas_20mT=meas_df[meas_df['treat_ac_field']==0.02] \n", "# make the site key in the measurements and specimens dataframes\n", "meas_20mT['site']=meas_20mT['specimen']\n", "spec_df['site']=spec_df['specimen']\n", "# we only want the core depth out of the sites dataframe, so we can pare it down like this:\n", "depth_df=site_df[['site','core_depth']]\n", "# merge the specimen, depth dataframes\n", "spec_df=pd.merge(spec_df,depth_df,on='site')\n", "# merge the measurements, depth dataframes\n", "meas_20mT=pd.merge(meas_20mT,depth_df,on='site')\n", "# filter for the desired depth range: \n", "spec_df=spec_df[(spec_df['core_depth']>depth_min)&(spec_df['core_depth']<depth_max)]\n", "meas_20mT=meas_20mT[(meas_20mT['core_depth']>depth_min)&(meas_20mT['core_depth']<depth_max)]\n", "# note that the age table has only height (not depth), so these numbers are the opposite\n", "ages_df=ages_df[(ages_df['tiepoint_height']<-depth_min)&(ages_df['tiepoint_height']>-depth_max)]\n", "# get the site latitude (there is only one)\n", "lat=site_df['lat'].unique()[0]\n", "\n"]}, {"block": 33, "type": "code", "linesLength": 16, "startIndex": 245, "lines": ["fig=plt.figure(1,(9,12)) # make the figure\n", "ax1=fig.add_subplot(131) # make the first of three subplots\n", "pmagplotlib.plot_ts(ax1,2,7,timescale='gts12') # plot on the time scale\n", "ax2=fig.add_subplot(132) # make the second of three subplots\n", "plt.plot(meas_20mT.dir_inc,meas_20mT.core_depth,'bo',markeredgecolor='black',alpha=.5)\n", "plt.plot(spec_df.dir_inc,spec_df.core_depth,'r^',markeredgecolor='black')\n", "\n", "plt.ylim(depth_max,depth_min)\n", "# calculate the geocentric axial dipole field for the site latitude\n", "gad=pmag.pinc(lat) # tan (I) = 2 tan (lat)\n", "# put it on the plot as a green dashed line\n", "plt.axvline(gad,color='green',linestyle='dashed',linewidth=2)\n", "plt.axvline(-gad,color='green',linestyle='dashed',linewidth=2)\n", "plt.title('Inclinations')\n", "pmagplotlib.label_tiepoints(ax2,100,ages_df.tiepoint.values,-1*ages_df.tiepoint_height.values,lines=True)\n", "#"]}, {"block": 34, "type": "markdown", "linesLength": 2, "startIndex": 261, "lines": ["### \"Christmas tree\" of anisotropy\n", "- use ipmag.ani\\_depthplot()"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 263, "lines": ["help(ipmag.ani_depthplot)"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 264, "lines": ["ipmag.ani_depthplot(dir_path=dir_path,dmin=40,dmax=160);"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 265, "lines": ["### Plotting External Results\n", "- ipmag.ani_depthplot() reads in a specimen file with the column aniso_s filled in and calculates the eigenvalues for you. in this exercise, you learn to calculate anisotropy eigenvalues from the aniso_s column in the specimens table yourself,\n", "-  plot anisotropy eigenvalues and the natural gamma radiation values from U1361A between 40 and 160 meters below sea floor"]}, {"block": 38, "type": "code", "linesLength": 47, "startIndex": 268, "lines": ["depth_min, depth_max= 40, 160 # set the core depth bounds as required\n", "# read in the data files and filter for desired columns\n", "site_df=pd.read_csv(dir_path+'/sites.txt',sep='\\t',header=1)\n", "site_df=site_df[['site','core_depth','external_results']]\n", "\n", "anis_df=pd.read_csv(dir_path+'/specimens.txt',sep='\\t',header=1)\n", "anis_df['site']=anis_df['specimen']\n", "anis_df.dropna(subset=['aniso_v1'],inplace=True)\n", "# merge with sites and filter for the depth\n", "anis_df=pd.merge(anis_df,site_df,on='site')\n", "anis_df=anis_df[(anis_df.core_depth>depth_min)&(anis_df.core_depth<depth_max)]\n", "\n", "\n", "# unpack the eigenparameters from aniso_v1,aniso_v2 and aniso_v3 and pick out the eigenvalues\n", "anis_df['tau1']=anis_df['aniso_v1'].str.split(':',expand=True)[0].astype('float').values\n", "anis_df['tau2']=anis_df['aniso_v2'].str.split(':',expand=True)[0].astype('float').values\n", "anis_df['tau3']=anis_df['aniso_v3'].str.split(':',expand=True)[0].astype('float').values\n", "\n", "# unpack external results data\n", "site_df['ngr']=site_df['external_results'].str.split(':',expand=True)[1].astype('float').values\n", "\n", "# make the plots\n", "\n", "\n", "fig=plt.figure(1,(6,12)) # make the figure\n", "ax1=fig.add_subplot(121) # make the first of two subplots\n", "ax2=fig.add_subplot(122) # make the second of two subplots\n", "\n", "# plot the eigenvalues with the usual symbols\n", "ax1.plot(anis_df['tau1'],anis_df['core_depth'],'rs') # red square\n", "ax1.plot(anis_df['tau2'],anis_df['core_depth'],'b^') # blue triangle\n", "ax1.plot(anis_df['tau3'],anis_df['core_depth'],'ko') # black circle\n", "ax1.set_ylim(depth_max,depth_min) # set the y axis limits\n", "ax1.set_xlabel('Eigenvalues')\n", "\n", "# plot the ngr data as a black line\n", "ax2.plot(site_df['ngr'],site_df['core_depth'],'k-')\n", "ax2.set_ylim(depth_max,depth_min) # set the y axis limits\n", "# shade in the high NGR regions - these are the clay dominated layers with higher anisotropy\n", "y2=np.ones(len(site_df['ngr']))*site_df['ngr'].median()\n", "plt.fill_betweenx(site_df['core_depth'],site_df['ngr'], y2,\\\n", "                  where = site_df['ngr']>=y2, facecolor='grey')\n", "ax2.axvline(site_df['ngr'].median()) # draw a vertical line up the median values\n", "ax2.set_xlabel('NGR'); # label the X axis\n", "\n", "\n", "\n"]}, {"block": 39, "type": "markdown", "linesLength": 7, "startIndex": 315, "lines": ["### PmagPy for getting geomagnetic vectors from IGRF-like tables\n", "\n", "- use pmag.pinc() to calculate the GAD inclination for a  particular latitude (e.g., 33)\n", "- use ipmag.igrf() and ipmag.igrf\\_print() to get values of the field for a specific place (e.g., San Diego at lon=-117,lat=33,alt=0) and date (2019)\n", "- make a plot of declination, inclination, B for a specific place and range of dates\n", "- use pmag.do\\_mag_map() and pmagplotlib.plot\\_mag\\_map() to make a map of the field at a specific date (2019)\n", "- make a movie of the field for the last 1000 years using the cals10k.2 model of Constable et al. (2016; [http://dx.doi.org/10.1016/j.epsl.2016.08.015](http://dx.doi.org/10.1016/j.epsl.2016.08.015))\n"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 322, "lines": ["help(pmag.pinc)"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 323, "lines": ["gad_inc=pmag.pinc(33)\n", "print(gad_inc)"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 325, "lines": ["help(ipmag.igrf)"]}, {"block": 43, "type": "code", "linesLength": 3, "startIndex": 326, "lines": ["date,lat,lon,alt=2019.9,33,-117,0 # set variables for ipmag.igrf\n", "local=ipmag.igrf([date, alt, lat, lon]) # get the local field vector\n", "ipmag.igrf_print(local) # format for nice printing"]}, {"block": 44, "type": "code", "linesLength": 24, "startIndex": 329, "lines": ["mod='cals10k.2' # set model to Constable et al. (2016) cals10k.2\n", "lat,lon,alt=33,-117,0  # set location information\n", "gad_inc=pmag.pinc(lat) # get the GAD inclination at the latitude\n", "dates=range(-8000,2050,50) # get a list of desired dates\n", "local_vectors=[] # make a container to put the vectors in\n", "for d in dates: # step through the date list\n", "    local=ipmag.igrf([d, alt, lat, lon],mod=mod) # get the vector at that place and time\n", "    local_vectors.append([d,local[0],local[1],local[2]]) # append it to the container of field vectors\n", "df=pd.DataFrame(local_vectors,columns=['Date','Dec','Inc','B_nT']) # make a Pandas DataFrame\n", "df['B_uT']=df['B_nT']*1e-3 # convert from nanotesla to microtesla\n", "df.loc[df['Dec']>180,'Dec']=df['Dec']-360. # make declinations centered around 0 \n", "fig=plt.figure(1,(8,8)) # make a figure object\n", "ax1=fig.add_subplot(311) # add subplots (3 rows, one column, plot 1)\n", "ax2=fig.add_subplot(312) # plot 2\n", "ax3=fig.add_subplot(313) # plot 3\n", "ax1.plot(df['Date'],df['Dec']) # plot declination against date\n", "ax1.axhline(0,color='black',linestyle='dotted') # make a horizontal black line at 0\n", "ax2.plot(df['Date'],df['Inc']) # plot inclination against date\n", "ax2.axhline(gad_inc,color='black',linestyle='dotted')\n", "ax3.plot(df['Date'],df['B_uT']) # plot microtesla against date\n", "ax1.set_ylabel(r'Declination ($^{\\circ}$)') # y label on plot 1\n", "ax2.set_ylabel('Inclination')# y label on plot 2\n", "ax3.set_ylabel('Intensity')# y label on plot 3\n", "ax3.set_xlabel('Age (+/- AD)'); # x label on bottom plot (3)"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 353, "lines": ["help(pmag.do_mag_map)"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 354, "lines": ["help(pmagplotlib.plot_mag_map)"]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 355, "lines": ["# define some useful parameters\n", "date,mod,lon_0,alt,ghfile=2019,'cals10k.2',0,0,\"\" # only date is required\n", "Ds,Is,Bs,Brs,lons,lats=pmag.do_mag_map(date,mod=mod,lon_0=lon_0,alt=alt,file=ghfile) # get the global data"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 358, "lines": ["help(pmagplotlib.plot_mag_map)"]}, {"block": 49, "type": "code", "linesLength": 4, "startIndex": 359, "lines": ["cmap='jet' # nice color map for contourf\n", "pmagplotlib.plot_mag_map(1,Bs,lons,lats,'B',cmap=cmap,date=date,proj='Mollweide',contours=False) # plot the field strength\n", "pmagplotlib.plot_mag_map(2,Is,lons,lats,'I',cmap=cmap,date=date,proj='Mollweide',contours=True)# plot the inclination\n", "pmagplotlib.plot_mag_map(3,Ds,lons,lats,'D',cmap=cmap,date=date,contours=True);# plot the declination    \n"]}, {"block": 50, "type": "code", "linesLength": 6, "startIndex": 363, "lines": ["dirs=os.listdir('PmagPy_online') # get a list of directories in this one\n", "if 'PmagPy_for_Geomag' not in dirs:\n", "    os.mkdir(\"PmagPy_online/PmagPy_for_Geomag\")\n", "    print ('PmagPy_for_Geomag directory created')\n", "else:\n", "    print ('PmagPy_for_Geomag directory already exists')\n"]}, {"block": 51, "type": "code", "linesLength": 23, "startIndex": 369, "lines": ["dir_path='PmagPy_Online/PmagPy_for_Geomag' # set the directory path name\n", "files=os.listdir(dir_path) # get a list of the directory\n", "for f in files:\n", "    if '.png' in f:os.remove(dir_path+'/'+f) # delete all the existing .png files in that directory\n", "mod,lon_0,alt,ghfile='cals10k.2',0,0,\"\" # define the variables \n", "cmap,title='jet','Intensity' # nice color map for contourf\n", "fignum=1\n", "dates=range(-1000,2100,500) # make maps for these years.  \n", "# to make a high resolution, smooth movie, uncomment this line\n", "#dates=range(-1000,2100,50) # make maps for these years.  \n", "lon_0=0 # center the maps at the Greenwich meridian\n", "element='B' # let's do field strength\n", "for date in dates:  # step through the loop\n", "\n", "    Ds,Is,Bs,Brs,lons,lats=pmag.do_mag_map(date,mod=mod,lon_0=lon_0,alt=alt,file=ghfile)\n", "    pmagplotlib.plot_mag_map(fignum,Bs,lons,lats,'B',cmap=cmap,date=date,proj='Mollweide',\n", "                             min=15,max=100,contours=False) # plot the field strength\n", "    figstr=str(fignum)\n", "    while len(figstr)<4:figstr='0'+figstr\n", "    \n", "    plt.savefig(dir_path+'/' +title.strip()+'_'+figstr+'.png') # saves the  figure. to a folder\n", "    fignum+=1\n", "    print ('figure saved as: ',title.strip()+'_'+figstr+'.png')"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 392, "lines": ["Now we can make the animated gif from these png files"]}, {"block": 53, "type": "code", "linesLength": 8, "startIndex": 393, "lines": ["filenames=sorted(os.listdir('PmagPy_Online/PmagPy_for_Geomag')) # listing of the directory\n", "images = [] # make a container to put the image files in\n", "for file in filenames: # step through all the maps\n", "    if '.png' in file: # skip some of the nasty hidden files\n", "        filename='PmagPy_Online/PmagPy_for_Geomag/'+file # make filename from the folder name and the file name\n", "        images.append(imageio.imread(filename)) # read it in and stuff in the container\n", "kargs={ 'duration':.3} # .3 second delay between frames\n", "imageio.mimsave('PmagPy_Online/PmagPy_for_Geomag/Bmovie.gif', images,'GIF',**kargs) # save to an animated gif.  "]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 401, "lines": ["Image(filename=\"PmagPy_Online/PmagPy_for_Geomag/Bmovie.gif\")"]}, {"block": 55, "type": "markdown", "linesLength": 6, "startIndex": 402, "lines": ["Here is an example of one done  at higher temporal resolution.\n", "You can do this too if you have the patience (perhaps not when dozens of other folks are using the jupyter-hub at the same time!  \n", "\n", "just uncomment this line in the map making code cell above:\n", "\n", "dates=range(-1000,2100,50) # make maps for these years.  "]}, {"block": 56, "type": "code", "linesLength": 1, "startIndex": 408, "lines": ["Image(filename=\"PmagPy_Online/PmagPy_for_Geomag/BigMovie.gif\")"]}, {"block": 57, "type": "code", "linesLength": 0, "startIndex": 409, "lines": []}]
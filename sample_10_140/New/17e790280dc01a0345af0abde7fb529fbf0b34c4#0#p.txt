[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Evaluation"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 1, "lines": ["Evaluation with offline metrics is pivotal to assess the quality of a recommender before it goes into production. Usually, evaluation metrics are carefully chosen based on the actual application scenario of a recommendation system. It is hence important to data scientists and AI developers that build recommendation systems to understand how each evaluation metric is calculated and what it is for.\n", "\n", "This notebook deep dives into several commonly used evaluation metrics, and illustrates how these metrics are used in practice."]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["## 0 Global settings"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["Most of the functions used in the notebook can be found in the `utilities` directory."]}, {"block": 4, "type": "code", "linesLength": 8, "startIndex": 6, "lines": ["import pandas as pd\n", "\n", "from utilities.common.spark_utils import start_or_get_spark\n", "from utilities.evaluation.spark_evaluation import SparkRankingEvaluation, SparkRatingEvaluation\n", "from utilities.evaluation.python_evaluation import PythonRankingEvaluation, PythonRatingEvaluation\n", "from utilities.recommender.sar.sar_singlenode import SARSingleNodeReference\n", "from utilities.dataset.url_utils import maybe_download\n", "from utilities.dataset.python_splitters import python_random_split"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Note to successfully run Spark codes with the Jupyter kernel, one needs to correctly set the environment variables of `PYSPARK_PYTHON` and `PYSPARK_DRIVER_PYTHON` that point to Python executables with the desired version. Detailed information can be found in the installation setup instruction, which is in the file of `Recommenders/SETUP.md`."]}, {"block": 6, "type": "code", "linesLength": 11, "startIndex": 15, "lines": ["COL_USER = \"UserId\"\n", "COL_ITEM = \"MovieId\"\n", "COL_RATING = \"Rating\"\n", "COL_PREDICTION = \"Rating\"\n", "\n", "HEADER = {\n", "    \"col_user\": COL_USER,\n", "    \"col_item\": COL_ITEM,\n", "    \"col_rating\": COL_RATING,\n", "    \"col_prediction\": COL_PREDICTION,\n", "}"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["## 1 Prepare data"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### 1.1 Prepare dummy data"]}, {"block": 9, "type": "markdown", "linesLength": 5, "startIndex": 28, "lines": ["For illustration purpose, a dummy data set is created for demonstrating how different evaluation metrics work. \n", "\n", "The data has the schema that can be frequently found in a recommendation problem, that is, each row in the dataset is a (user, item, rating) tuple, where \"rating\" can be an ordinal rating score (e.g., discrete integers of 1, 2, 3, etc.) or an numerical float number that quantitatively indicates the preference of the user towards that item. \n", "\n", "For simplicity reason, the column of rating in the dummy dataset we use in the example represent some ordinal ratings."]}, {"block": 10, "type": "code", "linesLength": 14, "startIndex": 33, "lines": ["df_true = pd.DataFrame(\n", "        {\n", "            COL_USER: [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n", "            COL_ITEM: [1, 2, 3, 1, 4, 5, 6, 7, 2, 5, 6, 8, 9, 10, 11, 12, 13, 14],\n", "            COL_RATING: [5, 4, 3, 5, 5, 3, 3, 1, 5, 5, 5, 4, 4, 3, 3, 3, 2, 1],\n", "        }\n", "    )\n", "df_pred = pd.DataFrame(\n", "    {\n", "        COL_USER: [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n", "        COL_ITEM: [3, 10, 12, 10, 3, 5, 11, 13, 4, 10, 7, 13, 1, 3, 5, 2, 11, 14],\n", "        COL_PREDICTION: [14, 13, 12, 14, 13, 12, 11, 10, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]\n", "    }\n", ")"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Take a look at ratings of the user with ID \"1\" in the dummy dataset."]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["df_true[df_true[COL_USER] == 1]"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["df_pred[df_pred[COL_USER] == 1]"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["### 1.2 Prepare Spark data"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Spark framework is sometimes used to evaluate metrics given datasets that are hard to fit into memory. In our example, Spark DataFrames can be created from the Python dummy dataset."]}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 52, "lines": ["spark = start_or_get_spark(\"EvaluationTesting\", \"local\")\n", "\n", "dfs_true = spark.createDataFrame(df_true)\n", "dfs_pred = spark.createDataFrame(df_pred)"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["dfs_true.filter(dfs_true[COL_USER] == 1).show()"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["dfs_pred.filter(dfs_pred[COL_USER] == 1).show()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["## 2 Evaluation metrics"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["### 2.1 Rating metrics"]}, {"block": 21, "type": "markdown", "linesLength": 26, "startIndex": 60, "lines": ["Rating metrics are similar to regression metrics used for evaluating a regression model that predicts numerical values given input observations. In the context of recommendation system, rating metrics are to evaluate how accurate a recommender is to predict ratings that users may give to items. Therefore, the metrics are **calculated exactly on the same group of (user, item) pairs that exist in both ground-truth dataset and prediction dataset** and **averaged by the total number of users**.\n", "\n", "In our examples below, to calculate rating metrics for input data frames in Spark, a Spark object, `SparkRatingEvaluation` is initialized. \n", "\n", "A few notes about the interface of the Rating evaluator class:\n", "1. The columns of user, item, and rating (prediction) should be present in the ground-truth DataFrame (prediction DataFrame).\n", "2. There should be no duplicates of (user, item) pairs in the ground-truth and the prediction DataFrames, othewise there may be unexpected behavior in calculating certain metrics.\n", "3. Default column names for user, item, rating, and prediction are \"UserId\", \"ItemId\", \"Rating\", and \"Prediciton\", respectively.\n", "\n", "The input data schemas for the ground-truth dataset and the prediction dataset are\n", "\n", "* Ground-truth dataset.\n", "\n", "|Column|Data type|Description|\n", "|-------------|------------|-------------|\n", "|`COL_USER`|<int\\>|User ID|\n", "|`COL_ITEM`|<int\\>|Item ID|\n", "|`COL_RATING`|<float\\>|Rating or numerical value of user preference.|\n", "\n", "* Prediction dataset.\n", "\n", "|Column|Data type|Description|\n", "|-------------|------------|-------------|\n", "|`COL_USER`|<int\\>|User ID|\n", "|`COL_ITEM`|<int\\>|Item ID|\n", "|`COL_RATING`|<float\\>|Predicted rating or numerical value of user preference.|"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 86, "lines": ["spark_rate_eval = SparkRatingEvaluation(dfs_true, dfs_pred, **HEADER)"]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 87, "lines": ["#### 2.1.1 Root Mean Square Error (RMSE)\n", "\n", "RMSE is for evaluating the accuracy of prediction on ratings. "]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 90, "lines": ["print(\"The RMSE is {}\".format(str(spark_rate_eval.rmse())))"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 91, "lines": ["#### 2.1.2 R Squared (R2)\n", "\n", "R2 is also called \"Coefficient of determination\" in some context. It is a metric that evaluate how well a regression model performs, based on the proportion of total variations of the observed results. "]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 94, "lines": ["print(\"The R2 is {}\".format(str(spark_rate_eval.rsquared())))"]}, {"block": 27, "type": "markdown", "linesLength": 3, "startIndex": 95, "lines": ["#### 2.1.3 Mean Absolute Error (MAE)\n", "\n", "MAE evaluates accuracy of prediction. It computes the metric value from ground truth and prediction in the same scale. Compared to RMSE, MAE is more explainable. "]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["print(\"The MAE is {}\".format(str(spark_rate_eval.mae())))"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 99, "lines": ["#### 2.1.4 Explained Variance \n", "\n", "Explained variance is usually used to measure how well a model performs with regard to the impact from the variation of the dataset. "]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 102, "lines": ["print(\"The explained variance is {}\".format(str(spark_rate_eval.exp_var())))"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["#### 2.1.5 Summary"]}, {"block": 32, "type": "markdown", "linesLength": 6, "startIndex": 104, "lines": ["|Metric|Range|Selection criteria|Limitation|Reference|\n", "|------|-------------------------------|---------|----------|---------|\n", "|RMSE|$> 0$|The smaller the better.|May be biased, and less explainable than MSE|[link](https://en.wikipedia.org/wiki/Root-mean-square_deviation)|\n", "|R2|$\\leq 1$|The closer to $1$ the better.|Depend on variable distributions.|[link](https://en.wikipedia.org/wiki/Coefficient_of_determination)|\n", "|MSE|$\\geq 0$|The smaller the better.|Dependent on variable scale.|[link](https://en.wikipedia.org/wiki/Mean_absolute_error)|\n", "|Explained variance|$\\leq 1$|The closer to $1$ the better.|Depend on variable distributions.|[link](https://en.wikipedia.org/wiki/Explained_variation)|"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["### 2.2 Ranking metrics"]}, {"block": 34, "type": "markdown", "linesLength": 6, "startIndex": 111, "lines": ["\"Beyond-accuray evaluation\" was proposed to evaluate how relevant recommendations are for users. In this case, a recommendation system is a treated as a ranking system. Given a relency definition, recommendation system outputs a list of recommended items to each user, which is ordered by relevance. The evaluation part takes ground-truth data, the actual items that users interact with (e.g., liked, purchased, etc.), and the recommendation data, as inputs, to calculate ranking evaluation metrics. \n", "\n", "A few notes about the interface of the Rating evaluator class:\n", "1. The columns of user, item, and rating (prediction) should be present in the ground-truth DataFrame (prediction DataFrame). The column of timestamp is optional, but it is required if certain relevanc function is used. For example, timestamps will be used if the most recent items are defined as the relevant one.\n", "2. There should be no duplicates of (user, item) pairs in the ground-truth and the prediction DataFrames, othewise there may be unexpected behavior in calculating certain metrics.\n", "3. Default column names for user, item, rating, and prediction are \"UserId\", \"ItemId\", \"Rating\", and \"Prediciton\", respectively."]}, {"block": 35, "type": "markdown", "linesLength": 36, "startIndex": 117, "lines": ["#### 2.2.1 Relevancy of recommendation\n", "\n", "Relevancy of recommendation can be measured in different ways:\n", "\n", "* **By ranking** - In this case, relevant items in the recommendations are defined as the top ranked items, i.e., top k items, which are taken from the list of the recommended items that is ordered by the predicted ratings (or other numerical scores that indicate preference of a user to an item). \n", "\n", "* **By timestamp** - Relevant items are defined as the most recently viewed k items, which are obtained from the recommended items ranked by timestamps.\n", "\n", "* **By rating** - Relevant items are defined as items with ratings (or other numerical scores that indicate preference of a user to an item) that are above a given threshold. \n", "\n", "Similarly, a ranking metric object can be initialized as below. The input data schema is\n", "\n", "* Ground-truth dataset.\n", "\n", "|Column|Data type|Description|\n", "|-------------|------------|-------------|\n", "|`COL_USER`|<int\\>|User ID|\n", "|`COL_ITEM`|<int\\>|Item ID|\n", "|`COL_RATING`|<float\\>|Rating or numerical value of user preference.|\n", "|`COL_TIMESTAMP`|<string\\>|Timestamps.|\n", "\n", "* Prediction dataset.\n", "\n", "|Column|Data type|Description|\n", "|-------------|------------|-------------|\n", "|`COL_USER`|<int\\>|User ID|\n", "|`COL_ITEM`|<int\\>|Item ID|\n", "|`COL_RATING`|<float\\>|Predicted rating or numerical value of user preference.|\n", "|`COL_TIMESTAM`|<string\\>|Timestamps.|\n", "\n", "In this case, in addition to the input datasets, there are also other arguments used for calculating the ranking metrics:\n", "\n", "|Argument|Data type|Description|\n", "|------------|------------|--------------|\n", "|`k`|<int\\>|Number of items recommended to user.|\n", "|`revelancy_method`|<string\\>|Methonds that extract relevant items from the recommendation list|"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 153, "lines": ["For example, the following code initializes a ranking metric object that calculates the metrics."]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 154, "lines": ["spark_rank_eval = SparkRankingEvaluation(dfs_true, dfs_pred, k=3, relevancy_method=\"top_k\", **HEADER)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["A few ranking metrics can then be calculated."]}, {"block": 39, "type": "markdown", "linesLength": 5, "startIndex": 156, "lines": ["#### 2.2.1 Precision\n", "\n", "Precision@k is a metric evaluate how many items, in the recommendation list, are relevant (hit) in the ground-truth data. For each user the precision score is normalized by `k` and then the overall precision scores are averaged by the total number of users. \n", "\n", "Note it is apparent that the precision@k metric grows with the number of `k`."]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 161, "lines": ["spark_rank_eval.precision_at_k()"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 162, "lines": ["#### 2.2.2 Recall\n", "\n", "Recall@k is a metric evaluate how many items, in the recommendation list, are relevant (hit) in the ground-truth data. The recall score for each user is normalized by the total number of ground-truth items and then the overall recall scores are averaged by the total number of users. "]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 165, "lines": ["spark_rank_eval.recall_at_k()"]}, {"block": 43, "type": "markdown", "linesLength": 3, "startIndex": 166, "lines": ["#### 2.2.3 Normalized Discounted Cumulative Gain (NDCG)\n", "\n", "NDCG is a metric that evaluates how well the recommender performs in recommending ranked items to users. Therefore both hit of relevant items and correctness in ranking of these items matter to the NDCG evaluation. The total NDCG score is normalized by the total number of users."]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 169, "lines": ["spark_rank_eval.ndcg_at_k()"]}, {"block": 45, "type": "markdown", "linesLength": 3, "startIndex": 170, "lines": ["#### 2.2.4 Mean Average Precision (MAP)\n", "\n", "MAP is a metric that evaluates the average precision for each user in the datasets. It also penalizes ranking correctness of the recommended items. The overall MAP score is normalized by the total number of users."]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 173, "lines": ["spark_rank_eval.map_at_k()"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 174, "lines": ["#### 2.2.5 Summary"]}, {"block": 48, "type": "markdown", "linesLength": 6, "startIndex": 175, "lines": ["|Metric|Range|Selection criteria|Limitation|Reference|\n", "|------|-------------------------------|---------|----------|---------|\n", "|Precision|$\\geq 0$ and $\\leq 1$|The closer to $1$ the better.|Only for hits in recommendations.|[link](https://spark.apache.org/docs/2.3.0/mllib-evaluation-metrics.html#ranking-systems)|\n", "|Recall|$\\geq 0$ and $\\leq 1$|The closer to $1$ the better.|Only for hits in the ground truth.|[link](https://en.wikipedia.org/wiki/Precision_and_recall)|\n", "|NDCG|$\\geq 0$ and $\\leq 1$|The closer to $1$ the better.|Does not penalize for bad/missing items, and does not perform for several equally good items.|[link](https://spark.apache.org/docs/2.3.0/mllib-evaluation-metrics.html#ranking-systems)|\n", "|MAP|$\\geq 0$ and $\\leq 1$|The closer to $1$ the better.|Depend on variable distributions.|[link](https://spark.apache.org/docs/2.3.0/mllib-evaluation-metrics.html#ranking-systems)|"]}, {"block": 49, "type": "markdown", "linesLength": 6, "startIndex": 181, "lines": ["## References\n", "\n", "1. Guy Shani and Asela Gunawardana, \\\"Evaluating Recommendation Systems\\\", Recommender Systems Handbook, Springer, 2015.\n", "2. PySpark MLlib evaluation metrics, url: https://spark.apache.org/docs/2.3.0/mllib-evaluation-metrics.html.\n", "3. Dimitris Paraschakis et al, \\\"Comparative Evaluation of Top-N Recommenders in e-Commerce: An Industrial Perspective\\\", IEEE ICMLA, 2015, Miami, FL, USA.\n", "4. Yehuda Koren and Robert Bell, \\\"Advances in Collaborative Filtering\\\", Recommender Systems Handbook, Springer, 2015."]}]
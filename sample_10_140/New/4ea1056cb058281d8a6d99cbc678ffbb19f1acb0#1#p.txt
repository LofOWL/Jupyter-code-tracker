[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains solutions to exercises in Chapter 4: Noise\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 17, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "\n", "import numpy as np\n", "import pandas as pd\n", "\n", "import warnings\n", "warnings.filterwarnings('ignore')\n", "\n", "from IPython.html.widgets import interact, interact_manual, fixed\n", "from IPython.html import widgets\n", "from IPython.display import display\n", "\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 8, "startIndex": 24, "lines": ["**Exercise:** ``A Soft Murmur'' is a web site that plays a mixture of natural\n", "noise sources, including rain, waves, wind, etc.  At\n", "http://asoftmurmur.com/about/ you can find their list\n", "of recordings, most of which are at http://freesound.org.\n", "\n", "Download a few of these files and compute the spectrum of each\n", "signal.  Does the power spectrum look like white noise, pink noise,\n", "or Brownian noise?  How does the spectrum vary over time?"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["wave = thinkdsp.read_wave('132736__ciccarelli__ocean-waves.wav')\n", "wave.make_audio()"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["I chose a recording of ocean waves.  I selected a short segment:"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["segment = wave.segment(start=1.5, duration=1.0)\n", "segment.make_audio()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["And here's its spectrum:"]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 38, "lines": ["spectrum = segment.make_spectrum()\n", "spectrum.plot_power()\n", "thinkplot.config(xlabel='frequency (Hz)')"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Amplitude drops off with frequency, so this might be red or pink noise.  We can check by looking at the power spectrum on a log-log scale."]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 42, "lines": ["spectrum.plot_power()\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                 xscale='log', \n", "                 yscale='log')"]}, {"block": 10, "type": "markdown", "linesLength": 5, "startIndex": 46, "lines": ["This structure, with increasing and then decreasing amplitude, seems to be common in natural noise sources.\n", "\n", "Above $f = 10^3$, it might be dropping off linearly, but we can't really tell.\n", "\n", "To see how the spectrum changes over time, I'll select another segment:"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 51, "lines": ["segment2 = wave.segment(start=2.5, duration=1.0)\n", "segment2.make_audio()"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["And plot the two spectrums:"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 54, "lines": ["spectrum2 = segment2.make_spectrum()\n", "spectrum.plot_power()\n", "spectrum2.plot_power(color='#beaed4')\n", "thinkplot.config(xlabel='frequency (Hz)',\n", "                 ylabel='amplitude')"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Here they are again, plotting power on a log-log scale."]}, {"block": 15, "type": "code", "linesLength": 6, "startIndex": 60, "lines": ["spectrum.plot_power()\n", "spectrum2.plot_power(color='#beaed4')\n", "thinkplot.config(xlabel='frequency (Hz)',\n", "                 ylabel='amplitude',\n", "                 xscale='log', \n", "                 yscale='log')"]}, {"block": 16, "type": "markdown", "linesLength": 3, "startIndex": 66, "lines": ["So the structure seems to be consistent over time.\n", "\n", "We can also look at a spectrogram:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 69, "lines": ["segment.make_spectrogram(512).plot(high=5000)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Within this segment, the overall amplitude drops off, but the mixture of frequencies seems consistent."]}, {"block": 19, "type": "markdown", "linesLength": 12, "startIndex": 71, "lines": ["**Exercise:** In a noise signal, the mixture of frequencies changes over time.\n", "In the long run, we expect the power at all frequencies to be equal,\n", "but in any sample, the power at each frequency is random.\n", "\n", "To estimate the long-term average power at each frequency, we can\n", "break a long signal into segments, compute the power spectrum for each segment, and then compute the average across\n", "the segments.  You can read more about this algorithm at\n", "http://en.wikipedia.org/wiki/Bartlett's_method.\n", "\n", "Implement Bartlett's method and use it to estimate the power\n", "spectrum for a noise wave.  Hint: look at the implementation\n", "of `make_spectrogram`."]}, {"block": 20, "type": "code", "linesLength": 20, "startIndex": 83, "lines": ["def bartlett_method(wave, seg_length=512):\n", "    \"\"\"Estimates the power spectrum of a noise wave.\n", "    \n", "    wave: Wave\n", "    seg_length: segment length\n", "    \"\"\"\n", "    # make a spectrogram and extract the spectrums\n", "    spectro = wave.make_spectrogram(seg_length)\n", "    spectrums = spectro.spec_map.values()\n", "    \n", "    # extract the power array from each spectrum\n", "    psds = [spectrum.power for spectrum in spectrums]\n", "    \n", "    # compute the root mean power (which is like an amplitude)\n", "    hs = np.sqrt(sum(psds) / len(psds))\n", "    fs = spectrums[0].fs\n", "    \n", "    # make a Spectrum with the mean amplitudes\n", "    spectrum = thinkdsp.Spectrum(hs, fs, wave.framerate)\n", "    return spectrum"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["`bartlett_method` makes a spectrogram and extracts `spec_map`, which maps from times to Spectrum objects.  It computes the PSD for each spectrum, adds them up, and puts the results into a Spectrum object."]}, {"block": 22, "type": "code", "linesLength": 10, "startIndex": 104, "lines": ["psd = bartlett_method(segment)\n", "psd2 = bartlett_method(segment2)\n", "\n", "psd.plot_power()\n", "psd2.plot_power(color='#beaed4')\n", "\n", "thinkplot.config(xlabel='frequency (Hz)', \n", "                 ylabel='power', \n", "                 xscale='log', \n", "                 yscale='log')"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Now we can see the relationship between power and frequency more clearly.  It is not a simple linear relationship, but it is consistent across different segments, even in details like the notches near 5000 Hz, 6000 Hz, and above 10,000 Hz. "]}, {"block": 24, "type": "markdown", "linesLength": 4, "startIndex": 115, "lines": ["**Exercise:** At http://www.coindesk.com you can download the daily\n", "price of a BitCoin as a CSV file.  Read this file and compute\n", "the spectrum of BitCoin prices as a function of time.\n", "Does it resemble white, pink, or Brownian noise?"]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 119, "lines": ["df = pd.read_csv('coindesk-bpi-USD-close.csv', nrows=1625, parse_dates=[0])\n", "ys = df.Close.values\n", "ts = np.arange(len(ys))"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 122, "lines": ["wave = thinkdsp.Wave(ys, ts, framerate=1)\n", "wave.plot()\n", "thinkplot.config(xlabel='Time (days)')"]}, {"block": 27, "type": "code", "linesLength": 4, "startIndex": 125, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot_power()\n", "thinkplot.config(xlabel='Frequency (1/days)',\n", "                 xscale='log', yscale='log')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["The slope is -1.8, which is similar to red noise (which should have a slope of -2)."]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 130, "lines": ["spectrum.estimate_slope()[0]"]}, {"block": 30, "type": "markdown", "linesLength": 5, "startIndex": 131, "lines": ["**Exercise:** A Geiger counter is a device that detects radiation. When an ionizing particle strikes the detector, it outputs a surge of current. The total output at a point in time can be modeled as uncorrelated Poisson (UP) noise, where each sample is a random quantity from a Poisson distribution, which corresponds to the number of particles detected during an interval.\n", "\n", "Write a class called `UncorrelatedPoissonNoise` that inherits from `thinkdsp._Noise` and provides `evaluate`. It should use `np.random.poisson` to generate random values from a Poisson distribution. The parameter of this function, `lam`, is the average number of particles during each interval. You can use the attribute `amp` to specify `lam`. For example, if the framerate is 10 kHz and `amp` is 0.001, we expect about 10 \u201cclicks\u201d per second.\n", "\n", "Generate about a second of UP noise and listen to it. For low values of `amp`, like 0.001, it should sound like a Geiger counter. For higher values it should sound like white noise. Compute and plot the power spectrum to see whether it looks like white noise. "]}, {"block": 31, "type": "code", "linesLength": 12, "startIndex": 136, "lines": ["class UncorrelatedPoissonNoise(thinkdsp._Noise):\n", "    \"\"\"Represents uncorrelated Poisson noise.\"\"\"\n", "\n", "    def evaluate(self, ts):\n", "        \"\"\"Evaluates the signal at the given times.\n", "\n", "        ts: float array of times\n", "        \n", "        returns: float wave array\n", "        \"\"\"\n", "        ys = np.random.poisson(self.amp, len(ts))\n", "        return ys"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 148, "lines": ["Here's what it sounds like at low levels of \"radiation\"."]}, {"block": 33, "type": "code", "linesLength": 7, "startIndex": 149, "lines": ["amp = 0.001\n", "framerate = 10000\n", "duration = 1\n", "\n", "signal = UncorrelatedPoissonNoise(amp=amp)\n", "wave = signal.make_wave(duration=duration, framerate=framerate)\n", "wave.make_audio()"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 156, "lines": ["To check that things worked, we compare the expected number of particles and the actual number:"]}, {"block": 35, "type": "code", "linesLength": 3, "startIndex": 157, "lines": ["expected = amp * framerate * duration\n", "actual = sum(wave.ys)\n", "print(expected, actual)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 160, "lines": ["Here's what the wave looks like:"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 161, "lines": ["wave.plot()"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 162, "lines": ["And here's its power spectrum on a log-log scale."]}, {"block": 39, "type": "code", "linesLength": 6, "startIndex": 163, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot_power()\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                 ylabel='Power',\n", "                 xscale='log', \n", "                 yscale='log')"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 169, "lines": ["Looks like white noise, and the slope is close to 0."]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 170, "lines": ["spectrum.estimate_slope().slope"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 171, "lines": ["With a higher arrival rate, it sounds more like white noise:"]}, {"block": 43, "type": "code", "linesLength": 7, "startIndex": 172, "lines": ["amp = 1\n", "framerate = 10000\n", "duration = 1\n", "\n", "signal = UncorrelatedPoissonNoise(amp=amp)\n", "wave = signal.make_wave(duration=duration, framerate=framerate)\n", "wave.make_audio()"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 179, "lines": ["It looks more like a signal:"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 180, "lines": ["wave.plot()"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 181, "lines": ["And the spectrum converges on Gaussian noise."]}, {"block": 47, "type": "code", "linesLength": 14, "startIndex": 182, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.hs[0] = 0\n", "\n", "thinkplot.preplot(2, cols=2)\n", "thinkstats2.NormalProbabilityPlot(spectrum.real, label='real')\n", "thinkplot.config(xlabel='Normal sample',\n", "                 ylabel='Power',\n", "                 legend=True,\n", "                 loc='lower right')\n", "\n", "thinkplot.subplot(2)\n", "thinkstats2.NormalProbabilityPlot(spectrum.imag, label='imag')\n", "thinkplot.config(xlabel='Normal sample',\n", "                     loc='lower right')"]}, {"block": 48, "type": "markdown", "linesLength": 6, "startIndex": 196, "lines": ["**Exercise:** The algorithm in this chapter for generating pink noise is\n", "conceptually simple but computationally expensive.  There are\n", "more efficient alternatives, like the Voss-McCartney algorithm.\n", "Research this method, implement it, compute the spectrum of\n", "the result, and confirm that it has the desired relationship\n", "between power and frequency."]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 202, "lines": ["# TODO: Write a solution to this exercise."]}]
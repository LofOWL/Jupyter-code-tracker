[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Hook callbacks"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 1, "lines": ["This provides both a standalone class and a callback for registering and automatically deregistering [PyTorch hooks](https://pytorch.org/tutorials/beginner/former_torchies/nn_tutorial.html#forward-and-backward-function-hooks), along with some pre-defined hooks. Hooks can be attached to any [`nn.Module`](https://pytorch.org/docs/stable/nn.html#torch.nn.Module), for either the forward or the backward pass.\n", "\n", "We'll start by looking at the pre-defined hook [`ActivationStats`](/callbacks.hooks.html#ActivationStats), then we'll see how to create our own."]}, {"block": 2, "type": "code", "linesLength": 5, "startIndex": 4, "lines": ["from fastai.gen_doc.nbdoc import *\n", "from fastai.callbacks.hooks import * \n", "from fastai import *\n", "from fastai.train import *\n", "from fastai.vision import *"]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 9, "lines": ["show_doc(ActivationStats)"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["[`ActivationStats`](/callbacks.hooks.html#ActivationStats) saves the layer activations in `self.stats` for all `modules` passed to it. By default it will save activations for *all* modules. For instance:"]}, {"block": 5, "type": "code", "linesLength": 4, "startIndex": 11, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "data = ImageDataBunch.from_folder(path)\n", "learn = create_cnn(data, models.resnet18, callback_fns=ActivationStats)\n", "learn.fit(1)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["The saved `stats` is a `FloatTensor` of shape `(2,num_modules,num_batches)`. The first axis is `(mean,stdev)`."]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 16, "lines": ["len(learn.data.train_dl),len(learn.activation_stats.modules)"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["learn.activation_stats.stats.shape"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["So this shows the standard deviation (`axis0==1`) of 5th last layer (`axis1==-5`) for each batch (`axis2`):"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["plt.plot(learn.activation_stats.stats[1][-5].numpy());"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["show_doc(Hook)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["Registers and manually deregisters a [PyTorch hook](https://pytorch.org/tutorials/beginner/former_torchies/nn_tutorial.html#forward-and-backward-function-hooks). Your `hook_func` will be called automatically when forward/backward (depending on `is_forward`) for your module `m` is run, and the result of that function is placed in `self.stored`."]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 22, "lines": ["show_doc(Hook.remove)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Deregister the hook, if not called already."]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["show_doc(Hooks)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Acts as a `Collection` (i.e. `len(hooks)` and `hooks[i]`) and an `Iterator` (i.e. `for hook in hooks`) of a group of hooks, one for each module in `ms`, with the ability to remove all as a group. Use `stored` to get all hook results. `hook_func` and `is_forward` behavior is the same as [`Hook`](/callbacks.hooks.html#Hook). See the source code for [`HookCallback`](/callbacks.hooks.html#HookCallback) for a simple example."]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 26, "lines": ["show_doc(Hooks.remove)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Deregister all hooks created by this class, if not previously called."]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["## Convenience functions for hooks"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["show_doc(hook_output)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Function that creates a [`Hook`](/callbacks.hooks.html#Hook) for `module` that simply stores the output of the layer."]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["show_doc(hook_outputs)"]}, {"block": 23, "type": "markdown", "linesLength": 7, "startIndex": 32, "lines": ["Function that creates a [`Hook`](/callbacks.hooks.html#Hook) for all passed `modules` that simply stores the output of the layers. For example, the (slightly simplified) source code of [`model_sizes`](/callbacks.hooks.html#model_sizes) is:\n", "\n", "```python\n", "def model_sizes(m, size):\n", "    x = m(torch.zeros(1, in_channels(m), *size))\n", "    return [o.stored.shape for o in hook_outputs(m)]\n", "```"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["show_doc(model_sizes)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["show_doc(model_summary)"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 41, "lines": ["show_doc(num_features_model)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["It can be useful to get the size of each layer of a model (e.g. for printing a summary, or for generating cross-connections for a [`DynamicUnet`](/vision.models.unet.html#DynamicUnet)), however they depend on the size of the input. This function calculates the layer sizes by passing in a minimal tensor of `size`."]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["show_doc(dummy_batch)"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["show_doc(dummy_eval)"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["show_doc(HookCallback)"]}, {"block": 31, "type": "markdown", "linesLength": 7, "startIndex": 46, "lines": ["For all `modules`, uses a callback to automatically register a method `self.hook` (that you must define in an inherited class) as a hook. This method must have the signature:\n", "\n", "```python\n", "def hook(self, m:Model, input:Tensors, output:Tensors)\n", "```\n", "\n", "If `do_remove` then the hook is automatically deregistered at the end of training. See [`ActivationStats`](/callbacks.hooks.html#ActivationStats) for a simple example of inheriting from this class."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["## Undocumented Methods - Methods moved below this line will intentionally be hidden"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["show_doc(HookCallback.remove)"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["show_doc(HookCallback.on_train_begin)"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["show_doc(HookCallback.on_train_end)"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["show_doc(ActivationStats.hook)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["show_doc(ActivationStats.on_batch_end)"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["show_doc(ActivationStats.on_train_begin)"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["show_doc(ActivationStats.on_train_end)"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["show_doc(Hook.hook_fn)"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["## New Methods - Please document or move to the undocumented section"]}]
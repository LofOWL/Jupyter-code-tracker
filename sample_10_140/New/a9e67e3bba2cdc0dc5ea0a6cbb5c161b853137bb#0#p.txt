[{"block": 0, "type": "markdown", "linesLength": 4, "startIndex": 0, "lines": ["ThinkDSP, by Allen Downey\n", "(think-dsp.com)\n", "\n", "This notebook contains code examples from Chapter 6: Discrete Cosine Transform"]}, {"block": 1, "type": "code", "linesLength": 10, "startIndex": 4, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "import math\n", "import numpy\n", "\n", "%precision 3\n", "PI2 = 2 * math.pi"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["The simplest way to synthesize a mixture of sinusoids is to evaluate the sinusoids and add them up."]}, {"block": 3, "type": "code", "linesLength": 7, "startIndex": 15, "lines": ["def synthesize1(amps, freqs, ts):\n", "    components = [thinkdsp.CosSignal(freq, amp)\n", "                  for amp, freq in zip(amps, freqs)]\n", "    signal = thinkdsp.SumSignal(*components)\n", "\n", "    ys = signal.evaluate(ts)\n", "    return ys"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Here's an example that's a mixture of 4 components."]}, {"block": 5, "type": "code", "linesLength": 9, "startIndex": 23, "lines": ["amps = numpy.array([0.6, 0.25, 0.1, 0.05])\n", "freqs = [100, 200, 300, 400]\n", "framerate = 11025\n", "\n", "ts = numpy.linspace(0, 1, framerate)\n", "ys = synthesize1(amps, freqs, ts)\n", "wave = thinkdsp.Wave(ys, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["We can express the same process using matrix multiplication."]}, {"block": 7, "type": "code", "linesLength": 5, "startIndex": 33, "lines": ["def synthesize2(amps, freqs, ts):\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    ys = numpy.dot(M, amps)\n", "    return ys"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["And it should sound the same."]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 39, "lines": ["ys = synthesize2(amps, freqs, ts)\n", "wave = thinkdsp.Wave(ys, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["The simplest way to analyze a signal---that is, find the amplitude for each component---is to create the same matrix we used for synthesis and then solve the system of linear equations."]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["def analyze1(ys, freqs, ts):\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    amps = numpy.linalg.solve(M, ys)\n", "    return amps"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Using the first 4 values from the wave array, we can recover the amplitudes."]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["n = len(freqs)\n", "amps2 = analyze1(ys[:n], freqs, ts[:n])\n", "amps2"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["What we have so far is a simple version of a discrete cosine tranform (DCT), but it is not an efficient implementation because the matrix we get is not orthogonal."]}, {"block": 15, "type": "code", "linesLength": 13, "startIndex": 54, "lines": ["def test1():\n", "    amps = numpy.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    time_unit = 0.001\n", "    ts = numpy.arange(N) / N * time_unit\n", "    max_freq = N / time_unit / 2\n", "    freqs = numpy.arange(N) / N * max_freq\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    return M\n", "\n", "M = test1()\n", "print(M)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["To check whether a matrix is orthogonal, we can compute $M^T M$, which should be the identity matrix:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["print(M.transpose().dot(M))"]}, {"block": 18, "type": "markdown", "linesLength": 3, "startIndex": 69, "lines": ["But it's not.\n", "\n", "Solving a linear system with a general matrix (that is, one that does not have nice properties like orthogonality) takes time proportional to $N^3$.  With an orthogonal matrix, we can get that down to $N^2$.  Here's how:"]}, {"block": 19, "type": "code", "linesLength": 11, "startIndex": 72, "lines": ["def test2():\n", "    amps = numpy.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    ts = (0.5 + numpy.arange(N)) / N\n", "    freqs = (0.5 + numpy.arange(N)) / 2\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    return M\n", "    \n", "M = test2()\n", "print(M)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Now $M^T M$ is $2I$ (approximately), so M is orthogonal except for a factor of two."]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 84, "lines": ["print(M.transpose().dot(M))"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["And that means we can solve the analysis problem using matrix multiplication."]}, {"block": 23, "type": "code", "linesLength": 5, "startIndex": 86, "lines": ["def analyze2(ys, freqs, ts):\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    amps = M.dot(ys) / 2\n", "    return amps"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["It works:"]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 92, "lines": ["n = len(freqs)\n", "amps2 = analyze1(ys[:n], freqs, ts[:n])\n", "amps2"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["What we've implemented is DCT-IV, which is one of several versions of DCT using orthogonal matrices."]}, {"block": 27, "type": "code", "linesLength": 8, "startIndex": 96, "lines": ["def dct_iv(ys):\n", "    N = len(ys)\n", "    ts = (0.5 + numpy.arange(N)) / N\n", "    freqs = (0.5 + numpy.arange(N)) / 2\n", "    args = numpy.outer(ts, freqs)\n", "    M = numpy.cos(PI2 * args)\n", "    amps = numpy.dot(M, ys) / 2\n", "    return amps"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["We can check that it works:"]}, {"block": 29, "type": "code", "linesLength": 8, "startIndex": 105, "lines": ["amps = numpy.array([0.6, 0.25, 0.1, 0.05])\n", "N = 4.0\n", "ts = (0.5 + numpy.arange(N)) / N\n", "freqs = (0.5 + numpy.arange(N)) / 2\n", "ys = synthesize2(amps, freqs, ts)\n", "\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["DCT and inverse DCT are the same things except for a factor of 2."]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 114, "lines": ["def inverse_dct_iv(amps):\n", "    return dct_iv(amps) * 2"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["And it works:"]}, {"block": 33, "type": "code", "linesLength": 4, "startIndex": 117, "lines": ["amps = [0.6, 0.25, 0.1, 0.05]\n", "ys = inverse_dct_iv(amps)\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 121, "lines": ["\n"]}, {"block": 35, "type": "code", "linesLength": 0, "startIndex": 122, "lines": []}]
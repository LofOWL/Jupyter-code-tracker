[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code solutions to exercises in Chapter 6: Discrete Cosine Transform\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 13, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "\n", "import numpy as np\n", "import scipy.fftpack\n", "\n", "import autocorr\n", "import dct\n", "\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 11, "startIndex": 20, "lines": ["**Exercise:** In this chapter I claim that `analyze1` takes time proportional\n", "to $n^3$ and `analyze2` takes time proportional to $n^2$.  To\n", "see if that's true, run them on a range of input sizes and time\n", "them.  In IPython, you can use the magic command `%timeit`.\n", "\n", "If you plot run time versus input size on a log-log scale, you\n", "should get a straight line with slope 3 for  `analyze1` and\n", "slope 2 for `analyze2`.  You also might want to test `dct_iv`\n", "and `scipy.fftpack.dct`.\n", "\n", "I'll start with a noise signal and an array of power-of-two sizes"]}, {"block": 3, "type": "code", "linesLength": 5, "startIndex": 31, "lines": ["signal = thinkdsp.UncorrelatedGaussianNoise()\n", "noise = signal.make_wave(duration=1.0)\n", "\n", "ns = 2 ** np.arange(6, 14)\n", "ns"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["The following function takes an array of results from a timing experiment, plots the results, and fits a straight line."]}, {"block": 5, "type": "code", "linesLength": 10, "startIndex": 37, "lines": ["def plot_bests(bests):    \n", "    thinkplot.plot(ns, bests)\n", "    thinkplot.config(xscale='log', yscale='log', legend=False)\n", "    \n", "    x = np.log(ns)\n", "    y = np.log(bests)\n", "    t = scipy.stats.linregress(x,y)\n", "    slope = t[0]\n", "\n", "    return slope"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Here are the results for 'analyze1'."]}, {"block": 7, "type": "code", "linesLength": 12, "startIndex": 48, "lines": ["results = []\n", "for N in ns:\n", "    ts = (0.5 + np.arange(N)) / N\n", "    freqs = (0.5 + np.arange(N)) / 2\n", "    ys = noise.ys[:N]\n", "    result = %timeit -o dct.analyze1(ys, freqs, ts)\n", "    results.append(result)\n", "\n", "bests = [result.best for result in results]\n", "\n", "thinkplot.preplot(3)\n", "plot_bests(bests)"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 60, "lines": ["The line is curved, which suggests that we have not reached the array size where the runtime shows asymptotic behavior.  As I ran this with larger array sizes, the estimated slope continued to increase.\n", "\n", "Here are the results for 'analyze2':"]}, {"block": 9, "type": "code", "linesLength": 10, "startIndex": 63, "lines": ["results = []\n", "for N in ns:\n", "    ts = (0.5 + np.arange(N)) / N\n", "    freqs = (0.5 + np.arange(N)) / 2\n", "    ys = noise.ys[:N]\n", "    result = %timeit -o dct.analyze2(ys, freqs, ts)\n", "    results.append(result)\n", "\n", "bests2 = [result.best for result in results]\n", "plot_bests(bests2)"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 73, "lines": ["`analyze2` is faster, and the estimated slope is close to the value we expected.\n", "\n", "Here are the results for the `scipy.fftpack.dct`"]}, {"block": 11, "type": "code", "linesLength": 8, "startIndex": 76, "lines": ["results = []\n", "for N in ns:\n", "    ys = noise.ys[:N]\n", "    result = %timeit -o scipy.fftpack.dct(ys, type=3)\n", "    results.append(result)\n", "\n", "bests3 = [result.best for result in results]\n", "plot_bests(bests3)"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 84, "lines": ["This implementation of dct is even faster.  The line is curved, which means either we haven't seen the asymptotic behavior yet, or the asymptotic behavior is not a simple exponent of $n$.  In fact, as we'll see soon, the run time is proportional to $n \\log n$.\n", "\n", "The following figure shows all three curves on the same axes."]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 87, "lines": ["thinkplot.preplot(3)\n", "thinkplot.plot(ns, bests, label='analyze1')\n", "thinkplot.plot(ns, bests2, label='analyze2')\n", "thinkplot.plot(ns, bests3, label='fftpack.dct')\n", "thinkplot.config(xscale='log', yscale='log', legend=True, loc='upper left')"]}, {"block": 14, "type": "code", "linesLength": 0, "startIndex": 92, "lines": []}, {"block": 15, "type": "markdown", "linesLength": 8, "startIndex": 92, "lines": ["5) One of the major applications of the DCT is compression for both sound and images. In its simplest form, DCT-based compression works like this:\n", "\n", "1. Break a long signal into segments.\n", "2. Compute the DCT of each segment.\n", "3. Identify frequency components with amplitudes so low they are inaudible, and remove them. Store only the frequencies and amplitudes that remain.\n", "4. To play back the signal, load the frequencies and amplitudes for each segment and apply the inverse DCT.\n", "\n", "Implement a version of this algorithm and apply it to a recording of music or speech. How many components can you eliminate before the difference is perceptible?"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["`thinkdsp` provides a class, `Dct` that is similar to a `Spectrum`, but which uses DCT instead of FFT.  We can use it to make a DCT Spectrogram; the following is almost identical to `Wave.make_spectrogram`:"]}, {"block": 17, "type": "code", "linesLength": 24, "startIndex": 101, "lines": ["def make_dct_spectrogram(wave, seg_length, window_func=np.hamming):\n", "    \"\"\"Computes the DCT spectrogram of the wave.\n", "\n", "    seg_length: number of samples in each segment\n", "    window_func: function used to compute the window\n", "\n", "    returns: Spectrogram\n", "    \"\"\"\n", "    n = len(wave.ys)\n", "    window = window_func(seg_length)\n", "\n", "    start, end, step = 0, seg_length, seg_length / 2\n", "    spec_map = {}\n", "\n", "    while end < n:\n", "        ys = wave.ys[start:end] * window\n", "\n", "        t = (start + end) / 2.0 / wave.framerate\n", "        spec_map[t] = thinkdsp.Wave(ys, wave.framerate).make_dct()\n", "\n", "        start += step\n", "        end += step\n", "\n", "    return thinkdsp.Spectrogram(spec_map, seg_length, window_func)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["As an example, I'll use a recording of a saxophone:"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 126, "lines": ["wave = thinkdsp.read_wave('100475__iluppai__saxophone-weep.wav')\n", "wave.make_audio()"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 128, "lines": ["Here's a short segment:"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 129, "lines": ["segment = wave.segment(start=1.2, duration=0.5)\n", "segment.normalize()\n", "segment.make_audio()"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 132, "lines": ["And here's the DCT of that segment:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 133, "lines": ["seg_dct = segment.make_dct()\n", "seg_dct.plot()"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 135, "lines": ["There are only a few harmonics with substantial amplitude, and many entries near zero."]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 136, "lines": ["cdf = thinkstats2.Cdf(np.abs(seg_dct.amps))\n", "thinkplot.cdf(cdf)\n", "thinkplot.config(xscale='log', legend=False)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["The following function takes a DCT and sets elements below `thresh` to 0."]}, {"block": 27, "type": "code", "linesLength": 9, "startIndex": 140, "lines": ["def compress(dct, thresh=1000):\n", "    count = 0\n", "    for i, amp in enumerate(dct.amps):\n", "        if abs(amp) < thresh:\n", "            dct.amps[i] = 0\n", "            count += 1\n", "            \n", "    n = len(dct.amps)\n", "    print(count, n, 100 * count / n, sep='\\t')"]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 149, "lines": ["To test `compress`, I'll make a DCT spectrogram and then compress each segment.\n", "\n", "The output shows the number of elements eliminated and the compression factor."]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 152, "lines": ["spectro = make_dct_spectrogram(wave, seg_length=1024)\n", "for t, dct in sorted(spectro.spec_map.iteritems()):\n", "    compress(dct, thresh=1000)"]}, {"block": 30, "type": "markdown", "linesLength": 3, "startIndex": 155, "lines": ["In most segments, the compression 60-80%.\n", "\n", "To hear what it sounds like, we can convert the spectrogram back to a wave and play it."]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 158, "lines": ["wave2 = spectro.make_wave()\n", "wave2.make_audio()"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 160, "lines": ["And here's the original again for comparison."]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 161, "lines": ["wave.make_audio()"]}, {"block": 34, "type": "markdown", "linesLength": 3, "startIndex": 162, "lines": ["As an experiment, you might try increasing `thresh` to see when the effect of compression becomes audible (to you).\n", "\n", "Also, you might try compressing a noise signal."]}, {"block": 35, "type": "code", "linesLength": 0, "startIndex": 165, "lines": []}]
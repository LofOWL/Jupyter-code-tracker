[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["<i>Copyright (c) Microsoft Corporation. All rights reserved.</i>\n", "\n", "<i>Licensed under the MIT License.</i>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["# Hyperparameter tuning (Spark based recommender)"]}, {"block": 2, "type": "markdown", "linesLength": 6, "startIndex": 4, "lines": ["Hyperparameter tuning for Spark based recommender algorithm is important to select a model with the optimal performance. This notebook introduces good practices in performing hyperparameter tuning for building recommender models with the utility functions provided in the [Microsoft/Recommenders](https://github.com/Microsoft/Recommenders.git) repository.\n", "\n", "Three different approaches are introduced and comparatively studied.\n", "* Spark native/custom constructs (`ParamGridBuilder`, `TrainValidationSplit`).\n", "* `hyperopt` package with Tree of Parzen Estimator algorithm. \n", "* Brute-force random search of parameter values sampled with pre-defined space. "]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["## 0 Global settings and import"]}, {"block": 4, "type": "code", "linesLength": 38, "startIndex": 11, "lines": ["# set the environment path to find Recommenders\n", "%matplotlib inline\n", "\n", "import matplotlib\n", "import matplotlib.pyplot as plt\n", "import sys\n", "sys.path.append(\"../../\")\n", "import pandas as pd\n", "import numpy as np\n", "import time\n", "\n", "import pyspark\n", "from pyspark.sql import SparkSession\n", "import pyspark.sql.functions as F\n", "from pyspark import SparkContext, SparkConf\n", "from pyspark.ml.recommendation import ALS\n", "from pyspark.ml.tuning import ParamGridBuilder, TrainValidationSplit\n", "from pyspark.ml.evaluation import Evaluator, RegressionEvaluator\n", "from pyspark.ml.pipeline import Estimator, Model\n", "from pyspark import keyword_only  \n", "from pyspark.ml import Transformer\n", "from pyspark.ml.param.shared import *\n", "from pyspark.ml.util import *\n", "from pyspark.mllib.evaluation import RegressionMetrics, RankingMetrics\n", "from pyspark.sql.types import ArrayType, IntegerType, StringType\n", "\n", "from hyperopt import fmin, tpe, hp, STATUS_OK, Trials\n", "from hyperopt.pyll.base import scope\n", "from hyperopt.pyll.stochastic import sample\n", "\n", "from reco_utils.common.spark_utils import start_or_get_spark\n", "from reco_utils.evaluation.spark_evaluation import SparkRankingEvaluation, SparkRatingEvaluation\n", "from reco_utils.dataset.movielens import load_spark_df\n", "from reco_utils.dataset.spark_splitters import spark_random_split\n", "\n", "print(\"System version: {}\".format(sys.version))\n", "print(\"Pandas version: {}\".format(pd.__version__))\n", "print(\"PySpark version: {}\".format(pyspark.__version__))"]}, {"block": 5, "type": "code", "linesLength": 24, "startIndex": 49, "lines": ["NUMBER_CORES = 1\n", "NUMBER_ITERATIONS = 25\n", "\n", "COL_USER = \"userID\"\n", "COL_ITEM = \"itemID\"\n", "COL_TIMESTAMP = \"timestamp\"\n", "COL_RATING = \"rating\"\n", "COL_PREDICTION = \"prediction\"\n", "\n", "HEADER = {\n", "    \"col_user\": COL_USER,\n", "    \"col_item\": COL_ITEM,\n", "    \"col_rating\": COL_RATING,\n", "    \"col_prediction\": COL_PREDICTION,\n", "}\n", "\n", "HEADER_ALS = {\n", "    \"userCol\": COL_USER,\n", "    \"itemCol\": COL_ITEM,\n", "    \"ratingCol\": COL_RATING\n", "}\n", "\n", "RANK = [10, 15, 20, 30, 40]\n", "REG = [ 0.1, 0.01, 0.001, 0.0001, 0.00001]"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["## 1 Data preparation"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["A Spark session is created. Note in this case, to study the running time for different approaches, the Spark session in local mode uses only one core for running. This eliminates the impact of parallelization of parameter tuning. "]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 75, "lines": ["spark = start_or_get_spark(url=\"local[{}]\".format(NUMBER_CORES))"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Movielens 100k dataset is used for running the demonstration."]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["data = load_spark_df(spark, size='100k', header=(COL_USER, COL_ITEM, COL_RATING))"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["The dataset is split into 3 subsets randomly with a given split ratio. The hyperparameter tuning is performed on the training and the validating data, and then the optimal recommender selected is evaluated on the testing dataset."]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 79, "lines": ["train, valid, test = spark_random_split(data, ratio=[3, 1, 1])"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["## 2 Hyper parameter tuning with Azure Machine Learning Services"]}, {"block": 14, "type": "markdown", "linesLength": 3, "startIndex": 81, "lines": ["The `hyperdrive` module in the [Azure Machine Learning Services](https://azure.microsoft.com/en-us/services/machine-learning-service/) runs [hyperparameter tuning and optimizing for machine learning model selection](https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-tune-hyperparameters). At the moment, the service supports running hyperparameter tuning on heterogenous computing targets such as cluster of commodity compute nodes with or without GPU devices (see detailed documentation [here](https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-set-up-training-targets)). It is feasible to run parameter tuning on a cluster of VM nodes. In this case, the service containerizes individual and independent Spark session on each node of the cluster to run the parameter tuning job in parallel, instead of inside a single Spark session where the training is executed in a distributed manner.  \n", "\n", "Detailed instructions of tuning hyperparameter of non-Spark workloads by using Azure Machine Learning Services can be found in [this](https://github.com/Microsoft/Recommenders.git) notebook. "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["## 3 Hyper parameter tuning with Spark ML constructs"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["### 3.1 Spark native construct"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 86, "lines": ["Spark ML lib implements modules such as `CrossValidator` and `TrainValidationSplit` for tuning hyperparameters (see [here](https://spark.apache.org/docs/2.2.0/ml-tuning.html)). However, by default, it does not support custom machine learning algorithms, data splitting methods, and evaluation metrics, like what are offered as utility functions in the Recommenders repository. \n", "\n", "For example, the Spark native constuct can be used for tuning a recommender against the `rmse` metric which is one of the available regression metrics in Spark."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Firstly, a Spark ALS object needs to be created. In this case, for illustration purpose, it is an ALS model object."]}, {"block": 19, "type": "code", "linesLength": 10, "startIndex": 90, "lines": ["# NOTE the parameters of interest, rank and regParam, are left unset, \n", "# because their values will be assigned in the parameter grid builder.\n", "als = ALS(\n", "    maxIter=15,\n", "    implicitPrefs=False,\n", "    alpha=0.1,\n", "    coldStartStrategy='drop',\n", "    nonnegative=False,\n", "    **HEADER_ALS\n", ")"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["Then, a parameter grid can be defined as follows. Without loss of generity, only `rank` and `regParam` are considered."]}, {"block": 21, "type": "code", "linesLength": 4, "startIndex": 101, "lines": ["paramGrid = ParamGridBuilder() \\\n", "    .addGrid(als.rank, RANK) \\\n", "    .addGrid(als.regParam, REG) \\\n", "    .build()"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 105, "lines": ["Given the settings above, a `TrainValidationSplit` constructor can be created for fitting the best model in the given parameter range. In this case, the `RegressionEvaluator` is using `RMSE`, by default, as an evaluation metric. \n", "\n", "Since the data splitter is embedded in the `TrainValidationSplit` object, to make sure the splitting ratio is consistent across different approaches, the split ratio is set to be 0.75 and in the model training the training dataset and validating dataset are combined. "]}, {"block": 23, "type": "code", "linesLength": 10, "startIndex": 108, "lines": ["tvs = TrainValidationSplit(\n", "    estimator=als,\n", "    estimatorParamMaps=paramGrid,\n", "    # A regression evaluation method is used. \n", "    evaluator=RegressionEvaluator(labelCol='rating'),\n", "    # 75% of the data will be used for training, 25% for validation.\n", "    # NOTE here the splitting is random. The Spark splitting utilities (e.g. chrono splitter)\n", "    # are therefore not available here. \n", "    trainRatio=0.75\n", ")"]}, {"block": 24, "type": "code", "linesLength": 7, "startIndex": 118, "lines": ["time_start = time.time()\n", "\n", "# Run TrainValidationSplit, and choose the best set of parameters.\n", "# NOTE train and valid is union because in Spark TrainValidationSplit does splitting by itself.\n", "model = tvs.fit(train.union(valid))\n", "\n", "time_spark = time.time() - time_start"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["The model parameters in the grid and the best metrics can be then returned. "]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 126, "lines": ["for idx, item in enumerate(model.getEstimatorParamMaps()):\n", "    print('Run {}:'.format(idx))\n", "    print('\\tValidation Metric: {}'.format(model.validationMetrics[idx]))\n", "    for key, value in item.items():\n", "        print('\\t{0}: {1}'.format(repr(key), value))"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 131, "lines": ["model.validationMetrics"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 132, "lines": ["To get the best model, just do"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 133, "lines": ["model_best_spark = model.bestModel"]}, {"block": 30, "type": "markdown", "linesLength": 3, "startIndex": 134, "lines": ["### 3.2 Custom `Estimator`, `Transformer`, and `Evaluator` for Spark ALS\n", "\n", "One can also customize Spark modules to allow tuning hyperparameters for a desired model and evaluation metric, given that the native Spark ALS does not allow tuning hyperparameters for ranking metrics such as precision@k, recall@k, etc. This can be done by creating custom `Estimator`, `Transformer` and `Evaluator`. The benefit is that, after the customization, the tuning process can make use of `trainValidSplit` directly, which distributes the tuning in a Spark session."]}, {"block": 31, "type": "markdown", "linesLength": 3, "startIndex": 137, "lines": ["#### Customized `Estimator` and `Transformer` for top k recommender based on Spark ALS\n", "\n", "The following shows how to implement a PySpark `Estimator` and `Transfomer` for recommending top k items from ALS model. The latter generates top k recommendations from the model object. Both of the two are designed by following the protocol of Spark APIs, to make sure that they can be run with the hyperparameter tuning constructs in Spark."]}, {"block": 32, "type": "code", "linesLength": 153, "startIndex": 140, "lines": ["class ALSTopK(\n", "    ALS,\n", "    Estimator,\n", "    HasInputCol,\n", "    HasPredictionCol\n", "):    \n", "    rank = Param(Params._dummy(), \"rank\", \"rank of the factorization\",\n", "                 typeConverter=TypeConverters.toInt)\n", "    numUserBlocks = Param(Params._dummy(), \"numUserBlocks\", \"number of user blocks\",\n", "                          typeConverter=TypeConverters.toInt)\n", "    numItemBlocks = Param(Params._dummy(), \"numItemBlocks\", \"number of item blocks\",\n", "                          typeConverter=TypeConverters.toInt)\n", "    implicitPrefs = Param(Params._dummy(), \"implicitPrefs\", \"whether to use implicit preference\",\n", "                          typeConverter=TypeConverters.toBoolean)\n", "    alpha = Param(Params._dummy(), \"alpha\", \"alpha for implicit preference\",\n", "                  typeConverter=TypeConverters.toFloat)\n", "    userCol = Param(Params._dummy(), \"userCol\", \"column name for user ids. Ids must be within \" +\n", "                    \"the integer value range.\", typeConverter=TypeConverters.toString)\n", "    itemCol = Param(Params._dummy(), \"itemCol\", \"column name for item ids. Ids must be within \" +\n", "                    \"the integer value range.\", typeConverter=TypeConverters.toString)\n", "    ratingCol = Param(Params._dummy(), \"ratingCol\", \"column name for ratings\",\n", "                      typeConverter=TypeConverters.toString)\n", "    nonnegative = Param(Params._dummy(), \"nonnegative\",\n", "                        \"whether to use nonnegative constraint for least squares\",\n", "                        typeConverter=TypeConverters.toBoolean)\n", "    intermediateStorageLevel = Param(Params._dummy(), \"intermediateStorageLevel\",\n", "                                     \"StorageLevel for intermediate datasets. Cannot be 'NONE'.\",\n", "                                     typeConverter=TypeConverters.toString)\n", "    finalStorageLevel = Param(Params._dummy(), \"finalStorageLevel\",\n", "                              \"StorageLevel for ALS model factors.\",\n", "                              typeConverter=TypeConverters.toString)\n", "    coldStartStrategy = Param(Params._dummy(), \"coldStartStrategy\", \"strategy for dealing with \" +\n", "                              \"unknown or new users/items at prediction time. This may be useful \" +\n", "                              \"in cross-validation or production scenarios, for handling \" +\n", "                              \"user/item ids the model has not seen in the training data. \" +\n", "                              \"Supported values: 'nan', 'drop'.\",\n", "                              typeConverter=TypeConverters.toString)\n", "\n", "    @keyword_only\n", "    def __init__(\n", "        self,\n", "        rank=10, maxIter=10, regParam=0.1, numUserBlocks=10, numItemBlocks=10,\n", "        implicitPrefs=False, alpha=1.0, userCol=\"user\", itemCol=\"item\", seed=None, k=10,\n", "        ratingCol=\"rating\", nonnegative=False, checkpointInterval=10,\n", "        intermediateStorageLevel=\"MEMORY_AND_DISK\",\n", "        finalStorageLevel=\"MEMORY_AND_DISK\", coldStartStrategy=\"nan\"\n", "    ):\n", "        super(ALS, self).__init__()\n", "        self._java_obj = self._new_java_obj(\"org.apache.spark.ml.recommendation.ALS\", self.uid)\n", "        self._setDefault(rank=10, maxIter=10, regParam=0.1, numUserBlocks=10, numItemBlocks=10,\n", "                         implicitPrefs=False, alpha=1.0, userCol=\"user\", itemCol=\"item\",\n", "                         ratingCol=\"rating\", nonnegative=False, checkpointInterval=10,\n", "                         intermediateStorageLevel=\"MEMORY_AND_DISK\",\n", "                         finalStorageLevel=\"MEMORY_AND_DISK\", coldStartStrategy=\"nan\")\n", "\n", "        kwargs = self._input_kwargs \n", "        kwargs = {x: kwargs[x] for x in kwargs if x not in {'k'}}\n", "        self.setParams(**kwargs)\n", "        \n", "        # The manually added parameter is not present in ALS Java implementation. \n", "        self.k = k\n", "        \n", "    def setRank(self, value):\n", "        \"\"\"\n", "        Sets the value of :py:attr:`rank`.\n", "        \"\"\"\n", "        return self._set(rank=value)\n", "\n", "    def getRank(self):\n", "        \"\"\"\n", "        Gets the value of rank or its default value.\n", "        \"\"\"\n", "        return self.getOrDefault(self.rank)\n", "    \n", "    def setParams(self, rank=10, maxIter=10, regParam=0.1, numUserBlocks=10, numItemBlocks=10,\n", "                  implicitPrefs=False, alpha=1.0, userCol=\"user\", itemCol=\"item\", seed=None,\n", "                  ratingCol=\"rating\", nonnegative=False, checkpointInterval=10,\n", "                  intermediateStorageLevel=\"MEMORY_AND_DISK\",\n", "                  finalStorageLevel=\"MEMORY_AND_DISK\", coldStartStrategy=\"nan\"):\n", "        \"\"\"\n", "        setParams(self, rank=10, maxIter=10, regParam=0.1, numUserBlocks=10, numItemBlocks=10, \\\n", "                 implicitPrefs=False, alpha=1.0, userCol=\"user\", itemCol=\"item\", seed=None, \\\n", "                 ratingCol=\"rating\", nonnegative=False, checkpointInterval=10, \\\n", "                 intermediateStorageLevel=\"MEMORY_AND_DISK\", \\\n", "                 finalStorageLevel=\"MEMORY_AND_DISK\", coldStartStrategy=\"nan\")\n", "        Sets params for ALS.\n", "        \"\"\"\n", "        kwargs = self._input_kwargs\n", "        kwargs = {x: kwargs[x] for x in kwargs if x not in {'k'}}\n", "        return self._set(**kwargs)\n", "        \n", "    def _fit(self, dataset):\n", "        kwargs = self._input_kwargs    \n", "        # Exclude k as it is not a parameter for ALS.\n", "        kwargs = {x: kwargs[x] for x in kwargs if x not in {'k'}}\n", "        kwargs['rank'] = self.getRank()\n", "        kwargs['regParam'] = self.getOrDefault(self.regParam)\n", "        als = ALS(\n", "            **kwargs\n", "        )\n", "        als_model = als.fit(dataset)\n", "        \n", "        user_col = kwargs['userCol']\n", "        item_col = kwargs['itemCol']\n", "        \n", "        k = self.k\n", "                     \n", "        topk_model = ALSTopKModel()\n", "        topk_model.setParams(\n", "            als_model,\n", "            user_col, \n", "            item_col, \n", "            k\n", "        )\n", "        \n", "        return topk_model\n", "    \n", "    \n", "class ALSTopKModel(\n", "    Model,\n", "    HasInputCol,\n", "    HasPredictionCol,\n", "    HasLabelCol\n", "):    \n", "    def setParams(self, model, userCol, itemCol, k):\n", "        self.model = model\n", "        self.userCol = userCol\n", "        self.itemCol = itemCol\n", "        self.k = k\n", "    \n", "    def _transform(self, dataset):\n", "        predictionCol = self.getPredictionCol()\n", "        labelCol = self.getLabelCol()\n", "        \n", "        users = dataset.select(self.userCol).distinct()\n", "        topk_recommendation = self.model.recommendForUserSubset(users, self.k)  \n", "        \n", "        extract_value = F.udf((lambda x: [y[0] for y in x]), ArrayType(IntegerType()))\n", "        topk_recommendation = topk_recommendation.withColumn(predictionCol, extract_value(F.col(\"recommendations\")))        \n", "        \n", "        dataset = (\n", "            dataset\n", "            .groupBy(self.userCol)\n", "            .agg(F.collect_list(F.col(self.itemCol)).alias(labelCol))\n", "        )\n", "            \n", "        topk_recommendation_all = dataset.join(\n", "            topk_recommendation, \n", "            on=self.userCol,\n", "            how=\"outer\"\n", "        )\n", "        \n", "        return topk_recommendation_all.select(self.userCol, labelCol, predictionCol)"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 293, "lines": ["#### Customized precision@k evaluation metric\n", "\n", "In addition to the custom `Estimator` and `Transformer`, it may also be desired to customize an `Evaluator` to allow \"beyond-rating\" metrics. The codes as following illustrates a precision@k evaluator. Other types of evaluators can be developed in a similar way."]}, {"block": 34, "type": "code", "linesLength": 20, "startIndex": 296, "lines": ["# Define a custom Evaulator. Here precision@k is used.\n", "class PrecisionAtKEvaluator(Evaluator):\n", "\n", "    def __init__(self, predictionCol=\"prediction\", labelCol=\"label\", k=10):\n", "        self.predictionCol = predictionCol\n", "        self.labelCol = labelCol\n", "        self.k = k\n", "\n", "    def _evaluate(self, dataset):\n", "        \"\"\"\n", "        Returns a random number. \n", "        Implement here the true metric\n", "        \"\"\"      \n", "        # Drop Nulls.\n", "        dataset = dataset.na.drop()\n", "        metrics = RankingMetrics(dataset.select(self.predictionCol, self.labelCol).rdd)\n", "        return metrics.precisionAt(self.k)\n", "\n", "    def isLargerBetter(self):\n", "        return True"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 316, "lines": ["Then a new ALS top-k recommender can be created, and the Spark native construct, `TrainValidationSplit` module, can be used to find the optimal model w.r.t the precision@k metric."]}, {"block": 36, "type": "code", "linesLength": 23, "startIndex": 317, "lines": ["alstopk = ALSTopK(\n", "    userCol=COL_USER,\n", "    itemCol=COL_ITEM,\n", "    ratingCol=COL_RATING,\n", "    k=10\n", ")\n", "\n", "# Here for illustration purpose, a small grid is used.\n", "paramGrid = ParamGridBuilder() \\\n", "    .addGrid(alstopk.rank, [10, 20]) \\\n", "    .addGrid(alstopk.regParam, [0.1, 0.01]) \\\n", "    .build()\n", "\n", "tvs = TrainValidationSplit(\n", "    estimator=alstopk,\n", "    estimatorParamMaps=paramGrid,\n", "    # A regression evaluation method is used. \n", "    evaluator=PrecisionAtKEvaluator(),\n", "    # 75% of the data will be used for training, 25% for validation.\n", "    # NOTE here the splitting is random. The Spark splitting utilities (e.g. chrono splitter)\n", "    # are therefore not available here. \n", "    trainRatio=0.75\n", ")"]}, {"block": 37, "type": "code", "linesLength": 5, "startIndex": 340, "lines": ["# Run TrainValidationSplit, and choose the best set of parameters.\n", "# NOTE train and valid is union because in Spark TrainValidationSplit does splitting by itself.\n", "model_precision = tvs.fit(train.union(valid))\n", "\n", "model_precision.getEstimatorParamMaps()"]}, {"block": 38, "type": "code", "linesLength": 9, "startIndex": 345, "lines": ["def best_param(model, is_larger_better=True):\n", "    if is_larger_better:\n", "        best_metric = max(model.validationMetrics)\n", "    else:\n", "        best_metric = min(model.validationMetrics)\n", "        \n", "    parameters = model.getEstimatorParamMaps()[model.validationMetrics.index(best_metric)]\n", "     \n", "    return list(parameters.values())"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 354, "lines": ["params = best_param(model_precision)"]}, {"block": 40, "type": "code", "linesLength": 7, "startIndex": 355, "lines": ["model_precision.bestModel.transform(valid).limit(5).show()\n", "\n", "for idx, item in enumerate(model_precision.getEstimatorParamMaps()):\n", "    print('Run {}:'.format(idx))\n", "    print('\\tValidation Metric: {}'.format(model_precision.validationMetrics[idx]))\n", "    for key, value in item.items():\n", "        print('\\t{0}: {1}'.format(repr(key), value))"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 362, "lines": ["## 4 Hyperparameter tuning with `hyperopt`"]}, {"block": 42, "type": "markdown", "linesLength": 5, "startIndex": 363, "lines": ["`hyperopt` is an open source Python package that is designed for tuning parameters for generic function with any pre-defined loss. More information about `hyperopt` can be found [here](https://github.com/hyperopt/hyperopt). `hyperopt` supports parallelization on MongoDB but not Spark. In our case, the tuning is performed in a sequential mode on a local computer.\n", "\n", "In `hyperopt`, an *objective* function is defined for optimizing the hyper parameters. In this case, the objective is similar to that in the Spark native construct situation, which is *to the RMSE metric for an ALS recommender*. Parameters of `rank` and `regParam` are used as hyperparameters. \n", "\n", "The objective function shown below demonstrates a RMSE loss for an ALS recommender. "]}, {"block": 43, "type": "code", "linesLength": 44, "startIndex": 368, "lines": ["# Customize an objective function\n", "def objective(params):\n", "    time_run_start = time.time()\n", "    \n", "    rank = params['rank']\n", "    reg = params['reg']\n", "    train = params['train'] \n", "    valid = params['valid'] \n", "    col_user = params['col_user'] \n", "    col_item = params['col_item']\n", "    col_rating = params['col_rating'] \n", "    col_prediction = params['col_prediction'] \n", "    k = params['k']\n", "    relevancy_method = params['relevancy_method']\n", "    \n", "    als = ALS(\n", "        rank=rank,\n", "        maxIter=15,\n", "        implicitPrefs=False,\n", "        alpha=0.1,\n", "        regParam=reg,\n", "        coldStartStrategy='drop',\n", "        nonnegative=False,\n", "        seed=42,\n", "        **HEADER_ALS\n", "    )\n", "    \n", "    model = als.fit(train) \n", "    prediction = model.transform(valid)\n", "\n", "    rating_eval = SparkRatingEvaluation(\n", "        valid, \n", "        prediction, \n", "        **HEADER\n", "    )\n", "    \n", "    rmse = rating_eval.rmse()\n", "    \n", "    # Return the objective function result.\n", "    return {\n", "        'loss': rmse,\n", "        'status': STATUS_OK,\n", "        'eval_time': time.time() - time_run_start\n", "    }"]}, {"block": 44, "type": "markdown", "linesLength": 7, "startIndex": 412, "lines": ["A search space is usually defined for hyperparameter exploration. Design of search space is empirical, and depends on the understanding of how distribution of parameter of interest affects the model performance measured by the loss function. \n", "\n", "In the ALS algorithm, the two hyper parameters, rank and reg, affect model performance in a way that\n", "* The higher the rank, the better the model performance but also the higher risk of overfitting.\n", "* The reg parameter prevents overfitting in certain way. \n", "\n", "Therefore, in this case, a uniform distribution and a lognormal distribution sampling spaces are used for rank and reg, respectively. A narrow search space is used for illustration purpose, that is, the range of rank is from 10 to 20, while that of reg is from $e^{-5}$ to $e^{-1}$. Together with the randomly sampled hyper parameters, other parameters use for building / evaluating the recommender, like `k`, column names, data, etc., are kept as constants."]}, {"block": 45, "type": "code", "linesLength": 13, "startIndex": 419, "lines": ["# define a search space\n", "space = {\n", "    'rank': hp.quniform('rank', 10, 40, 5),\n", "    'reg': hp.loguniform('reg', -5, -1),\n", "    'train': train, \n", "    'valid': valid, \n", "    'col_user': COL_USER, \n", "    'col_item': COL_ITEM, \n", "    'col_rating': COL_RATING, \n", "    'col_prediction': \"prediction\", \n", "    'k': 10,\n", "    'relevancy_method': \"top_k\"\n", "}"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 432, "lines": ["### 4.1 Hyperparameter tuning with TPE"]}, {"block": 47, "type": "markdown", "linesLength": 5, "startIndex": 433, "lines": ["`fmin` of `hyperopt` is used for running the trials for searching optimal hyper parameters. In `hyperopt`, there are different strategies for intelligently optimize hyper parameters. For example, `hyperopt` avails [Tree of Parzen Estimators (TPE) method](https://papers.nips.cc/paper/4443-algorithms-for-hyper-parameter-optimization.pdf) for searching optimal parameters. \n", "\n", "The TPE method models a surface response of $p(x|y)$ by transforming a generative process, replacing the distributions of the configuration prior with non-parametric densities, where $p$ is the probability of configuration space $x$ given the loss $y$. For different configuration space, the TPE method does different replacements. That is, uniform $\\to$ truncated Gaussian mixture, log-uniform $\\to$ exponentiated truncated Gaussian mixture, categorical $\\to$ re-weighted categorical, etc. Using different observations ${x(1), ..., x(k)}$ in the non-parametric densities, these substitutions represent a learning algorithm that can produce a variety of densities over the configuration space $X$. By maintaining sorted lists of observed variables in $H$, the runtime of each iteration of the TPE algorithm can scale linearly in $|H|$ and linearly in the number of variables (dimensions) being optimized. In a nutshell, the algorithm recognizes the irrelevant variables in the configuration space, and thus reduces iterations in searching for the optimal ones. Details of the TPE algorithm can be found in the reference paper.\n", "\n", "The following runs the trials with the pre-defined objective function and search space. TPE is used as the optimization method. Totally there will be 10 evaluations run for searching the best parameters."]}, {"block": 48, "type": "code", "linesLength": 14, "startIndex": 438, "lines": ["time_start = time.time()\n", "\n", "# Trials for recording each iteration of the hyperparameter searching.\n", "trials = Trials()\n", "\n", "best = fmin(\n", "    fn=objective,\n", "    space=space,\n", "    algo=tpe.suggest,\n", "    trials=trials,\n", "    max_evals=NUMBER_ITERATIONS\n", ")\n", "                  \n", "time_hyperopt = time.time() - time_start"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 452, "lines": ["trials.best_trial"]}, {"block": 50, "type": "code", "linesLength": 11, "startIndex": 453, "lines": ["parameters = ['rank', 'reg']\n", "cols = len(parameters)\n", "f, axes = plt.subplots(nrows=1, ncols=cols, figsize=(15,5))\n", "cmap = plt.cm.jet\n", "for i, val in enumerate(parameters):\n", "    xs = np.array([t['misc']['vals'][val] for t in trials.trials]).ravel()\n", "    ys = [t['result']['loss'] for t in trials.trials]\n", "    xs, ys = zip(*sorted(zip(xs, ys)))\n", "    ys = np.array(ys)\n", "    axes[i].scatter(xs, ys, s=20, linewidth=0.01, alpha=0.75, c=cmap(float(i)/len(parameters)))\n", "    axes[i].set_title(val)"]}, {"block": 51, "type": "markdown", "linesLength": 3, "startIndex": 464, "lines": ["It can be seen from the above plot that\n", "* The actual impact of rank is in line with the intuition - the smaller the value the better the result.\n", "* It is interesting to see that the optimal value of reg is around 0.1 to 0.15. "]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 467, "lines": ["Get the best model."]}, {"block": 53, "type": "code", "linesLength": 13, "startIndex": 468, "lines": ["als = ALS(\n", "    rank=best[\"rank\"],\n", "    regParam=best[\"reg\"],\n", "    maxIter=15,\n", "    implicitPrefs=False,\n", "    alpha=0.1,\n", "    coldStartStrategy='drop',\n", "    nonnegative=False,\n", "    seed=42,\n", "    **HEADER_ALS\n", ")\n", "    \n", "model_best_hyperopt = als.fit(train)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 481, "lines": ["Tuning prameters against other metrics can be simply done by modifying the `objective` function. The following shows an objective function of how to tune \"precision@k\". Since `fmin` in `hyperopt` only supports minimization while the actual objective of the loss is to maximize \"precision@k\", `-precision` instead of `precision` is used in the returned value of the `objective` function."]}, {"block": 55, "type": "code", "linesLength": 71, "startIndex": 482, "lines": ["# Customize an objective function\n", "def objective_precision(params):\n", "    time_run_start = time.time()\n", "    \n", "    rank = params['rank']\n", "    reg = params['reg']\n", "    train = params['train'] \n", "    valid = params['valid'] \n", "    col_user = params['col_user'] \n", "    col_item = params['col_item']\n", "    col_rating = params['col_rating'] \n", "    col_prediction = params['col_prediction'] \n", "    k = params['k']\n", "    relevancy_method = params['relevancy_method']\n", "    \n", "    header = {\n", "        \"userCol\": col_user,\n", "        \"itemCol\": col_item,\n", "        \"ratingCol\": col_rating,\n", "    }\n", "    \n", "    als = ALS(\n", "        rank=rank,\n", "        maxIter=15,\n", "        implicitPrefs=False,\n", "        alpha=0.1,\n", "        regParam=reg,\n", "        coldStartStrategy='drop',\n", "        nonnegative=False,\n", "        seed=42,\n", "        **header\n", "    )\n", "    \n", "    model = als.fit(train)\n", "    \n", "    users = train.select(col_user).distinct()\n", "    items = train.select(col_item).distinct()\n", "    user_item = users.crossJoin(items)\n", "    dfs_pred = model.transform(user_item)\n", "\n", "    # Remove seen items.\n", "    dfs_pred_exclude_train = dfs_pred.alias(\"pred\").join(\n", "        train.alias(\"train\"),\n", "        (dfs_pred[col_user] == train[col_user]) & (dfs_pred[col_item] == train[col_item]),\n", "        how='outer'\n", "    )\n", "\n", "    top_all = dfs_pred_exclude_train.filter(dfs_pred_exclude_train[\"train.Rating\"].isNull()) \\\n", "        .select('pred.' + col_user, 'pred.' + col_item, 'pred.' + \"prediction\")\n", "    \n", "    top_all.cache().count()\n", "\n", "    rank_eval = SparkRankingEvaluation(\n", "        valid, \n", "        top_all, \n", "        k=k, \n", "        col_user=col_user, \n", "        col_item=col_item, \n", "        col_rating=\"rating\", \n", "        col_prediction=\"prediction\", \n", "        relevancy_method=relevancy_method\n", "    )\n", "    \n", "    precision = rank_eval.precision_at_k()\n", "    \n", "    # Return the objective function result.\n", "    return {\n", "        'loss': -precision,\n", "        'status': STATUS_OK,\n", "        'eval_time': time.time() - time_run_start\n", "    }"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 553, "lines": ["### 4.2 Hyperparameter tuning with `hyperopt` sampling methods"]}, {"block": 57, "type": "markdown", "linesLength": 3, "startIndex": 554, "lines": ["Though `hyperopt` works well in a single node machine, its features (e.g., `Trials` module) do not support Spark environment, which makes it hard to perform the tuning tasks in a distributed/parallel manner. It is useful to use `hyperopt` for sampling parameter values from the pre-defined sampling space, and then parallelize the model training onto Spark cluster with the sampled parameter combinations.\n", "\n", "The downside of this method is that the intelligent searching algorithm (i.e., TPE) of `hyperopt` cannot be used. The approach introduced here is therefore equivalent to random search."]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 557, "lines": ["Sample the parameters used for model building from the pre-defined space. "]}, {"block": 59, "type": "code", "linesLength": 3, "startIndex": 558, "lines": ["time_start = time.time()\n", "\n", "sample_params = [sample(space) for x in range(NUMBER_ITERATIONS)]"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 561, "lines": ["The following runs model building on the sampled parameter values with the pre-defined objective function."]}, {"block": 61, "type": "code", "linesLength": 3, "startIndex": 562, "lines": ["results_map = list(map(lambda x: objective(x), sample_params))\n", "\n", "time_sample = time.time() - time_start"]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 565, "lines": ["results_map"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 566, "lines": ["Get the best model."]}, {"block": 64, "type": "code", "linesLength": 2, "startIndex": 567, "lines": ["loss_metrics = np.array([x['loss'] for x in results_map])\n", "best_loss = np.where(loss_metrics == min(loss_metrics))"]}, {"block": 65, "type": "code", "linesLength": 1, "startIndex": 569, "lines": ["best_param = sample_params[best_loss[0].item()]"]}, {"block": 66, "type": "code", "linesLength": 13, "startIndex": 570, "lines": ["als = ALS(\n", "    rank=best_param[\"rank\"],\n", "    regParam=best_param[\"reg\"],\n", "    maxIter=15,\n", "    implicitPrefs=False,\n", "    alpha=0.1,\n", "    coldStartStrategy='drop',\n", "    nonnegative=False,\n", "    seed=42,\n", "    **HEADER_ALS\n", ")\n", "    \n", "model_best_sample = als.fit(train)"]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 583, "lines": ["## 5 Evaluation on testing data"]}, {"block": 68, "type": "markdown", "linesLength": 3, "startIndex": 584, "lines": ["The optimal parameters can then be used for building a recommender, which is then evaluated on the testing data.\n", "\n", "The following codes generate the evaluation results by using the testing dataset with the optimal model selected against the pre-defined loss. Without loss of generity, in this case, the optimal model that performs the best w.r.t regression loss (i.e., the RMSE metric) is used. One can simply use other metrics like precision@k, as illustrated in the above sections, to evaluate the optimal model on the testing dataset."]}, {"block": 69, "type": "code", "linesLength": 27, "startIndex": 587, "lines": ["# Get prediction results with the optimal modesl from different approaches.\n", "prediction_spark = model_best_spark.transform(test)\n", "prediction_hyperopt = model_best_hyperopt.transform(test)\n", "prediction_sample = model_best_sample.transform(test)\n", "\n", "predictions = [prediction_spark, prediction_hyperopt, prediction_sample]\n", "elapsed = [time_spark, time_hyperopt, time_sample]\n", "\n", "approaches = ['spark', 'hyperopt', 'sample']\n", "test_evaluations = pd.DataFrame()\n", "for ind, approach in enumerate(approaches):    \n", "    rating_eval = SparkRatingEvaluation(\n", "        test, \n", "        predictions[ind],\n", "        **HEADER\n", "    )\n", "    \n", "    result = pd.DataFrame({\n", "        'Approach': approach,\n", "        'RMSE': rating_eval.rmse(),\n", "        'MAE': rating_eval.mae(),\n", "        'Explained variance': rating_eval.exp_var(),\n", "        'R squared': rating_eval.rsquared(),\n", "        'Elapsed': elapsed[ind]\n", "    }, index=[0])\n", "    \n", "    test_evaluations = test_evaluations.append(result)"]}, {"block": 70, "type": "code", "linesLength": 1, "startIndex": 614, "lines": ["test_evaluations"]}, {"block": 71, "type": "markdown", "linesLength": 3, "startIndex": 615, "lines": ["From the results, it can be seen that, *with the same number of iterations*, Spark native construct based approach takes the least amount of time, even if there is no parallel computing. This is simply because Spark native constructs leverage the underlying Java codes for running the actual analytics with high performance efficiency. Interestingly, the run time for `hyperopt` with TPE algorithm and random search methods are almost the same. Possible reasons for this are that, the TPE algorithm searches optimal parameters intelligently but runs the tuning iterations sequentially. Also, the advantage of TPE may become obvious when there is a higher dimensionality of hyperparameters. \n", "\n", "The three approaches use the same RMSE loss. In this measure, the native Spark construct performs the best. The `hyperopt` based approach performs the second best, but the advantage is very subtle. It should be noted that these differences may be owing to many factors like characteristics of datasets, dimensionality of hyperparameter space, sampling size in the searching, etc. Note the differences in the RMSE metrics may also come from the randomness of the intermediate steps in parameter tuning process. In practice, multiple runs are required for generating statistically robust comparison results. We have tried 5 times for running the same comparison codes above. The results aligned well with each other in terms of objective metric values and elapsed time. "]}, {"block": 72, "type": "markdown", "linesLength": 1, "startIndex": 618, "lines": ["# Conclusions"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 619, "lines": ["In summary, there are mainly three different approaches for running hyperparameter tuning for Spark based recommendation algorithm. The three different approaches are compared as follows."]}, {"block": 74, "type": "markdown", "linesLength": 5, "startIndex": 620, "lines": ["|Approach|Distributed (on Spark)|Param sampling|Advanced hyperparam searching algo|Custom evaluation metrics|Custom data split|\n", "|---------|-------------|--------------|--------------------------|--------------|------------|\n", "|AzureML Services|Parallelizing Spark sessions on multi-node cluster or single Spark session on one VM node.)|Random, Grid, Bayesian sampling for discrete and continuous variables.|Bandit policy, Median stopping policy, and truncation selection policy.|Yes|Yes|\n", "|Spark native construct|Distributed in single-node standalone Spark environment or multi-node Spark cluster.|No|No|Need to re-engineer Spark modules|Need to re-engineer Spark modules.|\n", "|`hyperopt`|No (only support parallelization on MongoDB)|Random sampling for discrete and continuous variables.|Tree Parzen Estimator|Yes|Yes|"]}, {"block": 75, "type": "markdown", "linesLength": 8, "startIndex": 625, "lines": ["# References\n", "\n", "* Azure Machine Learning Services, url: https://azure.microsoft.com/en-us/services/machine-learning-service/\n", "* Lisa Li, *et al*, Hyperband: A Novel Bandit-Based Approach to Hyperparameter Optimization, The Journal of Machine Learning Research, Volume 18 Issue 1, pp 6765-6816, January 2017.\n", "* James Bergstrat *et al*, Algorithms for Hyper-Parameter Optimization, Procs 25th NIPS 2011. \n", "* `hyperopt`, url: http://hyperopt.github.io/hyperopt/.\n", "* Bergstra, J., Yamins, D., Cox, D. D. (2013) Making a Science of Model Search: Hyperparameter Optimization in Hundreds of Dimensions for Vision Architectures. Proc. of the 30th International Conference on Machine Learning (ICML 2013).\n", "* Kris Wright, \"Hyper parameter tuning with hyperopt\", url:https://districtdatalabs.silvrback.com/parameter-tuning-with-hyperopt"]}]
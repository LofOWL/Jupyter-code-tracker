[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["ThinkDSP, by Allen Downey\n", "\n", "This notebook contains code examples from Chapter 1: Sounds and Signals"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 3, "lines": ["`thinkdsp` is a module that accompanies ThinkDSP and provides classes and functions for working with signals.\n", "\n", "`thinkplot` is a wrapper around matplotlib."]}, {"block": 2, "type": "code", "linesLength": 2, "startIndex": 6, "lines": ["import thinkdsp\n", "import thinkplot"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Instantiate cosine and sine signals."]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["cos_sig = thinkdsp.CosSignal(freq=440, amp=1.0, offset=0)\n", "sin_sig = thinkdsp.SinSignal(freq=880, amp=0.5, offset=0)"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Plot three periods from each signal."]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["cos_sig.plot()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["sin_sig.plot()"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["The sum of two signals is a SumSignal."]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["mix = sin_sig + cos_sig\n", "mix"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["A Signal represents a mathematical function defined for all values of time.  If you evaluate a signal at a sequence of equally-spaced times, the result is a Wave.  `framerate` is the number of samples per second."]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["wave = mix.make_wave(duration=0.5, start=0, framerate=11025)\n", "wave"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["IPython provides an Audio widget that can play a wave."]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 21, "lines": ["from IPython.display import Audio\n", "audio = Audio(data=wave.ys, rate=wave.framerate)\n", "audio"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Wave also provides `make_audio()`, which does the same thing:"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["wave.make_audio()"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["The `ys` attribute is a NumPy array that contains the values from the signal.  The interval between samples is the inverse of the framerate."]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["print 'Number of samples', len(wave.ys)\n", "print 'Timestep in ms', 1.0 / wave.framerate * 1000"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Signal objects that represent periodic signals have a `period` attribute.  Wave provides `segment`, which creates a new wave."]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["period = mix.period\n", "segment = wave.segment(start=0, duration=period*3)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Wave provides `plot`"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["segment.plot()"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 34, "lines": ["`normalize` scales a wave so the range doesn't exceed -1 to 1.\n", "\n", "`apodize` tapers the beginning and end of the wave so it doesn't click when you play it."]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 37, "lines": ["wave.normalize()\n", "wave.apodize()\n", "wave.plot()"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["You can write a wave to a WAV file."]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 41, "lines": ["filename = 'temp.wav'\n", "wave.write('temp.wav')"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["`play_wave` writes the wave to a file and then uses an exernal player."]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["thinkdsp.play_wave(filename='temp.wav', player='aplay')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["`read_wave` reads WAV files.  The WAV examples in the book are from freesound.org."]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 46, "lines": [" wave = thinkdsp.read_wave('92002__jcveliz__violin-origional.wav')"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["I pulled out a segment of this recording where the pitch is constant"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 48, "lines": ["start = 1.2\n", "duration = 0.6\n", "segment = wave.segment(start, duration)"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["`make_spectrum` computes the spectrum of the wave."]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["spectrum = segment.make_spectrum()"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Spectrum provides `plot`"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["spectrum.plot()"]}, {"block": 36, "type": "markdown", "linesLength": 0, "startIndex": 55, "lines": []}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["spectrum.low_pass(1800)"]}, {"block": 38, "type": "markdown", "linesLength": 0, "startIndex": 56, "lines": []}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["spectrum.plot()"]}, {"block": 40, "type": "markdown", "linesLength": 0, "startIndex": 57, "lines": []}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 57, "lines": ["filtered = spectrum.make_wave()\n", "filtered.plot()"]}, {"block": 42, "type": "markdown", "linesLength": 0, "startIndex": 59, "lines": []}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 59, "lines": ["filtered.normalize()\n", "filtered.plot()"]}, {"block": 44, "type": "markdown", "linesLength": 0, "startIndex": 61, "lines": []}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 61, "lines": ["segment.apodize()\n", "segment.plot()"]}, {"block": 46, "type": "markdown", "linesLength": 0, "startIndex": 63, "lines": []}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 63, "lines": ["filtered.apodize()\n", "filtered.plot()"]}, {"block": 48, "type": "markdown", "linesLength": 0, "startIndex": 65, "lines": []}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["segment.make_audio()"]}, {"block": 50, "type": "markdown", "linesLength": 0, "startIndex": 66, "lines": []}, {"block": 51, "type": "markdown", "linesLength": 0, "startIndex": 66, "lines": []}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["filtered.make_audio()"]}, {"block": 53, "type": "markdown", "linesLength": 0, "startIndex": 67, "lines": []}, {"block": 54, "type": "code", "linesLength": 0, "startIndex": 67, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code solutions to exercises in Chapter 3: Non-periodic signals\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 8, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "\n", "import numpy as np\n", "\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 5, "startIndex": 15, "lines": ["**Exercise:** Run and listen to the examples in chap03.ipynb.  In the leakage example, try replacing the Hamming window with one of the other windows provided by NumPy, and see what effect they have on leakage. \n", "\n", "See http://docs.scipy.org/doc/numpy/reference/routines.window.html\n", "\n", "Here's the leakage example:"]}, {"block": 3, "type": "code", "linesLength": 8, "startIndex": 20, "lines": ["signal = thinkdsp.SinSignal(freq=440)\n", "duration = signal.period * 30.25\n", "wave = signal.make_wave(duration)\n", "spectrum = wave.make_spectrum()\n", "\n", "thinkplot.preplot(1)\n", "spectrum.plot(high=50)\n", "thinkplot.config(xlabel='frequency (Hz)', ylabel='amplitude', legend=False)"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["The following figure shows the effect of 4 different windows."]}, {"block": 5, "type": "code", "linesLength": 11, "startIndex": 29, "lines": ["thinkplot.preplot(4)\n", "\n", "for window_func in [np.bartlett, np.blackman, np.hamming, np.hanning]:\n", "    wave = signal.make_wave(duration)\n", "    wave.ys *= window_func(len(wave.ys))\n", "\n", "    spectrum = wave.make_spectrum()\n", "    spectrum.plot(high=50, label=window_func.__name__)\n", "\n", "    \n", "thinkplot.config(xlabel='frequency (Hz)', ylabel='amplitude', legend=True)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["All four do a good job of reducing leakage.  The Bartlett filter leaves some residual \"ringing\".  The Hamming filter dissipates the least amount of energy. "]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["**Exercise 3.2**: Write a class called `SawtoothChirp` that extends `Chirp` and overrides evaluate to generate a sawtooth waveform with frequency that increases (or decreases) linearly."]}, {"block": 8, "type": "code", "linesLength": 20, "startIndex": 42, "lines": ["import math\n", "PI2 = 2 * math.pi\n", "\n", "class SawtoothChirp(thinkdsp.Chirp):\n", "    \"\"\"Represents a sawtooth signal with varying frequency.\"\"\"\n", "\n", "    def _evaluate(self, ts, freqs):\n", "        \"\"\"Helper function that evaluates the signal.\n", "\n", "        ts: float array of times\n", "        freqs: float array of frequencies during each interval\n", "        \"\"\"\n", "        dts = numpy.diff(ts)\n", "        dps = PI2 * freqs * dts\n", "        phases = numpy.cumsum(dps)\n", "        phases = numpy.insert(phases, 0, 0)\n", "        cycles = phases / PI2\n", "        frac, _ = numpy.modf(cycles)\n", "        ys = thinkdsp.normalize(thinkdsp.unbias(frac), self.amp)\n", "        return ys\n"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Here's what it sounds like."]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 63, "lines": ["signal = SawtoothChirp(start=220, end=880)\n", "wave = signal.make_wave(duration=2, framerate=10000)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["And here's the spectrogram."]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 68, "lines": ["sp = wave.make_spectrogram(1024)\n", "sp.plot()\n", "thinkplot.config(xlabel='time (s)', ylabel='frequency (Hz)', legend=False)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["At a relatively low frame rate, you can see the aliased harmonics bouncing off the folding frequency.  And you can hear them as a background hiss.  If you crank up the frame rate, they go away."]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["**Exercise 3.3**: In musical terminology, a \u201cglissando\u201d is a note that slides from one pitch to another, so it is similar to a chirp. A trombone player can play a glissando by extending the trombone slide while blowing continuously. As the slide extends, the total length of the tube gets longer, and the resulting pitch is inversely proportional to length."]}, {"block": 15, "type": "code", "linesLength": 14, "startIndex": 73, "lines": ["class TromboneGliss(thinkdsp.Chirp):\n", "    \"\"\"Represents a trombone-like signal with varying frequency.\"\"\"\n", "    \n", "    def evaluate(self, ts):\n", "        \"\"\"Evaluates the signal at the given times.\n", "\n", "        ts: float array of times\n", "        \n", "        returns: float wave array\n", "        \"\"\"\n", "        l1, l2 = 1.0 / self.start, 1.0 / self.end\n", "        lengths = numpy.linspace(l1, l2, len(ts)-1)\n", "        freqs = 1 / lengths\n", "        return self._evaluate(ts, freqs)"]}, {"block": 16, "type": "markdown", "linesLength": 5, "startIndex": 87, "lines": ["Write a function that simulates a trombone glissando from C4 up to F4 and back down to C4. C3 is 262 Hz; F3 is 349 Hz.\n", "\n", "Assuming that the player moves the slide at a constant speed, how does frequency vary with time? Is a trombone glissando more like a linear or exponential chirp?\n", "\n", "Here's the first part of the wave:"]}, {"block": 17, "type": "code", "linesLength": 6, "startIndex": 92, "lines": ["low = 262\n", "high = 340\n", "signal = TromboneGliss(high, low)\n", "wave1 = signal.make_wave(duration=1)\n", "wave1.apodize()\n", "wave1.make_audio()"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["And the second part:"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 99, "lines": ["signal = TromboneGliss(low, high)\n", "wave2 = signal.make_wave(duration=1)\n", "wave2.apodize()\n", "wave2.make_audio()"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Putting them together:"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 104, "lines": ["wave = wave1 | wave2\n", "wave.make_audio()"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["Here's the spectrogram:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 107, "lines": ["sp = wave.make_spectrogram(1024)\n", "sp.plot(high=40)"]}, {"block": 24, "type": "markdown", "linesLength": 2, "startIndex": 109, "lines": ["**Exercise 3.4**  Find or make a recording of a glissando and plot a spectrogram of the\n", "first few seconds.  "]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 111, "lines": ["wave = thinkdsp.read_wave('72475__rockwehrmann__glissup02.wav')\n", "wave.make_audio()"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 113, "lines": ["wave.make_spectrogram(512).plot(high=50)"]}, {"block": 27, "type": "markdown", "linesLength": 2, "startIndex": 114, "lines": ["**Exercise 3.5**  Make or find a recording of a series of vowel sounds and look at the\n", "spectrogram.  Can you identify different vowels?"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 116, "lines": ["wave = thinkdsp.read_wave('87778__marcgascon7__vocals.wav')\n", "wave.make_audio()"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["wave.make_spectrogram(1024).plot(high=50)"]}, {"block": 30, "type": "markdown", "linesLength": 5, "startIndex": 119, "lines": ["The stripe across the bottom is probably background noise.  The peaks in the spectrogram are called \"formants\".\n", "\n", "In general, vowel sounds are distinguished by the amplitude ratios of the first two formants relative to the fundamental.  For more, see https://en.wikipedia.org/wiki/Formant\n", "\n", "We can see the formats more clearly by selecting a segment during 'ah'."]}, {"block": 31, "type": "code", "linesLength": 5, "startIndex": 124, "lines": ["high = 300\n", "thinkplot.preplot(5)\n", "\n", "segment = wave.segment(start=1, duration=0.25)\n", "segment.make_spectrum().plot(high=high)"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["The fundamental is near 100 Hz.  The next highest peaks are at 200 Hz and 700 Hz.  People who know more about this than I do can identify vowels by looking at spectrums, but I can't."]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 130, "lines": ["segment = wave.segment(start=2.2, duration=0.25)\n", "segment.make_spectrum().plot(high=high)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 132, "lines": ["The 'eh' segment has a high-amplitude formant near 500 Hz."]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 133, "lines": ["segment = wave.segment(start=3.5, duration=0.25)\n", "segment.make_spectrum().plot(high=high)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 135, "lines": ["The 'ih' segment has no high frequency components."]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 136, "lines": ["segment = wave.segment(start=5.1, duration=0.25)\n", "segment.make_spectrum().plot(high=high)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["The 'aw' segment has a high-amplitude formant near 500 Hz, even higher than the fundamental."]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 139, "lines": ["segment = wave.segment(start=6.5, duration=0.25)\n", "segment.make_spectrum().plot(high=high)"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 141, "lines": ["The 'eu' segment has a high-amplitude formant near 300 Hz and no high-frequency components"]}, {"block": 41, "type": "code", "linesLength": 0, "startIndex": 142, "lines": []}]
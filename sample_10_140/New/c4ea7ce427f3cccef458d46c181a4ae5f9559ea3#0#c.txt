[{"block": 0, "type": "markdown", "linesLength": 9, "startIndex": 0, "lines": ["## ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 11: Modulation and sampling\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "Special thanks to my colleague Siddhartan Govindasamy; the sequence of topics in this notebook is based on material he developed for Signals and Systems at Olin College, which he and Oscar Mur-Miranda and I co-taught in Spring 2015.\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 6, "startIndex": 9, "lines": ["# Get thinkdsp.py\n", "\n", "import os\n", "\n", "if not os.path.exists('thinkdsp.py'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/thinkdsp.py"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 15, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "\n", "from thinkdsp import decorate"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["## Convolution with impulses\n", "\n", "To demonstrate the effect of convolution with impulses, I'll load a short beep sound."]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["if not os.path.exists('253887__themusicalnomad__positive-beeps.wav'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/253887__themusicalnomad__positive-beeps.wav"]}, {"block": 5, "type": "code", "linesLength": 5, "startIndex": 24, "lines": ["from thinkdsp import read_wave\n", "\n", "wave = read_wave('253887__themusicalnomad__positive-beeps.wav')\n", "wave.normalize()\n", "wave.plot()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Here's what it sounds like."]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["wave.make_audio()"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["And here's a sequence of 4 impulses with diminishing amplitudes:"]}, {"block": 9, "type": "code", "linesLength": 6, "startIndex": 32, "lines": ["from thinkdsp import Impulses\n", "\n", "imp_sig = Impulses([0.005, 0.3, 0.6, 0.9], amps=[1, 0.5, 0.25, 0.1])\n", "impulses = imp_sig.make_wave(start=0, duration=1.0, framerate=wave.framerate)\n", "impulses.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["If we convolve the wave with the impulses, we get 4 shifted, scaled copies of the original sound."]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 39, "lines": ["convolved = wave.convolve(impulses)\n", "convolved.plot()"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["And here's what it sounds like."]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["convolved.make_audio()"]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 43, "lines": ["## Amplitude modulation (AM)\n", "\n", "The previous example gives some insight into how AM works.\n", "\n", "First I'll load a recording that sounds like AM radio."]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 48, "lines": ["if not os.path.exists('105977__wcfl10__favorite-station.wav'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/105977__wcfl10__favorite-station.wav"]}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 50, "lines": ["wave = read_wave('105977__wcfl10__favorite-station.wav')\n", "wave.unbias()\n", "wave.normalize()\n", "wave.make_audio()"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Here's what the spectrum looks like:"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 55, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["For the following examples, it will be more useful to look at the full spectrum, which includes the negative frequencies.  Since we are starting with a real signal, the spectrum is always symmetric."]}, {"block": 20, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["spectrum = wave.make_spectrum(full=True)\n", "spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Amplitude modulation works my multiplying the input signal by a \"carrier wave\", which is a cosine, 10 kHz in this example."]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 63, "lines": ["from thinkdsp import CosSignal\n", "\n", "carrier_sig = CosSignal(freq=10000)\n", "carrier_wave = carrier_sig.make_wave(duration=wave.duration, framerate=wave.framerate)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["The `*` operator performs elementwise multiplication."]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["modulated = wave * carrier_wave"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["The result sounds pretty horrible."]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["modulated.make_audio()"]}, {"block": 27, "type": "markdown", "linesLength": 3, "startIndex": 71, "lines": ["Why?  Because multiplication in the time domain corresponds to convolution in the frequency domain.  The DFT of the carrier wave is two impulses; convolution with those impulses makes shifted, scaled copies of the spectrum.\n", "\n", "Specifically, AM modulation has the effect of splitting the spectrum in two halves and shifting the frequencies by 10 kHz (notice that the amplitudes are half what they were in the previous plot)."]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 74, "lines": ["modulated.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["To recover the signal, we modulate it again."]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["demodulated = modulated * carrier_wave"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["Each half of the spectrum gets split and shifted again.  Two of the quarters get shifted to 0 and added up.  The other two are at $\\pm$20Khz"]}, {"block": 32, "type": "code", "linesLength": 3, "startIndex": 79, "lines": ["demodulated_spectrum = demodulated.make_spectrum(full=True)\n", "demodulated_spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["If you listen to it now, it sounds pretty good.  You probably can't hear the extra components at high frequencies."]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 83, "lines": ["demodulated.make_audio()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["If we compare the input and output signals, they are pretty close."]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 85, "lines": ["wave.plot()\n", "demodulated.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["If the high frequency components bother you, you can clobber them by applying a low pass filter.  In this example, I use a \"brick wall\" filter that cuts off sharply at 10 kHz.  In real applications, we would use a more gentle filter."]}, {"block": 38, "type": "code", "linesLength": 3, "startIndex": 89, "lines": ["demodulated_spectrum.low_pass(10000)\n", "demodulated_spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Here's what it sounds like after filtering."]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 93, "lines": ["filtered = demodulated_spectrum.make_wave()\n", "filtered.make_audio()"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 95, "lines": ["To understand how AM works, let's see what's going on in the frequency domain.\n", "\n", "When we multiply two signals in the time domain, that corresponds to convolution in the frequency domain.  The carrier wave is a cosine at 10 kHz, so its spectrum is two impulses, at $\\pm$ 10 kHz"]}, {"block": 42, "type": "code", "linesLength": 3, "startIndex": 98, "lines": ["carrier_spectrum = carrier_wave.make_spectrum(full=True)\n", "carrier_spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["As we saw in the beep example, convolution with impulses makes shifted, scaled copies."]}, {"block": 44, "type": "code", "linesLength": 3, "startIndex": 102, "lines": ["convolved = spectrum.convolve(carrier_spectrum)\n", "convolved.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["After one convolution, we have two peaks.  After two convolutions, we have four."]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 106, "lines": ["reconvolved = convolved.convolve(carrier_spectrum)\n", "reconvolved.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["And that's how AM works.  Now let's talk about sampling."]}, {"block": 48, "type": "markdown", "linesLength": 3, "startIndex": 110, "lines": ["## Sampling\n", "\n", "I'll start with a recording of a drum break.  If you don't know about the Amen break, you might want to read this: https://en.wikipedia.org/wiki/Amen_break"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 113, "lines": ["if not os.path.exists('263868__kevcio__amen-break-a-160-bpm.wav'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/263868__kevcio__amen-break-a-160-bpm.wav"]}, {"block": 50, "type": "code", "linesLength": 4, "startIndex": 115, "lines": ["wave = read_wave('263868__kevcio__amen-break-a-160-bpm.wav')\n", "wave.normalize()\n", "wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["This signal is sampled at 44100 Hz.  Here's what it sounds like."]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 120, "lines": ["wave.make_audio()"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 121, "lines": ["And here's the spectrum:"]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 122, "lines": ["wave.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 124, "lines": ["Even though this signal has already been sampled, let's pretend it hasn't.  So we'll treat the original wave as if it were a continuous analog signal.\n", "\n", "Now I'm going to sample it at 1/4 of the framerate (11025 Hz) by keeping every 4th sample and setting the rest to zero."]}, {"block": 56, "type": "code", "linesLength": 11, "startIndex": 127, "lines": ["from thinkdsp import Wave\n", "\n", "def sample(wave, factor):\n", "    \"\"\"Simulates sampling of a wave.\n", "    \n", "    wave: Wave object\n", "    factor: ratio of the new framerate to the original\n", "    \"\"\"\n", "    ys = np.zeros(len(wave))\n", "    ys[::factor] = wave.ys[::factor]\n", "    return Wave(ys, framerate=wave.framerate) "]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["The result doesn't sound very good.  It has a bunch of extra high frequency components."]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 139, "lines": ["sampled = sample(wave, 4)\n", "sampled.make_audio()"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 141, "lines": ["If we look at the spectrum, we can see the extra components."]}, {"block": 60, "type": "code", "linesLength": 2, "startIndex": 142, "lines": ["sampled.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 61, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["To understand where those came from, it helps to think of sampling as multiplication with an \"impulse train\".  The following function is similar to `sample`, but it makes the impulse train explicit."]}, {"block": 62, "type": "code", "linesLength": 7, "startIndex": 145, "lines": ["def make_impulses(wave, factor):\n", "    ys = np.zeros(len(wave))\n", "    ys[::factor] = 1\n", "    ts = np.arange(len(wave)) / wave.framerate\n", "    return Wave(ys, ts, wave.framerate)\n", "\n", "impulses = make_impulses(wave, 4)"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 152, "lines": ["Multiplying by `impulses` has the same effect as `sample`."]}, {"block": 64, "type": "code", "linesLength": 2, "startIndex": 153, "lines": ["sampled = wave * impulses\n", "sampled.make_audio()"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["Now if we look at the spectrum of `impulses`, we can see what's going on in the frequency domain."]}, {"block": 66, "type": "code", "linesLength": 2, "startIndex": 156, "lines": ["impulses.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 158, "lines": ["Multiplying by `impulses` makes 4 shifted copies of the original spectrum.  One of them wraps around from the negative end of the spectrum to the positive, which is why there are 5 peaks in the spectrum off the sampled wave."]}, {"block": 68, "type": "code", "linesLength": 9, "startIndex": 159, "lines": ["def show_impulses(wave, factor):\n", "    impulses = make_impulses(wave, factor)\n", "    plt.subplot(1, 2, 1)\n", "    impulses.segment(0, 0.001).plot_vlines(linewidth=2)\n", "    decorate(xlabel='Time (s)')\n", "    \n", "    plt.subplot(1, 2, 2)\n", "    impulses.make_spectrum(full=True).plot()\n", "    decorate(xlabel='Frequency (Hz)', xlim=[-22400, 22400])"]}, {"block": 69, "type": "markdown", "linesLength": 3, "startIndex": 168, "lines": ["As we take fewer samples, they get farther apart in the time domain and the copies of the spectrum get closer together in the frequency domain.\n", "\n", "As you vary the sampling factor, below, you can see the effect."]}, {"block": 70, "type": "code", "linesLength": 5, "startIndex": 171, "lines": ["from ipywidgets import interact, interactive, fixed\n", "import ipywidgets as widgets\n", "\n", "slider = widgets.IntSlider(min=2, max=32, value=4)\n", "interact(show_impulses, wave=fixed(wave), factor=slider);"]}, {"block": 71, "type": "markdown", "linesLength": 1, "startIndex": 176, "lines": ["To recover the original wave, we can apply a low pass filter to clobber the unwanted copies.  The wave was sampled at 11025 Hz, so we'll cut it off at the Nyquist frequency, 5512.5."]}, {"block": 72, "type": "code", "linesLength": 4, "startIndex": 177, "lines": ["spectrum = sampled.make_spectrum(full=True)\n", "spectrum.low_pass(5512.5)\n", "spectrum.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 73, "type": "markdown", "linesLength": 4, "startIndex": 181, "lines": ["The result sounds quite different from the original, for two reasons:\n", "\n", "1. Because we had to cut off frequencies about 5512.5 Hz, we lost some of the high frequency components of the original signal.\n", "2. Even for the frequencies below 5512.5 Hz, the spectrum is not quite right, because it includes contributions leftover from the extra copies."]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 185, "lines": ["filtered = spectrum.make_wave()\n", "filtered.make_audio()"]}, {"block": 75, "type": "markdown", "linesLength": 1, "startIndex": 187, "lines": ["We can see that the original and the sampled/filtered signal are not the same:"]}, {"block": 76, "type": "code", "linesLength": 5, "startIndex": 188, "lines": ["def plot_segments(original, filtered):\n", "    start = 1\n", "    duration = 0.01\n", "    original.segment(start=start, duration=duration).plot(color='gray')\n", "    filtered.segment(start=start, duration=duration).plot()"]}, {"block": 77, "type": "code", "linesLength": 1, "startIndex": 193, "lines": ["plot_segments(wave, filtered)"]}, {"block": 78, "type": "markdown", "linesLength": 5, "startIndex": 194, "lines": ["Sampling didn't work very well with this signal because it contains a lot of components above the Nyquist frequency.\n", "\n", "## Sampling, take two\n", "\n", "Let's try again with a bass guitar intro (can you name that tune?).\n"]}, {"block": 79, "type": "code", "linesLength": 2, "startIndex": 199, "lines": ["if not os.path.exists('328878__tzurkan__guitar-phrase-tzu.wav'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/328878__tzurkan__guitar-phrase-tzu.wav"]}, {"block": 80, "type": "code", "linesLength": 4, "startIndex": 201, "lines": ["wave = read_wave('328878__tzurkan__guitar-phrase-tzu.wav')\n", "wave.normalize()\n", "wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 205, "lines": ["Unless you have good speakers, it might not sound very good."]}, {"block": 82, "type": "code", "linesLength": 1, "startIndex": 206, "lines": ["wave.make_audio()"]}, {"block": 83, "type": "markdown", "linesLength": 1, "startIndex": 207, "lines": ["Here's the spectrum.  Not a lot of high frequency components!"]}, {"block": 84, "type": "code", "linesLength": 2, "startIndex": 208, "lines": ["wave.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 85, "type": "markdown", "linesLength": 1, "startIndex": 210, "lines": ["Here's the spectrum after sampling:"]}, {"block": 86, "type": "code", "linesLength": 3, "startIndex": 211, "lines": ["sampled = sample(wave, 4)\n", "sampled.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 214, "lines": ["And here's what it sounds like:"]}, {"block": 88, "type": "code", "linesLength": 1, "startIndex": 215, "lines": ["sampled.make_audio()"]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 216, "lines": ["Now, instead of using `Spectrum.low_pass`, I'm going to make the low pass filter explicitly.  I'm calling it `boxcar` because it looks like the boxcar smoothing window from Chapter 8."]}, {"block": 90, "type": "code", "linesLength": 16, "startIndex": 217, "lines": ["from thinkdsp import Spectrum\n", "\n", "def make_boxcar(spectrum, factor):\n", "    \"\"\"Makes a boxcar filter for the given spectrum.\n", "    \n", "    spectrum: Spectrum to be filtered\n", "    factor: sampling factor\n", "    \"\"\"\n", "    fs = np.copy(spectrum.fs)\n", "    hs = np.zeros_like(spectrum.hs)\n", "    \n", "    cutoff = spectrum.framerate / 2 / factor\n", "    for i, f in enumerate(fs):\n", "        if abs(f) <= cutoff:\n", "            hs[i] = 1\n", "    return Spectrum(hs, fs, spectrum.framerate, full=spectrum.full)"]}, {"block": 91, "type": "markdown", "linesLength": 1, "startIndex": 233, "lines": ["Here's what it looks like:"]}, {"block": 92, "type": "code", "linesLength": 4, "startIndex": 234, "lines": ["spectrum = sampled.make_spectrum(full=True)\n", "boxcar = make_boxcar(spectrum, 4)\n", "boxcar.plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 93, "type": "markdown", "linesLength": 1, "startIndex": 238, "lines": ["Now we can apply the filter by multiplying in the frequency domain."]}, {"block": 94, "type": "code", "linesLength": 4, "startIndex": 239, "lines": ["filtered = (spectrum * boxcar).make_wave()\n", "filtered.scale(4)\n", "filtered.make_spectrum(full=True).plot()\n", "decorate(xlabel='Frequency (Hz)')"]}, {"block": 95, "type": "markdown", "linesLength": 1, "startIndex": 243, "lines": ["Now if we listen to the sampled/filtered wave, it sounds pretty good."]}, {"block": 96, "type": "code", "linesLength": 1, "startIndex": 244, "lines": ["filtered.make_audio()"]}, {"block": 97, "type": "markdown", "linesLength": 1, "startIndex": 245, "lines": ["And if we compare it to the original, it is almost identical."]}, {"block": 98, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["plot_segments(wave, filtered)\n", "decorate(xlabel='Time (s)')"]}, {"block": 99, "type": "markdown", "linesLength": 1, "startIndex": 248, "lines": ["It's not completely identical because the original signal had some tiny components above the Nyquist frequency.  But the differences are small."]}, {"block": 100, "type": "code", "linesLength": 3, "startIndex": 249, "lines": ["diff = wave.ys - filtered.ys\n", "plt.plot(diff.real)\n", "np.mean(abs(diff))"]}, {"block": 101, "type": "markdown", "linesLength": 1, "startIndex": 252, "lines": ["Multiplying the spectrum of the sampled signal and the boxcar filter, in the frequency domain, corresponds to convolution in the time domain.  And you might wonder what the convolution window looks like.  We can find out by computing the wave that corresponds to the boxcar filter."]}, {"block": 102, "type": "code", "linesLength": 4, "startIndex": 253, "lines": ["sinc = boxcar.make_wave()\n", "ys = np.roll(sinc.ys, 50)\n", "plt.plot(ys[:100].real)\n", "decorate(xlabel='Index')"]}, {"block": 103, "type": "markdown", "linesLength": 5, "startIndex": 257, "lines": ["It's the sinc function, which you can read about at https://en.wikipedia.org/wiki/Sinc_function\n", "\n", "## Sinc interpolation\n", "\n", "Multiplying by a boxcar filter corresponds to convolution with a sinc function, which has the effect of interpolating between the samples.  To see how that works, let's zoom in on a short segment of the signal:"]}, {"block": 104, "type": "code", "linesLength": 7, "startIndex": 262, "lines": ["start = 1.0\n", "duration = 0.01\n", "factor = 8\n", "\n", "short = wave.segment(start=start, duration=duration)\n", "short.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 105, "type": "markdown", "linesLength": 1, "startIndex": 269, "lines": ["Now I'll sample the signal and show the samples using vertical lines:"]}, {"block": 106, "type": "code", "linesLength": 3, "startIndex": 270, "lines": ["sampled = sample(short, factor)\n", "sampled.plot_vlines(color='gray')\n", "decorate(xlabel='Time(s)')"]}, {"block": 107, "type": "markdown", "linesLength": 5, "startIndex": 273, "lines": ["We can use the sampled spectrum to construct the sinc function.  In this example I\n", "\n", "1. Shift the sinc function in time so it lines up with the sampled segment (both start at 1.0 seconds).\n", "\n", "2. Roll the sinc function so the peak is in the middle, just because it looks better that way."]}, {"block": 108, "type": "code", "linesLength": 8, "startIndex": 278, "lines": ["spectrum = sampled.make_spectrum()\n", "boxcar = make_boxcar(spectrum, factor)\n", "sinc = boxcar.make_wave()\n", "sinc.shift(sampled.ts[0])\n", "sinc.roll(len(sinc)//2)\n", "\n", "sinc.plot()\n", "decorate(xlabel='Time(s)')"]}, {"block": 109, "type": "markdown", "linesLength": 1, "startIndex": 286, "lines": ["The following figure shows how convolution makes lots of shifted, scaled copies of the sinc function and adds them up. "]}, {"block": 110, "type": "code", "linesLength": 35, "startIndex": 287, "lines": ["def plot_sinc_demo(wave, factor, start=None, duration=None):\n", "\n", "    def make_sinc(t, i, y):\n", "        \"\"\"Makes a shifted, scaled copy of the sinc function.\"\"\"\n", "        sinc = boxcar.make_wave()\n", "        sinc.shift(t)\n", "        sinc.roll(i)\n", "        sinc.scale(y * factor)\n", "        return sinc\n", " \n", "    def plot_sincs(wave):\n", "        \"\"\"Plots sinc functions for each sample in wave.\"\"\"\n", "        t0 = wave.ts[0]\n", "        for i in range(0, len(wave), factor):\n", "            sinc = make_sinc(t0, i, wave.ys[i])\n", "            seg = sinc.segment(start, duration)\n", "            seg.plot(color='green', linewidth=0.5, alpha=0.3)\n", "            if i == 0:\n", "                total = sinc\n", "            else:\n", "                total += sinc\n", "            \n", "        seg = total.segment(start, duration)        \n", "        seg.plot(color='blue', alpha=0.5)\n", "\n", "    sampled = sample(wave, factor)\n", "    spectrum = sampled.make_spectrum()\n", "    boxcar = make_boxcar(spectrum, factor)\n", "\n", "    start = wave.start if start is None else start\n", "    duration = wave.duration if duration is None else duration\n", "        \n", "    sampled.segment(start, duration).plot_vlines(color='gray')\n", "    wave.segment(start, duration).plot(color='gray')\n", "    plot_sincs(wave)"]}, {"block": 111, "type": "code", "linesLength": 3, "startIndex": 322, "lines": ["# CAUTION: don't call plot_sinc_demo with a large wave or it will\n", "# fill memory and crash\n", "plot_sinc_demo(short, 4)"]}, {"block": 112, "type": "markdown", "linesLength": 9, "startIndex": 325, "lines": ["In this figure:\n", "\n", "1. The thin green lines are the shifted, scaled copies of the sinc function.\n", "2. The blue line is the sum of the sinc functions.\n", "3. The gray line (which you mostly can't see) is the original function.\n", "\n", "The sum of the sinc functions interpolates between the samples and recovers the original wave.  At the beginning and end, where the interpolation deviates from the original; the problem is that the original is not periodic, so the sinc interpolation breaks at the boundaries.\n", "\n", "If we zoom in on a short segment, we can see how it works more clearly."]}, {"block": 113, "type": "code", "linesLength": 5, "startIndex": 334, "lines": ["start = short.start + 0.004\n", "duration = 0.00061\n", "plot_sinc_demo(short, 4, start, duration)\n", "decorate(xlim=[start, start+duration],\n", "         ylim=[-0.05, 0.17])"]}, {"block": 114, "type": "markdown", "linesLength": 7, "startIndex": 339, "lines": ["The vertical gray lines are the samples.\n", "\n", "Again, the thin green lines are the shifted, scaled copies of the sinc function.\n", "\n", "In this segment, the interpolation matches the original wave very well.\n", "\n", "Notice that each sinc function has a peak at the location of one sample and the value 0 at every other sample location.  That way, when we add them up, the sum passes through each of the samples."]}, {"block": 115, "type": "code", "linesLength": 0, "startIndex": 346, "lines": []}]
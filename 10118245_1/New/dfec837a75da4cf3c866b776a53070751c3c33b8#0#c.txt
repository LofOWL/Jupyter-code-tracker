[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Autres librairies de visualisation"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Pour conclure cette s\u00e9quence sur les outils de visualisation, nous allons tr\u00e8s rapidement \u00e9voquer des alternatives \u00e0 la bibliot\u00e8que `matplotlib`, sachant qu'il existe en r\u00e9alit\u00e9 un tr\u00e8s grand nombre de biblioth\u00e8ques en d\u00e9veloppement dans ce domaine en pleine expansion."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Le poids du pass\u00e9"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 9, "lines": ["On a vu que `matplotlib` est un outil relativement complet. Toutefois, on peut lui reprocher deux d\u00e9fauts majeurs.\n", "\n", "* D'une part, `matplotlib` a choisi d'offrir une interface aussi proche que possible de ce qui existait pr\u00e9alablement en MatLab. C'est un choix tout \u00e0 fait judicieux dans l'optique d'attirer la communaut\u00e9 utilisatrice de MatLab \u00e0 des outils open source bas\u00e9s sur python et numpy. Mais en contrepartie cela implique d'adopter tels quels des choix de conception.\n", "\n", "* Et notamment, en suivant cette approche on h\u00e9rite d'un mod\u00e8le mental qui est plus orient\u00e9 vers la sortie vers du papier que vers la cr\u00e9ation de documents interactifs. "]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Ceci, ajout\u00e9 \u00e0 l'explosion du domaine de l'analyse et de la visualisation de donn\u00e9es, explique la largeur de l'offre en termes de biblioth\u00e8ques de visualisation alternatives."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["### `bokeh`"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 16, "lines": ["Parmi celles-ci, nous voulons vous signaler notamment la biblioth\u00e8que [`bokeh`](https://bokeh.pydata.org/en/latest/), qui est d\u00e9velopp\u00e9e principalement par Anaconda. \n", "\n", "`bokeh` pr\u00e9sente quelques bonnes propri\u00e9t\u00e9s qui nous semblent m\u00e9riter d'\u00eatre signal\u00e9es."]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["Pour commencer cette biblioth\u00e8que utilise une architecture qui permet de *penser la visualisation comme quelque chose d'interactif* (disons une page html), et non pas de fig\u00e9 comme lorsqu'on pense en termes de feuille de papier. Notamment elle permet de faire collaborer du code python avec du code JavaScript, qui offre imm\u00e9diatement des possibilit\u00e9s bien plus pertinentes lorsqu'il s'agit de cr\u00e9er des interactions utilisateur qui soient attractives et efficaces. Signalons en passant, \u00e0 cet \u00e9gard, qu'elle utilise [la librairie JavaScript `d3.js`](https://d3js.org/), qui est devenu un standard de fait plus ou moins incontournable dans le domaine de la visualisation.\n", "\n", "En tout \u00e9tat de cause, elle offre une interface de programmation qui tient compte d'environnements comme les notebooks, ce qui peut s'av\u00e9rer un atout pr\u00e9cieux si vous utilisez massivement ce support, comme on va le voir, pr\u00e9cis\u00e9ment, dans ce notebook."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Il peut aussi \u00eatre int\u00e9ressant de savoir que `bokeh` offre des possibilit\u00e9s natives de [visualisation de graphes](https://bokeh.pydata.org/en/latest/docs/user_guide/graph.html) et de [ donn\u00e9es g\u00e9ographiques](https://bokeh.pydata.org/en/latest/docs/user_guide/geo.html#)."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Par contre \u00e0 ce stade du d\u00e9veloppement, la visualisation en 3D n'est sans doute pas le point fort de `bokeh`. C'est une option qui reste possible (voir [par exemple ceci](https://github.com/bokeh/bokeh/tree/master/examples/app/surface3d)), mais cela est pour l'instant consid\u00e9r\u00e9 comme une extension de la librairie, et donc n'est accessible qu'au prix de l'\u00e9criture de code javascript."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Pour une pr\u00e9sentation plus compl\u00e8te, je vous renvoie \u00e0 [la documentation utilisateur](https://bokeh.pydata.org/en/latest/docs/user_guide.html)."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### `bokeh` dans les notebooks"]}, {"block": 14, "type": "markdown", "linesLength": 3, "startIndex": 26, "lines": ["Nous allons rapidement illustrer ici comment `bokeh` s'interface avec l'environnement des notebooks pour cr\u00e9er une visualisation interactive. Vous remarquerez que dans le code qui suit, on n'a **pas eu besoin de mentionner** de *magic* ipython, comme lorsqu'on avait du faire dans le compl\u00e9ement sur les notebooks interactifs\u00a0:\n", "\n", "    %matplotlib notebook"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["import numpy as np"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["# l'attirail de notebooks interactifs\n", "from ipywidgets import interact, fixed, FloatSlider"]}, {"block": 17, "type": "code", "linesLength": 7, "startIndex": 32, "lines": ["# les imports pour bokeh \n", "from bokeh.plotting import figure, show\n", "# dans la rubrique entr\u00e9e-sortie, on trouve\n", "# les outils pour produire du html \n", "#  (le mode par d\u00e9faut)\n", "# ou pour interactig avec un notebook\n", "from bokeh.io import push_notebook, output_notebook"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 39, "lines": ["# c'est cette d\u00e9claration qui remplace\n", "# si on veut la magic  '%matplotlib notebook'\n", "output_notebook()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["*****"]}, {"block": 20, "type": "code", "linesLength": 8, "startIndex": 43, "lines": ["# on cr\u00e9e un objet figure\n", "fig1 = figure(\n", "    title=\"fonctions trigonom\u00e9triques\",\n", "    plot_height=300, plot_width=600,\n", "    # c'est l\u00e0 notamment qu'on pr\u00e9cise\n", "    # l'intervalle en y\n", "    y_range=(-5, 5),\n", ")"]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 51, "lines": ["# on initialise la figure en cr\u00e9ant \n", "# un objet courbe \n", "x = np.linspace(0, 2*np.pi, 2000)\n", "y = np.sin(x)\n", "courbe_trigo = fig1.line(x, y, color=\"#2222aa\", line_width=3)"]}, {"block": 22, "type": "code", "linesLength": 17, "startIndex": 56, "lines": ["# la fonction de mise \u00e0 jour, qui sera connect\u00e9e\n", "# \u00e0 interact\n", "def update_trigo(function_name, frequence=1,\n", "                 amplitude=1, phase=0, \n", "                 # l'objet handle correspond \n", "                 # \u00e0 une figure \u00e0 mettre \u00e0 jour\n", "                 *, handle):\n", "    # juste une astuce pour pouvoir choisir \n", "    # la fonction trigonom\u00e9trique, qu'on recherche\n", "    # dans le module numpy\n", "    func = getattr(np, function_name)\n", "    # c'est ici qu'on modifie les donn\u00e9es\n", "    # utilis\u00e9es pour produire la courbe\n", "    courbe_trigo.data_source.data['y'] = \\\n", "       amplitude * func(frequence * x + phase)\n", "    # et c'est ici qu'on provoque la mise \u00e0 jour\n", "    push_notebook(handle)"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 73, "lines": ["# ou moment o\u00f9 mat\u00e9rialise l'objet figure\n", "# on r\u00e9cup\u00e8re une `handle` qui lui correspond\n", "handle1 = show(fig1, notebook_handle=True)"]}, {"block": 24, "type": "code", "linesLength": 7, "startIndex": 76, "lines": ["# maintenant on peut cr\u00e9er un interacteur\n", "interact(update_trigo, function_name=[\"sin\", \"cos\", \"tan\"],\n", "         frequence=(1,20),\n", "         amplitude=[0.5, 1, 3, 5],\n", "         phase=(0, 2*np.pi, 0.05),\n", "         handle=fixed(handle1),\n", "        );"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["*****"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["### distribution uniforme"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["Voyons un deuxi\u00e8me exemple avec `bokeh`. Vous pouvez prendre ceci comme un exercice, et le faire de votre cot\u00e9 avant de lire la suite du notebook."]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["On veut xxx ici"]}, {"block": 29, "type": "code", "linesLength": 9, "startIndex": 87, "lines": ["def uniform_distribution(N):\n", "    # on tire au hasard un rho et un rayon\n", "    rhos = 2 * np.pi * np.random.sample(N)\n", "    rads = np.random.sample(N)\n", "    # il faut prendre la racine carr\u00e9e du rayon \n", "    # sinon ce n'est pas uniforme dans le plan\n", "    circle_x = np.sqrt(rads) * np.cos(rhos)\n", "    circle_y = np.sqrt(rads) * np.sin(rhos)\n", "    return circle_x, circle_y"]}, {"block": 30, "type": "code", "linesLength": 7, "startIndex": 96, "lines": ["N = 1000\n", "radii = np.random.random(size=N) * .25\n", "reds = 50 + 200*np.random.random(size=N)\n", "greens = 30 + 220*np.random.random(size=N)\n", "colors = [f\"#{int(r):02x}{int(g):02x}{150:02x}\"\n", "          for r, g in zip(reds, greens)\n", "         ]"]}, {"block": 31, "type": "code", "linesLength": 5, "startIndex": 103, "lines": ["fig2 = figure(title=\"distribution uniforme\",\n", "              plot_height=300, plot_width=300,\n", "              x_range=(-10, 10),\n", "              y_range=(-10, 10),\n", "             )"]}, {"block": 32, "type": "code", "linesLength": 7, "startIndex": 108, "lines": ["x0, y0 = uniform_distribution(N)\n", "cloud = fig2.circle(\n", "    x0, y0, \n", "    radius = radii,\n", "    fill_color=colors, fill_alpha=0.6, \n", "    line_color=None, line_width=.1\n", ")"]}, {"block": 33, "type": "code", "linesLength": 9, "startIndex": 115, "lines": ["def update_cloud(rx, ry, dx, dy, alpha, handle):\n", "    # on recalcule les x et y \n", "    # \u00e0 partir des valeurs initiales\n", "    s, c = np.sin(alpha), np.cos(alpha)\n", "    x = dx + c * rx * x0 - s * ry * y0\n", "    y = dy + s * rx * x0 + c * ry * y0 \n", "    cloud.data_source.data['x'] = x\n", "    cloud.data_source.data['y'] = y\n", "    push_notebook(handle)"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["handle2 = show(fig2, notebook_handle=True)"]}, {"block": 35, "type": "code", "linesLength": 11, "startIndex": 125, "lines": ["interact(\n", "    update_cloud,\n", "    rx=FloatSlider(min=.5, max=8, \n", "                   step=.1, value=1.),\n", "    ry=FloatSlider(min=.5, max=8,\n", "                   step=.1, value=1.),\n", "    dx=(-3, +3, .2),\n", "    dy=(-3, +3, .2),\n", "    alpha=(0., np.pi, .05),\n", "    handle=fixed(handle2)\n", ");"]}]
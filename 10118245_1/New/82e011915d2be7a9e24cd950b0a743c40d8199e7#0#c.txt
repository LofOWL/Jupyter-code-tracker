[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `numpy` en dimension 1"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Dans cette premi\u00e8re partie nous allons commencer avec des tableaux \u00e0 une dimension, et voir comment les cr\u00e9er et les manipuler."]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 9, "lines": ["import numpy as np"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["### Cr\u00e9ation \u00e0 partir de donn\u00e9es"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["##### `np.array`"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["On peut cr\u00e9er un tableau numpy \u00e0 partir d'une liste - ou plus g\u00e9n\u00e9ralement un it\u00e9rable - avec la fonction `np.array` comme ceci\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 13, "lines": ["array = np.array([12, 25, 32, 55])\n", "array"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["**Attention**\u00a0: une erreur commune au d\u00e9but consiste \u00e0 faire ceci, qui ne marche pas\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 16, "lines": ["try:\n", "    array = np.array(1, 2, 3, 4)\n", "except Exception as e:\n", "    print(f\"OOPS, {type(e)}, {e}\")"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["\u00c7a marche aussi \u00e0 partir d'un it\u00e9rable\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["builtin_range = np.array(range(10))\n", "builtin_range"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### Cr\u00e9ation d'intervalles"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["##### `np.arange`"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Sauf que dans ce cas pr\u00e9cis on pr\u00e9f\u00e8rera utiliser directement la m\u00e9thode `arange` de `numpy`\u00a0:"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["numpy_range = np.arange(10)\n", "numpy_range"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Avec l'avantage qu'avec cette m\u00e9thode on peut donner des bornes et un pas d'incr\u00e9ment qui ne sont pas entiers\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 29, "lines": ["numpy_range_f = np.arange(1.0, 2.0, 0.1)\n", "numpy_range_f"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["##### `np.linspace`"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Aussi et surtout, lorsqu'on veut cr\u00e9er un intervalle dont on conna\u00eet les bornes, il est souvent plus facile d'utiliser `linspace`, qui cr\u00e9e un intervalle un peu comme `arange`, mais on lui pr\u00e9cise un nombre de points plut\u00f4t qu'un pas\u00a0:"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 33, "lines": ["X = np.linspace(0., 10., 50)\n", "X"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Vous remarquez que les 50 points couvrent \u00e0 intervalles r\u00e9guliers l'espace compris entre 0 et 10 inclusivement. Notons que 50 est aussi le nombre de points par d\u00e9faut. Cette fonction est tr\u00e8s utilis\u00e9e lorsqu'on veut dessiner une fonction entre deux bornes, on a d\u00e9j\u00e0 eu l'occasion de le faire\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 36, "lines": ["import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 39, "lines": ["# il est d'usage d'ajouter un point-virgule \u00e0 la fin de la derni\u00e8re ligne\n", "# si on ne le fait pas (essayez\u2026), on obtient l'affichage d'une ligne\n", "# de bruit qui n'apporte rien\n", "Y = np.cos(X)\n", "plt.plot(X, Y);"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["### Programmation vectorielle"]}, {"block": 26, "type": "markdown", "linesLength": 4, "startIndex": 45, "lines": ["Attardons-nous un petit peu\u00a0:\n", "\n", "* nous avons cr\u00e9\u00e9 un tableau X de 50 points qui couvrent l'intervalle $[0..10]$ de mani\u00e8re uniforme\u00a0;\n", "* nous avons calcul\u00e9 un tableau Y de 50 valeurs qui correspondent aux cosinus des nombres de X."]}, {"block": 27, "type": "markdown", "linesLength": 5, "startIndex": 49, "lines": ["Remarquez qu'on a fait ce premier calcul **sans m\u00eame savoir comment acc\u00e9der aux \u00e9l\u00e9ments d'un tableau**. Vous vous doutez bien qu'on va acc\u00e8der aux \u00e9l\u00e9ments d'un tableau \u00e0 base d'index, on le verra bien s\u00fbr, mais on n'en a pas eu besoin ici.\n", "\n", "En fait, avec `numpy`, on passe son temps \u00e0 \u00e9crire des expressions dont les \u00e9l\u00e9ments sont des tableaux, et cela produit des op\u00e9rations membre \u00e0 membre, comme on vient de le voir avec cosinus.\n", "\n", "Ainsi, pour tracer la fonction $x \\longrightarrow cos^2(x) + sin^2(x) + 3$, on fera tout simplement\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 6, "startIndex": 54, "lines": ["# l'\u00e9norme majorit\u00e9 du temps, on \u00e9crit avec numpy\n", "# des expressions qui impliquent des tableaux\n", "# exactement comme si c'\u00e9tait des nombres\n", "Z = np.cos(X)**2 + np.sin(X)**2 + 3\n", "\n", "plt.plot(X, Z);"]}, {"block": 29, "type": "markdown", "linesLength": 15, "startIndex": 60, "lines": ["C'est le premier r\u00e9flexe qu'il faut avoir avec les tableaux numpy\u00a0: on a vu que les compr\u00e9hensions et les expressions g\u00e9n\u00e9ratrices permettent de s'affranchir des boucles du genre\u00a0:\n", "```Python\n", "out_data = []\n", "for x in in_data:\n", "   out_data.append(une_fonction(x))\n", "```\n", "On a vu qu'en Python natif on ferait plut\u00f4t\u00a0:\n", "```Python\n", "out_data = (une_fonction(x) for x in in_data)\n", "```\n", "Eh bien en fait, avec numpy, on doit penser encore plus court\u00a0:\n", "```Python\n", "out_data = une_fonction(in_data)\n", "```\n", "Ou en tous cas \u00e0 une expression qui fait intervenir `in_data` comme un tout, sans avoir besoin d'acc\u00e9der \u00e0 ses \u00e9l\u00e9ments."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["##### `ufunc`"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Le m\u00e9canisme g\u00e9n\u00e9ral qui applique une fonction \u00e0 un tableau est connu sous le terme de *Universal function*, ou `ufunc`, \u00e7a peut vous \u00eatre utile avec les moteurs de recherche."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["Voyez notamment la liste des [fonctionnalit\u00e9s disponibles sous cette forme dans `numpy`](https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html)."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["Je vous signale \u00e9galement un utilitaire qui permet, sous forme de d\u00e9corateur, de passer d'une fonction scalaire \u00e0 une `ufunc`\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 7, "startIndex": 79, "lines": ["# le d\u00e9corateur np.vectorize vous permet\n", "# de facilement transformer une op\u00e9ration scalaire\n", "# en op\u00e9ration vectorielle\n", "# je choisis \u00e0 dessein une fonction d\u00e9finie par morceaux\n", "@np.vectorize\n", "def scalar_function(x):\n", "    return x**2 + 2*x + (1 if x <=0 else 10)"]}, {"block": 35, "type": "code", "linesLength": 5, "startIndex": 86, "lines": ["# je choisis de prendre beaucoup de points\n", "# \u00e0 cause de la discontinuit\u00e9\n", "X = np.linspace(-5, 5, 1000)\n", "Y = scalar_function(X)\n", "plt.plot(X, Y);"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["### Remarque - `ndarray` *vs* `array`"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 92, "lines": ["Je vous signale pour finir une petite incoh\u00e9rence au sujet de `array` et `ndarray`, compar\u00e9s aux types de base de Python (ce ne sera pas, malheureusement, la seule\u2026).\n", "\n", "Pour construire une liste, on utilise `list` comme usine \u00e0 fabriquer des listes. Logiquement ici, on devrait utiliser `np.ndarray` pour construire les tableaux, mais c'est `np.array` qu'il faut utiliser\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 95, "lines": ["a = np.array([12, 25, 32, 55])\n", "type(a)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["D'autant que bien \u00e9videmment la fonction `np.ndarray` existe aussi pour construire des tableaux mais elle offre une interface de plus bas niveau. Quoi qu'il en soit, en pratique \u00e7a n'est pas tr\u00e8s important, car le plus souvent on fabrique ces tableaux avec une des multiples autres m\u00e9thodes \u00e0 notre disposition, on y reviendra."]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["### Conclusion"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["Pour conclure ce compl\u00e9ment d'introduction, ce style de programmation - que je vais d\u00e9cider d'appeler programmation vectorielle de mani\u00e8re un peu impropre - est au c\u0153ur de `numpy`, et n'est bien entendu pas limit\u00e9e aux tableaux de dimension 1, comme on va le voir dans la suite."]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Comparaison de fonctions"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Exercice - niveau avanc\u00e9"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 7, "lines": ["# Pour charger l'exercice\n", "from corrections.exo_compare_all import exo_compare_all"]}, {"block": 4, "type": "markdown", "linesLength": 7, "startIndex": 9, "lines": ["\u00c0 pr\u00e9sent nous allons \u00e9crire une version tr\u00e8s simplifi\u00e9e de l'outil qui est utilis\u00e9 dans ce cours pour corriger les exercices. Vous aurez sans doute remarqu\u00e9 que les fonctions de correction prennent en argument la fonction \u00e0 corriger.\n", "\n", "Par exemple un peu plus bas, la cellule de correction fait\n", "\n", "    exo_compare_all.correction(compare_all)  \n", "    \n", "dans lequel `compare_all` est l'objet fonction que vous \u00e9crivez en r\u00e9ponse \u00e0 cet exercice."]}, {"block": 5, "type": "markdown", "linesLength": 7, "startIndex": 16, "lines": ["On vous demande d'\u00e9crire une fonction `compare` qui prend en argument\u00a0:\n", " * deux fonctions `f` et `g`\u00a0; imaginez que l'une d'entre elles fonctionne et qu'on cherche \u00e0 valider l'autre; dans cette version simplifi\u00e9e toutes les fonctions acceptent exactement un argument\u00a0;\n", " * une liste d'entr\u00e9es `entrees`\u00a0; vous pouvez supposer que chacune de ces entr\u00e9es est dans le domaine de `f` et de `g` (dit autrement, on peut appeler `f` et `g` sur chacune des entr\u00e9es sans craindre qu'une exception soit lev\u00e9e).\n", "\n", "Le r\u00e9sultat attendu pour le retour de `compare` est une liste qui contient autant de bool\u00e9ens que d'\u00e9l\u00e9ments dans `entrees`, chacun indiquant si avec l'entr\u00e9e correspondante on a pu v\u00e9rifier que `f(entree) == g(entree)`.\n", "\n", "Dans cette premi\u00e8re version de l'exercice vous pouvez enfin supposer que les entr\u00e9es ne sont pas modifi\u00e9es par `f` ou `g`. "]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 23, "lines": ["Pour information dans cet exercice\u00a0:\n", " * `factorial` correspond \u00e0 `math.factorial`\n", " * `fact` et `broken_fact` sont des fonctions impl\u00e9ment\u00e9es par nos soins, la premi\u00e8re est correcte alors que la seconde retourne 0 au lieu de 1 pour l'entr\u00e9e 0."]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["# par exemple\n", "exo_compare_all.example()"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Ce qui, dit autrement, veut tout simplement dire que `fact` et `factorial` co\u00efncident sur les entr\u00e9es 0, 1 et 5, alors que `broken_fact` et `factorial` ne renvoient pas la m\u00eame valeur avec l'entr\u00e9e `0`."]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 29, "lines": ["# c'est \u00e0 vous\n", "def compare_all(f, g, entrees):\n", "    \"<votre code>\""]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# pour v\u00e9rifier votre code\n", "exo_compare_all.correction(compare_all)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["## Exercice optionnel - niveau avanc\u00e9"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["# Pour charger l'exercice\n", "from corrections.exo_compare_args import exo_compare_args"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["### `compare` revisit\u00e9e"]}, {"block": 14, "type": "markdown", "linesLength": 9, "startIndex": 38, "lines": ["Nous reprenons ici la m\u00eame id\u00e9e que `compare`, mais en levant l'hypoth\u00e8se que les deux fonctions attendent un seul argument. Il faut \u00e9crire une nouvelle fonction `compare_args` qui prend en entr\u00e9e\u00a0:\n", " * deux fonctions `f` et `g` comme ci-dessus\u00a0;\n", " * mais cette fois une liste (ou un tuple) `argument_tuples` de **tuples** d'arguments d'entr\u00e9e.\n", " \n", "Comme ci-dessus on attend en retour une liste `retour` de bool\u00e9ens, de m\u00eame taille que `argument_tuples`, telle que, si `len(argument_tuples)` vaut $n$\u00a0:\n", " \n", "$\\forall i \\in \\{1,...,n\\}$, si `argument_tuples[i]` == [ $a_1$,...,$a_j$ ], alors\n", "\n", "`retour(i) == True` $\\Longleftrightarrow$  f ($a_1$,...,$a_j$) == g ($a_1$,...,$a_j$)"]}, {"block": 15, "type": "markdown", "linesLength": 5, "startIndex": 47, "lines": ["Pour information, dans tout cet exercice\u00a0:\n", " * `factorial` correspond \u00e0 `math.factorial`\u00a0;\n", " * `fact` et `broken_fact` sont des fonctions impl\u00e9ment\u00e9es par nos soins, la premi\u00e8re est correcte alors que la seconde retourne 0 au lieu de 1 pour l'entr\u00e9e 0\u00a0;\n", " * `add` correspond \u00e0 l'addition binaire `operator.add`\u00a0;\n", " * `plus` et `broken_plus` sont des additions binaires que nous avons \u00e9crites, l'une \u00e9tant correcte et l'autre \u00e9tant fausse lorsque le premier argument est nul."]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["exo_compare_args.example()"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 53, "lines": ["# ATTENTION vous devez aussi d\u00e9finir les arguments de la fonction\n", "def compare_args(votre, signature):\n", "    \"<votre_code>\""]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["exo_compare_args.correction(compare_args)"]}]
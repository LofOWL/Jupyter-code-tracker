[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `numpy` en dimension 1"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 8, "lines": ["Comme on l'a vu dans la vid\u00e9o, `numpy` est une biblioth\u00e8que qui offre un type suppl\u00e9mentaire par rapport aux types de base Python\u00a0: le **tableau**, qui s'appelle en anglais `array` (en fait techniquement, `ndarray`, pour *n-dimension array*).\n", "\n", "Bien que techniquement ce type ne fasse pas partie des types de base de Python, il est extr\u00eamement puissant, et surtout beaucoup plus efficace que les types de base, d\u00e8s lors qu'on manipule des donn\u00e9es qui ont la bonne forme, ce qui est le cas dans un grand nombre de domaines.\n", "\n", "Aussi, si vous utilisez une biblioth\u00e8que de calcul scientifique, la quasi totalit\u00e9 des objets que vous serez amen\u00e9s \u00e0 manipuler seront des tableaux `numpy`."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Dans cette premi\u00e8re partie nous allons commencer avec des tableaux \u00e0 une dimension, et voir comment les cr\u00e9er et les manipuler."]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["import numpy as np"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["### Cr\u00e9ation \u00e0 partir de donn\u00e9es"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["##### `np.array`"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["On peut cr\u00e9er un tableau numpy \u00e0 partir d'une liste - ou plus g\u00e9n\u00e9ralement un it\u00e9rable - avec la fonction `np.array` comme ceci\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["array = np.array([12, 25, 32, 55])\n", "array"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["**Attention**\u00a0: une erreur commune au d\u00e9but consiste \u00e0 faire ceci, qui ne marche pas\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 4, "startIndex": 21, "lines": ["try:\n", "    array = np.array(1, 2, 3, 4)\n", "except Exception as e:\n", "    print(f\"OOPS, {type(e)}, {e}\")"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["\u00c7a marche aussi \u00e0 partir d'un it\u00e9rable\u00a0:"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["builtin_range = np.array(range(10))\n", "builtin_range"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Cr\u00e9ation d'intervalles"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["##### `np.arange`"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Sauf que dans ce cas pr\u00e9cis on pr\u00e9f\u00e8rera utiliser directement la m\u00e9thode `arange` de `numpy`\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["numpy_range = np.arange(10)\n", "numpy_range"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Avec l'avantage qu'avec cette m\u00e9thode on peut donner des bornes et un pas d'incr\u00e9ment qui ne sont pas entiers\u00a0:"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["numpy_range_f = np.arange(1.0, 2.0, 0.1)\n", "numpy_range_f"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["##### `np.linspace`"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["Aussi et surtout, lorsqu'on veut cr\u00e9er un intervalle dont on conna\u00eet les bornes, il est souvent plus facile d'utiliser `linspace`, qui cr\u00e9e un intervalle un peu comme `arange`, mais on lui pr\u00e9cise un nombre de points plut\u00f4t qu'un pas\u00a0:"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["X = np.linspace(0., 10., 50)\n", "X"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["Vous remarquez que les 50 points couvrent \u00e0 intervalles r\u00e9guliers l'espace compris entre 0 et 10 inclusivement. Notons que 50 est aussi le nombre de points par d\u00e9faut. Cette fonction est tr\u00e8s utilis\u00e9e lorsqu'on veut dessiner une fonction entre deux bornes, on a d\u00e9j\u00e0 eu l'occasion de le faire\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 41, "lines": ["import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["# il est d'usage d'ajouter un point-virgule \u00e0 la fin de la derni\u00e8re ligne\n", "# si on ne le fait pas (essayez..), on obtient l'affichage d'une ligne\n", "# de bruit qui n'apporte rien\n", "Y = np.cos(X)\n", "plt.plot(X, Y);"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["### Programmation vectorielle"]}, {"block": 27, "type": "markdown", "linesLength": 4, "startIndex": 50, "lines": ["Attardons-nous un petit peu\u00a0:\n", "\n", "* nous avons cr\u00e9\u00e9 un tableau X de 50 points qui couvrent l'intervalle $[0..10]$ de mani\u00e8re uniforme,\n", "* et nous avons calcul\u00e9 un tableau Y de 50 valeurs qui correspondent aux cosinus des valeurs de X."]}, {"block": 28, "type": "markdown", "linesLength": 5, "startIndex": 54, "lines": ["Remarquez qu'on a fait ce premier calcul **sans m\u00eame savoir comment acc\u00e9der aux \u00e9l\u00e9ments d'un tableau**. Vous vous doutez bien qu'on va acc\u00e8der aux \u00e9l\u00e9ments d'un tableau \u00e0 base d'index, on le verra bien s\u00fbr, mais on n'en a pas eu besoin ici.\n", "\n", "En fait en `numpy` on passe son temps \u00e0 \u00e9crire des expressions dont les \u00e9l\u00e9ments sont des tableaux, et cela produit des op\u00e9rations membre \u00e0 membre, comme on vient de le voir avec cosinus.\n", "\n", "Ainsi pour tracer la fonction $x \\longrightarrow cos^2(x) + sin^2(x) + 3$ on fera tout simplement\u00a0:"]}, {"block": 29, "type": "code", "linesLength": 6, "startIndex": 59, "lines": ["# l'\u00e9norme majorit\u00e9 du temps, on \u00e9crit avec numpy\n", "# des expressions qui impliquent des tableaux\n", "# exactement comme si c'\u00e9tait des nombres\n", "Z = np.cos(X)**2 + np.sin(X)**2 + 3\n", "\n", "plt.plot(X, Z);"]}, {"block": 30, "type": "markdown", "linesLength": 21, "startIndex": 65, "lines": ["C'est le premier r\u00e9flexe qu'il faut avoir avec les tableaux numpy\u00a0: on a vu que les compr\u00e9hensions et les expressions g\u00e9n\u00e9ratrices permettent de s'affranchir des boucles du genre\u00a0:\n", "\n", "```python\n", "out_data = []\n", "for x in in_data:\n", "    out_data.append(une_fonction(x))\n", "```\n", "\n", "on a vu en python natif qu'on ferait plut\u00f4t\u00a0:\n", "\n", "```python\n", "out_data = (une_fonction(x) for x in in_data)\n", "```\n", "\n", "Eh bien en fait, en numpy, on doit penser encore plus court\u00a0:\n", "\n", "```python\n", "out_data = une_fonction(in_data)\n", "```\n", "\n", "ou en tous les cas une expression qui fait intervenir `in_data` comme un tout, sans avoir besoin d'acc\u00e9der \u00e0 ses \u00e9l\u00e9ments."]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["##### `ufunc`"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Le m\u00e9canisme g\u00e9n\u00e9ral qui applique une fonction \u00e0 un tableau est connu sous le terme de *Universal function*, ou `ufunc`, \u00e7a peut vous \u00eatre utile avec les moteurs de recherche."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Voyez notamment la liste des [fonctionnalit\u00e9s disponibles sous cette forme dans `numpy`](https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html)."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Je vous signale \u00e9galement un utilitaire qui permet, sous forme de d\u00e9corateur, de passer d'une fonction scalaire \u00e0 une `ufunc`\u00a0:"]}, {"block": 35, "type": "code", "linesLength": 7, "startIndex": 90, "lines": ["# le d\u00e9corateur np.vectorize vous permet\n", "# de facilement transformer une op\u00e9ration scalaire\n", "# en op\u00e9ration vectorielle\n", "# je choisis \u00e0 dessein une fonction d\u00e9finie par morceaux\n", "@np.vectorize\n", "def scalar_function(x):\n", "    return x**2 + 2*x + (1 if x <=0 else 10)"]}, {"block": 36, "type": "code", "linesLength": 5, "startIndex": 97, "lines": ["# je choisis de prendre beaucoup de points\n", "# \u00e0 cause de la discontinuit\u00e9\n", "X = np.linspace(-5, 5, 1000)\n", "Y = scalar_function(X)\n", "plt.plot(X, Y);"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["### Conclusion"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Pour conclure ce compl\u00e9ment d'introduction, ce style de programmation - que je vais d\u00e9cider d'appeler programmation vectorielle de mani\u00e8re un peu impropre - est au c\u0153ur de `numpy`, et n'est bien entendu pas limit\u00e9e aux tableaux de dimension 1, comme on va le voir dans la suite."]}]
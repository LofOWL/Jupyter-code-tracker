[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Les fichiers"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Voici quelques utilisations habituelles du type fichier en Python."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Avec un *context manager*"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Nous avons vu dans la vid\u00e9o les m\u00e9canismes de base sur les fichiers. Nous avons vu notamment qu'il est important de bien fermer un fichier apr\u00e8s usage. On a vu aussi qu'il est recommand\u00e9 de **toujours** utiliser l'instruction `with` et de contr\u00f4ler son encodage. Il est donc recommand\u00e9 de faire\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 4, "startIndex": 10, "lines": ["# avec un `with' on garantit la fermeture du fichier\n", "with open(\"foo.txt\", \"w\", encoding='utf-8') as sortie:\n", "    for i in range(2):\n", "        sortie.write(f\"{i}\\n\")"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Les modes d'ouverture"]}, {"block": 8, "type": "markdown", "linesLength": 4, "startIndex": 15, "lines": ["Les modes d'ouverture les plus utilis\u00e9s sont\u00a0:\n", " * `'r'` (la cha\u00eene contenant l'unique caract\u00e8re `r`) pour ouvrir un fichier en lecture seulement\u00a0;\n", " * `'w'` en \u00e9criture seulement\u00a0; le contenu pr\u00e9c\u00e9dent du fichier, s'il existait, est perdu\u00a0;\n", " * `'a'` en \u00e9criture seulement\u00a0; mais pour ajouter du contenu en fin de fichier."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Voici par exemple comment on pourrait ajouter deux lignes de texte dans le fichier `foo.txt` qui contient, \u00e0 ce stade du notebook, deux entiers\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 20, "lines": ["# on ouvre le fichier en mode 'a' comme append (= ajouter)\n", "with open(\"foo.txt\", \"a\", encoding='utf-8') as sortie:\n", "    for i in range(100, 102):\n", "        sortie.write(f\"{i}\\n\")"]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 24, "lines": ["# maintenant on regarde ce que contient le fichier\n", "with open(\"foo.txt\", encoding='utf-8') as entree: # remarquez que sans 'mode', on ouvre en lecture seule\n", "    for line in entree:\n", "        # line contient d\u00e9j\u00e0 un retour \u00e0 la ligne\n", "        print(line, end='')"]}, {"block": 12, "type": "markdown", "linesLength": 5, "startIndex": 29, "lines": ["Il existe de nombreuses variantes au mode d'ouverture, pour par exemple\u00a0:\n", " * ouvrir le fichier en lecture *et* en \u00e9criture (mode `+`)\u00a0;\n", " * ouvrir le fichier en mode binaire (mode `b`).\n", "\n", "Ces variantes sont d\u00e9crites dans [la section sur la fonction built-in `open`](https://docs.python.org/3/library/functions.html#open) dans la documentation Python."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["### Un fichier est un it\u00e9rateur"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Nous reparlerons des notions d'it\u00e9rable et d'it\u00e9rateur dans les semaines suivantes. Pour l'instant, on peut dire qu'un fichier - qui donc **est it\u00e9rable** puisqu'on peut le lire par une boucle `for` - est aussi **son propre it\u00e9rateur**. Cela implique que l'on ne peut le parcourir qu'une fois dans une boucle `for`. Pour le reparcourir, il faut le fermer et l'ouvrir de nouveau."]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["# un fichier est son propre it\u00e9rateur"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["with open(\"foo.txt\", encoding='utf-8') as entree:\n", "    print(entree.__iter__() is entree)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["Par cons\u00e9quent, \u00e9crire deux boucles `for` imbriqu\u00e9es sur **le m\u00eame objet fichier** ne **fonctionnerait pas** comme on pourrait s'y attendre."]}, {"block": 19, "type": "code", "linesLength": 10, "startIndex": 41, "lines": ["# Si l'on essaie d'\u00e9crire deux boucles imbriqu\u00e9es\n", "# sur le m\u00eame objet fichier, le r\u00e9sultat est inattendu\n", "with open(\"foo.txt\", encoding='utf-8') as entree:\n", "    for l1 in entree:\n", "        # on enl\u00e8ve les fins de ligne\n", "        l1 = l1.strip()\n", "        for l2 in entree:\n", "            # on enl\u00e8ve les fins de ligne\n", "            l2 = l2.strip()\n", "            print(l1, \"x\", l2)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["### Autres m\u00e9thodes"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Vous pouvez \u00e9galement acc\u00e9der \u00e0 des fonctions de beaucoup plus bas niveau, notamment celle fournies directement par le syst\u00e8me d'exploitation\u00a0; nous allons en d\u00e9crire deux parmi les plus utiles."]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["##### Digression - `repr()`"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Comme nous allons utiliser maintenant des outils d'assez bas niveau pour lire du texte, aussi pour examiner ce texte nous allons utiliser la fonction `repr()`, et voici pourquoi\u00a0:"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["# construisons \u00e0 la main une cha\u00eene qui contient deux lignes\n", "lines = \"abc\" + \"\\n\" + \"def\"  + \"\\n\""]}, {"block": 26, "type": "code", "linesLength": 4, "startIndex": 58, "lines": ["# si on l'imprime on voit bien les retours \u00e0 la ligne\n", "# d'ailleurs on sait qu'il n'est pas utile\n", "# d'ajouter un retour \u00e0 la ligne \u00e0 la fin\n", "print(lines, end=\"\")"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 62, "lines": ["# v\u00e9rifions que repr() nous permet de bien\n", "# voir le contenu de cette chaine\n", "print(repr(lines))"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["##### Lire un contenu - bas niveau"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Revenons aux fichiers\u00a0; la m\u00e9thode `read()` permet de lire dans le fichier un buffer d'une certaine taille\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 7, "startIndex": 67, "lines": ["# read() retourne TOUT le contenu\n", "# ne pas utiliser avec de tr\u00e8s gros fichier bien s\u00fbr\n", "\n", "# une autre fa\u00e7on de montrer tout le contenu du fichier\n", "with open(\"foo.txt\", encoding='utf-8') as entree:\n", "    full_contents = entree.read()\n", "    print(f\"Contenu complet\\n{full_contents}\", end=\"\")"]}, {"block": 31, "type": "code", "linesLength": 4, "startIndex": 74, "lines": ["# lire dans le fichier deux blocs de quatre caract\u00e8res\n", "with open(\"foo.txt\", encoding='utf-8') as entree:\n", "    for bloc in range(2):\n", "        print(f\"Bloc {bloc} >>{repr(entree.read(4))}<<\")"]}, {"block": 32, "type": "markdown", "linesLength": 6, "startIndex": 78, "lines": ["On voit donc que chaque bloc contient bien quatre caract\u00e8res en comptant les sauts de ligne\u00a0:\n", "\n", "| bloc # | contenu                                    |\n", "|:-------|:-------------------------------------------|\n", "| 0      | un `0`, un *newline*, un `1`, un *newline* |\n", "| 1      | un `1`, deux `0`, un *newline*             |"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["##### La m\u00e9thode `flush`"]}, {"block": 34, "type": "markdown", "linesLength": 3, "startIndex": 85, "lines": ["Les entr\u00e9es-sorties sur fichier sont bien souvent *bufferis\u00e9es* par le syst\u00e8me d'exploitation. Cela signifie qu'un appel \u00e0 `write` ne provoque pas forc\u00e9ment une \u00e9criture imm\u00e9diate, car pour des raisons de performance on attend d'avoir suffisamment de mati\u00e8re avant d'\u00e9crire sur le disque.\n", "\n", "Il y a des cas o\u00f9 ce comportement peut s'av\u00e9rer g\u00eanant, et o\u00f9 on a besoin d'\u00e9crire imm\u00e9diatement (et donc de vider le *buffer*), et c'est le propos de la m\u00e9thode `flush`."]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["### Fichiers textuels et fichiers binaires"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["De la m\u00eame fa\u00e7on que le langage propose les deux types `str` et `bytes`, il est possible d'ouvrir un fichier en mode *textuel* ou en mode *binaire*."]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["Les fichiers que nous avons vus jusqu'ici \u00e9taient ouverts en mode *textuel* (c'est le d\u00e9faut), et c'est pourquoi quand nous avons interagi avec eux avec des objets de type `str`\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 4, "startIndex": 91, "lines": ["# un fichier ouvert en mode textuel nous donne des str\n", "with open('foo.txt', encoding='utf-8') as input:\n", "    for line in input:\n", "        print(\"on a lu un objet de type\", type(line))"]}, {"block": 39, "type": "markdown", "linesLength": 3, "startIndex": 95, "lines": ["Lorsque ce n'est pas le comportement souhait\u00e9, on peut\u00a0:\n", "* ouvrir le fichier en mode *binaire* - pour cela on ajoute le caract\u00e8re `b` au mode d'ouverture\u00a0;\n", "* et on peut alors interagir avec le fichier avec des objets de type `bytes`"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 98, "lines": ["Pour illustrer ce trait, nous allons\u00a0:\n", "0. cr\u00e9er un fichier en mode texte, et y ins\u00e9rer du texte en UTF-8\u00a0;\n", "0. relire le fichier en mode binaire, et retrouver le codage des diff\u00e9rents caract\u00e8res."]}, {"block": 41, "type": "code", "linesLength": 7, "startIndex": 101, "lines": ["# phase 1 : on \u00e9crit un fichier avec du texte en UTF-8\n", "# on ouvre le donc le fichier en mode texte\n", "# en toute rigueur il faut pr\u00e9ciser l'encodage,\n", "# si on ne le fait pas il sera d\u00e9termin\u00e9\n", "# \u00e0 partir de vos r\u00e9glages syst\u00e8me\n", "with open('strbytes', 'w', encoding='utf-8') as output:\n", "    output.write(\"d\u00e9j\u00e0 l'\u00e9t\u00e9\\n\")"]}, {"block": 42, "type": "code", "linesLength": 9, "startIndex": 108, "lines": ["# phase 2: on ouvre le fichier en mode binaire\n", "with open('strbytes', 'rb') as rawinput:\n", "    # on lit tout le contenu\n", "    octets = rawinput.read()\n", "    # qui est de type bytes\n", "    print(\"on a lu un objet de type\", type(octets))\n", "    # si on regarde chaque octet un par un\n", "    for i, octet in enumerate(octets):\n", "        print(f\"{i} \u2192 {repr(chr(octet))} [{hex(octet)}]\")"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 117, "lines": ["Vous retrouvez ainsi le fait que l'unique caract\u00e8re Unicode `\u00e9`, a \u00e9t\u00e9 encod\u00e9 par UTF-8 sous la forme de deux octets de code hexad\u00e9cimal `0xc3` et `0xa9`."]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 118, "lines": ["Vous pouvez \u00e9galement consulter ce site qui visualise l'encodage UTF-8, avec notre s\u00e9quence d'entr\u00e9e\u00a0:\n", "\n", "https://mothereff.in/utf-8#d%C3%A9j%C3%A0%20l%27%C3%A9t%C3%A9%0A"]}, {"block": 45, "type": "code", "linesLength": 5, "startIndex": 121, "lines": ["# on peut comparer le nombre d'octets et le nombre de caract\u00e8res\n", "with open('strbytes', encoding='utf-8') as textfile:\n", "    print(f\"en mode texte, {len(textfile.read())} caract\u00e8res\")\n", "with open('strbytes', 'rb') as binfile:\n", "    print(f\"en mode binaire, {len(binfile.read())} octets\")"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["Ce qui correspond au fait que nos quatre caract\u00e8res non-ASCII (3 x `\u00e9` et 1 x `\u00e0`) sont tous encod\u00e9s par UTF-8 comme deux octets, comme vous pouvez vous en assurer [ici pour `\u00e9`](https://mothereff.in/utf-8#%C3%A9) et [l\u00e0 pour `\u00e0`](https://mothereff.in/utf-8#%C3%A0)."]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["### Pour en savoir plus"]}, {"block": 48, "type": "markdown", "linesLength": 3, "startIndex": 128, "lines": ["Pour une description exhaustive vous pouvez vous reporter\u00a0:\n", "* au [glossaire sur la notion de `object file`](https://docs.python.org/3/glossary.html#term-file-object),\n", "* et aussi et surtout [au module `io`](https://docs.python.org/3/library/io.html#module-io) qui d\u00e9crit plus en d\u00e9tails les fonctionnalit\u00e9s disponibles."]}]
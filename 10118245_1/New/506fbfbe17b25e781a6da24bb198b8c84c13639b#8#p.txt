[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Les outils de base sur les strings"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["### Lire la documentation"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["M\u00eame apr\u00e8s des ann\u00e9es de pratique, il est difficile de se souvenir de toutes les m\u00e9thodes travaillant sur les cha\u00eenes de caract\u00e8res. Aussi il est toujours utile de recourir \u00e0 la documentation embarqu\u00e9e:"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 5, "lines": ["help(str)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Nous allons tenter ici de citer les m\u00e9thodes les plus utilis\u00e9es; nous n'avons le temps que de les utiliser de mani\u00e8re tr\u00e8s simple, mais bien souvent il est possible de passer en param\u00e8tre des options permettant de ne travailler que sur une sous-cha\u00eene, ou sur la premi\u00e8re ou derni\u00e8re occurrence d'une sous-cha\u00eene; nous vous renvoyons \u00e0 la documentation pour obtenir toutes les pr\u00e9cisions utiles."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### D\u00e9coupage - assemblage : `split` et `join`"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["On l'a vu dans la vid\u00e9o, la paire `split` et `join` permet de d\u00e9couper une chaine selon un s\u00e9parateur pour obtenir une liste, et \u00e0 l'inverse de reconstruire une cha\u00eene \u00e0 partir d'une liste."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["`split` permet donc de d\u00e9couper:"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 10, "lines": ["'abc=:=def=:=ghi=:=jkl'.split('=:=')"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Et \u00e0 l'inverse"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["\"=:=\".join(['abc', 'def', 'ghi', 'jkl'])"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Attention toutefois si le s\u00e9parateur est un terminateur, la liste r\u00e9sultat contient alors une derni\u00e8re cha\u00eene vide."]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["'abc;def;ghi;jkl;'.split(';')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Qui s'inverse correctement cependant"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 16, "lines": ["\";\".join(['abc', 'def', 'ghi', 'jkl', ''])"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["### Remplacements : `replace`"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["`replace` est tr\u00e8s pratique pour remplacer une sous-cha\u00eene par une autre, avec une limite \u00e9ventuelle sur le nombre de remplacements"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["\"abcdefabcdefabcdef\".replace(\"abc\", \"zoo\")"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["\"abcdefabcdefabcdef\".replace(\"abc\", \"zoo\", 2)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["Plusieurs appels \u00e0 `replace` peuvent \u00eatre cha\u00een\u00e9s comme ceci"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 22, "lines": ["\"les [x] qui disent [y]\".replace(\"[x]\", \"chevaliers\").replace(\"[y]\", \"Ni\")"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### Nettoyage : `strip`"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["On pourrait par exemple utiliser `replace` pour enlever les espaces dans une cha\u00eene, ce qui peut \u00eatre utile pour \"nettoyer\" comme ceci:"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["\" abc:def:ghi \".replace(\" \", \"\")"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Toutefois bien souvent on pr\u00e9f\u00e8re utiliser `strip` qui ne s'occupe que du d\u00e9but et de la fin de la cha\u00eene, et g\u00e8re aussi les tabulations et autres retour \u00e0 la ligne"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["\" \\tune chaine avec des trucs qui d\u00e9passent \\n\".strip()"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Rechercher une sous-cha\u00eene"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Plusieurs outils permettent de chercher une sous-cha\u00eene. Le plus simple est `find` qui renvoie le plus petit index o\u00f9 on trouve la sous-cha\u00eene:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["# l'indice du d\u00e9but de la premi\u00e8re occurrence\n", "\"abcdefcdefghefghijk\".find(\"def\")"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# ou -1 si la chaine n'est pas pr\u00e9sente:\n", "\"abcdefcdefghefghijk\".find(\"zoo\")"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["`rfind` fonctionne comme `find` mais en partant de la fin de la cha\u00eene"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["# en partant de la fin\n", "\"abcdefcdefghefghijk\".rfind(\"fgh\")"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 37, "lines": ["# notez que le r\u00e9sultat correspond\n", "# tout de m\u00eame toujours au d\u00e9but de la chaine\n", "\"abcdefcdefghefghijk\"[13]"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["La m\u00e9thode `index` se comporte comme `find`, mais en cas d'absence elle l\u00e8ve une **exception** (nous verrons ce concept plus tard) plut\u00f4t que de renvoyer `-1`:"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 41, "lines": ["\"abcdefcdefghefghijk\".index(\"def\")"]}, {"block": 37, "type": "code", "linesLength": 4, "startIndex": 42, "lines": ["try:\n", "    \"abcdefcdefghefghijk\".index(\"zoo\")\n", "except Exception as e:\n", "    print(\"OOPS\", type(e), e)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["La m\u00e9thode `count` compte le nombre d'occurrences d'une sous-cha\u00eene:"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["\"abcdefcdefghefghijk\".count(\"ef\")"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Signalons enfin les m\u00e9thodes de commodit\u00e9 suivantes:"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["\"abcdefcdefghefghijk\".startswith(\"abcd\")"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["\"abcdefcdefghefghijk\".endswith(\"ghijk\")"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["S'agissant des deux derni\u00e8res, remarquons que:"]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 52, "lines": ["`chaine.startswith(sous_chaine)` $\\Longleftrightarrow$ `chaine.find(sous_chaine) == 0`\n", "\n", "`chaine.endswith(sous_chaine)` $\\Longleftrightarrow$ `chaine.rfind(sous_chaine) == (len(chaine)-len(sous_chaine))`"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["### Capitalisation"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["Voici pour conclure quelques m\u00e9thodes utiles qui parlent d'elles-m\u00eames:"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["\"monty PYTHON\".upper()"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["\"monty PYTHON\".lower()"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["\"monty PYTHON\".swapcase()"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["\"monty PYTHON\".capitalize()"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["\"monty PYTHON\".title()"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["### Pour en savoir plus"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Tous ces outils sont [document\u00e9s en d\u00e9tail ici (en anglais)](https://docs.python.org/2/library/stdtypes.html#string-methods)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["### Expressions r\u00e9guli\u00e8res"]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 65, "lines": ["Signalons enfin que python propose \u00e9galement un module d'expressions r\u00e9guli\u00e8res, un outil qui permet de faire des calculs beaucoup plus \u00e9labor\u00e9s. Cette technique bien connue a \u00e9t\u00e9 rendue populaire historiquement au travers notamment du langage Perl.\n", "\n", "Ce concept est tr\u00e8s puissant, et permet d'aborder des cas qui vont bien au-del\u00e0 de ce qui est pr\u00e9sent\u00e9 ici, pour reconna\u00eetre les cha\u00eenes qui ob\u00e9issent \u00e0 des r\u00e8gles lexicales pr\u00e9cises. \u00c9tant d'une utilisation tr\u00e8s sp\u00e9cifique, nous avons choisi d'aborder ce sujet en derni\u00e8re semaine lors de la session consacr\u00e9e aux sujets avanc\u00e9s."]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Expressions r\u00e9guli\u00e8res et le module `re`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["Une expression r\u00e9guli\u00e8re est un objet math\u00e9matique permettant de d\u00e9crire un ensemble de textes qui poss\u00e8dent des propri\u00e9t\u00e9s communes; par exemple, s'il vous arrive d'utiliser un terminal, et que vous tapez:\n", "\n", "    $ dir *.txt\n", "\n", "(ou `ls *.txt` sur linux ou mac), vous utilisez l'expression r\u00e9guli\u00e8re `*.txt` qui d\u00e9signe tous les fichiers dont le nom se termine par `.txt`; on dit que l'expression r\u00e9guli\u00e8re *filtre* toutes les cha\u00eenes qui se terminent par `.txt` (l'expression anglaise consacr\u00e9e est le *pattern matching*)."]}, {"block": 4, "type": "markdown", "linesLength": 7, "startIndex": 8, "lines": ["Le langage Perl a \u00e9t\u00e9 le premier \u00e0 populariser l'utilisation des expressions r\u00e9guli\u00e8res en les supportant nativement dans le langage, et non au travers d'une librairie.\n", "\n", "En python, les expressions r\u00e9guli\u00e8res sont disponibles de mani\u00e8re plus traditionnelle, via le module `re` de la librairie standard, que nous allons voir maintenant.\n", "\n", "Dans la commande ci-dessus, `*.txt` est une expression r\u00e9guli\u00e8re tr\u00e8s simple. Le module `re` fournit le moyen de construire des expressions r\u00e9guli\u00e8res tr\u00e8s \u00e9labor\u00e9es et plus puissantes que ce que supporte le terminal. C'est pourquoi la syntaxe des regexps de `re` est un peu diff\u00e9rente; par exemple pour filtrer la m\u00eame famille de cha\u00eenes que `*.txt` avec le module `re`, il nous faudra \u00e9crire l'expression r\u00e9guli\u00e8re sous une forme l\u00e9g\u00e8rement diff\u00e9rente.\n", "\n", "Le propos de ce compl\u00e9ment est de vous donner une premi\u00e8re introduction au module `re`. "]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 15, "lines": ["import re"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Je vous conseille d'avoir sous la main la [documentation du module `re`](https://docs.python.org/3/library/re.html) pendant que vous lisez ce compl\u00e9ment."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["### Avertissement"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 18, "lines": ["Dans ce compl\u00e9ment nous serons amen\u00e9s \u00e0 utiliser des traits qui d\u00e9pendent du LOCALE, c'est-\u00e0-dire, pour faire simple, de la configuration de l'ordinateur vis-\u00e0-vis de la langue. \n", "\n", "Tant que vous ex\u00e9cutez ceci dans le notebook sur la plateforme, en principe tout le monde verra exactement la m\u00eame chose. Par contre, si vous faites tourner le m\u00eame code sur votre ordinateur, il se peut que vous obteniez des r\u00e9sultats l\u00e9g\u00e8rement diff\u00e9rents."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["### Un exemple simple"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["##### `findall`"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["On se donne deux exemples de cha\u00eenes:"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["sentences = ['Lacus a donec, vitae gravida proin sociis.', \n", "             'Neque ipsum! rhoncus cras quam.']"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["On peut **chercher tous** les mots se terminant par `a` ou `m` dans une cha\u00eene avec `findall`:"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["for sentence in sentences:\n", "    print(f\"---- dans >{sentence}<\")\n", "    print(re.findall(r\"\\w*[am]\\W\", sentence))"]}, {"block": 15, "type": "markdown", "linesLength": 8, "startIndex": 30, "lines": ["Ce code permet de chercher toutes (`findall`) les occurrences de l'expression r\u00e9guli\u00e8re, qui ici est d\u00e9finie par le *raw-string*:\n", "\n", "    r\"\\w*[am]\\W\"\n", "    \n", "Nous verrons tout \u00e0 l'heure comment fabriquer des expressions r\u00e9guli\u00e8res plus en d\u00e9tail, mais pour d\u00e9mystifier au moins celle-ci, on a mis bout \u00e0 bout les morceaux suivants:\n", " * `\\w*` : on veut trouver une sous-cha\u00eene qui commence par un nombre quelconque, y compris nul (`*`) de caract\u00e8res alphanum\u00e9riques (`\\w`); ceci est d\u00e9fini en fonction de votre LOCALE, on y reviendra;\n", " * `[am]` : imm\u00e9diatement apr\u00e8s, il nous faut trouver un carat\u00e8re `a` ou `m`;\n", " * `\\W` : et enfin, il nous faut un caract\u00e8re qui ne soit **pas** alphanum\u00e9rique. Ceci est important puisqu'on cherche les mots qui **se terminent** par un `a` ou un `m`; si on ne le mettait pas on obtiendrait ceci:"]}, {"block": 16, "type": "code", "linesLength": 5, "startIndex": 38, "lines": ["# le \\W final est important\n", "# voici ce qu'on obtient si on l'omet\n", "for sentence in sentences:\n", "    print(f\"---- dans >{sentence}<\")\n", "    print(re.findall(r\"\\w*[am]\", sentence))"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["##### `split`"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["Une autre forme simple d'utilisation des regexps est `re.split`, qui fournit une fonctionnalit\u00e9 voisine de `str.split`, mais ou les s\u00e9parateurs sont exprim\u00e9s comme une expression r\u00e9guli\u00e8re:"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 45, "lines": ["for sentence in sentences:\n", "    print(f\"---- dans >{sentence}<\")\n", "    print(re.split(r\"\\W+\", sentence))\n", "    print()"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 49, "lines": ["Ici l'expression r\u00e9guli\u00e8re, qui bien s\u00fbr d\u00e9crit le s\u00e9parateur, est simplement `\\W+` c'est-\u00e0-dire toute suite d'au moins un caract\u00e8re non alphanum\u00e9rique. \n", "\n", "Nous avons donc l\u00e0 un moyen simple, et plus puissant que `str.split`, de couper un texte en mots."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["##### `sub`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Une troisi\u00e8me m\u00e9thode utilitaire est `re.sub` qui permet de remplacer les occurrences d'une *regexp*, comme par exemple:"]}, {"block": 23, "type": "code", "linesLength": 4, "startIndex": 54, "lines": ["for sentence in sentences:\n", "    print(f\"---- dans >{sentence}<\")\n", "    print(re.sub(r\"(\\w+)\", r\"X\\1Y\", sentence))\n", "    print()"]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 58, "lines": ["Ici, l'expression r\u00e9guli\u00e8re (le premier argument) contient un **groupe** : on a utilis\u00e9 des parenth\u00e8ses autour du `\\w+`. Le second argument est la cha\u00eene de remplacement, dans laquelle on a fait **r\u00e9f\u00e9rence au groupe** en \u00e9crivant `\\1`, qui veut dire tout simplement \"le premier groupe\".\n", "\n", "Donc au final l'effet de cet appel est d'entourer toutes les suites de caract\u00e8res alphanum\u00e9riques par `X` et `Y`. "]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["##### Pourquoi un *raw-string* ?"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["En guise de digression, il n'y a aucune obligation \u00e0 utiliser un *raw-string*; d'ailleurs on rappelle qu'il n'y a pas de diff\u00e9rence de nature entre un *raw-string* et une cha\u00eene usuelle:"]}, {"block": 27, "type": "code", "linesLength": 6, "startIndex": 63, "lines": ["raw = r'abc'\n", "regular = 'abc'\n", "# comme on a pris une 'petite' cha\u00eene ce sont les m\u00eames objets\n", "print(f\"both compared with is \u2192 {raw is regular}\")\n", "# et donc a fortiori\n", "print(f\"both compared with == \u2192 {raw == regular}\")"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Il se trouve que le *backslash* `\\` \u00e0 l'int\u00e9rieur des expressions r\u00e9guli\u00e8res est d'un usage assez courant - on l'a vu d\u00e9j\u00e0 plusieurs fois. C'est pourquoi on **utilise fr\u00e9quemment un *raw-string*** pour d\u00e9crire une expression r\u00e9guli\u00e8re, et en g\u00e9n\u00e9ral \u00e0 chaque fois qu'elle comporte un *backslash*."]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Ici 6 et 4 repr\u00e9sentent la largeur des colonnes pour afficher `aaabbb` et `a*b+` respectivement. Nous allons voir plus bas pourquoi cette expressions r\u00e9guli\u00e8re filtre effectivement cette entr\u00e9e."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["### Un deuxi\u00e8me exemple"]}, {"block": 31, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["Nous allons maintenant voir comment on peut d'abord v\u00e9rifier si une cha\u00eene est conforme au crit\u00e8re d\u00e9fini par l'expression r\u00e9guli\u00e8re, mais aussi *extraire* les morceaux de la cha\u00eene qui correspondent aux diff\u00e9rentes parties de l'expression. \n", "\n", "Pour cela, supposons qu'on s'int\u00e9resse aux cha\u00eenes qui comportent 5 parties, une suite de chiffres, une suite de lettres, des chiffres \u00e0 nouveau, des lettres, et enfin de nouveau des chiffres."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Pour cela on consid\u00e8re ces trois chaines en entr\u00e9e:"]}, {"block": 33, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["inputs = ['890hj000nnm890',    # cette entr\u00e9e convient\n", "          '123abc456def789',   # celle-ci aussi\n", "          '8090abababab879',   # celle-ci non\n", "          ]"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["##### `match`"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Pour commencer, voyons que l'on peut facilement **v\u00e9rifier si une cha\u00eene v\u00e9rifie** ou non le crit\u00e8re:"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["regexp1 = \"[0-9]+[A-Za-z]+[0-9]+[A-Za-z]+[0-9]+\""]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Si on applique cette expression r\u00e9guli\u00e8re \u00e0 toutes nos entr\u00e9es:"]}, {"block": 38, "type": "code", "linesLength": 3, "startIndex": 84, "lines": ["for input in inputs:\n", "    match = re.match(regexp1, input)\n", "    print(f\"{input:16s} \u2192 {match}\")"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Pour rendre ce r\u00e9sultat un peu plus lisible nous nous d\u00e9finissons une petite fonction de confort:"]}, {"block": 40, "type": "code", "linesLength": 4, "startIndex": 88, "lines": ["# pour simplement visualiser si on a un match ou pas\n", "def nice(match):\n", "    # le retour de re.match est soit None, soit un objet match\n", "    return \"no\" if match is None else \"Match!\""]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Avec quoi on peut refaire l'essai sur toutes nos entr\u00e9es:"]}, {"block": 42, "type": "code", "linesLength": 5, "startIndex": 93, "lines": ["# la m\u00eame chose mais un peu moins encombrant\n", "print(f\"REGEXP={regexp1}\\n\")\n", "for input in inputs:\n", "    match = re.match(regexp1, input)\n", "    print(f\"{input:>16s} \u2192 {nice(match)}\")"]}, {"block": 43, "type": "markdown", "linesLength": 5, "startIndex": 98, "lines": ["Ici plut\u00f4t que d'utiliser les raccourcis comme `\\w` j'ai pr\u00e9f\u00e9r\u00e9 \u00e9crire explicitement les ensembles de caract\u00e8res en jeu; de cette fa\u00e7on, on rend son code ind\u00e9pendant du LOCALE si c'est ce qu'on veut faire. Il y a deux morceaux qui interviennent tour \u00e0 tour:\n", " * `[0-9]+` signifie une suite de au moins un caract\u00e8re dans l'intervalle `[0-9]`,\n", " * `[A-Za-z]+` pour une suite d'au moins un caract\u00e8re dans l'intervalle `[A-Z]` ou dans l'intervalle `[a-z]`. \n", " \n", "Et comme tout \u00e0 l'heure on a simplement juxtapos\u00e9 les morceaux dans le bon ordre pour construire l'expression r\u00e9guli\u00e8re compl\u00e8te."]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["##### Nommer un morceau (un groupe)"]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 104, "lines": ["# on se concentre sur une entr\u00e9e correcte\n", "haystack = inputs[1]\n", "haystack"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["Maintenant, on va m\u00eame pouvoir **donner un nom** \u00e0 un morceau de la regexp, ici on d\u00e9signe par `needle` le groupe de chiffres du milieu:"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 108, "lines": ["# la m\u00eame regexp, mais on donne un nom au groupe de chiffres central\n", "regexp2 = \"[0-9]+[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+[0-9]+\""]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["Et une fois que c'est fait, on peut demander \u00e0 l'outil de nous **retrouver la partie correspondante** dans la chaine initiale:"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 111, "lines": ["print(re.match(regexp2, haystack).group('needle'))"]}, {"block": 50, "type": "markdown", "linesLength": 3, "startIndex": 112, "lines": ["Dans cette expression on a utilis\u00e9 un **groupe nomm\u00e9** `(?P<needle>[0-9]+)`, dans lequel:\n", " * les parenth\u00e8ses d\u00e9finissent un groupe,\n", " * `?P<needle>` sp\u00e9cifie que ce groupe pourra \u00eatre r\u00e9f\u00e9renc\u00e9 sous le nom `needle` (cette syntaxe tr\u00e8s absconse est h\u00e9rit\u00e9e semble-t-il de perl...)"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["### Un troisi\u00e8me exemple"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["Enfin, et c'est un trait qui n'est pas pr\u00e9sent dans tous les langages, on peut restreindre un morceau de cha\u00eene \u00e0 \u00eatre identique \u00e0 un groupe d\u00e9j\u00e0 vu plus t\u00f4t dans la cha\u00eene; dans l'exemple ci-dessus on pourrait ajouter comme contrainte que le premier et le dernier groupes de chiffres soient identiques, comme ceci:"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["regexp3 = \"(?P<id>[0-9]+)[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+(?P=id)\""]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 118, "lines": ["Si bien que maintenant, avec les m\u00eames entr\u00e9es que tout \u00e0 l'heure:"]}, {"block": 55, "type": "code", "linesLength": 4, "startIndex": 119, "lines": ["print(f\"REGEXP={regexp3}\\n\")\n", "for input in inputs:\n", "    match = re.match(regexp3, input)\n", "    print(f\"{input:>16s} \u2192 {nice(match)}\")    "]}, {"block": 56, "type": "markdown", "linesLength": 2, "startIndex": 123, "lines": ["Comme pr\u00e9c\u00e9demment on a d\u00e9fini le groupe nomm\u00e9 `id` comme \u00e9tant la premi\u00e8re suite de chiffres. \n", "La nouveaut\u00e9 ici est la **contrainte** qu'on a impos\u00e9e sur le dernier groupe avec `(?P=id)`. Comme vous le voyez, on n'obtient un *match* qu'avec les entr\u00e9es dans lesquelles le dernier groupe de chiffres est identique au premier."]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["### Comment utiliser la librairie"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["Avant d'apprendre \u00e0 \u00e9crire une expression r\u00e9guli\u00e8re, disons quelques mots du mode d'emploi de la librairie."]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["##### Fonctions de commodit\u00e9 et *workflow*"]}, {"block": 60, "type": "markdown", "linesLength": 3, "startIndex": 128, "lines": ["Comme vous le savez peut-\u00eatre, une expression r\u00e9guli\u00e8re d\u00e9crite sous forme de cha\u00eene, comme par exemple `\"\\w*[am]\\W\"`, peut \u00eatre traduite dans un **automate fini** qui permet de faire le filtrage avec une cha\u00eene. C'est ce qui explique le *workflow* que nous avons r\u00e9sum\u00e9 dans cette figure:\n", "\n", "<img src=\"media/re-workflow.png\">"]}, {"block": 61, "type": "markdown", "linesLength": 3, "startIndex": 131, "lines": ["La m\u00e9thode recommand\u00e9e pour utiliser la librairie, lorsque vous avez le m\u00eame *pattern* \u00e0 appliquer \u00e0 un grand nombre de cha\u00eenes, est de:\n", " * compiler **une seule fois** votre cha\u00eene en un automate, qui est mat\u00e9rialis\u00e9 par un objet de la classe `re.RegexObject`, en utilisant `re.compile`, \n", " * puis d'**utiliser directement cet objet** autant de fois que vous avez de cha\u00eenes."]}, {"block": 62, "type": "markdown", "linesLength": 7, "startIndex": 134, "lines": ["Nous avons utilis\u00e9 dans les exemples plus haut (et nous continuerons plus bas pour une meilleure lisibilit\u00e9) des **fonctions de commodit\u00e9** du module, qui sont pratiques, par exemple, pour mettre au  point une expression r\u00e9guli\u00e8re en mode interactif, mais qui ne **sont pas forc\u00e9ment** adapt\u00e9es dans tous les cas. \n", "\n", "Ces fonctions de commodit\u00e9 fonctionnent toutes sur le m\u00eame principe:\n", "    \n", "`re.match(regexp, input)`  $\\Longleftrightarrow$ `re.compile(regexp).match(input)`\n", "\n", "Donc \u00e0 chaque fois qu'on utilise une fonction de commodit\u00e9, on recompile la cha\u00eene en automate, ce qui, d\u00e8s qu'on a plus d'une cha\u00eene \u00e0 traiter, repr\u00e9sente un surco\u00fbt."]}, {"block": 63, "type": "code", "linesLength": 6, "startIndex": 141, "lines": ["# au lieu de faire comme ci-dessus:\n", "\n", "# imaginez 10**6 cha\u00eenes dans inputs\n", "for input in inputs:\n", "    match = re.match(regexp3, input)\n", "    print(f\"{input:>16s} \u2192 {nice(match)}\")    "]}, {"block": 64, "type": "code", "linesLength": 9, "startIndex": 147, "lines": ["# dans du vrai code on fera plut\u00f4t:\n", "\n", "# on compile la cha\u00eene en automate une seule fois\n", "re_obj3 = re.compile(regexp3)\n", "\n", "# ensuite on part directement de l'automate\n", "for input in inputs:\n", "    match = re_obj3.match(input)\n", "    print(f\"{input:>16s} \u2192 {nice(match)}\")"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 156, "lines": ["Cette deuxi\u00e8me version ne compile qu'une fois la cha\u00eene en automate, et donc est plus efficace."]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 157, "lines": ["##### Les m\u00e9thodes sur la classe `RegexObject`"]}, {"block": 67, "type": "markdown", "linesLength": 5, "startIndex": 158, "lines": ["Les objets de la classe `RegexObject` repr\u00e9sentent donc l'automate \u00e0 \u00e9tat fini qui est le r\u00e9sultat de la compilation de l'expression r\u00e9guli\u00e8re. \n", "Pour r\u00e9sumer ce qu'on a d\u00e9j\u00e0 vu, les m\u00e9thodes les plus utiles sur un objet `RegexObject` sont:\n", " * `match` et `search`, qui cherchent un *match* soit uniquement au d\u00e9but (`match`) ou n'importe o\u00f9 dans la cha\u00eene (`search`);\n", " * `findall` et `split` pour chercher toutes les occurences (`findall`) ou leur n\u00e9gatif (`split`);\n", " * `sub` (qui aurait pu sans doute s'appeler `replace`, mais c'est comme \u00e7a) pour remplacer les occurrences de pattern."]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 163, "lines": ["##### Exploiter le r\u00e9sultat"]}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 164, "lines": ["Les **m\u00e9thodes** disponibles sur la classe **`re.MatchObject`** sont [document\u00e9es en d\u00e9tail ici](https://docs.python.org/3/library/re.html#match-objects). On en a d\u00e9j\u00e0 rencontr\u00e9 quelques-unes, en voici \u00e0 nouveau un aper\u00e7u rapide:"]}, {"block": 70, "type": "code", "linesLength": 3, "startIndex": 165, "lines": ["# exemple\n", "input = \"    Isaac Newton, physicist\"\n", "match = re.search(r\"(\\w+) (?P<name>\\w+)\", input)"]}, {"block": 71, "type": "markdown", "linesLength": 1, "startIndex": 168, "lines": [" * `re` et `string` pour retrouver les donn\u00e9es d'entr\u00e9e du match:"]}, {"block": 72, "type": "code", "linesLength": 1, "startIndex": 169, "lines": ["match.string"]}, {"block": 73, "type": "code", "linesLength": 1, "startIndex": 170, "lines": ["match.re"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 171, "lines": [" * `group`, `groups`, `groupdict` pour retrouver les morceaux de la cha\u00eene d'entr\u00e9e qui correspondent aux **groupes** de la regexp; on peut y acc\u00e9der par rang, ou par nom (comme on l'a vu plus haut avec `needle`);"]}, {"block": 75, "type": "code", "linesLength": 1, "startIndex": 172, "lines": ["match.groups()"]}, {"block": 76, "type": "code", "linesLength": 1, "startIndex": 173, "lines": ["match.group(1)"]}, {"block": 77, "type": "code", "linesLength": 1, "startIndex": 174, "lines": ["match.group('name')"]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 175, "lines": ["match.group(2)"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 176, "lines": ["match.groupdict()"]}, {"block": 80, "type": "markdown", "linesLength": 3, "startIndex": 177, "lines": [" Comme on le voit pour l'acc\u00e8s par rang **les indices commencent \u00e0 1** pour des raisons historiques (on peut d\u00e9j\u00e0 r\u00e9f\u00e9rencer `\\1` en sed depuis la fin des ann\u00e9es 70). \n", " \n", " On peut aussi acc\u00e9der au **groupe 0** comme \u00e9tant la partie de la cha\u00eene de d\u00e9part qui a effectivement \u00e9t\u00e9 filtr\u00e9e par l'expression r\u00e9guli\u00e8re, et qui peut tout \u00e0 fait \u00eatre au beau milieu de la cha\u00eene de d\u00e9part, comme dans notre exemple: "]}, {"block": 81, "type": "code", "linesLength": 1, "startIndex": 180, "lines": ["match.group(0)"]}, {"block": 82, "type": "markdown", "linesLength": 1, "startIndex": 181, "lines": [" * `expand` permet de faire une esp\u00e8ce de `str.format` avec les valeurs des groupes;"]}, {"block": 83, "type": "code", "linesLength": 1, "startIndex": 182, "lines": ["match.expand(r\"last_name \\g<name> first_name \\1\")"]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 183, "lines": [" * `span` pour conna\u00eetre les index dans la cha\u00eene d'entr\u00e9e pour un groupe donn\u00e9:"]}, {"block": 85, "type": "code", "linesLength": 2, "startIndex": 184, "lines": ["begin, end = match.span('name')\n", "input[begin:end]"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 186, "lines": ["##### Les diff\u00e9rents modes (*flags*)"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 187, "lines": ["Enfin il faut noter qu'on peut passer \u00e0 `re.compile` un certain nombre de *flags* qui modifient globalement l'interpr\u00e9tation de la cha\u00eene, et qui peuvent rendre service. "]}, {"block": 88, "type": "markdown", "linesLength": 6, "startIndex": 188, "lines": ["Vous trouverez [une liste exhaustive de ces *flags* ici](https://docs.python.org/3/library/re.html#module-contents); ils ont en g\u00e9n\u00e9ral un nom long et parlant, et un alias court sur un seul caract\u00e8re. Les plus utiles sont sans doute:\n", " * `IGNORECASE` (*alias* `I`): pour, eh bien, ne pas faire la diff\u00e9rence entre minuscules et majuscules,\n", " * `UNICODE` (*alias* `U`): pour rendre les s\u00e9quences `\\w` et autres bas\u00e9es sur les propri\u00e9t\u00e9s des caract\u00e8res dans la norme Unicode,\n", " * `LOCALE` (*alias* `L`): cette fois `\\w` d\u00e9pend du `locale` courant.\n", " * `MULTILINE` (*alias* `M`), et\n", " * `DOTALL` (*alias* S): pour ces deux flags voir la discussion \u00e0 la fin du compl\u00e9ment."]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 194, "lines": ["Comme c'est souvent le cas, on doit passer \u00e0 `re.compile` un **ou logique** (caract\u00e8re `|`) des diff\u00e9rents flags que l'on veut utiliser, c'est-\u00e0-dire qu'on fera par exemple:"]}, {"block": 90, "type": "code", "linesLength": 2, "startIndex": 195, "lines": ["regexp = \"a*b+\"\n", "re_obj = re.compile(regexp, flags=re.IGNORECASE | re.DEBUG)"]}, {"block": 91, "type": "code", "linesLength": 2, "startIndex": 197, "lines": ["# on ignore la casse des caract\u00e8res \n", "print(regexp, \"->\", nice(re_obj.match(\"AabB\")))"]}, {"block": 92, "type": "markdown", "linesLength": 1, "startIndex": 199, "lines": ["### Comment construire une expression r\u00e9guli\u00e8re"]}, {"block": 93, "type": "markdown", "linesLength": 1, "startIndex": 200, "lines": ["Nous pouvons \u00e0 pr\u00e9sent voir comment construire une expression r\u00e9guli\u00e8re, en essayant de rester synth\u00e9tique (la [documentation du module `re`](https://docs.python.org/3/library/re.html) en donne une version exhaustive)."]}, {"block": 94, "type": "markdown", "linesLength": 1, "startIndex": 201, "lines": ["##### La brique de base : le caract\u00e8re"]}, {"block": 95, "type": "markdown", "linesLength": 14, "startIndex": 202, "lines": ["Au commencement il faut sp\u00e9cifier des caract\u00e8res:\n", " * **un seul** caract\u00e8re: \n", "   * vous le citez tel quel, en le pr\u00e9c\u00e9dent d'un backslash `\\` s'il a par ailleurs un sens sp\u00e9cial dans le micro-langage de regexps (comme `+`, `*`, `[`, etc.);\n", " * l'**attrape-tout** (*wildcard*):\n", "    * un point `.` signifie \"n'importe quel caract\u00e8re\";\n", " * **un ensemble** de caract\u00e8res avec la notation `[...]` qui permet de d\u00e9crire par exemple:\n", "   * `[a1=]` un ensemble in extenso, ici un caract\u00e8re parmi `a`, `1`, ou `=`,\n", "   * `[a-z]` un intervalle de caract\u00e8res, ici de `a` \u00e0 `z`,\n", "   * `[15e-g]` un m\u00e9lange des deux, ici un ensemble qui contiendrait `1`, `5`, `e`, `f` et `g`,\n", "   * `[^15e-g]` une **n\u00e9gation**, qui a `^` comme premier caract\u00e8re dans les `[]`, ici tout sauf l'ensemble pr\u00e9c\u00e9dent;\n", " * un **ensemble pr\u00e9d\u00e9fini** de caract\u00e8res, qui peuvent alors d\u00e9pendre de l'environnement (UNICODE et LOCALE) avec entre autres les notations:\n", "   * `\\w` les caract\u00e8res alphanum\u00e9riques, et `\\W` (les autres),\n", "   * `\\s` les caract\u00e8res \"blancs\" - espace, tabulation, saut de ligne, etc., et `\\S` (les autres),\n", "   * `\\d` pour les chiffres, et `\\D` (les autres)."]}, {"block": 96, "type": "code", "linesLength": 5, "startIndex": 216, "lines": ["input = \"abcd\"\n", "\n", "for regexp in ['abcd', 'ab[cd][cd]', 'ab[a-z]d', r'abc.', r'abc\\.']:\n", "    match = re.match(regexp, input)\n", "    print(f\"{input} / {regexp:<10s} \u2192 {nice(match)}\")"]}, {"block": 97, "type": "markdown", "linesLength": 1, "startIndex": 221, "lines": ["Pour ce dernier exemple, comme on a backslash\u00e9 le `.` il faut que la cha\u00eene en entr\u00e9e contienne vraiment un `.`:"]}, {"block": 98, "type": "code", "linesLength": 1, "startIndex": 222, "lines": ["print(nice(re.match (r\"abc\\.\", \"abc.\")))"]}, {"block": 99, "type": "markdown", "linesLength": 1, "startIndex": 223, "lines": ["##### En s\u00e9rie ou en parall\u00e8le"]}, {"block": 100, "type": "markdown", "linesLength": 5, "startIndex": 224, "lines": ["Si je fais une analogie avec les montages \u00e9lectriques, jusqu'ici on a vu le montage en s\u00e9rie: on met des expressions r\u00e9guli\u00e8res bout \u00e0 bout, qui filtrent (`match`) la chaine en entr\u00e9e s\u00e9quentiellement du d\u00e9but \u00e0 la fin. On a *un peu* de marge pour sp\u00e9cifier des alternatives, lorsqu'on fait par exemple\n", "\n", "    \"ab[cd]ef\"\n", "    \n", "mais c'est limit\u00e9 \u00e0 **un seul** caract\u00e8re. Si on veut reconnaitre deux mots qui n'ont pas grand-chose \u00e0 voir comme `abc` **ou** `def`, il faut en quelque sorte mettre deux regexps en parall\u00e8le, et c'est ce que permet l'op\u00e9rateur `|`"]}, {"block": 101, "type": "code", "linesLength": 5, "startIndex": 229, "lines": ["regexp = \"abc|def\"\n", "\n", "for input in ['abc', 'def', 'aef']:\n", "    match = re.match(regexp, input)\n", "    print(f\"{input} / {regexp} \u2192 {nice(match)}\")"]}, {"block": 102, "type": "markdown", "linesLength": 1, "startIndex": 234, "lines": ["##### Fin(s) de cha\u00eene"]}, {"block": 103, "type": "markdown", "linesLength": 9, "startIndex": 235, "lines": ["Selon que vous utilisez `match` ou `search`, vous pr\u00e9cisez si vous vous int\u00e9ressez uniquement \u00e0 un match en d\u00e9but (`match`) ou n'importe o\u00f9 (`search`) dans la cha\u00eene.\n", "\n", "Mais ind\u00e9pendamment de cela, il peut \u00eatre int\u00e9ressant de \"coller\" l'expression en d\u00e9but ou en fin de ligne, et pour \u00e7a il existe des caract\u00e8res sp\u00e9ciaux:\n", " * `^` lorsqu'il est utilis\u00e9 comme un caract\u00e8re (c'est \u00e0 dire pas en d\u00e9but de `[]`) signifie un d\u00e9but de cha\u00eene;\n", " * `\\A` a le m\u00eame sens (sauf en mode MULTILINE), et je le recommande de pr\u00e9f\u00e9rence \u00e0 `^` qui est d\u00e9j\u00e0 pas mal surcharg\u00e9;\n", " * `$` matche une fin de ligne;\n", " * `\\Z` est voisin mais pas tout \u00e0 fait identique.\n", "\n", "Reportez-vous \u00e0 la documentation pour le d\u00e9tails des diff\u00e9rences. Attention aussi \u00e0 entrer le `^` correctement, il vous faut le caract\u00e8re ASCII et non un voisin dans la m\u00e9nagerie Unicode."]}, {"block": 104, "type": "code", "linesLength": 5, "startIndex": 244, "lines": ["input = 'abcd'\n", "\n", "for regexp in [ 'bc', r'\\Aabc', '^abc', r'\\Abc', '^bc', r'bcd\\Z', 'bcd$', r'bc\\Z', 'bc$' ]:\n", "    match = re.match(regexp, input)\n", "    print(f\"{input} / {regexp:5s} \u2192 {nice(match)}\")"]}, {"block": 105, "type": "markdown", "linesLength": 1, "startIndex": 249, "lines": ["On a en effet bien le pattern `bc` dans la chaine en entr\u00e9e, mais il n'est ni au d\u00e9but ni \u00e0 la fin."]}, {"block": 106, "type": "markdown", "linesLength": 1, "startIndex": 250, "lines": ["##### Parenth\u00e9ser - (grouper)"]}, {"block": 107, "type": "markdown", "linesLength": 1, "startIndex": 251, "lines": ["Pour pouvoir faire des montages \u00e9labor\u00e9s, il faut pouvoir parenth\u00e9ser:"]}, {"block": 108, "type": "code", "linesLength": 6, "startIndex": 252, "lines": ["# une parenth\u00e9se dans une RE \n", "# pour mettre en ligne:\n", "# un d\u00e9but 'a', \n", "# un milieu 'bc' ou 'de' \n", "# et une fin 'f'\n", "regexp = \"a(bc|de)f\""]}, {"block": 109, "type": "markdown", "linesLength": 1, "startIndex": 258, "lines": ["<img src=\"media/re-serie-parallele.png\">"]}, {"block": 110, "type": "code", "linesLength": 3, "startIndex": 259, "lines": ["for input in ['abcf', 'adef',  'abef', 'abf']:\n", "    match = re.match(regexp, input)\n", "    print(f\"{input:>4s} \u2192 {nice(match)}\")"]}, {"block": 111, "type": "markdown", "linesLength": 1, "startIndex": 262, "lines": ["Les parenth\u00e8ses jouent un r\u00f4le additionel de **groupe**, ce qui signifie qu'on **peut retrouver** le texte correspondant \u00e0 l'expression r\u00e9guli\u00e8re comprise dans les `()`. Par exemple, pour le premier match:"]}, {"block": 112, "type": "code", "linesLength": 3, "startIndex": 263, "lines": ["input = 'abcf'\n", "match = re.match(regexp, input)\n", "print(f\"{input}, {regexp} \u2192 {match.groups()}\")"]}, {"block": 113, "type": "markdown", "linesLength": 1, "startIndex": 266, "lines": ["dans cet exemple, on n'a utilis\u00e9 qu'un seul groupe `()`, et le morceau de cha\u00eene qui correspond \u00e0 ce groupe se trouve donc \u00eatre le seul groupe retourn\u00e9 par `MatchObject.group`."]}, {"block": 114, "type": "markdown", "linesLength": 1, "startIndex": 267, "lines": ["##### Compter les r\u00e9p\u00e9titions"]}, {"block": 115, "type": "markdown", "linesLength": 6, "startIndex": 268, "lines": ["Vous disposez des op\u00e9rateurs suivants:\n", " * `*` l'\u00e9toile qui signifie n'importe quel nombre, m\u00eame nul, d'occurrences  - par exemple, `(ab)*` pour indiquer `''` ou `'ab'` ou `'abab'` ou etc.,\n", " * `+` le plus qui signifie au moins une occurrence - e.g. `(ab)+` pour `ab` ou `abab` ou `ababab` ou etc,\n", " * `?` qui indique une option, c'est-\u00e0-dire 0 ou 1 occurence - autrement dit `(ab)?` matche `''` ou `ab`, \n", " * `{n}` pour exactement n occurrences de `(ab)` - e.g. `(ab){3}` qui serait exactement \u00e9quivalent \u00e0 `ababab`,\n", " * `{m,n}` entre m et n fois inclusivement."]}, {"block": 116, "type": "code", "linesLength": 8, "startIndex": 274, "lines": ["inputs = [n*'ab' for n in [0, 1, 3, 4]] + ['baba']\n", "\n", "for regexp in ['(ab)*', '(ab)+', '(ab){3}', '(ab){3,4}']:\n", "    # on ajoute \\A \\Z pour matcher toute la chaine\n", "    line_regexp = r\"\\A{}\\Z\".format(regexp)\n", "    for input in inputs:\n", "        match = re.match(line_regexp, input)\n", "        print(f\"{input:>8s} / {line_regexp:14s} \u2192 {nice(match)}\")"]}, {"block": 117, "type": "markdown", "linesLength": 1, "startIndex": 282, "lines": ["##### Groupes et contraintes"]}, {"block": 118, "type": "markdown", "linesLength": 6, "startIndex": 283, "lines": ["Nous avons d\u00e9j\u00e0 vu un exemple de groupe nomm\u00e9 (voir `needle` plus haut); les op\u00e9rateurs que l'on peut citer dans cette cat\u00e9gorie sont:\n", " * `(...)` les parenth\u00e8ses d\u00e9finissent un groupe anonyme,\n", " * `(?P<name>...)` d\u00e9finit un groupe nomm\u00e9,\n", " * `(?:...)` permet de mettre des parenth\u00e8ses mais sans cr\u00e9er un groupe, pour optimiser l'ex\u00e9cution puisqu'on n'a pas besoin de  conserver les liens vers la cha\u00eene d'entr\u00e9e,\n", " * `(?P=name)` qui ne matche que si l'on retrouve \u00e0 cet endroit de l'entr\u00e9e la m\u00eame sous-cha\u00eene que celle trouv\u00e9e pour le groupe `name` en amont,\n", " * enfin `(?=...)`, `(?!...)`et `(?<=...)` permettent des contraintes encore plus \u00e9labor\u00e9es, nous vous laissons le soin d'exp\u00e9rimenter avec elles si vous \u00eates int\u00e9ress\u00e9s; sachez toutefois que l'utilisation de telles constructions peut en th\u00e9orie rendre l'interpr\u00e9tation de votre expression r\u00e9guli\u00e8re beaucoup moins efficace."]}, {"block": 119, "type": "markdown", "linesLength": 1, "startIndex": 289, "lines": ["##### Greedy *vs* non-greedy"]}, {"block": 120, "type": "markdown", "linesLength": 1, "startIndex": 290, "lines": ["Lorsqu'on stipule une r\u00e9p\u00e9tition un nombre ind\u00e9fini de fois, il se peut qu'il existe **plusieurs** fa\u00e7ons de filtrer l'entr\u00e9e avec l'expression r\u00e9guli\u00e8re. Que ce soit avec `*`, ou `+`, ou `?`, l'algorithme va toujours essayer de trouver la **s\u00e9quence la plus longue**, c'est pourquoi on qualifie l'approche de *greedy* - quelque chose comme glouton en fran\u00e7ais:"]}, {"block": 121, "type": "code", "linesLength": 12, "startIndex": 291, "lines": ["# un fragment d'HTML \n", "line='<h1>Title</h1>'\n", "\n", "# si on cherche un texte quelconque entre crochets\n", "# c'est-\u00e0-dire l'expression r\u00e9guli\u00e8re \"<.*>\"\n", "re_greedy = '<.*>'\n", "\n", "# on obtient ceci\n", "# on rappelle que group(0) montre la partie du fragment\n", "# HTML qui matche l'expression r\u00e9guli\u00e8re\n", "match = re.match(re_greedy, line)\n", "match.group(0)"]}, {"block": 122, "type": "markdown", "linesLength": 4, "startIndex": 303, "lines": ["\u00c7a n'est pas forc\u00e9ment ce qu'on voulait faire; aussi on peut sp\u00e9cifier l'approche inverse, c'est-\u00e0-dire de trouver la **plus-petite** cha\u00eene qui matche, dans une approche dite *non-greedy*, avec les op\u00e9rateurs suivants:\n", " * `*?` : `*` mais *non-greedy*,\n", " * `+?` : `+` mais *non-greedy*,\n", " * `??` : `?` mais *non-greedy*,"]}, {"block": 123, "type": "code", "linesLength": 7, "startIndex": 307, "lines": ["# ici on va remplacer * par *? pour rendre l'op\u00e9rateur * non-greedy\n", "re_non_greedy = re_greedy = '<.*?>'\n", "\n", "# mais on continue \u00e0 cherche un texte entre <> naturellement\n", "# si bien que cette fois, on obtient\n", "match = re.match(re_non_greedy, line)\n", "match.group(0)"]}, {"block": 124, "type": "markdown", "linesLength": 1, "startIndex": 314, "lines": ["##### S'agissant du traitement des fins de ligne"]}, {"block": 125, "type": "markdown", "linesLength": 5, "startIndex": 315, "lines": ["Il peut \u00eatre utile, pour conclure cette pr\u00e9sentation, de pr\u00e9ciser un peu le comportement de la librairie vis-\u00e0-vis des fins de ligne.\n", "\n", "Historiquement, les expressions r\u00e9guli\u00e8res telles qu'on les trouve dans les librairies C, donc dans `sed`, `grep` et autre utilitaires Unix, sont associ\u00e9es au mod\u00e8le mental o\u00f9 on filtre les entr\u00e9es ligne par ligne.\n", "\n", "Le module `re` en garde des traces, puisque:"]}, {"block": 126, "type": "code", "linesLength": 6, "startIndex": 320, "lines": ["# un exemple de traitement des 'newline' \n", "input = \"\"\"une entr\u00e9e\n", "sur\n", "plusieurs\n", "lignes\n", "\"\"\""]}, {"block": 127, "type": "code", "linesLength": 2, "startIndex": 326, "lines": ["match = re.compile(\"(.*)\").match(input)\n", "match.groups()"]}, {"block": 128, "type": "markdown", "linesLength": 1, "startIndex": 328, "lines": ["Vous voyez donc que l'attrape-tout `'.'` en fait n'attrape pas le caract\u00e8re de fin de ligne `\\n`, puisque si c'\u00e9tait le cas et  compte tenu du cot\u00e9 *greedy* de l'algorithme on devrait voir ici tout le contenu de `input`. Il existe un *flag* `re.DOTALL` qui permet de faire de `.` un vrai attrape-tout qui capture aussi les *newline*:"]}, {"block": 129, "type": "code", "linesLength": 2, "startIndex": 329, "lines": ["match = re.compile(\"(.*)\", flags=re.DOTALL).match(input)\n", "match.groups()"]}, {"block": 130, "type": "markdown", "linesLength": 1, "startIndex": 331, "lines": ["Cela dit, le caract\u00e8re *newline* est par ailleurs consid\u00e9r\u00e9 comme un caract\u00e8re comme un autre, on peut le mentionner **dans une regexp** comme les autres; voici quelques exemples pour illustrer tout ceci:"]}, {"block": 131, "type": "code", "linesLength": 3, "startIndex": 332, "lines": ["# sans mettre le flag unicode \\w ne matche que l'ASCII\n", "match = re.compile(\"([\\w ]*)\").match(input)\n", "match.groups()"]}, {"block": 132, "type": "code", "linesLength": 3, "startIndex": 335, "lines": ["# sans mettre le flag unicode \\w ne matche que l'ASCII\n", "match = re.compile(\"([\\w ]*)\", flags=re.U).match(input)\n", "match.groups()"]}, {"block": 133, "type": "code", "linesLength": 8, "startIndex": 338, "lines": ["# si on ajoute \\n \u00e0 la liste des caract\u00e8res attendus \n", "# on obtient bien tout le contenu initial\n", "\n", "# attention ici il ne FAUT PAS utiliser un raw string,\n", "# car on veut vraiment \u00e9crire un newline dans la regexp\n", "\n", "match = re.compile(\"([\\w \\n]*)\", flags=re.UNICODE).match(input)\n", "match.groups()"]}, {"block": 134, "type": "markdown", "linesLength": 1, "startIndex": 346, "lines": ["### Conclusion"]}, {"block": 135, "type": "markdown", "linesLength": 1, "startIndex": 347, "lines": ["La mise au point d'expressions r\u00e9guli\u00e8res est certes un peu exigeante, et demande pas mal de pratique, mais permet d'\u00e9crire en quelques lignes des fonctionnalit\u00e9s tr\u00e8s puissantes, c'est un investissement tr\u00e8s rentable :)"]}, {"block": 136, "type": "markdown", "linesLength": 3, "startIndex": 348, "lines": ["Je vous signale enfin l'existence de **sites web** qui \u00e9valuent une expression r\u00e9guli\u00e8re **de mani\u00e8re interactive** et qui peuvent rendre la mise au point moins fastidieuse. \n", "\n", "Je vous signale notamment https://pythex.org/, et il en existe beaucoup d'autres."]}, {"block": 137, "type": "markdown", "linesLength": 1, "startIndex": 351, "lines": ["### Pour en savoir plus"]}, {"block": 138, "type": "markdown", "linesLength": 9, "startIndex": 352, "lines": ["Pour ceux qui ont quelques rudiments de la th\u00e9orie des langages, vous savez qu'on distingue en g\u00e9n\u00e9ral \n", " * l'**analyse lexicale**, qui d\u00e9coupe le texte en morceaux (qu'on appelle des *tokens*),\n", " * et l'**analyse syntaxique** qui d\u00e9crit pour simplifier \u00e0 l'extr\u00eame l'ordre dans lequel on peut trouver les tokens.\n", " \n", "Avec les expression r\u00e9guli\u00e8res, on adresse le niveau de l'analyse lexicale. Pour l'analyse syntaxique, qui est franchement au del\u00e0 des objectifs de ce cours, il existe de nombreuses alternatives, parmi lesquelles:\n", " * [`pyparsing`](http://pyparsing.wikispaces.com/Download+and+Installation)\n", " * [`PLY` (Python Lex-Yacc)](http://www.dabeaz.com/ply/)\n", " * [`ANTLR`](http://www.antlr.org) qui est un outil \u00e9crit en Java mais qui peut g\u00e9n\u00e9rer des parsers en python,\n", " * ...\n"]}]
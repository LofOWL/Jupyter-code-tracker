[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 9: Signals and Systems\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 13, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import math\n", "import numpy as np\n", "import pandas\n", "import scipy.signal\n", "\n", "PI2 = 2 * math.pi\n", "\n", "%precision 3\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["We'll start by exploring the price of BitCoin, which resembles red noise:"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["df = pandas.read_csv('coindesk-bpi-USD-close.csv', nrows=1625, parse_dates=[0])\n", "ys = df.Close.values"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Here's what the time series looks like:"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["wave = thinkdsp.Wave(ys, framerate=1)\n", "wave.plot()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["And here's the spectrum on a log-log scale."]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot()\n", "thinkplot.config(xscale='log', yscale='log', legend=False)"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["The slope is -1.8, which is similar to red noise (which should have a slope of -2)."]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["spectrum.estimate_slope()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["We can use `np.diff` to compute the difference between successive elements, which is the daily change."]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 33, "lines": ["diff = np.diff(ys)\n", "wave2 = thinkdsp.Wave(diff, framerate=1)\n", "wave2.plot()"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["And here's the spectrum of the daily changes:"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 37, "lines": ["spectrum2 = wave2.make_spectrum()\n", "spectrum2.plot()"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["And here's the spectrum on a log-log scale."]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 40, "lines": ["spectrum2.plot()\n", "thinkplot.config(xscale='log', yscale='log', legend=False)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["The estimated slope is close to zero, which is consistent with white noise."]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["spectrum2.estimate_slope()"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["Now let's compare the spectrum of closing price with the spectrum of daily changes; that is, the ratio of the spectrums before and after applying 'np.diff':"]}, {"block": 19, "type": "code", "linesLength": 7, "startIndex": 45, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "\n", "n = min(len(amps), len(amps2))\n", "ratio = amps2[:n] / amps[:n]\n", "\n", "thinkplot.plot(ratio)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["We can think the diff operation as convolution with a difference window:"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["window = np.array([1.0, -1.0])"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["And we can use `scipy.signal.convolve` to compute it:"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 55, "lines": ["ys = scipy.signal.convolve(wave.ys, window, mode='valid')\n", "diff = thinkdsp.Wave(ys, framerate=1)\n", "diff.plot()"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Or you can compute the same thing by computing the difference filter, which is the DFT of the difference window, and they multiplying in the frequency domain."]}, {"block": 25, "type": "code", "linesLength": 4, "startIndex": 59, "lines": ["def zero_pad(array, n):\n", "    res = np.zeros(n)\n", "    res[:len(array)] = array\n", "    return res"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Here are two windows that approximate the first derivative:"]}, {"block": 27, "type": "code", "linesLength": 4, "startIndex": 64, "lines": ["window = np.array([1.0, -1.0])\n", "window2 = np.array([-1, 4, -3]) / 2.0\n", "\n", "padded = zero_pad(window, len(wave))"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["And here's what the corresponding filter looks like:"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 69, "lines": ["fft_window = np.fft.rfft(padded)\n", "thinkplot.plot(abs(fft_window))"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Now here's the filter again, superimposed on the ratios we computed earlier:"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 72, "lines": ["thinkplot.plot(ratio, color='gray')\n", "thinkplot.plot(abs(fft_window))\n", "thinkplot.config(ylim=[0, 4])"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["The difference filter has this shape because it is an approximation of differentiation, and the filter for differentiation is proportional to $f$.  Specifically, each complex component is multiplied by $2 \\pi i f$.  So we can compute a numerical derivative by applying this filter in the frequency domain:"]}, {"block": 33, "type": "code", "linesLength": 5, "startIndex": 76, "lines": ["spectrum3 = wave.make_spectrum()\n", "i = complex(0, 1)\n", "filtr = PI2 * i * spectrum3.fs\n", "spectrum3.hs *= filtr\n", "spectrum3.plot()"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["The results are similar, with some differences due to (1) the difference window is only a coarse approximation of the derivative, especially at higher frequencies, and (2) the spectral derivative is based on the assumption that the signal is periodic, so the behavior at the beginning and end is different."]}, {"block": 35, "type": "code", "linesLength": 3, "startIndex": 82, "lines": ["wave3 = spectrum3.make_wave()\n", "wave2.plot(color='0.7')\n", "wave3.plot()"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["Here's the difference between the derivative filter and the difference filter:"]}, {"block": 37, "type": "code", "linesLength": 5, "startIndex": 86, "lines": ["amps = spectrum.amps\n", "amps3 = spectrum3.amps\n", "ratio3 = amps3 / amps\n", "thinkplot.plot(abs(fft_window))\n", "thinkplot.plot(ratio3)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["The next topic is the use of impulse response for system characterization.  We start with a recording of a gunshot:"]}, {"block": 39, "type": "code", "linesLength": 5, "startIndex": 92, "lines": ["response = thinkdsp.read_wave('180961__kleeb__gunshots.wav')\n", "response = response.segment(start=0.26, duration=5.0)\n", "response.normalize()\n", "response.plot()\n", "thinkplot.config(ylim=[-1.05, 1.05])"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["Here's what it sounds like:"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["response.make_audio()"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["The recording is the impulse response of the system (the room and recording equipment).   The DFT of the impulse response is the transfer function:"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 100, "lines": ["transfer = response.make_spectrum()\n", "transfer.plot()"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["Here's the transfer function on a log-log scale:"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["transfer.plot()\n", "thinkplot.config(xscale='log', yscale='log')"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["Now we can simulate what a recording would sound like if it were played in the same room and recorded in the same way.  Here's the violin recording we have used before:"]}, {"block": 47, "type": "code", "linesLength": 5, "startIndex": 106, "lines": ["violin = thinkdsp.read_wave('92002__jcveliz__violin-origional.wav')\n", "violin.ys = violin.ys[:len(response)]\n", "violin.normalize()\n", "violin.plot()\n", "thinkplot.config(ylim=[-1.05, 1.05])"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 111, "lines": ["Here's what it sounds like before transformation:"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["violin.make_audio()"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["Now we compute the DFT of the violin recording."]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 114, "lines": ["spectrum = violin.make_spectrum()"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["I trimmed the violin recording to the same length as the impulse response:"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 116, "lines": ["len(spectrum.hs), len(transfer.hs)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 117, "lines": ["We we can multiply in the frequency domain and the transform back to the time domain."]}, {"block": 55, "type": "code", "linesLength": 2, "startIndex": 118, "lines": ["output = (spectrum * transfer).make_wave()\n", "output.normalize()"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Here'a  comparison of the original and transformed recordings:"]}, {"block": 57, "type": "code", "linesLength": 2, "startIndex": 121, "lines": ["violin.plot()\n", "output.plot()"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 123, "lines": ["And here's what it sounds like:"]}, {"block": 59, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["output.make_audio()"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["To understand how that worked, you can think about the input signal as a series of impulses, and the output as the sume of shifted, scaled versions of the impulse response."]}, {"block": 61, "type": "code", "linesLength": 5, "startIndex": 126, "lines": ["def shifted_scaled(wave, shift, factor):\n", "    res = wave.copy()\n", "    res.shift(shift)\n", "    res.scale(factor)\n", "    return res"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 131, "lines": ["Here's what it would sound like if we fired a big gun followed by a small gun:"]}, {"block": 63, "type": "code", "linesLength": 7, "startIndex": 132, "lines": ["dt = 1\n", "shift = dt * response.framerate\n", "factor = 0.5\n", "\n", "response2 = response + shifted_scaled(response, shift, factor)\n", "response2.plot()\n", "thinkplot.config(xlabel='time (s)', ylabel='amplitude', ylim=[-1.05, 1.05])"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["Two gunshots:"]}, {"block": 65, "type": "code", "linesLength": 1, "startIndex": 140, "lines": ["response2.make_audio()"]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 141, "lines": ["Here's what it sounds like if we fire 100 guns at a rate of 441 gunshots per second:"]}, {"block": 67, "type": "code", "linesLength": 4, "startIndex": 142, "lines": ["total = 0\n", "for j in range(100):\n", "    total += shifted_scaled(response, j*100, 1.0)\n", "total.normalize()"]}, {"block": 68, "type": "markdown", "linesLength": 0, "startIndex": 146, "lines": []}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 146, "lines": ["total.make_audio()"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["The result has a fundamental frequency at 441, with additional harmonics."]}, {"block": 71, "type": "code", "linesLength": 1, "startIndex": 148, "lines": ["total.make_spectrum().plot(high=8000)"]}, {"block": 72, "type": "markdown", "linesLength": 1, "startIndex": 149, "lines": ["Now let's do the same thing with a sawtooth signal:"]}, {"block": 73, "type": "code", "linesLength": 3, "startIndex": 150, "lines": ["sawtooth = thinkdsp.SawtoothSignal(freq=410).make_wave(duration=0.2, framerate=response.framerate)\n", "sawtooth.plot()\n", "thinkplot.config(xlabel='time (s)', ylabel='amplitude', ylim=[-1.05, 1.05])"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 153, "lines": ["Here's what it sounds like:"]}, {"block": 75, "type": "code", "linesLength": 1, "startIndex": 154, "lines": ["sawtooth.make_audio()"]}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["And here's what we get if we use the sawtooth to generate shifted, scaled versions of the impulse response:"]}, {"block": 77, "type": "code", "linesLength": 4, "startIndex": 156, "lines": ["total = 0\n", "for j, y in enumerate(sawtooth.ys):\n", "    total += shifted_scaled(response, j, y)\n", "total.normalize()"]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 160, "lines": ["The result is a simulation of what the sawtooth signal would sound like if it was recorded in the room where the gunshot was recorded:"]}, {"block": 79, "type": "code", "linesLength": 2, "startIndex": 161, "lines": ["total.plot()\n", "thinkplot.config(xlabel='time (s)', ylabel='amplitude', ylim=[-1.05, 1.05])"]}, {"block": 80, "type": "markdown", "linesLength": 1, "startIndex": 163, "lines": ["And here's what it sounds like:"]}, {"block": 81, "type": "code", "linesLength": 1, "startIndex": 164, "lines": ["total.make_audio()"]}, {"block": 82, "type": "markdown", "linesLength": 3, "startIndex": 165, "lines": ["To me it sounds a bit like a car horn in a garage.\n", "\n", "And here's the spectrum:"]}, {"block": 83, "type": "code", "linesLength": 1, "startIndex": 168, "lines": ["total.make_spectrum().plot(high=8000)"]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 169, "lines": ["Here's a comparison before and after convolution:"]}, {"block": 85, "type": "code", "linesLength": 5, "startIndex": 170, "lines": ["sawtooth.make_spectrum().plot(high=500, color='0.7')\n", "\n", "segment = total.segment(duration=0.2)\n", "segment.make_spectrum().plot(high=1000)\n", "thinkplot.config(xlabel='frequency (Hz)', ylabel='amplitude')"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 175, "lines": ["Now that we recognize this operation as convolution, we can compute it by multiplying the signals (which performs convolution):"]}, {"block": 87, "type": "code", "linesLength": 3, "startIndex": 176, "lines": ["convolved = sawtooth.convolve(response)\n", "convolved.normalize()\n", "convolved.make_audio()"]}, {"block": 88, "type": "markdown", "linesLength": 1, "startIndex": 179, "lines": ["And we can do the same thing with the violin recording:"]}, {"block": 89, "type": "code", "linesLength": 3, "startIndex": 180, "lines": ["convolved2 = violin.convolve(response)\n", "convolved2.normalize()\n", "convolved2.make_audio()"]}, {"block": 90, "type": "markdown", "linesLength": 1, "startIndex": 183, "lines": ["To understand why the impulse response is sufficient to characterize a system, it is informative to look at the DFT of an impulse:"]}, {"block": 91, "type": "code", "linesLength": 3, "startIndex": 184, "lines": ["impulse = np.zeros(8)\n", "impulse[0] = 1\n", "print(impulse)"]}, {"block": 92, "type": "markdown", "linesLength": 1, "startIndex": 187, "lines": ["The DFT of an impulse is all ones, which means that the impulse contains equal energy at all frequencies.  So testing a system with an impulse is like testing it will all frequency components at the same time:"]}, {"block": 93, "type": "code", "linesLength": 2, "startIndex": 188, "lines": ["spectrum = np.fft.fft(impulse)\n", "print(spectrum)"]}, {"block": 94, "type": "markdown", "linesLength": 1, "startIndex": 190, "lines": ["You might notice something about the impulse and its DFT:"]}, {"block": 95, "type": "code", "linesLength": 1, "startIndex": 191, "lines": ["np.sum(np.absolute(impulse)**2)"]}, {"block": 96, "type": "code", "linesLength": 1, "startIndex": 192, "lines": ["np.sum(np.absolute(spectrum)**2)"]}, {"block": 97, "type": "markdown", "linesLength": 3, "startIndex": 193, "lines": ["In general, the total magnitue of DFT(y) is N times the total magnitude of y.\n", "\n", "Finally, let's look at a mini example of system characterization.  Suppose you have a system that smooths the signal by taking a moving average of adjacent elements:"]}, {"block": 98, "type": "code", "linesLength": 1, "startIndex": 196, "lines": ["window = np.array([0.5, 0.5, 0, 0, 0, 0, 0, 0,])"]}, {"block": 99, "type": "markdown", "linesLength": 1, "startIndex": 197, "lines": ["For this moving average window, we can compute the transfer function:"]}, {"block": 100, "type": "code", "linesLength": 2, "startIndex": 198, "lines": ["filtr = scipy.fftpack.fft(window)\n", "filtr"]}, {"block": 101, "type": "markdown", "linesLength": 1, "startIndex": 200, "lines": ["Here are the magnitudes:"]}, {"block": 102, "type": "code", "linesLength": 1, "startIndex": 201, "lines": ["np.absolute(filtr)"]}, {"block": 103, "type": "markdown", "linesLength": 1, "startIndex": 202, "lines": ["To visualize the transfer function, I'll roll it so that frequency 0 is in the middle.  The DFT of a smoothing window is approximately Gaussian:"]}, {"block": 104, "type": "code", "linesLength": 2, "startIndex": 203, "lines": ["rolled = np.roll(filtr, 3)\n", "thinkplot.plot([-3, -2, -1, 0, 1, 2, 3, 4], rolled.real)"]}, {"block": 105, "type": "markdown", "linesLength": 1, "startIndex": 205, "lines": ["If you multiply the transfer function by the spectrum of an impulse (which is all ones), the result is the filter:"]}, {"block": 106, "type": "code", "linesLength": 2, "startIndex": 206, "lines": ["product = spectrum * filtr\n", "print(product)"]}, {"block": 107, "type": "markdown", "linesLength": 1, "startIndex": 208, "lines": ["Now if you transform back to the time domain, you have the impulse response, which looks a lot like the window:"]}, {"block": 108, "type": "code", "linesLength": 2, "startIndex": 209, "lines": ["filtered = scipy.fftpack.ifft(product)\n", "thinkplot.plot(filtered.real)"]}, {"block": 109, "type": "code", "linesLength": 1, "startIndex": 211, "lines": ["print(filtered.real)"]}, {"block": 110, "type": "markdown", "linesLength": 1, "startIndex": 212, "lines": ["This example is meant to demonstrate why a recording of an impulse response is sufficient to characterize a system: because it is the IDFT of the transfer function."]}, {"block": 111, "type": "code", "linesLength": 0, "startIndex": 213, "lines": []}]
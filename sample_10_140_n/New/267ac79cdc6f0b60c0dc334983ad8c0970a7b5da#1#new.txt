[{"block": 0, "type": "markdown", "linesLength": 14, "startIndex": 0, "lines": ["# Introduction: Analysis of Medium Stats\n", "\n", "In this notebook, we will analyze my Medium article stats. The functions for scraping and formatting the data were developed in the `Development` notebook, and here we will focus on looking at the data quantitatively and visually.\n", "\n", "## Instructions\n", "\n", "To apply to your own medium data\n", "\n", "1. Go to the stats page https://medium.com/me/stats\n", "2. Make sure to scroll all the way down to the bottom so all the articles are loaded\n", "3. Right click, and hit 'save as'. \n", "4. Save the file as `stats.html` in the `data/` directory. You can also save the responses to do a similar analysis.\n", "\n", "![](images/stats-saving-medium.gif)"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 14, "lines": ["    # Might need to run this on MAC for multiprocessing to work properly\n", "    # see https://stackoverflow.com/questions/50168647/multiprocessing-causes-python-to-crash-and-gives-an-error-may-have-been-in-progr\n", "    !export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 17, "lines": ["# Retrieve Statistics\n", "\n", "Thanks to a few functions already developed, you can get all of the statistics for your articles in under 10 seconds."]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 20, "lines": ["%load_ext autoreload\n", "%autoreload 2"]}, {"block": 4, "type": "code", "linesLength": 3, "startIndex": 22, "lines": ["from retrieval import process_in_parallel, get_table_rows\n", "\n", "table_rows = get_table_rows(fname='stats.html')"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Each of these entries is a separate article. To get the information about each article, we use the next function. This scrapes both the article metadata and the article itself (using `requests` and `BeautifulSoup`)."]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["df = process_in_parallel(table_rows=table_rows, processes=25)\n", "df.head()"]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 28, "lines": ["# Analysis\n", "\n", "With the comprehensive data, we can do any sort of analysis we want. There's a lot of data here and I'm sure you'll be able to find other interesting things to do with the data."]}, {"block": 8, "type": "code", "linesLength": 21, "startIndex": 31, "lines": ["# Data science imports\n", "import pandas as pd\n", "import numpy as np\n", "\n", "%load_ext autoreload\n", "%autoreload 2\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 25\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "import plotly.figure_factory as ff\n", "from plotly.offline import iplot\n", "\n", "import cufflinks\n", "cufflinks.go_offline()"]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 52, "lines": ["## Correlations\n", "\n", "We can start off by looking at correlations. We'll limit this to the `published` articles for now."]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 55, "lines": ["corrs = df[df['type'] == 'published'].corr()\n", "corrs.round(2)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["If we are looking at maximizing claps, what do we want to focus on?"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["corrs['claps'].sort_values(ascending=False)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Okay, so most of these occur after the article is released. However, the tag `Towards Data Science` seems to help quite a bit! It also looks like the read time is negatively correlated with the number of claps. "]}, {"block": 14, "type": "markdown", "linesLength": 9, "startIndex": 60, "lines": ["## Correlation Heatmap\n", "\n", "Using the `plotly` python library, we can very rapidly create interactive great looking charts.\n", "\n", "Here are the avaiable colorscales if you want to try others:\n", "\n", "    colorscales = ['Greys', 'YlGnBu', 'Greens', 'YlOrRd', 'Bluered', 'RdBu',\n", "            'Reds', 'Blues', 'Picnic', 'Rainbow', 'Portland', 'Jet',\n", "            'Hot', 'Blackbody', 'Earth', 'Electric', 'Viridis', 'Cividis']"]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 69, "lines": ["colorscales = ['Greys', 'YlGnBu', 'Greens', 'YlOrRd', 'Bluered', 'RdBu',\n", "        'Reds', 'Blues', 'Picnic', 'Rainbow', 'Portland', 'Jet',\n", "        'Hot', 'Blackbody', 'Earth', 'Electric', 'Viridis', 'Cividis']"]}, {"block": 16, "type": "code", "linesLength": 65, "startIndex": 72, "lines": ["import os\n", "import pandas as pd\n", "import plotly\n", "import plotly.graph_objs as go\n", "import time\n", "from pyvirtualdisplay import Display\n", "from selenium import webdriver\n", "from PIL import Image\n", "\n", "      \n", "### from bokeh/io, slightly modified to avoid their import_required util\n", "### didn't ultimately use, but leaving in case I figure out how to stick wtih phentomjs\n", "### - https://github.com/bokeh/bokeh/blob/master/bokeh/io/export.py\n", "def create_default_webdriver():\n", "    '''Return phantomjs enabled webdriver'''\n", "    phantomjs_path = detect_phantomjs()\n", "    return webdriver.PhantomJS(executable_path=phantomjs_path, service_log_path=devnull)\n", "\n", "\n", "### based on last SO answer above\n", "### - https://stackoverflow.com/questions/38615811/how-to-download-a-file-with-python-selenium-and-phantomjs\n", "def create_chromedriver_webdriver(dload_path):\n", "    display = Display(visible=0)\n", "    display.start()\n", "    chrome_options = webdriver.ChromeOptions()\n", "    prefs = {\"download.default_directory\": dload_path}\n", "    chrome_options.add_experimental_option(\"prefs\", prefs)\n", "    driver = webdriver.Chrome(chrome_options=chrome_options)\n", "    return driver, display\n", "\n", "df = pd.DataFrame(\n", "    {'fruits': ['Apples', 'Pears', 'Nectarines', 'Plums', 'Grapes', 'Strawberries'],\n", "     'counts': [5, 3, 4, 2, 4, 6] })\n", "\n", "data = [go.Bar(x=df['fruits'],\n", "               y=df['counts'])]\n", "\n", "dload = os.path.expanduser('~/Downloads')\n", "html_file = 'plotly-fruit-plot.html'\n", "fname = 'plotly-fruit-plot'\n", "\n", "### original code contained height/width for the display and chromium webdriver\n", "### I found they didn't matter; specifying the image size to generate will \n", "### produce a plot of that size no matter the webdriver\n", "plotly.offline.plot(data, filename=html_file, auto_open=False,\n", "                    image_width=1280, image_height=800,\n", "                    image_filename=fname, image='png')\n", "\n", "### create webdrive, open file, maximize, and sleep\n", "driver, display = create_chromedriver_webdriver(dload)\n", "\n", "driver.get('file:///{}'.format(os.path.abspath(html_file)))\n", "\n", "# make sure we give the file time to download\n", "time.sleep(1)\n", "\n", "### was in the SO post and could be a more robust way to wait vs. just sleeping 1sec\n", "# while not(glob.glob(os.path.join(dl_location, filename))):\n", "#     time.sleep(1)\n", "\n", "driver.close()\n", "display.stop()\n", "\n", "image = Image.open('{}.png'.format(os.path.join(dload, fname)))\n", "image"]}, {"block": 17, "type": "code", "linesLength": 7, "startIndex": 137, "lines": ["for c in colorscales:\n", "    figure = ff.create_annotated_heatmap(z = corrs.round(2).values, \n", "                                     x =list(corrs.columns), \n", "                                     y=list(corrs.index), \n", "                                     colorscale=c,\n", "                                     annotation_text=corrs.round(2).values)\n", "from plotly.plotly import sign_in"]}, {"block": 18, "type": "code", "linesLength": 6, "startIndex": 144, "lines": ["figure = ff.create_annotated_heatmap(z = corrs.round(2).values, \n", "                                     x =list(corrs.columns), \n", "                                     y=list(corrs.index), \n", "                                     colorscale='Portland',\n", "                                     annotation_text=corrs.round(2).values)\n", "iplot(figure)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 150, "lines": ["Correlations by themselves don't tell us that much. It does not help that most of these are pretty obvious, such as the `claps` and `fans` will be highly correlated. Sometimes correlations by themselves are useful, but not really in this case."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["## Scatterplot Matrix"]}, {"block": 21, "type": "code", "linesLength": 4, "startIndex": 152, "lines": ["figure = ff.create_scatterplotmatrix(df[['read_time', 'claps', 'type']],\n", "                                     index = 'type', colormap='Jet', title='Scatterplot Matrix by Type',\n", "                                     diag='histogram', width=800, height=800)\n", "iplot(figure)"]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 156, "lines": ["figure = ff.create_scatterplotmatrix(df[['read_time', 'claps', 'publication']],\n", "                                     index = 'publication', title='Scatterplot Matrix by Publication',\n", "                                     diag='histogram', width=800, height=800)\n", "iplot(figure)"]}, {"block": 23, "type": "code", "linesLength": 8, "startIndex": 160, "lines": ["figure = ff.create_scatterplotmatrix(df[['read_time', 'claps', 'views',\n", "                                         'num_responses', 'edit_days','publication']],\n", "                                     index = 'publication', \n", "                                     diag='histogram', \n", "                                     size=8, width=1000, height=1000,\n", "                                     title='Scatterplot Matrix by Publication')\n", "\n", "iplot(figure)"]}, {"block": 24, "type": "code", "linesLength": 7, "startIndex": 168, "lines": ["figure = ff.create_scatterplotmatrix(df[['read_time', 'views', 'ratio', 'publication']],\n", "                                     index = 'publication', \n", "                                     diag='histogram', \n", "                                     size=8, width=1000, height=1000,\n", "                                     title='Scatterplot Matrix by Publication')\n", "\n", "iplot(figure)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 175, "lines": ["# Histograms"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 176, "lines": ["from visuals import make_hist"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 177, "lines": ["figure = make_hist(df, x='views', category='publication')\n", "iplot(figure)"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 179, "lines": ["figure = make_hist(df, x='word_count', category='type')\n", "iplot(figure)"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 181, "lines": ["# Cumulative Plot"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 182, "lines": ["from visuals import make_cum_plot"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 183, "lines": ["figure = make_cum_plot(df, y='views')\n", "iplot(figure)"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 185, "lines": ["figure = make_cum_plot(df, y='views', category='publication')\n", "iplot(figure)"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 187, "lines": ["figure = make_cum_plot(df, y='word_count')\n", "iplot(figure)"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 189, "lines": ["df.head()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 190, "lines": ["# Scatter Plots"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 191, "lines": ["from visuals import make_scatter_plot"]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 192, "lines": ["figure = make_scatter_plot(df, x='read_time', y='ratio')\n", "iplot(figure)"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 194, "lines": ["figure = make_scatter_plot(df, x='read_time', y='ratio', category='type')\n", "iplot(figure)"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 196, "lines": ["figure = make_scatter_plot(df, x='read_time', y='views', ylog=True,\n", "                           category='type')\n", "iplot(figure)"]}, {"block": 40, "type": "code", "linesLength": 4, "startIndex": 199, "lines": ["df['binned_ratio'] = pd.cut(df['ratio'], list(range(0, 100, 10))).astype('str')\n", "figure = make_scatter_plot(df, x='read_time', y='views', ylog=True,\n", "                           category='binned_ratio')\n", "iplot(figure)"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 203, "lines": ["list(np.insert(np.logspace(start=0, stop=5, num=6),0,-1).astype(int))"]}, {"block": 42, "type": "code", "linesLength": 4, "startIndex": 204, "lines": ["df['binned_claps'] = pd.cut(df['claps'], list(np.insert(np.logspace(start=0, stop=5, num=6),0,-1).astype(int))).astype(str)\n", "figure = make_scatter_plot(df, x='word_count', y='fans',\n", "                           category='binned_claps')\n", "iplot(figure)"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 208, "lines": ["# Linear Regressions"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 209, "lines": ["figure = make_scatter_plot(df[df['type'] == 'published'], 'word_count', 'views')\n", "iplot(figure)"]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 211, "lines": ["from scipy import stats\n", "pub = df[df['type']=='published'].copy()\n", "stats.linregress(pub['word_count'], pub['views'])"]}, {"block": 46, "type": "code", "linesLength": 2, "startIndex": 214, "lines": ["figure = make_scatter_plot(df[df['type'] == 'published'], 'word_count', 'views', xlog=True)\n", "iplot(figure)"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 216, "lines": ["figure = make_scatter_plot(df, x='word_count', y='claps', scale='fans')\n", "iplot(figure)"]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 218, "lines": ["go.Scatter(a\n", "          )"]}, {"block": 49, "type": "code", "linesLength": 3, "startIndex": 220, "lines": ["from scipy import stats\n", "pub = df[df['type']=='published'].copy()\n", "stats.linregress(pub['word_count'], np.log10(pub['views']))"]}, {"block": 50, "type": "code", "linesLength": 2, "startIndex": 223, "lines": ["pub_tds = df[(df['type']=='published') & (df['<tag>Towards Data Science'] == 1)].copy()\n", "stats.linregress(pub_tds['word_count'], np.log10(pub_tds['views']))"]}, {"block": 51, "type": "code", "linesLength": 3, "startIndex": 225, "lines": ["figure = make_scatter_plot(df[(df['type']=='published') & (df['<tag>Towards Data Science'] == 1)], \n", "                           'word_count', 'views', xlog=True, category='claps')\n", "iplot(figure)"]}, {"block": 52, "type": "code", "linesLength": 3, "startIndex": 228, "lines": ["figure = make_scatter_plot(df[(df['type']=='published') & (df['<tag>Towards Data Science'] == 1)], \n", "                           'read_time', 'views', xlog=True)\n", "iplot(figure)"]}, {"block": 53, "type": "code", "linesLength": 0, "startIndex": 231, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 9: Differentiation and Integration\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 12, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import math\n", "import numpy as np\n", "import pandas\n", "import scipy.signal\n", "\n", "PI2 = 2 * math.pi\n", "\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["As the first example, I'll look at daily closing stock prices for Facebook, from its IPO on 17 May 2012 to 8 December 2015 (note: the dataset includes only trading days )"]}, {"block": 3, "type": "code", "linesLength": 3, "startIndex": 20, "lines": ["df = pandas.read_csv('fb.csv', parse_dates=[0])\n", "ys = df.Close.values[::-1]\n", "len(ys)"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Here's what the time series looks like:"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["close = thinkdsp.Wave(ys, framerate=1)\n", "close.plot()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["And here's the spectrum on a log-log scale."]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["close_spectrum = close.make_spectrum()\n", "close_spectrum.plot()\n", "thinkplot.config(xscale='log', yscale='log', legend=False)"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["The slope is -1.86, which is similar to red noise (which should have a slope of -2)."]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["close_spectrum.estimate_slope()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["We can use `np.diff` to compute the difference between successive elements, which is the daily change."]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 33, "lines": ["change = thinkdsp.Wave(np.diff(ys), framerate=1)\n", "change.plot()"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["And here's the spectrum of the daily changes:"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 36, "lines": ["change_spectrum = change.make_spectrum()\n", "change_spectrum.plot()"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["And here's the spectrum on a log-log scale."]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 39, "lines": ["change_spectrum.plot()\n", "thinkplot.config(xscale='log', yscale='log', legend=False)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["The estimated slope is close to zero, which is consistent with white noise."]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["change_spectrum.estimate_slope()"]}, {"block": 18, "type": "markdown", "linesLength": 3, "startIndex": 43, "lines": ["We can think the diff operation as convolution with a difference window, [1, -1].  Convolution with this window corresponds to multiplication by a filter.\n", "\n", "The following function computes the filter that corresponds to the window."]}, {"block": 19, "type": "code", "linesLength": 12, "startIndex": 46, "lines": ["def make_filter(window, wave):\n", "    \"\"\"Computes the filter that corresponds to a window.\n", "    \n", "    window: NumPy array\n", "    wave: wave used to choose the length and framerate\n", "    \n", "    returns: new Spectrum\n", "    \"\"\"\n", "    padded = thinkdsp.zero_pad(window, len(wave))\n", "    wave = thinkdsp.Wave(padded, framerate=wave.framerate)\n", "    philter = wave.make_spectrum()\n", "    return philter"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["And here's what the corresponding filter looks like:"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["diff_window = np.array([1.0, -1.0])\n", "diff_filter = make_filter(diff_window, close)\n", "diff_filter.plot()"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["And the angles:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["thinkplot.plot(diff_filter.angles())"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["So we could also compute the daily changes by multiplying the spectrum of closing prices by the diff filter:"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 65, "lines": ["change_spectrum2 = close_spectrum * diff_filter\n", "change_spectrum2.plot()"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 67, "lines": ["And then converting the spectrum to a wave.\n", "\n", "In the result, the first element is wrong, so I remove it."]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 70, "lines": ["change2 = change_spectrum2.make_wave()\n", "change2.ys = change2.ys[1:]\n", "change2.plot()"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Then we can confirm that we get the same result both ways (within floating point error)."]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 74, "lines": ["max(abs(change.ys - change2.ys))"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["This diff operation is an approximation of differentiation, and we can compute the filter for differentiation analytically: each complex component is multiplied by $2 \\pi i f$."]}, {"block": 31, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["deriv_filter = close.make_spectrum()\n", "i = complex(0, 1)\n", "deriv_filter.hs = PI2 * i * deriv_filter.fs\n", "deriv_filter.plot()"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["Now we can multiply the closing prices by the derivative filter:"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 81, "lines": ["deriv_spectrum = close_spectrum * deriv_filter\n", "deriv_spectrum.plot()"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["The results are similar, with some differences due to (1) the difference window is only a coarse approximation of the derivative, especially at higher frequencies, and (2) the spectral derivative is based on the assumption that the signal is periodic, so the behavior at the beginning and end is different."]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["deriv = deriv_spectrum.make_wave()\n", "len(deriv), len(change)"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 86, "lines": ["deriv = deriv_spectrum.make_wave()\n", "change.plot(color='gray', alpha=0.5)\n", "deriv.plot(color='red', alpha=0.3)"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["We can see the differences more clearly by zooming in on a section in the middle:"]}, {"block": 38, "type": "code", "linesLength": 3, "startIndex": 90, "lines": ["low, high = 400, 430\n", "thinkplot.plot(change.ys[low:high], color='gray', alpha=0.5)\n", "thinkplot.plot(deriv.ys[low:high], color='red', alpha=0.3)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["The differences and derivative are similar in many places, but sometimes substantially different."]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["Here's the difference between the derivative filter and the difference filter:"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 95, "lines": ["deriv_filter.plot()\n", "diff_filter.plot()"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["The difference filter does not amplify the highest frequencies as much, which is why it is smoother than the derivative."]}, {"block": 43, "type": "markdown", "linesLength": 5, "startIndex": 98, "lines": ["## Integration\n", "\n", "Now let's think about integration.  We can compute the filter for integration analytically: each frequency component gets divided by $2 \\pi i f$.\n", "\n", "I plot the result on a log-y scale so we can see it more clearly."]}, {"block": 44, "type": "code", "linesLength": 6, "startIndex": 103, "lines": ["integ_filter = deriv_filter.copy()\n", "i = complex(0, 1)\n", "integ_filter.hs = 1 / (PI2 * i * integ_filter.fs)\n", "integ_filter.hs[0] = 0\n", "integ_filter.plot()\n", "thinkplot.config(yscale='log')"]}, {"block": 45, "type": "markdown", "linesLength": 0, "startIndex": 109, "lines": []}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 109, "lines": ["len(deriv_spectrum), len(integ_filter)"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["We can confirm that the integration filter is correct by applying it to the spectrum of the derivative we just computed:"]}, {"block": 48, "type": "code", "linesLength": 3, "startIndex": 111, "lines": ["integ_spectrum = deriv_spectrum * integ_filter\n", "integ_spectrum.plot()\n", "thinkplot.config(yscale='log', legend=False)"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["And then converting back to a wave.  The result is identical to the daily closing prices we started with, but shifted so the mean is 0.  The problem is that the derivative clobbers the first element of the spectrum, which is the bias.  Once the bias information is lost, integration can't restore it.  So the result has an unspecified constant of integration."]}, {"block": 50, "type": "code", "linesLength": 4, "startIndex": 115, "lines": ["thinkplot.preplot(2)\n", "integ_wave = integ_spectrum.make_wave()\n", "close.plot(label='closing prices')\n", "integ_wave.plot(label='integrated derivative')"]}, {"block": 51, "type": "code", "linesLength": 2, "startIndex": 119, "lines": ["shift = np.mean(close.ys) - np.mean(integ_wave.ys)\n", "max(abs(integ_wave.ys-close.ys+shift))"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 121, "lines": ["In the same way that the diff operator approximates differentiation, the cumulative sum approximates integration.  The following figure shows the cumulative sum of the daily changes:"]}, {"block": 53, "type": "code", "linesLength": 3, "startIndex": 122, "lines": ["cumsum_wave = change.copy()\n", "cumsum_wave.ys = np.cumsum(cumsum_wave.ys)\n", "cumsum_wave.plot()"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["Unlike the difference operator, it's not obvious how to write the cumulative sum in terms of convolution with a window.  But since cumsum is the inverse operation of diff, its filter must be the inverse of `diff_filter`:"]}, {"block": 55, "type": "code", "linesLength": 3, "startIndex": 126, "lines": ["cumsum_filter = make_filter(diff_window, change).invert()\n", "cumsum_filter.plot()\n", "thinkplot.config(yscale='log', legend=False)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["We can confirm that by computing the ratio of the cumsum spectrum to the change spectrum:"]}, {"block": 57, "type": "code", "linesLength": 4, "startIndex": 130, "lines": ["cumsum_spectrum = cumsum_wave.make_spectrum()\n", "ratio_spectrum = cumsum_spectrum.ratio(change_spectrum, thresh=0.1)\n", "ratio_spectrum.plot()\n", "thinkplot.config(yscale='log')"]}, {"block": 58, "type": "code", "linesLength": 5, "startIndex": 134, "lines": ["thinkplot.preplot(2)\n", "ratio_spectrum.plot(color='gray', alpha=0.3)\n", "cumsum_filter.plot(label='inverse diff')\n", "integ_filter.plot(label='integration')\n", "thinkplot.config(yscale='log', legend=True)"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["They have the same general shape, but the ratios are noisy and look like they are offset by a constant factor (a shift on a log scale)."]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 140, "lines": ["Now that we've established that cumsum can be computed by multiplying a spectrum with a filter, we might wonder what the corresponding window looks like:"]}, {"block": 61, "type": "code", "linesLength": 3, "startIndex": 141, "lines": ["cumsum_filter.hs[0] = 0\n", "cumsum_window = cumsum_filter.make_wave()\n", "cumsum_window.plot()"]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 144, "lines": ["len(change_spectrum), len(cumsum_filter), len(cumsum_window)"]}, {"block": 63, "type": "code", "linesLength": 16, "startIndex": 145, "lines": ["thinkplot.preplot(3)\n", "\n", "unbiased_change = change.copy()\n", "unbiased_change.unbias()\n", "\n", "cumsum_wave = unbiased_change.copy()\n", "cumsum_wave.ys = np.cumsum(cumsum_wave.ys)\n", "cumsum_wave.unbias()\n", "cumsum_wave.plot(label='cumsum')\n", "\n", "unbiased_change_spectrum = unbiased_change.make_spectrum()\n", "cumsum_wave2 = (unbiased_change_spectrum * cumsum_filter).make_wave()\n", "cumsum_wave2.plot(label='filter')\n", "\n", "thinkplot.config(legend=True, loc='upper left')\n", "#max(abs(cumsum_wave.ys - cumsum_wave2.ys))"]}, {"block": 64, "type": "code", "linesLength": 18, "startIndex": 161, "lines": ["thinkplot.preplot(3)\n", "\n", "unbiased_change = change.copy()\n", "#unbiased_change.unbias()\n", "\n", "cumsum_wave = unbiased_change.copy()\n", "cumsum_wave.ys = np.cumsum(cumsum_wave.ys)\n", "cumsum_wave.unbias()\n", "cumsum_wave.plot(label='cumsum')\n", "\n", "cumsum_wave2 = (change_spectrum * cumsum_filter).make_wave()\n", "cumsum_wave2.plot(label='filter')\n", "\n", "cumsum_wave3 = unbiased_change.convolve(cumsum_window)\n", "cumsum_wave3.plot(label='convolution')\n", "\n", "thinkplot.config(legend=True, loc='upper left')\n", "#max(abs(cumsum_wave.ys - cumsum_wave2.ys))"]}, {"block": 65, "type": "markdown", "linesLength": 3, "startIndex": 179, "lines": ["###Periodic signal\n", "\n", "We can do the same thing using a periodic signal like a sawtooth:"]}, {"block": 66, "type": "code", "linesLength": 2, "startIndex": 182, "lines": ["in_wave = thinkdsp.SawtoothSignal(freq=50).make_wave(duration=0.1, framerate=44100)\n", "in_wave.plot()"]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Here's the spectrum before the cumulative sum:"]}, {"block": 68, "type": "code", "linesLength": 2, "startIndex": 185, "lines": ["in_spectrum = in_wave.make_spectrum()\n", "in_spectrum.plot()"]}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 187, "lines": ["The output wave is the cumulative sum of the input"]}, {"block": 70, "type": "code", "linesLength": 3, "startIndex": 188, "lines": ["out_wave = in_wave.cumsum()\n", "out_wave.unbias()\n", "out_wave.plot()"]}, {"block": 71, "type": "markdown", "linesLength": 1, "startIndex": 191, "lines": ["And here's its spectrum"]}, {"block": 72, "type": "code", "linesLength": 2, "startIndex": 192, "lines": ["out_spectrum = out_wave.make_spectrum()\n", "out_spectrum.plot()"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 194, "lines": ["Now we compute the ratio of the output to the input:"]}, {"block": 74, "type": "code", "linesLength": 1, "startIndex": 195, "lines": ["sum(in_spectrum.amps < 1), len(in_spectrum)"]}, {"block": 75, "type": "markdown", "linesLength": 1, "startIndex": 196, "lines": ["In between the harmonics, the input componenents are small, so I set those ratios to NaN."]}, {"block": 76, "type": "code", "linesLength": 5, "startIndex": 197, "lines": ["ratio_spectrum = out_spectrum.ratio(in_spectrum, thresh=1e-11, val=np.nan)\n", "ratio_spectrum.plot(style='.')\n", "\n", "thinkplot.config(yscale='log', legend=False)\n", "sum(np.isnan(ratio_spectrum.hs)), len(ratio_spectrum)"]}, {"block": 77, "type": "markdown", "linesLength": 1, "startIndex": 202, "lines": ["To get the cumsum filter, I compute the diff filter again and invert it."]}, {"block": 78, "type": "code", "linesLength": 8, "startIndex": 203, "lines": ["diff_window = np.array([1.0, -1.0])\n", "diff_filter2 = make_filter(diff_window, in_wave)\n", "cumsum_filter2 = diff_filter2.invert()\n", "cumsum_filter2.hs[0] = 0\n", "\n", "thinkplot.preplot(1)\n", "cumsum_filter2.plot()\n", "thinkplot.config(yscale='log', legend=False)"]}, {"block": 79, "type": "markdown", "linesLength": 1, "startIndex": 211, "lines": ["Finally, we can compare the computed ratios to the filter.  They match, confirming that the cumsum filter is the inverse of the diff filter."]}, {"block": 80, "type": "code", "linesLength": 3, "startIndex": 212, "lines": ["cumsum_filter2.plot(label='filter', color='gray', alpha=0.5, linewidth=6)\n", "ratio_spectrum.plot(label='ratio', style='.', color='red', alpha=0.7, markersize=1)\n", "thinkplot.config(yscale='log', legend=True)"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 215, "lines": ["Now we can compute the output wave using the convolution theorem, and compare the results:"]}, {"block": 82, "type": "code", "linesLength": 1, "startIndex": 216, "lines": ["len(in_spectrum), len(cumsum_filter2)"]}, {"block": 83, "type": "code", "linesLength": 8, "startIndex": 217, "lines": ["thinkplot.preplot(2)\n", "\n", "out_wave.plot(label='cumsum')\n", "\n", "out_wave2 = (in_spectrum * cumsum_filter2).make_wave()\n", "out_wave2.plot(label='filter')\n", "\n", "thinkplot.config(legend=True, loc='lower right')"]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 225, "lines": ["They are the same, within floating point error."]}, {"block": 85, "type": "code", "linesLength": 1, "startIndex": 226, "lines": ["max(abs(out_wave.ys - out_wave2.ys))"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 227, "lines": ["Since we're figured out the filter that corresponds to cumulative sum, we can compute the window that corresponds to the filter."]}, {"block": 87, "type": "code", "linesLength": 3, "startIndex": 228, "lines": ["cumsum_window2 = cumsum_filter2.make_wave()\n", "cumsum_window2.ys += 0\n", "cumsum_window2.plot()"]}, {"block": 88, "type": "markdown", "linesLength": 1, "startIndex": 231, "lines": ["Convolving with this window should be the same as applying the cumsum function."]}, {"block": 89, "type": "code", "linesLength": 1, "startIndex": 232, "lines": ["len(cumsum_window2), len(in_wave)"]}, {"block": 90, "type": "code", "linesLength": 8, "startIndex": 233, "lines": ["thinkplot.preplot(2)\n", "\n", "out_wave.plot(label='cumsum')\n", "\n", "out_wave3 = in_wave.convolve(cumsum_window2)\n", "out_wave3.plot(label='convolution')\n", "\n", "thinkplot.config(legend=True, loc='lower right')"]}, {"block": 91, "type": "markdown", "linesLength": 3, "startIndex": 241, "lines": ["But it's not.  One problem is that the version computed with cumsum starts at 150, but that's because I unbiased it.  The convolution starts at 0, as it should.\n", "\n", "The other problem is that the convolution has a trend that shouldn't be there and a smaller magnitude.  In terms of frequencies, it looks like there's a lot of energy at a very low frequency, and energy has been sapped from the higher frequencies.  So what's going on there?"]}, {"block": 92, "type": "code", "linesLength": 0, "startIndex": 244, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# The data block API"]}, {"block": 1, "type": "code", "linesLength": 3, "startIndex": 1, "lines": ["from fastai.gen_doc.nbdoc import *\n", "from fastai.vision import * \n", "from fastai import *"]}, {"block": 2, "type": "markdown", "linesLength": 9, "startIndex": 4, "lines": ["The data block API lets you customize how to create a [`DataBunch`](/basic_data.html#DataBunch) by isolating the underlying parts of that process in separate blocks, mainly:\n", "- where are the inputs\n", "- how to label them\n", "- how to split the data into a training and validation set\n", "- what type of [`Dataset`](https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset) to create\n", "- possible transforms to apply\n", "- how to warp in dataloaders and create the [`DataBunch`](/basic_data.html#DataBunch)\n", "\n", "This is a bit longer than using the factory methods but is way more flexible. As usual, we'll begin with end-to-end examples, then switch to the details of each of those parts."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["## Examples of use"]}, {"block": 4, "type": "markdown", "linesLength": 4, "startIndex": 14, "lines": ["To do:\n", "\n", "- make imdb unsup filter work\n", "- ?LabelList class methods"]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 18, "lines": ["path = untar_data(URLs.MNIST_TINY)\n", "tfms = get_transforms(do_flip=False)\n", "path.ls()"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["(path/'train').ls()"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["In [`vision.data`](/vision.data.html#vision.data), we create an easy [`DataBunch`](/basic_data.html#DataBunch) suitable for classification by simply typing:"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 23, "lines": ["data = ImageDataBunch.from_folder(path, ds_tfms=tfms, size=24)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["This is aimed at data that is in fodlers following an ImageNet style, with a train and valid directory containing each one subdirectory per class, where all the pictures are. With the data block API, the same thing is achieved like this:"]}, {"block": 10, "type": "code", "linesLength": 6, "startIndex": 25, "lines": ["data = (ImageItemList.from_folder(path) #Where to find the data? -> in path and its subfolders\n", "        .split_by_folder()              #How to split in train/valid? -> use the folders\n", "        .label_from_folder()            #How to label? -> depending on the folder of the filenames\n", "        .add_test_folder()              #Optionally add a test set\n", "        .transform(tfms, size=64)       #Data augmentation? -> use tfms with a size of 64\n", "        .databunch())                   #Finally? -> use the defaults for conversion to ImageDataBunch"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["data.show_batch(3, figsize=(6,6), hide_axis=False)"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 32, "lines": ["data.train_ds[0], data.test_ds.classes"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Let's look at another example from [`vision.data`](/vision.data.html#vision.data) with the planet dataset. This time, it's a multiclassification problem with the labels in a csv file and no given split between valid and train data, so we use a random split. The factory method is:"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 34, "lines": ["planet = untar_data(URLs.PLANET_TINY)\n", "planet_tfms = get_transforms(flip_vert=True, max_lighting=0.1, max_zoom=1.05, max_warp=0.)\n", "data = ImageDataBunch.from_csv(planet, folder='train', size=128, suffix='.jpg', sep = ' ', ds_tfms=planet_tfms)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["With the data block API we can rewrite this like that:"]}, {"block": 16, "type": "code", "linesLength": 10, "startIndex": 38, "lines": ["data = (ImageItemList.from_csv(planet, 'labels.csv', folder='train', suffix='.jpg')\n", "        #Where to find the data? -> in planet 'train' folder\n", "        .random_split_by_pct()\n", "        #How to split in train/valid? -> randomly with the default 20% in valid\n", "        .label_from_df(sep=' ')\n", "        #How to label? -> use the csv file\n", "        .transform(planet_tfms, size=128)\n", "        #Data augmentation? -> use tfms with a size of 128\n", "        .databunch())                          \n", "        #Finally -> use the defaults for conversion to databunch"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["data.show_batch(rows=2, figsize=(10,8))"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["The data block API also allows you to use dataset types for which there is no direct [`ImageDataBunch`](/vision.data.html#ImageDataBunch) factory method. For a segmentation task, for instance, we can use it to quickly get a [`DataBunch`](/basic_data.html#DataBunch). Let's take the example of the [camvid dataset](http://mi.eng.cam.ac.uk/research/projects/VideoRec/CamVid/). The images are in an 'images' folder and their corresponding mask is in a 'labels' folder."]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["camvid = untar_data(URLs.CAMVID_TINY)\n", "path_lbl = camvid/'labels'\n", "path_img = camvid/'images'"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["We have a file that gives us the names of the classes (what each code inside the masks corresponds to: a pedestrian, a tree, a road...)"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["codes = np.loadtxt(camvid/'codes.txt', dtype=str); codes"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["And we define the following function that infers the mask filename from the image filename."]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["get_y_fn = lambda x: path_lbl/f'{x.stem}_P{x.suffix}'"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Then we can easily define a [`DataBunch`](/basic_data.html#DataBunch) using the data block API. Here we need to use `tfm_y=True` in the transform call because we need the same transforms to be applied to the target mask as were applied to the image."]}, {"block": 25, "type": "code", "linesLength": 4, "startIndex": 58, "lines": ["data = (ImageItemList.from_folder(path_img)\n", "        .random_split_by_pct()\n", "        .label_from_func(get_y_fn, ItemList, create_func=open_mask)\n", "        .databunch())"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["data.show_batch(rows=2, figsize=(7,5))"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["One last example for object detection. We use our tiny sample of the [COCO dataset](http://cocodataset.org/#home) here. There is a helper function in the library that reads the annotation file and returns the list of images names with the list of labelled bboxes associated to it. We convert it to a dictionary that maps image names with their bboxes and then write the function that will give us the target for each image filename."]}, {"block": 28, "type": "code", "linesLength": 4, "startIndex": 64, "lines": ["coco = untar_data(URLs.COCO_TINY)\n", "images, lbl_bbox = get_annotations(coco/'train.json')\n", "img2bbox = {img:bb for img, bb in zip(images, lbl_bbox)}\n", "get_y_func = lambda o:img2bbox[o.name]"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["The following code is very similar to what we saw before. The only new addition is the use of special function to collate the samples in batches. This comes from the fact that our images may have multiple bounding boxes, so we need to pad them to the largest number of bounding boxes."]}, {"block": 30, "type": "code", "linesLength": 5, "startIndex": 69, "lines": ["class ObjectLabelList(LabelList):\n", "    def _get_y(self,i,x):\n", "        bbs,labels = self.y[i]\n", "        cats = LongTensor([self.class2idx[l] for l in labels])\n", "        return (ImageBBox.create(bbs, *x.size, cats))"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 74, "lines": ["class ObjectItemList(ImageItemList):\n", "    def __init__(self, items:Iterator, create_func:Callable=None, path:PathOrStr='.', xtra:Any=None):\n", "        super().__init__(items, create_func=create_func, label_cls=ObjectLabelList, path=path, xtra=xtra)"]}, {"block": 32, "type": "code", "linesLength": 6, "startIndex": 77, "lines": ["data = (ObjectItemList.from_folder(coco)\n", "        #Where are the images? -> in coco\n", "        .random_split_by_pct()                          \n", "        #How to split in train/valid? -> randomly with the default 20% in valid\n", "        .label_from_func(get_y_func)\n", "       )"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 83, "lines": ["data.train[0]"]}, {"block": 34, "type": "code", "linesLength": 6, "startIndex": 84, "lines": ["        #How to find the labels? -> use get_y_func\n", "        .datasets(ObjectDetectDataset)\n", "        #How to create datasets? -> with ObjectDetectDataset\n", "        #Data augmentation? -> Standard transforms with tfm_y=True\n", "        .databunch(bs=16, collate_fn=bb_pad_collate))   \n", "        #Finally we convert to a DataBunch and we use bb_pad_collate"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 90, "lines": ["data.show_batch(rows=3, ds_type=DatasetType.Valid, figsize=(8,7))"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["## Provide inputs"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["The inputs we want to feed our model are regrouped in the following class. The class contains methods to get the corresponding labels."]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["show_doc(InputList, title_level=3, doc_string=False)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["This class regroups the inputs for our model in `items` and saves a `path` attribute which is where it will look for any files (image files, csv file with labels...)"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 95, "lines": ["show_doc(InputList.from_folder)"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["Note that [`InputList`](/data_block.html#InputList) is subclassed in vision by [`ImageFileList`](/vision.data.html#ImageFileList) that changes the default of `extensions` to image file extensions (which is why we used [`ImageFileList`](/vision.data.html#ImageFileList) in our previous examples)."]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["## Labelling the inputs"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["All the followings are methods of [`InputList`](/data_block.html#InputList). Note that some of them are primarly intended for inputs that are filenames and might not work in general situations."]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 99, "lines": ["show_doc(InputList.label_const)"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 100, "lines": ["show_doc(InputList.label_from_csv)"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["If a `folder` is specified, filenames are taken in `self.path/folder`. `suffix` is added. If `sep` is specified, splits the values in `label_col` accordingly. This method is intended for inputs that are filenames."]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 102, "lines": ["jekyll_note(\"This method will only keep the filenames that are both present in the csv file and in `self.items`.\")"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 103, "lines": ["show_doc(InputList.label_from_df)"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["jekyll_note(\"This method will only keep the filenames that are both present in the dataframe and in `self.items`.\")"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 105, "lines": ["show_doc(InputList.label_from_folder)"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 106, "lines": ["jekyll_note(\"This method looks at the last subfolder in the path to determine the classes.\")"]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 107, "lines": ["show_doc(InputList.label_from_func)"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["This method is primarly intended for inputs that are filenames, but could work in other settings."]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 109, "lines": ["show_doc(InputList.label_from_re)"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 110, "lines": ["show_doc(LabelList, title_level=3, doc_string=False)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 111, "lines": ["A list of labelled inputs in `items` (expected to be tuples of input, label) with a `path` attribute. This class contains methods to create `SplitDataset`."]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["show_doc(LabelList.from_csv)"]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 113, "lines": ["show_doc(LabelList.from_csvs)"]}, {"block": 59, "type": "code", "linesLength": 1, "startIndex": 114, "lines": ["show_doc(LabelList.from_df)"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["## Split the data between train and validation."]}, {"block": 61, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["The following functions are methods of [`LabelList`](/data_block.html#LabelList), to create a [`SplitData`](/data_block.html#SplitData) in different ways."]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["show_doc(LabelList.random_split_by_pct)"]}, {"block": 63, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["show_doc(LabelList.split_by_files)"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 119, "lines": ["show_doc(LabelList.split_by_fname_file)"]}, {"block": 65, "type": "code", "linesLength": 1, "startIndex": 120, "lines": ["show_doc(LabelList.split_by_folder)"]}, {"block": 66, "type": "code", "linesLength": 1, "startIndex": 121, "lines": ["jekyll_note(\"This method looks at the folder immediately after `self.path` for `valid` and `train`.\")"]}, {"block": 67, "type": "code", "linesLength": 1, "startIndex": 122, "lines": ["show_doc(LabelList.split_by_idx)"]}, {"block": 68, "type": "code", "linesLength": 1, "startIndex": 123, "lines": ["show_doc(LabelList.split_by_valid_func)"]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["show_doc(SplitData, title_level=3)"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["You won't normally construct a [`SplitData`](/data_block.html#SplitData) yourself, but instead will use one of the `split*` methods in [`LabelList`](/data_block.html#LabelList)."]}, {"block": 71, "type": "code", "linesLength": 1, "startIndex": 126, "lines": ["show_doc(LabelList.from_csv)"]}, {"block": 72, "type": "code", "linesLength": 1, "startIndex": 127, "lines": ["show_doc(SplitData.add_test)"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 128, "lines": ["## Create datasets"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["To create the datasets from [`SplitData`](/data_block.html#SplitData) we have the following class method."]}, {"block": 75, "type": "code", "linesLength": 1, "startIndex": 130, "lines": ["show_doc(SplitData.datasets)"]}, {"block": 76, "type": "code", "linesLength": 1, "startIndex": 131, "lines": ["show_doc(SplitDatasets, title_level=3)"]}, {"block": 77, "type": "markdown", "linesLength": 1, "startIndex": 132, "lines": ["This class can be constructed directly from one of the following factory methods."]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 133, "lines": ["show_doc(SplitDatasets.from_single)"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 134, "lines": ["show_doc(SplitDatasets.single_from_c)"]}, {"block": 80, "type": "code", "linesLength": 1, "startIndex": 135, "lines": ["show_doc(SplitDatasets.single_from_classes)"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 136, "lines": ["Then we can build the [`DataLoader`](https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader) around our [`Dataset`](https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset) like this."]}, {"block": 82, "type": "code", "linesLength": 1, "startIndex": 137, "lines": ["show_doc(SplitDatasets.dataloaders)"]}, {"block": 83, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["The methods `img_transform` and `img_databunch` used earlier are documented in [`vision.data`](/vision.data.html#vision.data)."]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["## Utility classes and functions"]}, {"block": 85, "type": "code", "linesLength": 1, "startIndex": 140, "lines": ["show_doc(ItemList, title_level=3)"]}, {"block": 86, "type": "code", "linesLength": 1, "startIndex": 141, "lines": ["show_doc(PathItemList, title_level=3)"]}, {"block": 87, "type": "code", "linesLength": 1, "startIndex": 142, "lines": ["show_doc(get_files)"]}, {"block": 88, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["## Undocumented Methods - Methods moved below this line will intentionally be hidden"]}, {"block": 89, "type": "code", "linesLength": 1, "startIndex": 144, "lines": ["show_doc(LabelList.split_by_list)"]}, {"block": 90, "type": "code", "linesLength": 1, "startIndex": 145, "lines": ["show_doc(SplitData.dataset_cls)"]}, {"block": 91, "type": "code", "linesLength": 1, "startIndex": 146, "lines": ["show_doc(InputList.create_label_list)"]}, {"block": 92, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["## New Methods - Please document or move to the undocumented section"]}]
[{"block": 0, "type": "markdown", "linesLength": 36, "startIndex": 0, "lines": ["# PmagPy Jupyter Notebook Version\n", "\n", "by Lisa Tauxe, Lori Jonestrask, Nick Swanson-Hysell and Nick Jarboe\n", "\n", "### What is **PmagPy**?  \n", "\n", "**PmagPy** is a software package for analyzing paleomagnetic and rock magnetic data using Python. This notebook demonstrates how to use **PmagPy** in a Jupyter notebook or Python script.  For examples of how to use PmagPy scripts on the command line, see the static version of [**PmagPy\\_cli.ipynb**](http://pmagpy.github.io/PmagPy-cli.html), or you can open it locally the same way you opened this notebook.\n", "\n", "\n", "### What are paleomagnetism and rock magnetism?  \n", "\n", "For information on the science of paleomagnetism and rock magnetism, see textbook at: https://earthref.org/MagIC/books/Tauxe/Essentials/\n", "\n", "\n", "### Using Jupyter notebooks for Earth Science\n", "\n", "If you already have some experience working with Python, you should be able to use this notebook without difficulty. \n", "\n", "If not, we have a full course in Python for Earth Scientists available on Github.  To check it out, see: \n", "\n", "https://nbviewer.jupyter.org/github/ltauxe/Python-for-Earth-Science-Students/blob/master/Lecture_01.ipynb\n", "\n", " \n", "\n", "### Customizing this notebook\n", "\n", "If you want to make changes to this notebook, you should make a copy (see File menu).  Otherwise each time you update **PmagPy**, your changes will be overwritten.\n", "\n", "### Get started\n", "\n", "To use the functions in this notebook, we have to   import the **PmagPy** modules **pmagplotlib**, **pmag** and **ipmag** and some other handy functions for use in the notebook.  This is done in the following code block which must be executed before running any other code block. To execute, click on the code block and then click on the \"Run\" button in the menu.  \n", "\n", "In order to access the example data, this notebook is meant to be run in the PmagPy-data directory (PmagPy directory for developers).\n", "\n", "Try it!  Run the code block below (click on the cell and then click 'Run'):\n", "\n"]}, {"block": 1, "type": "code", "linesLength": 23, "startIndex": 36, "lines": ["import pmagpy.pmag as pmag\n", "import pmagpy.pmagplotlib as pmagplotlib\n", "import pmagpy.ipmag as ipmag\n", "import pmagpy.contribution_builder as cb\n", "from pmagpy import convert_2_magic as convert\n", "import matplotlib.pyplot as plt # our plotting buddy\n", "import numpy as np # the fabulous NumPy package\n", "import pandas as pd # and of course Pandas\n", "# test if Basemap and/or cartopy is installed\n", "has_basemap, Basemap = pmag.import_basemap()\n", "has_cartopy, Cartopy = pmag.import_cartopy()\n", "# test if xlwt is installed (allows you to export to excel)\n", "try:\n", "    import xlwt\n", "    has_xlwt = True\n", "except ImportError:\n", "    has_xlwt = False\n", "# This allows you to make matplotlib plots inside the notebook.  \n", "%matplotlib inline \n", "from IPython.display import Image\n", "import os\n", "\n", "print('All modules imported!')"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["- Now you have everything you need to run PmagPy!"]}, {"block": 3, "type": "markdown", "linesLength": 133, "startIndex": 60, "lines": ["## Guide to PmagPy\n", "\n", "- the functions in this notebook are listed alphabetically so here is a handy guide by function:\n", "- Calculations: \n", "    - [angle](#angle) : calculates the angle between two vectors\n", "    - [apwp](#apwp) : returns predicted paleolatitudes, directions and pole latitude/longitude from apparent polar wander paths of Besse and Courtillot (2002).\n", "    - [b_vdm](#b_vdm) : converts B (in microT) and (magnetic) latitude to V(A)DM (see [vdm_b](#vdm_b))\n", "    - [bootams](#bootams) : calculates bootstrap statistics for tensor data\n", "    - [cart_dir](#cart_dir) : converts cartesian coordinates (x,y,z) to declination, inclination, intensity (see [dir_cart](#dir_cart))\n", "    - [di_eq](#di_eq) : maps declination, inclinatitions to X,Y for plotting in equal area projections\n", "    - [di_geo](#di_geo) : rotates declination, inclination in specimen coordinates to geographic coordinates\n", "    - [di_rot](#di_rot) : rotates directions to a  coordinate system with D,I as center\n", "    - [di_tilt](#di_tilt) : rotates directions to stratigraphic coordinates\n", "    - [di_vgp](#di_vgp) : converts direction to Virtual Geomagnetic Pole (see [vgp_di](#vgp_di))\n", "    - [dia_vgp](#dia_vgp) : converts direction and $\\alpha_{95}$ to Virtual Geomagnetic Pole and dp,dm\n", "    - [dipole_pinc](#dipole_pinc) : calculates inclination given latitude assuming geocentric axial dipole\n", "    - [dipole_plat](#dipole_plat) : calculates latitude given inclination assuming geocentric axial dipole\n", "    - [dir_cart](#dir_cart) : converts declination, inclination, intensity to cartesian coordinates (see [cart_dir](#cart_dir))\n", "    - [eigs_s](#eigs_s) : converts eigenparameters to equivalent 6 element tensor (see [s_eigs](#s_eigs))\n", "    - [eq_di](#eq_di) : takes X,Y from equal area projection (e.g., from digitized coordinates) and  converts to declination, inclination\n", "    - [fcalc](#fcalc) : returns the value from an F table, given the degrees of freedom.\n", "    - [fisher](#fisher) : generates sets of directions drawn from Fisher distributions with vertical true mean\n", "    - [fishrot](#fishrot) : generates sets of directions drawn from Fisher distributions with arbitrary true mean\n", "    - [flip](#flip) : flips a second mode (reverse directions) to their antipodes\n", "    - [gaussian](#gaussian) : generates data drawn from a normal distribution\n", "    - [gobing](#gobing) : calculates Bingham statistics from a set of directions\n", "    - [gofish](#gofish) : calculates Fisher statistics from a set of directions\n", "    - [gokent](#gokent) : calculates Kent statistics from a set of directions\n", "    - [goprinc](#goprinc) : calculates principal directions statistics\n", "    - [igrf](#igrf) : calculates geomagnetic field vectors for location, age given a field model (e.g., IGRF)\n", "    - [incfish](#incfish) : estimates the true mean inclination from inclination only data\n", "    - [pca](#pca) : calculates the best-fit line or plane for demagnetization data and associated statistics\n", "    - [pt_rot](#pt_rot) : rotates point given finite rotation pole\n", "    - [scalc](#scalc) : calculates  VGP scatter\n", "    - [s_eigs](#s_eigs) : takes a 6 element tensor and calculates eigen parameters (see [eigs_s](#eigs_s))\n", "    - [s_geo](#s_geo) : rotates 6 element tensors to geographic coordinates\n", "    - [s_hext](#s_hext) : calculates Hext statistics from 6 element tensors\n", "    - [s_tilt](#s_tilt) : rotates 6 element tensors to stratigraphic coordinates\n", "    - [separate_directions](#separate_directions) : separates a set of directions into two modes (normal and reverse)\n", "    - [squish](#squish): flattens inclination data given flattening factor (see [unsquish](#unsquish))\n", "    - [sundec](#sundec) : calulates direction to sun for location, date, time and sun azimuth\n", "    - [tk03](#tk03) : generates sets of directions consistent with the TK03 field model\n", "    - [uniform](#uniform) : generates sets of uniformly distributed directions\n", "    - [unsquish](#unsquish) : unsquishes flattened inclinations, given flattening factor (see [squish](#squish))\n", "    - [vector_mean](#vector_mean) : calculates vector mean for sets of vectors (declination, inclination, intensity)\n", "    - [vdm_b](#vdm_b) : calculates intensity at given location from specified virtual dipole moment (see [b_vdm](#b_vdm))\n", "    - [vgp_di](#vgp_di) : calculates direction at given location from virtual geomagnetic pole (see [di_vgp](#di_vgp))\n", "    - [watsons_f](#watsons_f) : calculates Watson's F statistic for testing for common mean\n", "    \n", "- Plots:\n", "    - [ani_depthplot](#ani_depthplot) : plots anisotropy data against depth in stratigraphic section (Xmas tree plots)\n", "    - [aniso_magic](#aniso_magic) : makes plots of anisotropy data and bootstrapped confidences \n", "    - [biplot_magic](#biplot_magic) : plots different columns against each other in MagIC formatted data files\n", "    - [chi_magic](#chi_magic) : plots magnetic susceptibility data in MagIC format as function of field, frequency or temperature\n", "    - [common_mean](#common_mean) : graphical approach to testing two sets of directions for common mean using bootstrap\n", "    - [core_depthplot](#core_depthplot) : plots MagIC formatted data \n", "    - [curie](#curie) : makes plots of Curie Temperature data and provides estimates for Tc\n", "    - [dayplot_magic](#dayplot_magic) : makes Day et al. (1977) and other plots with hysteresis statistics\n", "    - [dmag_magic](#dmag_magic) : plots remanence against demagnetization step for MagIC formatted files\n", "    - [eqarea](#eqarea) and [eqarea_magic](#eqarea_magic) : makes equal area projections for directions\n", "    - [eqarea_ell](#eqarea_ell) : makes equal area projections for directions with specified confidence ellipses\n", "    - [find_ei](#find_ei) : finds the inclination unflattening factor that unsquishes directions to match TK03 distribution\n", "    - [fishqq](#fishqq): makes a Quantile-Quantile plot for directions against uniform and exponential distributions\n", "    - [foldtest](#foldtest) & [foldtest_magic](#foldtest_magic) : finds  tilt correction that maximizes concentration of directions, with bootstrap confidence bounds.          \n", "    - [forc_diagram](#forc_diagram): plots FORC diagrams for both conventional and irregular FORCs\n", "    - [hysteresis_magic](#hysteresis_magic) : makes plots of hysteresis data (not FORCs). \n", "    - [irm_unmix](#irm_unmix) : analyzes IRM acquisition data in terms of coercivity distributions\n", "    - [irmaq_magic](#irm_magic) : plots IRM acquistion data\n", "    - [lnp_magic](#lnp_magic) : plots lines and planes for site level data and calculates best fit mean and alpha_95\n", "    - [lowes](#lowes) : makes a plot of the Lowe's spectrum for a geomagnetic field model\n", "    - [lowrie](#lowrie) and [lowrie_magic](#lowrie_magic) : makes plots of Lowrie's (1990) 3D-IRM demagnetization experiments\n", "    - [plot_cdf](#plot_cdf) and [plot_2cdfs](#plot_2cdfs) : makes a cumulative distribution plot of data\n", "    - [plotdi_a](#plotdi_a) : makes equal are plots of directions and their $\\alpha_{95}$s\n", "    - [plot_geomagia](#plot_geomagia) : makes plots from files downloaded from the  geomagia website\n", "    - [plot_magic_keys](#plot_magic_keys) : plots data from MagIC formatted data files\n", "    - [qqplot](#qqplot) : makes a Quantile-Quantile plot for data against a normal distribution\n", "    - [qqunf](#qqunf) : makes a Quantile-Quantile plot for data against a uniform distribution\n", "    - [revtest](#revtest) & [revtest_magic](#revtest_magic) : performs a bootstrap reversals test\n", "    - [thellier_magic](#thellier_magic) : makes plots of thellier-thellier data. \n", "    - [watsons_v](#watsons_v) : makes a graph for Watson's V test for common mean\n", "    - [zeq](#zeq) and [zeq_magic](#zeq_magic) : makes quicky zijderveld plots for measurement data\n", "\n", "- Maps: \n", "    - [cont_rot](#cont_rot) : makes plots of continents after rotation to specified coordinate system\n", "    - [plot_mag_map](#plot_mag_map) : makes a color contour plot of geomagnetic field models\n", "    - [plot_map_pts](#plot_map_pts) : plots points on maps\n", "    - [polemap_magic](#polemap_magic) : reads in MagIC formatted file with paleomagnetic poles and plots them\n", "    - [vgpmap_magic](#vgpmap_magic) : reads in MagIC formatted file with virtual geomagnetic poles and plots them\n", "   \n", "- Working with MagIC:\n", "    - [reading MagIC files](#magic_read) : reading in MagIC formatted files\n", "    - [writing MagIC files](#magic_write) : outputing MagIC formatted files\n", "    - [combine_magic](#combine_magic) : combines two MagIC formatted files of same type\n", "    - [convert_ages](#convert_ages) : convert ages in downloaded MagIC file to Ma\n", "    - [grab_magic_key](#grab_magic_key) : prints out a single column from a MagIC format file\n", "    - [magic_select](#magic_select) : selects data from MagIC format file given conditions (e.g., method_codes contain string)\n", "    - [sites_extract](#sites_extract) : makes excel or latex files from sites.txt for publications\n", "    - [criteria_extract](#criteria_extract) : makes excel or latex files from criteria.txt for publications\n", "    - [specimens_extract](#specimens_extract) : makes excel or latex files from specimens.txt for publications\n", "\n", "    - [contributions](#Contributions) work with data model 3.0 MagIC contributions\n", "        - [download_magic](#download_magic) : unpacks a contribution text file downloaded from the MagIC website\n", "        - [upload_magic](#upload_magic) : prepares a directory with a MagIC contribution for uploading to MagIC\n", "        - [cb.add_sites_to_meas_table](#cb.add_sites_to_meas_table) : completes a measurements data frame with the information required for plotting by site. \n", "        - [cb.get_intensity_col](#cb.get_intensity_col) : finds the first non-zero type of intensity data in a measurements dataframe.\n", "\n", "    - [conversion scripts](#Conversion-Scripts) : convert many laboratory measurement formats to the MagIC data model 3 format\n", "        - [\\_2g\\_asc_magic](#\\_2g\\_asc\\_magic) : converts 2G ascii files to MagIC\n", "        - [\\_2g\\_bin_magic](#\\_2g\\_bin\\_magic) : converts 2G binary files to MagIC\n", "        - [aarm_magic](#aarm_magic) : takes a MagIC formated _measurements.txt_ file with anisotropy of ARM data and calculates the tensors and stores in a MagIC formatted _specimens.txt_ file.\n", "        - [atrm_magic](#atrm_magic) : takes a MagIC formated _measurements.txt_ file with anisotropy of TRM data and calculates the tensors and stores in a MagIC formatted _specimens.txt_ file.\n", "        - [agm_magic](#agm_magic) : converts Princeton Measurements alternating gradient force magnetization (AGM) files to MagIC.\n", "        - [bgc_magic](#bgc_magic) : convert Berkeley Geochronology Center files to MagIC. \n", "        - [cit_magic](#cit_magic) : convert Cal Tech format files to MagIC.\n", "        - [generic_magic](#generic_magic) : converts generic files to MagIC. \n", "        - [huji_magic](#huji_magic) : converts Hebrew University, Jerusalem, Israel files to MagIC.\n", "        - [huji_sample_magic](#huji_sample_magic) : converts HUJI files to a MagIC format. \n", "        - [jr6_jr6_magic](#jr6_jr6_magic) : converts the AGICO JR6 spinner .jr6 files to MagIC \n", "        - [jr6_txt_magic](#jr6_txt_magic) : converts the AGICO JR6 .txt files to MagIC\n", "        - [k15_magic](#k15_magic) : converts 15 measurement anisotropy of magnetic susceptibility files to MagIC.\n", "        - [kly4s_magic](#kly4s_magic) : converts Agico KLY4S formatted files to MagIC.\n", "        - [ldeo_magic](#ldeo_magic) : converts Lamont-Doherty files to MagIC.  \n", "        - [livdb_magic](#livdb_magic) : converts Liverpool files to MagIC.  \n", "        - [mst_magic](#mst_magic) : converts Curie Temperature experimental data to MagIC\n", "        - [s_magic](#s_magic) : converts files with 6 tensor elements (S_j) to MagIC format\n", "        - [sio_magic](#sio_magic) : converts Scripps Institution of Oceanography data files to MagIC \n", "        - [sufar4_magic](#sufar4_magic) : converts AGICO SUFAR program (ver.1.2.) ascii files to MagIC\n", "        - [tdt_magic](#tdt_magic) : converts Thellier Tool files to MagIC\n", "        - [utrecht_magic](#utrecht_magic) : converts Fort Hoofddijk, Utrecht University Robot files to MagIC\n", "        - [orientation_magic](#orientation_magic) : converts an \"orient.txt\" formatted file with field notebook information into MagIC formatted files\n", "        - [azdip_magic](#azdip_magic) : converts an \"azdip\" formatted file to a samples.txt file format\n", "- other handy scripts\n", "    - [chartmaker](#chartmaker) : script for making chart to guide IZZI lab experiment"]}, {"block": 4, "type": "markdown", "linesLength": 11, "startIndex": 193, "lines": ["## Figures\n", "\n", "- The plotting functions make plots to the screen (using the  `%matplotlib inline` magic command), but all **matplotlib** plots can be saved with the command: \n", "\n", "`plt.savefig('PATH_TO_FILE_NAME.FMT') `\n", "\n", "and then viewed in the notebook with:\n", "\n", "`Image('PATH_TO_FILE_NAME.FMT')`\n", "\n", "\n"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 204, "lines": ["## Working with the MagIC database\n", "- The Magnetics Information Consortium (MagIC) maintains a database of published rock and paleomagnetic data: https://www.earthref.org/MagIC \n", "- Many **PmagPy** scripts are designed to work with data in the MagIC format.  This notebook uses Data Model 3.0: https://www.earthref.org/MagIC/data-models/3.0   There are nine basic tables: contribution, locations, sites, samples, specimens, measurements, criteria, ages and images.   These are tab delimited data tables with the first line consisting of a delimiter and the table name: (e.g.,  tab    measurements).  All of the examples here are tab delimited.  The second line are the column names: (e.g., specimen experiment method_codes treat_temp.....).  Each subsequent line is a single record.\n", "\n", "See the first few lines of this sample file below:"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 209, "lines": ["with open('data_files/3_0/McMurdo/samples.txt') as f:\n", "    for line in f.readlines()[:3]:\n", "        print(line, end=\"\")"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 212, "lines": ["### I/O with MagIC data files"]}, {"block": 8, "type": "markdown", "linesLength": 12, "startIndex": 213, "lines": ["### magic_read\n", "\n", "- MagIC formatted data files can be imported to a notebook in one of two ways: a\n", "\n", "    - importing to a Pandas DataFrame using the Pandas pd.read_csv() function\n", "    - importing to a list of dictionaries using the pmag.magic_read() function.  \n", "    \n", "    In this notebook, we generally read MagIC tables into a Pandas Dataframe with a command like: \n", "\n", "`meas_df = pd.read_csv('MEASUREMENTS_FILE_PATH',sep='\\t',header=1)`\n", "\n", "These data can then be manipulated with **Pandas** functions (https://pandas.pydata.org/)\n"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 225, "lines": ["meas_df=pd.read_csv('data_files/3_0/McMurdo/measurements.txt',sep='\\t',header=1)\n", "meas_df.head()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 227, "lines": ["Alternatively, the user may wish to use a list of dictionaries compatible with many **pmag** functions.  For that, use the **pmag.magic_read()** function: "]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 228, "lines": ["help (pmag.magic_read)"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 229, "lines": ["meas_dict,file_type=pmag.magic_read('data_files/3_0/McMurdo/measurements.txt')\n", "print (file_type)\n", "print (meas_dict[0])"]}, {"block": 13, "type": "markdown", "linesLength": 12, "startIndex": 232, "lines": ["### magic_write\n", "\n", "To write out a  MagIC table from a Pandas DataFrame, first convert it to a list of dictionaries using a command like:\n", "\n", "`dicts = df.to_dict('records')`\n", "\n", "\n", "\n", "then call **pmag.magic_write()**.\n", "\n", "From a list of dictionaries, you can just call **pmag.magic_write()** directly.  \n", "\n"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 244, "lines": ["### pmag.magic_write"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 245, "lines": ["help(pmag.magic_write)"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["meas_dicts = meas_df.to_dict('records')\n", "pmag.magic_write('my_measurements.txt', meas_dicts, 'measurements')"]}, {"block": 17, "type": "markdown", "linesLength": 6, "startIndex": 248, "lines": ["### combine_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#combine_magic.py)\n", " \n", " MagIC tables have many columns only some of which are used in a particular instance. So combining files of the same type must be done carefully to ensure that the right data come under the right headings. The program **combine_magic** can be used to combine any number of MagIC files from a given type.  \n", "It  reads in MagIC formatted files of a common type (e.g., sites.txt) and combines them into a single file, taking care that all the columns are preserved. For example, if there are both AF and thermal data from a study and we created a measurements.txt formatted file for each, we could use **combine_magic.py** on the command line to combine them together into a single measurements.txt file.   In a notebook, we use  **ipmag.combine_magic()**.  \n"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 254, "lines": ["help(ipmag.combine_magic)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 255, "lines": ["Here we make a list of names of two MagIC formatted measurements.txt files and use **ipmag.combine_magic()** to put them together."]}, {"block": 20, "type": "code", "linesLength": 3, "startIndex": 256, "lines": ["filenames=['data_files/combine_magic/af_measurements.txt','../combine_magic/therm_measurements.txt']\n", "outfile='data_files/combine_magic/measurements.txt'\n", "ipmag.combine_magic(filenames,outfile)"]}, {"block": 21, "type": "markdown", "linesLength": 6, "startIndex": 259, "lines": ["### convert_ages\n", "\n", "Files downloaded from the MagIC search interface have ages that are in the original units, but what is often desired is for them to be in a single unit.  For example, if we searched the MagIC database for all absolute paleointensity data (records with method codes of 'LP-PI-TRM') from the last five million years, the data sets have a variety of age units.  We can use **pmag.convert_ages()**    to convert them all to millions of years.  \n", "\n", "First we follow the instructions for unpacking downloaded files in [download_magic](#download_magic).  \n", "\n"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 265, "lines": ["ipmag.download_magic('magic_downloaded_rows.txt',dir_path='data_files/convert_ages/',\n", "      input_dir_path='data_files/convert_ages/')"]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 267, "lines": ["After some minimal filtering using Pandas, we can convert a DataFrame to a list of dictionaries required by most PmagPy functions and use **pmag.convert_ages()** to convert all the ages.  The converted list of dictionaries can then be turned back into a Pandas DataFrame and either plotted or filtered further as desired.  \n", "\n", "In this example, we filter for data older than the Brunhes (0.78 Ma) and younger than 5 Ma, then plot them against latitude.  We can also use [vdm_b](#vdm_b) to plot the intensities expected from the present dipole moment (~80 ZAm$^2$). "]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 270, "lines": ["help(pmag.convert_ages)"]}, {"block": 25, "type": "code", "linesLength": 25, "startIndex": 271, "lines": ["# read in the sites.txt file as a dataframe\n", "site_df=pd.read_csv('data_files/convert_ages/sites.txt',sep='\\t',header=1)\n", "# get rid aof any records without intensity data or latitude\n", "site_df=site_df.dropna(subset=['int_abs','lat'])\n", "# Pick out the sites with 'age' filled in\n", "site_df_age=site_df.dropna(subset=['age'])\n", "# pick out those with age_low and age_high filled in\n", "site_df_lowhigh=site_df.dropna(subset=['age_low','age_high'])\n", "# concatenate the two\n", "site_all_ages=pd.concat([site_df_age,site_df_lowhigh]) \n", "# get rid of duplicates (records with age, age_high AND age_low)\n", "site_all_ages.drop_duplicates(inplace=True)\n", "# Pandas reads in blanks as NaN, which pmag.convert_ages hates\n", "# this replaces all the NaNs with blanks\n", "site_all_ages.fillna('',inplace=True)\n", "# converts to a list of dictionaries\n", "sites=site_all_ages.to_dict('records')\n", "# converts the ages to Ma\n", "converted_df=pmag.convert_ages(sites)\n", "# turn it back into a DataFrame\n", "site_ages=pd.DataFrame(converted_df)\n", "# filter away\n", "site_ages=site_ages[site_ages.age.astype(float) <= 5]\n", "site_ages=site_ages[site_ages.age.astype(float) >=0.05]\n", "\n"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 296, "lines": ["Let's plot them up and see what we get."]}, {"block": 27, "type": "code", "linesLength": 10, "startIndex": 297, "lines": ["plt.plot(site_ages.lat,site_ages.int_abs*1e6,'bo')\n", "\n", "# put on the expected values for the present dipole moment (~80 ZAm^2)\n", "\n", "lats=np.arange(-80,70,1)\n", "vdms=80e21*np.ones(len(lats))\n", "bs=pmag.vdm_b(vdms,lats)*1e6\n", "plt.plot(lats,bs,'r-')\n", "plt.xlabel('Latitude')\n", "plt.ylabel('Intensity ($\\mu$T)')\n"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 307, "lines": ["That is pretty awful agreement.  Someday we need to figure out what is wrong with the data or  our GAD hypothesis.  "]}, {"block": 29, "type": "markdown", "linesLength": 5, "startIndex": 308, "lines": ["### grab_magic_key\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#grab_magic_key.py)\n", "\n", "Sometimes you want to read in a MagIC file and print out the desired key. **Pandas** makes this easy!  In this example, we will print out latitudes for each site record."]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 313, "lines": ["sites=pd.read_csv('data_files/download_magic/sites.txt',sep='\\t',header=1)\n", "print (sites.lat)"]}, {"block": 31, "type": "markdown", "linesLength": 8, "startIndex": 315, "lines": ["### magic_select\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#magic_select.py)\n", "\n", "This example demonstrates how to select MagIC records that meet a certain criterion, like having a particular method code.\n", "\n", "Note:  to output into a MagIC formatted file, we can change the DataFrame to a list of dictionaries (with df.to_dict(\"records\")) and\n", "use **pmag.magic_write()**.. "]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 323, "lines": ["help(pmag.magic_write)"]}, {"block": 33, "type": "code", "linesLength": 7, "startIndex": 324, "lines": ["# read in the data file\n", "spec_df=pd.read_csv('data_files/magic_select/specimens.txt',sep='\\t',header=1)\n", "# pick out the desired data \n", "method_key='method_codes' # change to method_codes for data model 3\n", "spec_df=spec_df[spec_df.method_codes.str.contains('LP-DIR-AF')]\n", "specs=spec_df.to_dict('records') # export to list of dictionaries\n", "success,ofile=pmag.magic_write('data_files/magic_select/AF_specimens.txt',specs,'pmag_specimens') # specimens for data model 3.0\n"]}, {"block": 34, "type": "markdown", "linesLength": 3, "startIndex": 331, "lines": ["### sites_extract\n", "\n", "It is frequently desirable to format tables for publications from the MagIC formatted files.  This example is for the sites.txt formatted file.  It will create a site information table with the location and age information,  and directions and/or intenisty summary tables.  The function to call is **ipmag.sites_extract()**."]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 334, "lines": ["help(ipmag.sites_extract)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 335, "lines": ["Here is an example for how to create Latex files: "]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 336, "lines": ["#latex way:\n", "ipmag.sites_extract(directions_file='directions.tex',intensity_file='intensities.tex',\n", "              output_dir_path='data_files/3_0/McMurdo',info_file='site_info.tex',latex=True)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 339, "lines": ["And here is how to create Excel files:"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 340, "lines": ["#xls way:\n", "if has_xlwt:\n", "    print(ipmag.sites_extract(output_dir_path='data_files/3_0/McMurdo'))"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 343, "lines": ["### criteria_extract\n", "\n", "This example is for the criteria.txt formatted file.  It will create a criteria  table suitable for publication in either LaTex or .csv format.  The function to call is **ipmag.criteria_extract()**."]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 346, "lines": ["help(ipmag.criteria_extract)"]}, {"block": 42, "type": "code", "linesLength": 3, "startIndex": 347, "lines": ["# latex way:\n", "ipmag.criteria_extract(output_dir_path='data_files/3_0/Megiddo',\n", "                       latex=True,output_file='criteria.tex',)"]}, {"block": 43, "type": "code", "linesLength": 3, "startIndex": 350, "lines": ["#xls way:\n", "if has_xlwt:\n", "    print(ipmag.criteria_extract(output_dir_path='data_files/3_0/Megiddo'))"]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 353, "lines": ["### specimens_extract\n", "\n", "Similarly, it is useful to make tables for specimen (intensity) data to include in publications.  Here are examples using a specimens.txt file.  "]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 356, "lines": ["help(ipmag.specimens_extract)"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 357, "lines": ["#latex way:\n", "ipmag.specimens_extract(output_file='specimens.tex',landscape=True,\n", "              output_dir_path='data_files/3_0/Megiddo',latex=True,longtable=True)"]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 360, "lines": ["#xls way:\n", "if has_xlwt:\n", "    print(ipmag.specimens_extract(output_dir_path='data_files/3_0/Megiddo'))"]}, {"block": 48, "type": "markdown", "linesLength": 3, "startIndex": 363, "lines": ["## Contributions\n", "\n", "Here are some useful functions for working with MagIC data model 3.0 contributions. "]}, {"block": 49, "type": "markdown", "linesLength": 9, "startIndex": 366, "lines": ["### download_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#download_magic.py)\n", "\n", " This program unpacks the .txt files downloaded from the MagIC database into individual text files. It has an option to also separate files for each location\n", " \n", " As an example, go to the MagIC data base at http://earthref.org/MAGIC/doi/10.1029/2003gc000661 and dowload the contribution.    Make a folder into which you should put the downloaded txt file called MagIC_download and move the file into it. Now use the program **download_magic** to unpack the .txt file (magic_contribution_16533.txt).\n", "\n", "To do this within a notebook,  use the function **ipmag.download_magic()**. "]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 375, "lines": ["help(ipmag.download_magic)"]}, {"block": 51, "type": "code", "linesLength": 2, "startIndex": 376, "lines": ["ipmag.download_magic(infile='magic_contribution_16533.txt',\\\n", "                     input_dir_path='data_files/download_magic',dir_path='data_files/download_magic')"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 378, "lines": ["You could look at these data with [dmag_magic](#dmag_magic) for example..."]}, {"block": 53, "type": "markdown", "linesLength": 6, "startIndex": 379, "lines": ["### upload_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#upload_magic.py)\n", "\n", "We can just turn around and try to upload the file downloaded in [download_magic](#download_magic).  For this we use **ipmag.upload_magic()** in the same directory as for the download.   You can try to upload the file you create to the MagIC data base as a private contribution here: https://www2.earthref.org/MagIC/upload\n", "\n"]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 385, "lines": ["help(ipmag.upload_magic)"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 386, "lines": ["ipmag.upload_magic(dir_path='data_files/download_magic',concat=True)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 387, "lines": ["If this were your own study, you could now go to https://earthref.org/MagIC and upload your contribution to a Private Workspace, validate, assign a DOI and activate!  "]}, {"block": 57, "type": "markdown", "linesLength": 3, "startIndex": 388, "lines": ["### cb.add_sites_to_meas_table\n", "\n", "MagIC data model 3 took out redundant columns in the MagIC tables so the hierarchy of specimens (in the measurements and specimens tables) up to samples, sites and locations is lost.  To put these back into the measurement table, we have the function **cb.add_sites_to_meas_table()**, which is super handy when data analysis requires it.  "]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 391, "lines": ["help(cb.add_sites_to_meas_table)"]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 392, "lines": ["status,meas_df=cb.add_sites_to_meas_table('data_files/3_0/McMurdo')\n", "meas_df.columns"]}, {"block": 60, "type": "markdown", "linesLength": 3, "startIndex": 394, "lines": ["### cb.get_intensity_col\n", "\n", "The MagIC data model has several different forms of magnetization with different normalizations (moment, volume, or mass).  So to find the one used in a particular measurements table we can use this handy function.  "]}, {"block": 61, "type": "code", "linesLength": 1, "startIndex": 397, "lines": ["help(cb.get_intensity_col)"]}, {"block": 62, "type": "code", "linesLength": 2, "startIndex": 398, "lines": ["magn_col=cb.get_intensity_col(meas_df)\n", "print (magn_col)"]}, {"block": 63, "type": "markdown", "linesLength": 6, "startIndex": 400, "lines": ["# Conversion Scripts\n", "\n", "## convert_2_magic\n", "\n", "We imported this module as **convert**.  It provides many functions for creating MagIC format files from non-MagIC formats. The MagIC formatted files can then be used with PmagPy programs and uploaded to the MagIC database. Let's take a look at the options:\n", "\n"]}, {"block": 64, "type": "markdown", "linesLength": 3, "startIndex": 406, "lines": ["### \\_2g\\_asc\\_magic\n", "\n", "This conversion has not been written yet. If you have this file format and wish to convert it to the MagIC file format, please let us know."]}, {"block": 65, "type": "markdown", "linesLength": 5, "startIndex": 409, "lines": ["### \\_2g\\_bin\\_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#_2g_bin_magic.py)\n", "\n", "To convert the binary formatted 2G Enterprises measurement files, we  can use the function **convert.\\_2g_bin()** in the **convert_2_magic** module (imported as **convert**). "]}, {"block": 66, "type": "code", "linesLength": 1, "startIndex": 414, "lines": ["help(convert._2g_bin)"]}, {"block": 67, "type": "code", "linesLength": 4, "startIndex": 415, "lines": ["# set the input directory\n", "input_dir='data_files/convert_2_magic/2g_bin_magic/mn1/'\n", "mag_file='mn001-1a.dat'\n", "convert._2g_bin(mag_file=mag_file,input_dir=input_dir,dir_path=input_dir)"]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 419, "lines": ["These are measurement data for a single specimen, so we can take a quickie look at the data in an equal area projection."]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 420, "lines": ["help(ipmag.plot_di)"]}, {"block": 70, "type": "code", "linesLength": 3, "startIndex": 421, "lines": ["meas_df=pd.read_csv(input_dir+'measurements.txt',sep='\\t',header=1)\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(dec=meas_df['dir_dec'],inc=meas_df['dir_inc'])"]}, {"block": 71, "type": "markdown", "linesLength": 8, "startIndex": 424, "lines": ["### agm_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#agm_magic.py)\n", "\n", " This program converts Micromag hysteresis files into MagIC formatted files. Because this program creates files for uploading to the MagIC database, specimens should also have sample/site/location information, which can be provided on the command line. If this information is not available, for example if this is a synthetic specimen, specify syn= True for synthetic name. \n", "\n", "Someone named Lima Tango has measured a synthetic specimen named myspec for hysteresis and saved the data in a file named agm_magic_example.agm in the agm_magic/agm_directory folder. The backfield IRM curve for the same specimen was saved in same directory as agm_magic_example.irm. Use the function **convert.agm()** to convert the data into a measurements.txt output file. For the backfield IRM file, set the keyword \"bak\" to True.  These were measured using cgs units, so be sure to set the units key word argument properly. Combine the two output files together using the instructions for [combine_magic](#combine_magic).  The agm files can be plotted using [hysteresis_magic](#hysteresis_magic) but the back-field plots are broken.  \n", "\n"]}, {"block": 72, "type": "code", "linesLength": 1, "startIndex": 432, "lines": ["help(convert.agm)"]}, {"block": 73, "type": "code", "linesLength": 2, "startIndex": 433, "lines": ["convert.agm('agm_magic_example.agm',dir_path='data_files/convert_2_magic/agm_magic/',\n", "            specimen='myspec',fmt='old',meas_outfile='agm.magic')"]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 435, "lines": ["convert.agm('agm_magic_example.irm',dir_path='data_files/convert_2_magic/agm_magic/',\n", "            specimen='myspec',fmt='old',meas_outfile='irm.magic')"]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 437, "lines": ["infiles=['data_files/convert_2_magic/agm_magic/agm.magic','data_files/convert_2_magic/agm_magic/irm.magic']\n", "ipmag.combine_magic(infiles,'data_files/convert_2_magic/agm_magic/measurements.txt')"]}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 439, "lines": ["We can look at these data using [hysteresis_magic](#hysteresis_magic):"]}, {"block": 77, "type": "code", "linesLength": 23, "startIndex": 440, "lines": ["# read in the measurements data\n", "meas_data=pd.read_csv('data_files/convert_2_magic/agm_magic/agm.magic',sep='\\t',header=1)\n", "# pick out the hysteresis data using the method code for hysteresis lab protocol\n", "hyst_data=meas_data[meas_data.method_codes.str.contains('LP-HYS')]\n", "\n", "# make the dictionary for figures that pmagplotlib likes\n", "\n", "# make a list of specimens\n", "specimens=hyst_data.specimen.unique()\n", "cnt=1\n", "for specimen in specimens:\n", "    HDD={'hyst':cnt,'deltaM':cnt+1,'DdeltaM':cnt+2}\n", "    spec_data=hyst_data[hyst_data.specimen==specimen]\n", "# make a list of the field data\n", "    B=spec_data.meas_field_dc.tolist()\n", "# make a list o the magnetizaiton data\n", "    M=spec_data.magn_moment.tolist()\n", "# call the plotting function\n", "    hpars=pmagplotlib.plot_hdd(HDD,B,M,specimen)\n", "    hpars['specimen']=specimen\n", "# print out the hysteresis parameters\n", "    print (specimen,': \\n',hpars)\n", "    cnt+=3"]}, {"block": 78, "type": "markdown", "linesLength": 6, "startIndex": 463, "lines": ["### bgc_magic \n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#bgc_magic.py)\n", "\n", "Here we convert the Berkeley Geochronology Center's AutoCore format to MagIC use **convert.bgc()**. \n", "\n"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 469, "lines": ["help(convert.bgc)"]}, {"block": 80, "type": "code", "linesLength": 2, "startIndex": 470, "lines": ["dir_path='data_files/convert_2_magic/bgc_magic/'\n", "convert.bgc('15HHA1-2A',dir_path=dir_path)"]}, {"block": 81, "type": "markdown", "linesLength": 1, "startIndex": 472, "lines": ["And let's take a look"]}, {"block": 82, "type": "code", "linesLength": 3, "startIndex": 473, "lines": ["meas_df=pd.read_csv(dir_path+'measurements.txt',sep='\\t',header=1)\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(dec=meas_df['dir_dec'],inc=meas_df['dir_inc'])"]}, {"block": 83, "type": "markdown", "linesLength": 11, "startIndex": 476, "lines": ["### cit_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#cit_magic.py)\n", "\n", "To convert the CalTech format to MagIC, use **convert.cit()**. \n", "\n", "Craig Jones\u2019 PaleoMag software package (http://cires.colorado.edu/people/jones.craig/PMag3.html) imports various file formats, including the \u2019CIT\u2019 format developed for the Caltech lab and now used in magnetometer control software that ships with 2G magnetometers that utilized a vertical sample changer system. The documentation for the CIT sample format is here: http://cires.colorado.edu/people/jones.craig/PMag_Formats.html#SAM_format. Demagnetization data for each specimen are in their own file in a directory with all the data for a site or study. These files are strictly formatted with fields determined by the character number in the line. There must be a file with the suffix \u2018.sam\u2019 in the same directory as the specimen data files which gives details about the specimens and a list of the specimen measurementfiles in the directory. \n", "\n", " The first line in the .sam file is a comment (in this case the site name), the second is the latitude and longitude followed by a declination correction. In these data, the declination correction was applied to the specimen orientations so the value of the declination correction is set to be 0.\n", "\n", "For detailed description of the .sam and sample file formats, check the PaleoMag Formats website linked to above.\n"]}, {"block": 84, "type": "code", "linesLength": 1, "startIndex": 487, "lines": ["help(convert.cit)"]}, {"block": 85, "type": "markdown", "linesLength": 1, "startIndex": 488, "lines": ["Use the function **convert.cit()** to covert the CIT data files from Swanson-Hysell lab at Berkeley for the PI47 site in the data_files/convert_2_magic/cit_magic/PI47 directory. The site (PI47) was part of a data set published in Fairchild et al., (2016) (available in the MagIC database: (https://earthref.org/MagIC/11292/). The location name was \u201cSlate Islands\u201d, the naming convention was #2, the specimen name is specified with 1 character, we don\u2019t wish to average replicate measurements  and they were collected by drilling and with a magnetic compass (\u201dFS-FD\",and \"SO-MAG\u201d). "]}, {"block": 86, "type": "code", "linesLength": 4, "startIndex": 489, "lines": ["dir_path='data_files/convert_2_magic/cit_magic/PI47/'\n", "convert.cit(dir_path=dir_path,\n", "           magfile='PI47-.sam',locname=\"Slate Islands\",specnum=1,samp_con='2',\n", "           methods=['FS-FD','SO-MAG'],noave=True)"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 493, "lines": ["We can make some Zijderveld diagrams (see [zeq_magic](#zeq_magic)). "]}, {"block": 88, "type": "code", "linesLength": 1, "startIndex": 494, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 495, "lines": ["Use the function convert.cit() to covert the CIT data files from the USGS lab at Menlo Park. The data file is in the data_files/convert_2_magic/cit_magic/USGS/bl9-1 directory, the file name is bl9-1.sam, and the analyst was Hagstrum. The location name was \u201cBoring volcanic field\u201d, and this site name was set by Hagstrum to BL9001 because the site name cannot be determined from the sample name with the current available options. The samples were collected by drilling and with a magnetic compass and sun compass (\u201dFS-FD\",and \"SO-MAG\u201d), the measurement are in Oersted instead of the standard milliTesla, and we don\u2019t wish to average replicate measurements."]}, {"block": 90, "type": "code", "linesLength": 5, "startIndex": 496, "lines": ["dir_path='data_files/convert_2_magic/cit_magic/USGS/bl9-1'\n", "convert.cit(dir_path=dir_path,\n", "           magfile='bl9-1.sam',user='Hagstrum',locname=\"Boring volcanic field\",\n", "           sitename='BL9001',methods=['FS-FD','SO-SM','LT-AF-Z'], oersted=True,\n", "           noave=True)"]}, {"block": 91, "type": "markdown", "linesLength": 1, "startIndex": 501, "lines": ["We can look at the Zijderveld, etc.  Diagrams with [zeq_magic](#zeq_magic)."]}, {"block": 92, "type": "code", "linesLength": 1, "startIndex": 502, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 93, "type": "markdown", "linesLength": 4, "startIndex": 503, "lines": ["Use the function convert.cit() to convert the CIT data files from Ben Wiess's lab at MIT. This data was part of a set published in ESPL. \"A nonmagnetic differentiated early planetary body\", \n", "doi:10.1016/j.epsl.2017.03.026 The data can be found in MagIC at https://earthref.org/MagIC/11943\n", "\n", "The data file is in the data_files/convert_2_magic/cit_magic/MIT/7325B directory, the file name is 7325B.sam, and the analyst was Wiess. The location name was \u201cNWA 7325\u201d with the site name coming from the sample name with the \"1\" convention. The samples are described with the method codes DE-VM, LP-DIR-T, LT-AF-Z, LT-NO, LT-T-Z, and SO-CMD-NORTH (see https://www2.earthref.org/MagIC/method-codes for full descriptions). We also don\u2019t wish to average replicate measurements."]}, {"block": 94, "type": "code", "linesLength": 4, "startIndex": 507, "lines": ["convert.cit(dir_path='data_files/convert_2_magic/cit_magic/MIT/7325B',\n", "           magfile='7325B.sam',user='Wiess',locname=\"NWA 7325\",samp_con='1',\n", "           methods=['DE-VM', 'LP-DIR-T', 'LT-AF-Z', 'LT-NO', 'LT-T-Z', 'SO-CMD-NORTH'],\n", "           noave=True)"]}, {"block": 95, "type": "markdown", "linesLength": 1, "startIndex": 511, "lines": ["And take a look see:"]}, {"block": 96, "type": "code", "linesLength": 1, "startIndex": 512, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 97, "type": "markdown", "linesLength": 7, "startIndex": 513, "lines": ["### generic_magic \n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#generic_magic.py)\n", "\n", "If you have a data file format that is not supported, you can relabel column headers to fit the generic format as in the generic_magic example data file. \n", "\n", "To import the generic file format, use **convert.generic()**.\n"]}, {"block": 98, "type": "code", "linesLength": 1, "startIndex": 520, "lines": ["help(convert.generic)"]}, {"block": 99, "type": "code", "linesLength": 2, "startIndex": 521, "lines": ["convert.generic(magfile='data_files/convert_2_magic/generic_magic/generic_magic_example.txt',\n", "                experiment='PI',dir_path='data_files/convert_2_magic/generic_magic')"]}, {"block": 100, "type": "code", "linesLength": 3, "startIndex": 523, "lines": ["# let's take a look\n", "dir_path='data_files/convert_2_magic/generic_magic/'\n", "ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 101, "type": "markdown", "linesLength": 5, "startIndex": 526, "lines": ["### huji_magic \n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#huji_magic.py)\n", "\n", "To import the Hebrew University, Jerusalem, Israel file format to MagIC, use **convert.huji()**.   "]}, {"block": 102, "type": "code", "linesLength": 1, "startIndex": 531, "lines": ["help(convert.huji)"]}, {"block": 103, "type": "code", "linesLength": 3, "startIndex": 532, "lines": ["dir_path='data_files/convert_2_magic/huji_magic/'\n", "convert.huji(dir_path=dir_path,\n", "             magfile='Massada_AF_HUJI_new_format.txt',codelist='T')"]}, {"block": 104, "type": "code", "linesLength": 1, "startIndex": 535, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False, n_plots=10)"]}, {"block": 105, "type": "markdown", "linesLength": 6, "startIndex": 536, "lines": ["### huji_sample_magic\n", "\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#huji_sample_magic.py)\n", "\n", "To convert a Hebrew University Jersalem, Israel sample format to MagIC, use **convert.huji_sample()**.  "]}, {"block": 106, "type": "code", "linesLength": 1, "startIndex": 542, "lines": ["help(convert.huji_sample)"]}, {"block": 107, "type": "code", "linesLength": 2, "startIndex": 543, "lines": ["convert.huji_sample('magdelkrum_datafile.txt',\n", "                   dir_path='data_files/convert_2_magic/huji_magic/')"]}, {"block": 108, "type": "code", "linesLength": 1, "startIndex": 545, "lines": ["help(ipmag.combine_magic)"]}, {"block": 109, "type": "markdown", "linesLength": 5, "startIndex": 546, "lines": ["### jr6_jr6_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#jr6_jr6_magic.py)\n", "\n", "The AGICO JR6 spinner magnetometer has two output formats, the .jr6 and the .txt.  Here we illustrate the conversion of the .jr6 format.  There are data from two different studies in the example folder.  One (from Anita di Chiara) has the suffix '.JR6' and the other (from Roi Granot) are lower case (.jr6'). Each file has the data from a single specimen's experiment.  So, we can convert Anita's data to a series of MagIC formatted measurement files, combine them with [ipmag.combine_magic](#ipmag.combine_magic) and look at them with Demag GUI (on the command line) or [zeq_magic](#zeq_magic) within the notebook. \n"]}, {"block": 110, "type": "code", "linesLength": 1, "startIndex": 551, "lines": ["help(convert.jr6_jr6)"]}, {"block": 111, "type": "markdown", "linesLength": 2, "startIndex": 552, "lines": ["\n", "Let's start with Anita's files"]}, {"block": 112, "type": "code", "linesLength": 24, "startIndex": 554, "lines": ["dir_path='data_files/convert_2_magic/jr6_magic/'\n", "files=os.listdir(dir_path)\n", "meas_files,spec_files,samp_files,site_files=[],[],[],[]\n", "for file in files:\n", "    if '.JR6' in file:\n", "        print (file)\n", "        stem=file.split('.')[0]\n", "        meas_file=stem+'_measurements.txt' # make a unique measurements file\n", "        spec_file=stem+'_specimens.txt'\n", "        samp_file=stem+'_samples.txt'\n", "        site_file=stem+'_sites.txt'\n", "        convert.jr6_jr6(file,dir_path=dir_path,\n", "                        meas_file=meas_file,spec_file=spec_file,samp_file=samp_file,\n", "                        site_file=site_file,user='Anita')\n", "        meas_files.append(dir_path+meas_file) # save the file name to a list\n", "        spec_files.append(dir_path+spec_file)\n", "        samp_files.append(dir_path+samp_file)\n", "        site_files.append(dir_path+site_file)\n", "\n", "# combine the files\n", "ipmag.combine_magic(meas_files,dir_path+'measurements.txt')\n", "ipmag.combine_magic(spec_files,dir_path+'specimens.txt',magic_table='specimens')\n", "ipmag.combine_magic(samp_files,dir_path+'samples.txt',magic_table='samples')\n", "ipmag.combine_magic(site_files,dir_path+'sites.txt',magic_table='sites')\n"]}, {"block": 113, "type": "code", "linesLength": 1, "startIndex": 578, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 114, "type": "markdown", "linesLength": 1, "startIndex": 579, "lines": ["Now we can do Roi's files"]}, {"block": 115, "type": "code", "linesLength": 23, "startIndex": 580, "lines": ["dir_path='data_files/convert_2_magic/jr6_magic/'\n", "files=os.listdir(dir_path)\n", "meas_files,spec_files,samp_files,site_files=[],[],[],[]\n", "for file in files:\n", "    if file.endswith('.jr6'):\n", "        stem=file.split('.')[0]\n", "        meas_file=stem+'_measurements.txt' # make a unique measurements file\n", "        spec_file=stem+'_specimens.txt'\n", "        samp_file=stem+'_samples.txt'\n", "        site_file=stem+'_sites.txt'\n", "        convert.jr6_jr6(file,dir_path=dir_path,\n", "                        meas_file=meas_file,spec_file=spec_file,samp_file=samp_file,\n", "                        site_file=site_file,user='Roi')\n", "        meas_files.append(dir_path+meas_file) # save the file name to a list\n", "        spec_files.append(dir_path+spec_file)\n", "        samp_files.append(dir_path+samp_file)\n", "        site_files.append(dir_path+site_file)\n", "\n", "# combine the files\n", "ipmag.combine_magic(meas_files,dir_path+'measurements.txt')\n", "ipmag.combine_magic(spec_files,dir_path+'specimens.txt',magic_table='specimens')\n", "ipmag.combine_magic(samp_files,dir_path+'samples.txt',magic_table='samples')\n", "ipmag.combine_magic(site_files,dir_path+'sites.txt',magic_table='sites')\n"]}, {"block": 116, "type": "code", "linesLength": 1, "startIndex": 603, "lines": ["ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 117, "type": "markdown", "linesLength": 5, "startIndex": 604, "lines": ["### jr6_txt_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#jr6_txt_magic.py)\n", "\n", "We can repeat the exercise for the JR6 .txt format using **convert.jr6_txt()**.  "]}, {"block": 118, "type": "code", "linesLength": 1, "startIndex": 609, "lines": ["help(convert.jr6_txt)"]}, {"block": 119, "type": "markdown", "linesLength": 1, "startIndex": 610, "lines": ["There are only data from Roi Granot in this format. The measurement values should be identical to the **convert.jr6_jr6()** function on .jr6 files with the same stem. Additional columns will be found when converting the .JR6 format as that format contains more information than the .txt files."]}, {"block": 120, "type": "code", "linesLength": 23, "startIndex": 611, "lines": ["dir_path='data_files/convert_2_magic/jr6_magic/'\n", "files=['AF.txt','TRM.txt','AP12.txt']\n", "meas_files,spec_files,samp_files,site_files=[],[],[],[]\n", "for file in files:\n", "        print (file)\n", "        stem=file.split('.')[0]\n", "        meas_file=stem+'_measurements.txt' # make a unique measurements file\n", "        spec_file=stem+'_specimens.txt'\n", "        samp_file=stem+'_samples.txt'\n", "        site_file=stem+'_sites.txt'\n", "        convert.jr6_txt(file,dir_path=dir_path,\n", "                        meas_file=meas_file,spec_file=spec_file,samp_file=samp_file,\n", "                        site_file=site_file,user='Roi')\n", "        meas_files.append(dir_path+meas_file) # save the file name to a list\n", "        spec_files.append(dir_path+spec_file)\n", "        samp_files.append(dir_path+samp_file)\n", "        site_files.append(dir_path+site_file)\n", "\n", "# combine the files\n", "ipmag.combine_magic(meas_files,dir_path+'measurements.txt')\n", "ipmag.combine_magic(spec_files,dir_path+'specimens.txt',magic_table='specimens')\n", "ipmag.combine_magic(samp_files,dir_path+'samples.txt',magic_table='samples')\n", "ipmag.combine_magic(site_files,dir_path+'sites.txt',magic_table='sites')"]}, {"block": 121, "type": "code", "linesLength": 1, "startIndex": 634, "lines": ["ipmag.zeq_magic(meas_file='AP12_measurements.txt',input_dir_path=dir_path, save_plots=False)"]}, {"block": 122, "type": "markdown", "linesLength": 7, "startIndex": 635, "lines": ["### k15_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#k15_magic.py)\n", "\n", "Someone took a set of samples from a dike margin in the Troodos Ophiolite and measured their anisotropy of magnetic susceptibility on an a Kappabridge KLY 2.0 instrument in the SIO laboratory.  An example of the  data file format is in k15_magic.  \n", "\n", "The first line of each set of four has the specimen name, azimuth, plunge, and bedding strike and dip the next three lines are sets of five measurements in the 15 positions recommended by Jelinek (1977): \n"]}, {"block": 123, "type": "code", "linesLength": 1, "startIndex": 642, "lines": ["Image('data_files/Figures/meas15.png')"]}, {"block": 124, "type": "markdown", "linesLength": 3, "startIndex": 643, "lines": ["The 15 measurements for each specimen, along with orientation information and the specimen name were saved in the file data_files/k15_magic/k15_example.dat. \n", "\n", "To convert 15 measurement anisotropy of magnetic susceptibility file format to MagIC,   use **convert.k15()**. "]}, {"block": 125, "type": "code", "linesLength": 1, "startIndex": 646, "lines": ["help(convert.k15)"]}, {"block": 126, "type": "code", "linesLength": 2, "startIndex": 647, "lines": ["convert.k15('k15_example.dat',dir_path='data_files/convert_2_magic/k15_magic/',\n", "            location='Troodos Ophiolite')"]}, {"block": 127, "type": "code", "linesLength": 1, "startIndex": 649, "lines": ["ipmag.aniso_magic_nb(infile='specimens.txt',dir_path='data_files/convert_2_magic/k15_magic/') "]}, {"block": 128, "type": "markdown", "linesLength": 19, "startIndex": 650, "lines": ["### kly4s_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#kly4s_magic.py)\n", "\n", " The program AMSSpin available for downloading from http://earthref.org/ERDA/940/ generates data for the Kappabridge KLY4S spinning magnetic susceptibility instrument as described by Gee et al. (2008).\n", "\n", "\n", "\n", "Output files are in the format of the file KLY4S_magic_example.dat (found in the measurement_import/kly4s_magic folder). \n", "\n", "The columns in the example file are:\n", "\n", "Specimen S_1 S_2 S_3 S_4 S_5 S_6 \u03c7b(\u03bcSI) date time user\n", "\n", "\n", "\n", "\n", "To convert the Agico Kappabridge KLY4S files generated by the SIO labview program (written by Jeff Gee), use **convert.kly4s()**. \n", "This function will create the files needed by the MagIC database and the data can be plotted using [aniso_magic](#aniso_magic).   If you were to import the sample files from the LIMS data base for these samples, you could plot them versus depth, or as equal area projections using **ani_depthplot** and **aniso_magic** respectively. \n"]}, {"block": 129, "type": "code", "linesLength": 1, "startIndex": 669, "lines": ["help(convert.kly4s)"]}, {"block": 130, "type": "code", "linesLength": 2, "startIndex": 670, "lines": ["convert.kly4s('KLY4S_magic_example.dat',\n", "              dir_path='data_files/convert_2_magic/kly4s_magic/')"]}, {"block": 131, "type": "code", "linesLength": 1, "startIndex": 672, "lines": ["ipmag.aniso_magic_nb(infile='specimens.txt',dir_path='data_files/convert_2_magic/kly4s_magic/') "]}, {"block": 132, "type": "markdown", "linesLength": 7, "startIndex": 673, "lines": ["### ldeo_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#ldeo_magic.py)\n", "\n", "To convert Lamont-Doherty Earth Observatory data files to MagIC, use **convert.ldeo()**. \n", "\n", "NB:  this doesn't seem to work properly at all.  "]}, {"block": 133, "type": "code", "linesLength": 1, "startIndex": 680, "lines": ["help(convert.ldeo)"]}, {"block": 134, "type": "code", "linesLength": 2, "startIndex": 681, "lines": ["convert.ldeo('ldeo_magic_example.dat',codelist='AF',\n", "             dir_path='data_files/convert_2_magic/ldeo_magic/')"]}, {"block": 135, "type": "code", "linesLength": 1, "startIndex": 683, "lines": ["ipmag.zeq_magic(input_dir_path='data_files/convert_2_magic/ldeo_magic/', save_plots=False)"]}, {"block": 136, "type": "markdown", "linesLength": 8, "startIndex": 684, "lines": ["### livdb_magic \n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#livdb_magic.py)\n", "\n", "To convert the Liverpool university database  format to MagIC use **convert.livdb()**.  \n", "\n", "Here we have several experiment types as examples as examples.  \n", "\n"]}, {"block": 137, "type": "code", "linesLength": 1, "startIndex": 692, "lines": ["help(convert.livdb)"]}, {"block": 138, "type": "markdown", "linesLength": 1, "startIndex": 693, "lines": ["Here's an example for an IZZI style, thermal experiment:"]}, {"block": 139, "type": "code", "linesLength": 3, "startIndex": 694, "lines": ["convert.livdb('data_files/convert_2_magic/livdb_magic/TH_IZZI+/',\n", "             output_dir_path='data_files/convert_2_magic/livdb_magic/TH_IZZI+',\n", "             site_name_con=2,site_num_chars=3)"]}, {"block": 140, "type": "code", "linesLength": 2, "startIndex": 697, "lines": ["ipmag.thellier_magic(input_dir_path='data_files/convert_2_magic/livdb_magic/TH_IZZI+', \n", "                     save_plots=False, interactive=False, n_specs=5)"]}, {"block": 141, "type": "markdown", "linesLength": 1, "startIndex": 699, "lines": ["here's one for microwave \"C+\" experiment"]}, {"block": 142, "type": "code", "linesLength": 3, "startIndex": 700, "lines": ["convert.livdb('data_files/convert_2_magic/livdb_magic/MW_C+/',\n", "             output_dir_path='data_files/convert_2_magic/livdb_magic/MW_C+',\n", "             site_name_con=2,site_num_chars=3)"]}, {"block": 143, "type": "markdown", "linesLength": 1, "startIndex": 703, "lines": ["An example for both microwave IZZI and C++:"]}, {"block": 144, "type": "code", "linesLength": 3, "startIndex": 704, "lines": ["convert.livdb('data_files/convert_2_magic/livdb_magic/MW_IZZI+andC++/',\n", "             output_dir_path='data_files/convert_2_magic/livdb_magic/MW_IZZI+andC++',\n", "             samp_name_con='2', samp_num_chars=1,site_name_con=2,site_num_chars=1)"]}, {"block": 145, "type": "markdown", "linesLength": 1, "startIndex": 707, "lines": ["An example for both microwave OT+:"]}, {"block": 146, "type": "code", "linesLength": 3, "startIndex": 708, "lines": ["convert.livdb('data_files/convert_2_magic/livdb_magic/MW_OT+/',\n", "             output_dir_path='data_files/convert_2_magic/livdb_magic/MW_OT+',\n", "             site_name_con=2,site_num_chars=3)"]}, {"block": 147, "type": "markdown", "linesLength": 1, "startIndex": 711, "lines": ["And an example for MW_P experiments.   "]}, {"block": 148, "type": "code", "linesLength": 3, "startIndex": 712, "lines": ["convert.livdb('data_files/convert_2_magic/livdb_magic/MW_P/',\n", "             output_dir_path='data_files/convert_2_magic/livdb_magic/MW_P',\n", "             site_name_con=2,site_num_chars=3)"]}, {"block": 149, "type": "markdown", "linesLength": 1, "startIndex": 715, "lines": ["Now you can look at these data (except for MW_P) with thellier_gui or [thellier_magic](#thellier_magic)."]}, {"block": 150, "type": "markdown", "linesLength": 5, "startIndex": 716, "lines": ["### mst_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#mst_magic.py)\n", "\n", "To convert a Curie Temperature experiment to MagIC, use **convert.mst()**.  The data file format should be a space delimited file with temperature and magnetization couplets.   "]}, {"block": 151, "type": "code", "linesLength": 1, "startIndex": 721, "lines": ["help(convert.mst)"]}, {"block": 152, "type": "code", "linesLength": 2, "startIndex": 722, "lines": ["convert.mst('curie_example.dat',samp_con=\"5\",\n", "           dir_path='data_files/convert_2_magic/mst_magic/')"]}, {"block": 153, "type": "markdown", "linesLength": 1, "startIndex": 724, "lines": ["We can now use [curie](#curie) to plot the data. "]}, {"block": 154, "type": "code", "linesLength": 1, "startIndex": 725, "lines": ["ipmag.curie(path_to_file='data_files/convert_2_magic/mst_magic/',file_name='measurements.txt',magic=True)"]}, {"block": 155, "type": "markdown", "linesLength": 10, "startIndex": 726, "lines": ["### pmd_magic \n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#pmd_magic.py)\n", "\n", " This format is the one used to import .PMD formatted magnetometer files (used for example in the PaleoMac software of Cogn\u00e9, 2003) into the MagIC format. (See http://www.ipgp.fr/~cogne/pub/paleomac/PMhome.html for the PaleoMac home page. The version of these files that **pmd_magic** expects (UCSC version) contains demagnetization data for a single specimen and has a format as in the example file in ../measurement_import/pmd_magic/PMD/ss0207a.pmd\n", "\n", "\n", "The first line is a comment line. The second line has the specimen name, the core azimuth (a=) and plunge (b=) which are assumed to be the lab arrow azimuth and plunge (Orientation scheme #4)D. The third line is a header explaining the columns in the file.\n", "\n", "Use **convert.pmd()**  to convert the file ss0101a.pmd in the directory \u2019PMD\u2019 in the \u2019pmd_magic\u2019 folder of the measurement_import directory in the example data_files directory. These were taken at a location named \u2019Summit Springs\u2019 and have a naming convention of the type XXXX[YYY], where YYY is sample designation with Z characters from site XXX, or naming convention # 4-2. A single character distinguishes the specimen from the sample (specnum=1). All samples were oriented with a magnetic compass. "]}, {"block": 156, "type": "code", "linesLength": 1, "startIndex": 736, "lines": ["help(convert.pmd)"]}, {"block": 157, "type": "code", "linesLength": 2, "startIndex": 737, "lines": ["convert.pmd('ss0207a.pmd',dir_path='data_files/convert_2_magic/pmd_magic/PMD/',\n", "           samp_con='4-2',location='Summit Springs',specnum=1)"]}, {"block": 158, "type": "markdown", "linesLength": 9, "startIndex": 739, "lines": ["### sio_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#sio_magic.py)\n", "\n", "This program allows conversion of the SIO format magnetometer files to the MagIC common measurements format. The columns in the example data file are: \n", "\n", "Specimen treatment intensity declination inclination optional_string \n", "\n", "The treatment field is the temperature (in centigrade), the AF field (in mT), the impulse field strength, etc. For special experiments like IRM acquisition, the coil number of the popular ASC impulse magnetizer can be specified if the treatment steps are in volts. The position for anisotropy experiments or whether the treatment is \u201cin-field\u201d or in zero field also require special formatting. The units of the intensity field are in cgs and the directions are relative to the \u2018lab arrow\u2019 on the specimen. Here are some examples of commonly used specimens and conversions from field arrow to lab arrow. "]}, {"block": 159, "type": "code", "linesLength": 1, "startIndex": 748, "lines": ["Image('data_files/Figures/samples.png')"]}, {"block": 160, "type": "markdown", "linesLength": 3, "startIndex": 749, "lines": ["As an example, we use data from Sbarbori et al. (2009) done on a set of samples from the location \u201cSocorro\u201d, including AF, thermal, and thellier experimental data. These were saved in sio_af_example.dat, sio_thermal_example.dat, and sio_thellier_example.dat respectively. The lab field for the thellier experiment was 25 \u03bcT and was applied along the specimen\u2019s Z axis (phi=0,theta=90).] \n", "\n", "We can convert the example files into measurement formatted files with names like af_measurements.txt, etc. using the function **convert.sio()**.   Then combine them together following the instructions for  [combine_magic](#combine_magic).   "]}, {"block": 161, "type": "code", "linesLength": 1, "startIndex": 752, "lines": ["help(convert.sio)"]}, {"block": 162, "type": "code", "linesLength": 4, "startIndex": 753, "lines": ["convert.sio('sio_af_example.dat',dir_path='data_files/convert_2_magic/sio_magic/',\n", "           specnum=1,location='Isla Soccoro',codelist='AF',samp_con='1',\n", "           meas_file='af_measurements.txt',spec_file='af_specimens.txt',\n", "           samp_file='af_samples.txt',site_file='af_sites.txt')"]}, {"block": 163, "type": "code", "linesLength": 4, "startIndex": 757, "lines": ["convert.sio('sio_thermal_example.dat',dir_path='data_files/convert_2_magic/sio_magic/',\n", "            specnum=1,location='Isla Soccoro',codelist='T',\n", "            meas_file='thermal_measurements.txt',spec_file='thermal_specimens.txt',\n", "            samp_file='thermal_samples.txt',site_file='thermal_sites.txt')"]}, {"block": 164, "type": "markdown", "linesLength": 1, "startIndex": 761, "lines": ["And combine them together... "]}, {"block": 165, "type": "code", "linesLength": 12, "startIndex": 762, "lines": ["# combine the measurements files\n", "measfiles=['data_files/convert_2_magic/sio_magic/af_measurements.txt',\n", "           'data_files/convert_2_magic/sio_magic/thermal_measurements.txt']\n", "ipmag.combine_magic(measfiles,'data_files/convert_2_magic/sio_magic/measurements.txt')\n", "\n", "specfiles=['data_files/convert_2_magic/sio_magic/af_specimens.txt',\n", "           'data_files/convert_2_magic/sio_magic/thermal_specimens.txt']\n", "ipmag.combine_magic(specfiles,'data_files/convert_2_magic/sio_magic/specimens.txt', magic_table='specimens')\n", "\n", "sitefiles=['data_files/convert_2_magic/sio_magic/af_sites.txt',\n", "           'data_files/convert_2_magic/sio_magic/thermal_sites.txt']\n", "ipmag.combine_magic(sitefiles,'data_files/convert_2_magic/sio_magic/sites.txt',magic_table='sites')\n"]}, {"block": 166, "type": "markdown", "linesLength": 5, "startIndex": 774, "lines": ["### sufar4_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#sufar4_asc_magic.py)\n", "\n", "The AGICO program SUFAR creates ascii txt files as output.  **convert.sufar4()** will convert these to the MagIC format."]}, {"block": 167, "type": "code", "linesLength": 1, "startIndex": 779, "lines": ["help(convert.sufar4)"]}, {"block": 168, "type": "code", "linesLength": 2, "startIndex": 780, "lines": ["convert.sufar4('sufar4-asc_magic_example.txt',dir_path='data_files/convert_2_magic/sufar_asc_magic/',\n", "              sample_naming_con='5',locname='U1356A')"]}, {"block": 169, "type": "markdown", "linesLength": 1, "startIndex": 782, "lines": ["Now we can test it out with, for example, [ipmag.aniso_magic_nb()](#aniso_magic)"]}, {"block": 170, "type": "code", "linesLength": 1, "startIndex": 783, "lines": ["ipmag.aniso_magic_nb(infile='data_files/convert_2_magic/sufar_asc_magic/specimens.txt')"]}, {"block": 171, "type": "markdown", "linesLength": 5, "startIndex": 784, "lines": ["### tdt_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#tdt_magic.py)\n", "\n", "Convertions of the Thellier Tool format of Leonhardt et al., 2004 can be done with **convert.tdt()**.  THERE IS A PROBLEM WITH THE XXX.4 TREATMENT STEP CONVERSION.  "]}, {"block": 172, "type": "code", "linesLength": 1, "startIndex": 789, "lines": ["help(convert.tdt)"]}, {"block": 173, "type": "code", "linesLength": 1, "startIndex": 790, "lines": ["convert.tdt('data_files/convert_2_magic/tdt_magic/')"]}, {"block": 174, "type": "markdown", "linesLength": 3, "startIndex": 791, "lines": ["### utrecht_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#utrecht_magic.py)\n"]}, {"block": 175, "type": "code", "linesLength": 1, "startIndex": 794, "lines": ["help(convert.utrecht)"]}, {"block": 176, "type": "code", "linesLength": 2, "startIndex": 795, "lines": ["convert.utrecht('Utrecht_Example.af',dir_path='data_files/convert_2_magic/utrecht_magic',\n", "               specnum=0,samp_con='3')"]}, {"block": 177, "type": "markdown", "linesLength": 6, "startIndex": 797, "lines": ["### orientation_magic\n", "\n", "[\\[Preparing for MagIC\\]](https://earthref.org/PmagPy/cookbook/#QQ2-1-25) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#orientation_magic.py)\n", "\n", "**orientation_magic** is meant to import the field book data as entered into the format like in  orientation_example.txt into the MagIC format samples, sites and location tables.  \n", "Click [here](https://earthref.org/PmagPy/cookbook/#field_info)  for details about the orient.txt file format. The example file used here has field information for a few sites. The samples were oriented with a Pomeroy orientation device (the default) and it is desirable to calculate the magnetic declination from the IGRF at the time of sampling (also the default). Sample names follow the rule that the sample is designated by a letter at the end of the site name (convention \\#1 - which is also the default). We can do this from within a notebook by calling  **ipmag.orientation_magic()**.\n"]}, {"block": 178, "type": "code", "linesLength": 1, "startIndex": 803, "lines": ["help(ipmag.orientation_magic)"]}, {"block": 179, "type": "markdown", "linesLength": 1, "startIndex": 804, "lines": [" We need to know which orientation convention was used to take the samples (it was with a Pomeroy, so, the default).  We want to use the igrf calculated magnetic declination at each site (so dec_correction_con=1, the default).  These samples were collected in Antarctica with a local time of GMT+13, so we need to subtract 13 hours so hours_from_gmt should be 13.  we are using data model 3.0 for this notebook, so data_model=3.  Also, input_dir_path and output_dir_path are both ../orientation_magic.  "]}, {"block": 180, "type": "code", "linesLength": 2, "startIndex": 805, "lines": ["ipmag.orientation_magic(input_dir_path='data_files/orientation_magic',orient_file='orient_example.txt',\n", "                        hours_from_gmt=13,data_model=3,output_dir_path='data_files/orientation_magic')"]}, {"block": 181, "type": "markdown", "linesLength": 8, "startIndex": 807, "lines": ["### azdip_magic\n", "\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#azdip_magic.py)\n", "\n", "Many paleomagnetists save orientation information in files in this format: Sample Azimuth Plunge Strike Dip (AZDIP format), where the Azimuth and Plunge are the declination and inclination of the drill direction and the strike and dip are the attitude of the sampled unit (with dip to the right of strike). Of course there are many ways to think about sample orientation and the MagIC database convention is to store the direction of the X coordinate of the specimen measurements. To convert an AzDip formatted file (example in data_files/azdip_magic/azdip_magic_example.dat), we can use **ipmag.azdip_magic()**.  \n", "\n", "\n", "\n"]}, {"block": 182, "type": "code", "linesLength": 1, "startIndex": 815, "lines": ["help(ipmag.azdip_magic)"]}, {"block": 183, "type": "markdown", "linesLength": 2, "startIndex": 816, "lines": ["The method_codes are important. If you don't specify any sample orientation method, for example, the program will assume that they are unoriented.  Pick the appropriate method codes for field sampling (FS-) and sample orientation (SO-) from the lists here:  https://www2.earthref.org/MagIC/method-codes\n", "\n"]}, {"block": 184, "type": "code", "linesLength": 2, "startIndex": 818, "lines": ["ipmag.azdip_magic(orient_file='azdip_magic_example.dat',input_dir='data_files/azdip_magic/',\n", "                  output_dir='data_files/azdip_magic/', method_codes='FS-FD:SO-MAG')"]}, {"block": 185, "type": "markdown", "linesLength": 1, "startIndex": 820, "lines": ["# PmagPy"]}, {"block": 186, "type": "markdown", "linesLength": 15, "startIndex": 821, "lines": ["### aarm_magic\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#aarm_magic.py)\n", "\n", "Anisotropy of anhysteretic or other remanence can be converted to a tensor and used to correct natural remanence data for the effects of anisotropy remanence acquisition. For example, directions may be deflected from the geomagnetic field direction or intensities may be biased by strong anisotropies in the magnetic fabric of the specimen. By imparting an anhysteretic or thermal remanence in many specific orientations, the anisotropy of remanence acquisition can be characterized and used for correction. We do this for anisotropy of anhysteretic remanence (AARM) by imparting an ARM in 9, 12 or 15 positions. Each ARM must be preceded by an AF demagnetization step. The 15 positions are shown in the [k15_magic](#k15_magic) example.\n", "\n", "For the 9 position scheme, **aarm_magic** assumes that the AARMs are imparted in positions 1,2,3, 6,7,8, 11,12,13. Someone (a.k.a. Josh Feinberg) has kindly made the measurements and saved them an SIO formatted measurement file named aarm_magic_example.dat in the datafile directory called aarm_magic. Note the special format of these files - the treatment column (column #2) has the position number (1,2,3,6, etc.) followed by either a \u201c00\u201d for the obligatory zero field baseline step or a \u201c10\u201d for the in-field step. These could also be \u20180\u2018 and \u20181\u2019.\n", "\n", "We need to first import these into the measurements format and then calculate the anisotropy tensors. These can then be plotted or used to correct paleointensity or directional data for anisotropy of remanence.\n", "\n", "So, first follow the instructions in  [sio_magic](#sio_magic) to import the AARM data into the MagIC format. The DC field was 50 \u03bcT, the peak AC field was 180 mT, the location was \"Bushveld\" and the lab protocol was AF and Anisotropy. The naming convention used Option # 3 (see help menu).\n", "\n", "Then we need  to calculate the best-fit tensor and write them out to the specimens.txt MagIC tables which can be used to correct remanence data for anisotropy. \n", "\n", "The **aarm_magic** program takes a measurements.txt formatted file with anisotropy of ARM data in it and calculates the tensors, rotates it into the desired coordinate system and stores the data in a specimens.txt format file.  To do this in a notebook, use **ipmag.aarm_magic()**.  "]}, {"block": 187, "type": "code", "linesLength": 3, "startIndex": 836, "lines": ["convert.sio('arm_magic_example.dat',dir_path='data_files/aarm_magic/',specnum=3,\n", "           location='Bushveld',codelist='AF:ANI',samp_con='3',\n", "           meas_file='aarm_measurements.txt',peakfield=180,labfield=50, phi=-1, theta=-1)"]}, {"block": 188, "type": "code", "linesLength": 1, "startIndex": 839, "lines": ["help(ipmag.aarm_magic)"]}, {"block": 189, "type": "code", "linesLength": 1, "startIndex": 840, "lines": ["ipmag.aarm_magic('aarm_measurements.txt',dir_path='data_files/aarm_magic/')"]}, {"block": 190, "type": "code", "linesLength": 1, "startIndex": 841, "lines": ["ipmag.aniso_magic_nb(infile='data_files/aarm_magic/specimens.txt')"]}, {"block": 191, "type": "code", "linesLength": 1, "startIndex": 842, "lines": ["help(ipmag.aniso_magic_nb)"]}, {"block": 192, "type": "markdown", "linesLength": 8, "startIndex": 843, "lines": ["## angle\n", "\n", "[\\[Essentials Appendix A.3.4\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap1.html#x20-215000A.3.4) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#angle.py)\n", "\n", "\n", "**angle** calculates the angle $\\alpha$ between two declination,inclination pairs. It reads in the directions from the command line or from a file and calls **pmag.angle()** to do the calculation.  \n", "\n", "There are several ways to use this from the notebook - one loading the data into a Pandas dataframe, then convert to the desired arrays, or load directly into a **Numpy** array of desired shape.  "]}, {"block": 193, "type": "code", "linesLength": 1, "startIndex": 851, "lines": ["help(pmag.angle)"]}, {"block": 194, "type": "code", "linesLength": 4, "startIndex": 852, "lines": ["# Pandas way:\n", "di=pd.read_csv('data_files/angle/angle.dat',delim_whitespace=True,header=None)\n", "#rename column headers\n", "di.columns=['Dec1','Inc1','Dec2','Inc2']\n"]}, {"block": 195, "type": "markdown", "linesLength": 1, "startIndex": 856, "lines": ["Here's the sort of data  in the file: "]}, {"block": 196, "type": "code", "linesLength": 1, "startIndex": 857, "lines": ["di.head()"]}, {"block": 197, "type": "markdown", "linesLength": 1, "startIndex": 858, "lines": ["Now we will use **pmag.angle()** to calculate the angles.  "]}, {"block": 198, "type": "code", "linesLength": 2, "startIndex": 859, "lines": ["# call pmag.angle\n", "pmag.angle(di[['Dec1','Inc1']].values,di[['Dec2','Inc2']].values)"]}, {"block": 199, "type": "markdown", "linesLength": 1, "startIndex": 861, "lines": ["Here is the other (equally valid) way using **np.loadtext()**."]}, {"block": 200, "type": "code", "linesLength": 5, "startIndex": 862, "lines": ["# Numpy way:\n", "di=np.loadtxt('data_files/angle/angle.dat').transpose() # read in file\n", "D1=di[0:2].transpose() # assign to first array\n", "D2=di[2:].transpose() # assign to second array\n", "pmag.angle(D1,D2) # call pmag.angle"]}, {"block": 201, "type": "markdown", "linesLength": 1, "startIndex": 867, "lines": ["You can always save your output using **np.savetxt()**.   "]}, {"block": 202, "type": "code", "linesLength": 1, "startIndex": 868, "lines": ["angles=pmag.angle(D1,D2) # assign the returned array to angles"]}, {"block": 203, "type": "markdown", "linesLength": 8, "startIndex": 869, "lines": ["### ani_depthplot\n", "\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-15600013) [\\[MagIC Database\\]](https://earthref.org/MagIC) [\\[command_line_version\\]](http://pmagpy.github.io/PmagPy-cli.html#ani_depthplot.py)\n", "\n", " Anisotropy data can be plotted versus depth. The program **ani_depthplot** uses MagIC formatted data tables. Bulk susceptibility measurements can also be plotted if they are available in a **measurements.txt** formatted file.\n", "\n", "In this example, we will use the data from Tauxe et al. (2015, doi:10.1016/j.epsl.2014.12.034) measured on samples obtained during Expedition 318 of the International Ocean Drilling Program. To get the entire dataset, go to the MagIC data base at: https://www2.earthref.org/MagIC/doi/10.1016/j.epsl.2014.12.034.  Download the data set and unpack it with [ipmag.download_magic](#download_magic).\n"]}, {"block": 204, "type": "markdown", "linesLength": 1, "startIndex": 877, "lines": ["We will use the **ipmag.ani_depthplot()** version of this program."]}, {"block": 205, "type": "code", "linesLength": 1, "startIndex": 878, "lines": ["help(ipmag.ani_depthplot)"]}, {"block": 206, "type": "markdown", "linesLength": 1, "startIndex": 879, "lines": ["And here we go:"]}, {"block": 207, "type": "code", "linesLength": 1, "startIndex": 880, "lines": ["ipmag.ani_depthplot(dir_path='data_files/ani_depthplot');"]}, {"block": 208, "type": "markdown", "linesLength": 9, "startIndex": 881, "lines": ["### aniso_magic\n", "\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-15600013) [\\[MagIC Database\\]](https://earthref.org/MagIC) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#aniso_magic.py)\n", "\n", " Samples were collected from the eastern margin a dike oriented with a bedding pole declination of 110\u2218 and dip of 2\u2218. The data have been imported into a MagIC (data model 3) formatted file named dike_specimens.txt.\n", "\n", "We will make a plot of the data using **ipmag.aniso_magic_nb()**, using the site parametric bootstrap option and plot out the bootstrapped eigenvectors. We will also draw on the trace of the dike.\n", "\n"]}, {"block": 209, "type": "code", "linesLength": 1, "startIndex": 890, "lines": ["help(ipmag.aniso_magic_nb)"]}, {"block": 210, "type": "code", "linesLength": 2, "startIndex": 891, "lines": ["ipmag.aniso_magic_nb(infile='dike_specimens.txt',dir_path='data_files/aniso_magic',\n", "       iboot=1,ihext=0,ivec=1,PDir=[120,10],ipar=1, save_plots=False) # compare dike directions with plane of dike with pole of 120,10"]}, {"block": 211, "type": "markdown", "linesLength": 5, "startIndex": 893, "lines": [" The specimen eigenvectors are plotted in the top diagram with the usual convention that squares are the V$_1$ directions, triangles are the V$_2$ directions and circles are the V$_3$ directions. All directions are plotted on the lower hemisphere. The bootstrapped eigenvectors are shown in the middle diagram. Cumulative distributions of the bootstrapped eigenvalues are shown in the bottom plot with the 95% confidence bounds plotted as vertical lines. It appears that the magma was moving in the northern and slightly up direction along the dike.\n", "\n", "There are more options to **ipmag.aniso_magic_nb()** that come in handy. In particular, one often wishes to test if a particular fabric is isotropic (the three eigenvalues cannot be distinguished), or if a particular eigenvector is parallel to some direction. For example, undisturbed sedimentary fabrics are oblate (the maximum and intermediate directions cannot be distinguished from one another, but are distinct from the minimum) and the eigenvector associated with the minimum eigenvalue is vertical. These criteria can be tested using the distributions of bootstrapped eigenvalues and eigenvectors.\n", "\n", "The following session illustrates how this is done, using the data in the test file sed_specimens.txt in the aniso_magic directory. "]}, {"block": 212, "type": "code", "linesLength": 2, "startIndex": 898, "lines": ["ipmag.aniso_magic_nb(infile='sed_specimens.txt',dir_path='data_files/aniso_magic',\n", "       iboot=1,ihext=0,ivec=1,Dir=[0,90],vec=3,ipar=1, save_plots=False) # parametric bootstrap and compare V3 with vertical"]}, {"block": 213, "type": "markdown", "linesLength": 1, "startIndex": 900, "lines": ["The top three plots are as in the dike example before, showing a clear triaxial fabric (all three eigenvalues and associated eigenvectors are distinct from one another. In the lower three plots we have the distributions of the three components of the chosen axis, V$_3$, their 95% confidence bounds (dash lines) and the components of the designated direction (solid line). This direction is also shown in the equal area projection above as a red pentagon. The minimum eigenvector is not vertical in this case. "]}, {"block": 214, "type": "markdown", "linesLength": 1, "startIndex": 901, "lines": ["NOTE TO SELF:  Add in 'by site' or 'by sample' as in dmag_magic.  "]}, {"block": 215, "type": "markdown", "linesLength": 8, "startIndex": 902, "lines": ["## apwp\n", "\n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html#x15-15600016)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#apwp.py)\n", "\n", "The program **apwp** calculates paleolatitude, declination, inclination from a pole latitude and longitude based on the paper Besse and Courtillot (2002; see [Essentials Chapter 16](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html#x15-15600016)   for complete discussion). Here we will  calculate the expected direction for 100 million year old rocks at a locality in La Jolla Cove (Latitude: 33$^{\\circ}$N, Longitude 117$^{\\circ}$W). Assume that we are on the North American Plate! (Note that there IS no option for the Pacific plate in the program **apwp**, and that La Jolla was on the North American plate until a few million years ago (6?). \n", "\n", "\n", "Within the notebook we will call **pmag.apwp**.\n"]}, {"block": 216, "type": "code", "linesLength": 1, "startIndex": 910, "lines": ["help(pmag.apwp)"]}, {"block": 217, "type": "code", "linesLength": 3, "startIndex": 911, "lines": ["# here are the desired plate, latitude, longitude and age:\n", "data=['NA',33,-117,100] # North American plate, lat and lon of San Diego at 100 Ma\n", "pmag.apwp(data,print_results=True)"]}, {"block": 218, "type": "markdown", "linesLength": 6, "startIndex": 914, "lines": ["## atrm_magic\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#atrm_magic.py)\n", "\n", "Anisotropy of thermal remanence (ATRM) is similar to anisotropy of anhysteretic remanence (AARM) and the procedure for obtaining the tensor is also similar. Therefore, the **atrm_magic** is quite similar to [aarm_magic](#aarm_magic). However, the SIO lab procedures for the two experiments are somewhat different. In the ATRM experiment, there is a single, zero field step at the chosen temperature which is used as a baseline. We use only six positions (as opposed to nine for AARM) because of the additional risk of alteration at each temperature step. The positions are also different:\n", "\n"]}, {"block": 219, "type": "code", "linesLength": 1, "startIndex": 920, "lines": ["Image('data_files/Figures/atrm_meas.png')"]}, {"block": 220, "type": "markdown", "linesLength": 6, "startIndex": 921, "lines": ["The file atrm_magic_example.dat in the data_files/atrm_magic directory is an SIO formatted data file containing ATRM measurement data done in a temperature of 520\u2218C. Note the special format of these files - the treatment column (column 2) has the temperature in centigrade followed by either a \u201c00\u201d for the obligatory zero field baseline step or a \u201c10\u201d for the first postion, and so on. These could also be \u20180\u2018 and \u20181\u2019, etc..\n", "\n", "Follow the instructions for  [sio_magic](#sio_magic) to import the ATRM data into the MagIC format. The DC field was 40 \u03bcT. The sample/site naming convention used option # 1 (see help menu) and the specimen and sample name are the same (specnum=0). \n", "\n", "We will use **ipmag.atrm_magic()** to calculate the best-fit tensor and write out the MagIC tables which can be used to correct remanence data  for the effects of remanent anisotropy.\n", "\n"]}, {"block": 221, "type": "code", "linesLength": 3, "startIndex": 927, "lines": ["convert.sio('atrm_magic_example.dat',dir_path='data_files/atrm_magic/',specnum=0,\n", "           location='unknown',codelist='T:ANI',samp_con='1',\n", "           meas_file='measurements.txt',labfield=40, phi=-1, theta=-1)"]}, {"block": 222, "type": "code", "linesLength": 1, "startIndex": 930, "lines": ["help(ipmag.atrm_magic)"]}, {"block": 223, "type": "code", "linesLength": 1, "startIndex": 931, "lines": ["ipmag.atrm_magic('measurements.txt',dir_path='data_files/atrm_magic')"]}, {"block": 224, "type": "markdown", "linesLength": 9, "startIndex": 932, "lines": ["### b_vdm\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560002)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#b_vdm.py)\n", "\n", "\n", "\n", "**b_vdm** converts geomagnetic field intensity observed at the earth's surface at a particular (paleo)latitude and calculates the Virtual \\[Axial\\] Dipole Moment (vdm or vadm).  We will call **pmag.b_vdm()** directly from within the notebook. \\[See also [**vdm_b**](#vdm_b).\\]\n", "\n", "Here we use the function  **pmag.b_vdm()** to convert an estimated paleofield value of 33 $\\mu$T obtained from a lava flow at 22$^{\\circ}$ N latitude to the equivalent Virtual Dipole Moment (VDM) in Am$^2$. "]}, {"block": 225, "type": "code", "linesLength": 1, "startIndex": 941, "lines": ["help(pmag.b_vdm)"]}, {"block": 226, "type": "code", "linesLength": 1, "startIndex": 942, "lines": ["print ('%7.1f'%(pmag.b_vdm(33e-6,22)*1e-21),' ZAm^2')"]}, {"block": 227, "type": "code", "linesLength": 1, "startIndex": 943, "lines": ["pmag.b_vdm(33e-6,22)*1e-21"]}, {"block": 228, "type": "markdown", "linesLength": 9, "startIndex": 944, "lines": ["### biplot_magic \n", "\n", "[\\[Essentials Chapter 8\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch8.html#x15-1560008) [\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#biplot_magic.py)\n", "\n", "It is often useful to plot measurements from one experiement against another. For example, rock magnetic studies of sediments often plot the IRM against the ARM or magnetic susceptibility. All of these types of measurements can be imported into a single measurements formatted file and use the MagIC method codes and other clues (lab fields, etc.) to differentiate one measurement from another. \n", "\n", "Data were obtained by Hartl and Tauxe (1997, doi: 10.1111/j.1365-246X.1997.tb04082.x) from a Paleogene core from 28$^{\\circ}$ S (DSDP Site 522) and used for a relative paleointensity study. IRM, ARM, magnetic susceptibility and remanence data were uploaded to the MagIC database. The MagIC measurements formatted file for this study (which you can get from   https://earthref.org/MagIC/doi/10.1111/j.1365-246X.1997.tb04082.x and unpack with [download_magic](#download_magic)  is saved in data_files/biplot_magic/measurements.txt. \n", "\n", "We can create these plots using Pandas.  The key to what the measurements mean is in the [Magic method codes](https://www2.earthref.org/MagIC/method-codes), so we can first get a unique list of all the available method_codes, then plot the ones we are interested in  against each other.  Let's read in the data file in to a **Pandas** DataFrame and exctract the method codes to see what we have: "]}, {"block": 229, "type": "code", "linesLength": 6, "startIndex": 953, "lines": ["# read in the data\n", "meas_df=pd.read_csv('data_files/biplot_magic/measurements.txt',sep='\\t',header=1)\n", "# get the method_codes and print\n", "print(meas_df.method_codes.unique())\n", "# take a look at the top part of the measurements data frame\n", "meas_df.head()"]}, {"block": 230, "type": "markdown", "linesLength": 1, "startIndex": 959, "lines": ["These are: an AF demag step (LT-AF-Z), an ARM (LT-AF-I), an IRM  (LT-IRM) and a susceptibility (LP-X).  Now we can fish out data for each method, merge them by specimen, dropping any missing measurements and finally plot one against the other.  "]}, {"block": 231, "type": "code", "linesLength": 16, "startIndex": 960, "lines": ["# get the IRM data\n", "IRM=meas_df[meas_df.method_codes.str.contains('LT-IRM')]\n", "IRM=IRM[['specimen','magn_mass']] #trim the data frame\n", "IRM.columns=['specimen','IRM'] # rename the column\n", "# do the same for the ARM data\n", "ARM=meas_df[meas_df.method_codes.str.contains('LT-AF-I')]\n", "ARM=ARM[['specimen','magn_mass']]\n", "ARM.columns=['specimen','ARM']\n", "# and the magnetic susceptibility\n", "CHI=meas_df[meas_df.method_codes.str.contains('LP-X')]\n", "CHI=CHI[['specimen','susc_chi_mass']]  \n", "CHI.columns=['specimen','CHI']\n", "# merge IRM ARM data by specimen\n", "RMRMs=pd.merge(IRM,ARM,on='specimen')\n", "# add on the susceptility data\n", "RMRMs=pd.merge(RMRMs,CHI,on='specimen')"]}, {"block": 232, "type": "markdown", "linesLength": 1, "startIndex": 976, "lines": ["Now we are ready to make the plots.  "]}, {"block": 233, "type": "code", "linesLength": 13, "startIndex": 977, "lines": ["fig=plt.figure(1, (12,4)) # make a figure\n", "fig.add_subplot(131) # make the first in a row of three subplots \n", "plt.plot(RMRMs.IRM,RMRMs.ARM,'ro',markeredgecolor='black')\n", "plt.xlabel('IRM (Am$^2$/kg)') # label the X axis\n", "plt.ylabel('ARM (Am$^2$/kg)') # and the Y axis\n", "fig.add_subplot(132)# make the second in a row of three subplots \n", "plt.plot(RMRMs.IRM,RMRMs.CHI,'ro',markeredgecolor='black')\n", "plt.xlabel('IRM (Am$^2$/kg)')\n", "plt.ylabel('$\\chi$ (m$^3$/kg)')\n", "fig.add_subplot(133)# and the third in a row of three subplots \n", "plt.plot(RMRMs.ARM,RMRMs.CHI,'ro',markeredgecolor='black')\n", "plt.xlabel('$\\chi$ (m$^3$/kg)')\n", "plt.ylabel('IRM (Am$^2$/kg)');"]}, {"block": 234, "type": "markdown", "linesLength": 16, "startIndex": 990, "lines": ["### bootams\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-15600013)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#bootams.py)\n", "\n", " **bootams** calculates bootstrap statistics for anisotropy tensor data in the form of:\n", "\n", "x11 x22 x33 x12 x23 x13\n", "\n", "It does this by selecting para-data sets and calculating the Hext average eigenparameters. It has an optional parametric bootstrap whereby the $\\sigma$ for the data set as a whole is used to draw new para data sets. The bootstrapped eigenparameters are assumed to be Kent distributed and the program calculates Kent error ellipses for each set of eigenvectors. It also estimates the standard deviations of the bootstrapped eigenvalues.\n", "\n", "**bootams**   reads in a file with data for the six tensor elements (x11 x22 x33 x12 x23 x13) for specimens, calls **pmag.s_boot()**  using a parametric or non-parametric bootstrap as desired. If all that is desired is the bootstrapped eigenparameters, **pmag.s_boot()** has all we need, but if the Kent ellipses are required, and we can call **pmag.sbootpars()** to calculated these more derived products and  print them out.\n", "\n", "Note that every time the bootstrap program gets called, the output will be slightly different because this depends on calls to random number generators. If the answers are different by a lot, then the number of bootstrap calculations is too low. The number of bootstraps can be changed with the nb option below. \n", "\n", "\n", "We can do all this from within the notebook as follows: "]}, {"block": 235, "type": "code", "linesLength": 1, "startIndex": 1006, "lines": ["help(pmag.s_boot)"]}, {"block": 236, "type": "markdown", "linesLength": 4, "startIndex": 1007, "lines": ["So we will:\n", "- read in the AMS tensor data\n", "- get the bootstrapped eigenparameters\n", "- print out the formatted results"]}, {"block": 237, "type": "code", "linesLength": 20, "startIndex": 1011, "lines": ["Ss=np.loadtxt('data_files/bootams/bootams_example.dat')\n", "Tmean,Vmean,Taus,Vs=pmag.s_boot(Ss) # get the bootstrapped eigenparameters\n", "bpars=pmag.sbootpars(Taus,Vs) # calculate kent parameters for bootstrap\n", "print(\"\"\"tau tau_sigma V_dec V_inc V_eta V_eta_dec V_eta_inc V_zeta V_zeta_dec V_zeta_inc\n", "\"\"\")\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[0],bpars[\"t1_sigma\"],Vmean[0][0],Vmean[0][1],\\\n", "          bpars[\"v1_zeta\"],bpars[\"v1_zeta_dec\"],bpars[\"v1_zeta_inc\"],\\\n", "          bpars[\"v1_eta\"],bpars[\"v1_eta_dec\"],bpars[\"v1_eta_inc\"])\n", "print(outstring)\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[1],bpars[\"t2_sigma\"],Vmean[1][0],Vmean[1][1],\\\n", "          bpars[\"v2_zeta\"],bpars[\"v2_zeta_dec\"],bpars[\"v2_zeta_inc\"],\\\n", "          bpars[\"v2_eta\"],bpars[\"v2_eta_dec\"],bpars[\"v2_eta_inc\"])\n", "print(outstring)\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[2],bpars[\"t3_sigma\"],Vmean[2][0],Vmean[2][1],\\\n", "          bpars[\"v3_zeta\"],bpars[\"v3_zeta_dec\"],bpars[\"v3_zeta_inc\"],\\\n", "          bpars[\"v3_eta\"],bpars[\"v3_eta_dec\"],bpars[\"v3_eta_inc\"])\n", "print(outstring)"]}, {"block": 238, "type": "code", "linesLength": 21, "startIndex": 1031, "lines": ["# with parametric bootstrap: \n", "Ss=np.loadtxt('data_files/bootams/bootams_example.dat')\n", "Tmean,Vmean,Taus,Vs=pmag.s_boot(Ss,ipar=1,nb=5000) # get the bootstrapped eigenparameters\n", "bpars=pmag.sbootpars(Taus,Vs) # calculate kent parameters for bootstrap\n", "print(\"\"\"tau tau_sigma V_dec V_inc V_eta V_eta_dec V_eta_inc V_zeta V_zeta_dec V_zeta_inc\n", "\"\"\")\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[0],bpars[\"t1_sigma\"],Vmean[0][0],Vmean[0][1],\\\n", "          bpars[\"v1_zeta\"],bpars[\"v1_zeta_dec\"],bpars[\"v1_zeta_inc\"],\\\n", "          bpars[\"v1_eta\"],bpars[\"v1_eta_dec\"],bpars[\"v1_eta_inc\"])\n", "print(outstring)\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[1],bpars[\"t2_sigma\"],Vmean[1][0],Vmean[1][1],\\\n", "          bpars[\"v2_zeta\"],bpars[\"v2_zeta_dec\"],bpars[\"v2_zeta_inc\"],\\\n", "          bpars[\"v2_eta\"],bpars[\"v2_eta_dec\"],bpars[\"v2_eta_inc\"])\n", "print(outstring)\n", "outstring='%7.5f %7.5f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f'%(\\\n", "          Tmean[2],bpars[\"t3_sigma\"],Vmean[2][0],Vmean[2][1],\\\n", "          bpars[\"v3_zeta\"],bpars[\"v3_zeta_dec\"],bpars[\"v3_zeta_inc\"],\\\n", "          bpars[\"v3_eta\"],bpars[\"v3_eta_dec\"],bpars[\"v3_eta_inc\"])\n", "print(outstring)"]}, {"block": 239, "type": "markdown", "linesLength": 5, "startIndex": 1052, "lines": ["### cart_dir\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560002)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#cart_dir.py)\n", "\n", "**cart_dir** converts cartesian coordinates (X,Y,Z) to polar coordinates (Declination, Inclination, Intensity).  We will call **pmag.cart2dir()**."]}, {"block": 240, "type": "code", "linesLength": 1, "startIndex": 1057, "lines": ["help(pmag.cart2dir)"]}, {"block": 241, "type": "code", "linesLength": 8, "startIndex": 1058, "lines": ["# read in data file from example file\n", "cart=np.loadtxt('data_files/cart_dir/cart_dir_example.dat')\n", "print ('Input: \\n',cart) # print out the cartesian coordinates\n", "# print out the  results\n", "dirs = pmag.cart2dir(cart)\n", "print (\"Output: \")\n", "for d in dirs:\n", "    print ('%7.1f %7.1f %8.3e'%(d[0],d[1],d[2]))"]}, {"block": 242, "type": "markdown", "linesLength": 9, "startIndex": 1066, "lines": ["### chi_magic\n", "\n", "\n", "[\\[Essentials Chapter 8\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch8.html#x15-1560008) [\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#chi_magic.py)\n", "\n", " It is sometimes useful to measure susceptibility as a function of temperature, applied field and frequency. Here we use a data set that came from the Tiva Canyon Tuff sequence (see Jackson et al., 2006, doi: 10.1029/2006JB004514). \n", "\n", "\n", "**chi_magic** reads in a MagIC formatted file and makes various plots.  We do this using Pandas.\n"]}, {"block": 243, "type": "code", "linesLength": 2, "startIndex": 1075, "lines": ["# with ipmag\n", "ipmag.chi_magic('data_files/chi_magic/measurements.txt', save_plots=False)"]}, {"block": 244, "type": "code", "linesLength": 7, "startIndex": 1077, "lines": ["# read in data from data model 3 example file using pandas\n", "chi_data=pd.read_csv('data_files/chi_magic/measurements.txt',sep='\\t',header=1)\n", "print (chi_data.columns)\n", "# get arrays of available temps, frequencies and fields\n", "Ts=np.sort(chi_data.meas_temp.unique())\n", "Fs=np.sort(chi_data.meas_freq.unique())\n", "Bs=np.sort(chi_data.meas_field_ac.unique())\n"]}, {"block": 245, "type": "code", "linesLength": 10, "startIndex": 1084, "lines": ["# plot chi versus temperature at constant field\n", "b=Bs.max()\n", "for f in Fs:\n", "    this_f=chi_data[chi_data.meas_freq==f]\n", "    this_f=this_f[this_f.meas_field_ac==b]\n", "    plt.plot(this_f.meas_temp,1e6*this_f.susc_chi_volume,label='%i'%(f)+' Hz')\n", "plt.legend()\n", "plt.xlabel('Temperature (K)')\n", "plt.ylabel('$\\chi$ ($\\mu$SI)')\n", "plt.title('B = '+'%7.2e'%(b)+ ' T')"]}, {"block": 246, "type": "code", "linesLength": 10, "startIndex": 1094, "lines": ["# plot chi versus frequency at constant B\n", "b=Bs.max()\n", "t=Ts.min()\n", "this_t=chi_data[chi_data.meas_temp==t]\n", "this_t=this_t[this_t.meas_field_ac==b]\n", "plt.semilogx(this_t.meas_freq,1e6*this_t.susc_chi_volume,label='%i'%(t)+' K')\n", "plt.legend()\n", "plt.xlabel('Frequency (Hz)')\n", "plt.ylabel('$\\chi$ ($\\mu$SI)')\n", "plt.title('B = '+'%7.2e'%(b)+ ' T')"]}, {"block": 247, "type": "markdown", "linesLength": 1, "startIndex": 1104, "lines": [" You can see the dependence on temperature, frequency and applied field. These data support the suggestion that there is a strong superparamagnetic component in these specimens.\n"]}, {"block": 248, "type": "markdown", "linesLength": 10, "startIndex": 1105, "lines": ["### common_mean\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html#x15-15600012)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#common_mean.py)\n", "\n", " Most paleomagnetists use some form of Fisher Statistics to decide if two directions are statistically distinct or not (see [Essentials Chapter 11](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html#x15-15600011) for a discussion of those techniques. But often directional data are not Fisher distributed and the parametric approach will give misleading answers. In these cases, one can use a boostrap approach, described in detail in [Essentials Chapter 12]. The program **common_mean** can be used for a bootstrap test for common mean to check whether two declination, inclination data sets have a common mean at the 95% level of confidence. \n", " \n", " We want to compare the two data sets: common_mean_ex_file1.dat and common_mean_ex_file2.dat. But first, let\u2019s look at the data in equal area projection using the methods outline in the section on [eqarea](#eqarea).\n", "\n", "\n", "\n"]}, {"block": 249, "type": "code", "linesLength": 5, "startIndex": 1115, "lines": ["directions_A=np.loadtxt('data_files/common_mean/common_mean_ex_file1.dat')\n", "directions_B=np.loadtxt('data_files/common_mean/common_mean_ex_file2.dat') \n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=directions_A,color='red')\n", "ipmag.plot_di(di_block=directions_B,color='blue')\n"]}, {"block": 250, "type": "markdown", "linesLength": 1, "startIndex": 1120, "lines": ["Now let\u2019s look at the common mean problem using **ipmag.common_mean_bootstrap()**."]}, {"block": 251, "type": "code", "linesLength": 1, "startIndex": 1121, "lines": ["help(ipmag.common_mean_bootstrap)"]}, {"block": 252, "type": "code", "linesLength": 1, "startIndex": 1122, "lines": ["ipmag.common_mean_bootstrap(directions_A,directions_B,figsize=(9,3))"]}, {"block": 253, "type": "markdown", "linesLength": 6, "startIndex": 1123, "lines": [" These suggest that the two data sets share a common mean.\n", "\n", "Now compare the data in common_mean_ex_file1.dat with the expected direction at the 5$^{\\circ}$ N latitude that these data were collected (Dec=0, Inc=9.9).\n", "\n", "To do this, we set the second data set to be the desired direction for comparison. \n", "\n"]}, {"block": 254, "type": "code", "linesLength": 2, "startIndex": 1129, "lines": ["comp_dir=[0,9.9]\n", "ipmag.common_mean_bootstrap(directions_A,comp_dir,figsize=(9,3))"]}, {"block": 255, "type": "markdown", "linesLength": 1, "startIndex": 1131, "lines": ["Apparently the data (cumulative distribution functions) are entirely consistent with the expected direction (dashed lines are the cartesian coordinates of that). "]}, {"block": 256, "type": "markdown", "linesLength": 8, "startIndex": 1132, "lines": ["### cont_rot \n", "\n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html#x15-15600016)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#cont_rot.py)\n", "\n", "We can  make an orthographic projection with latitude = -20$^{\\circ}$ and longitude = 0$^{\\circ}$ at the center of the African and South American continents reconstructed to 180 Ma using the Torsvik et al. (2008, doi: 10.1029/2007RG000227) poles of finite rotation. We would do this by first holding Africa fixed. \n", "\n", "We need to read in in the outlines of continents from **continents.get_cont()**, rotate them around a rotation pole and angle as specified by the age  and continent in question (from **frp.get_pole()** using **pmag.pt_rot()**.  Then we can plot them using **pmagplotlib.plot_map()**.  If the Basemap version is preferred, use **pmagplotlib.plot_map_basemap()**. \n", "Here we demonstrate this from within  the notebook by just calling the  PmagPy  functions.  "]}, {"block": 257, "type": "code", "linesLength": 4, "startIndex": 1140, "lines": ["# load in the continents module\n", "import pmagpy.continents as continents\n", "import pmagpy.frp as frp\n", "help(continents.get_continent)"]}, {"block": 258, "type": "code", "linesLength": 1, "startIndex": 1144, "lines": ["help(pmagplotlib.plot_map)"]}, {"block": 259, "type": "code", "linesLength": 20, "startIndex": 1145, "lines": ["# retrieve continental outline\n", "# This is the version that uses cartopy and requires installation of cartopy\n", "af=continents.get_continent('af').transpose()\n", "sam=continents.get_continent('sam').transpose()\n", "\n", "\n", "#define options for pmagplotlib.plot_map\n", "plt.figure(1,(5,5))\n", "Opts = {'latmin': -90, 'latmax': 90, 'lonmin': 0., 'lonmax': 360., 'lat_0': -20, \\\n", "            'lon_0': 345,'proj': 'ortho', 'sym': 'r-', 'symsize': 3,\\\n", "            'pltgrid': 0, 'res': 'c', 'boundinglat': 0.}\n", "if has_cartopy:\n", "    pmagplotlib.plot_map(1,af[0],af[1],Opts)\n", "    Opts['sym']='b-'\n", "    pmagplotlib.plot_map(1,sam[0],sam[1],Opts)\n", "elif has_basemap:\n", "    pmagplotlib.plot_map_basemap(1,af[0],af[1],Opts)\n", "    Opts['sym']='b-'\n", "    pmagplotlib.plot_map_basemap(1,sam[0],sam[1],Opts)\n", "    "]}, {"block": 260, "type": "markdown", "linesLength": 1, "startIndex": 1165, "lines": ["Now for the rotation part.  These are in a function called **frp.get_pole()**"]}, {"block": 261, "type": "code", "linesLength": 1, "startIndex": 1166, "lines": ["help(frp.get_pole)"]}, {"block": 262, "type": "code", "linesLength": 4, "startIndex": 1167, "lines": ["# get the rotation pole for south america relative to South Africa at 180 Ma\n", "sam_pole=frp.get_pole('sam',180)\n", "# NB: for african rotations, first rotate other continents to fixed Africa, then \n", "# rotate with South African pole (saf)\n"]}, {"block": 263, "type": "markdown", "linesLength": 1, "startIndex": 1171, "lines": ["The rotation is done by **pmag.pt_rot()**."]}, {"block": 264, "type": "code", "linesLength": 1, "startIndex": 1172, "lines": ["help(pmag.pt_rot)"]}, {"block": 265, "type": "markdown", "linesLength": 1, "startIndex": 1173, "lines": ["so here we go...  "]}, {"block": 266, "type": "code", "linesLength": 12, "startIndex": 1174, "lines": ["plt.figure(1,(5,5))\n", "sam_rot=pmag.pt_rot(sam_pole,sam[0],sam[1]) # same for south america\n", "# and plot 'em\n", "Opts['sym']='r-'\n", "if has_cartopy:\n", "    pmagplotlib.plot_map(1,af[0],af[1],Opts)\n", "    Opts['sym']='b-'\n", "    pmagplotlib.plot_map(1,sam_rot[0],sam_rot[1],Opts)\n", "elif has_basemap:\n", "    pmagplotlib.plot_map_basemap(1,af[0],af[1],Opts)\n", "    Opts['sym']='b-'\n", "    pmagplotlib.plot_map_basemap(1,sam_rot[0],sam_rot[1],Opts)"]}, {"block": 267, "type": "markdown", "linesLength": 12, "startIndex": 1186, "lines": ["### core_depthplot\n", "\n", "[\\[Essentials Chapter 15\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch15.html#x15-15600015)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#core_depthplot.py)\n", "\n", "The program **core_depthplot** can be used to plot various measurement data versus sample depth. The data must be in the MagIC data format. The program will plot whole core data, discrete sample at a bulk demagnetization step, data from vector demagnetization experiments, and so on. \n", "\n", "We can try this out on some data from DSDP Hole 522, (drilled at 26S/5W) and measured by Tauxe and Hartl (1997, doi: 10.1111/j.1365-246X.1997.tb04082.x). These were  downloaded and unpacked in the [biplot_magic](#biplot_magic) example. More of the data are in the directory ../data_files/core_depthplot. \n", "\n", " In this example, we will plot the alternating field (AF) data after the 15 mT step. The magnetizations will be plotted on a log scale and, as this is a record of the Oligocene, we will plot the Oligocene time scale, using the calibration of Gradstein et al. (2012), commonly referred to as \u201cGTS12\u201d for the the Oligocene. We are only interested in the data between 50 and 150 meters  and we are not interested in the declinations here. \n", "\n", "\n", "All this can be done using the wonders of Pandas data frames using the  data in the **data_files/core_depthplot** directory.   \n"]}, {"block": 268, "type": "markdown", "linesLength": 10, "startIndex": 1198, "lines": ["Let's do things this way:\n", "- read in the data from the sites and specimens files.\n", "- Drop the records with NaN for analysts, keeping one of the three lines available for each specimen. \n", "- Make a new column named **site** in the specdimens table that is the same as the **specimen** column.\n", "- (this makes sense because these are core data, so the specimen=sample=site. )\n", "- Merge the two DataFrames on the **site** column.\n", "- filter the data for depths between 50 and 150.\n", "- Plot **dir_inc** versus **core_depth**.  \n", "- Put on GAD field inclination\n", "- plot the time scale"]}, {"block": 269, "type": "code", "linesLength": 8, "startIndex": 1208, "lines": ["specimens=pd.read_csv('data_files/core_depthplot/specimens.txt',sep='\\t',header=1)\n", "sites=pd.read_csv('data_files/core_depthplot/sites.txt',sep='\\t',header=1)\n", "specimens=specimens.dropna(subset=['dir_inc']) # kill unwanted lines with duplicate or irrelevent info\n", "specimens['site']=specimens['specimen'] # make a column with site name\n", "data=pd.merge(specimens,sites,on='site') # merge the two data frames on site\n", "data=data[data.core_depth>50] # all levels > 50\n", "data=data[data.core_depth<150] # and < 150\n", "lat=26 # we need this for the GAD INC\n"]}, {"block": 270, "type": "markdown", "linesLength": 1, "startIndex": 1216, "lines": ["Plot versus core_depth"]}, {"block": 271, "type": "code", "linesLength": 16, "startIndex": 1217, "lines": ["fig=plt.figure(1,(6,12)) # make the figure\n", "ax=fig.add_subplot(121) # make the first of 2 subplots\n", "plt.ylabel('Depth (m)') # label the Y axis\n", "plt.plot(data.dir_inc,data.core_depth,'k-') # draw on a black line through the data\n", "# draw the data points as cyan dots with black edges\n", "plt.plot(data.dir_inc,data.core_depth,'co',markeredgecolor='black')\n", "plt.title('Inclinations') # put on a title\n", "plt.axvline(0,color='black')# make a central line at inc=0\n", "plt.ylim(150,50) # set the plot Y limits to the desired depths\n", "fig.add_subplot(122) # make the second of two subplots\n", "# plot intensity data on semi-log plot\n", "plt.semilogx(data.int_rel/data.int_rel.mean(),data.core_depth,'k-')\n", "plt.semilogx(data.int_rel/data.int_rel.mean(),\\\n", "             data.core_depth,'co',markeredgecolor='black')\n", "plt.ylim(150,50)\n", "plt.title('Relative Intensity');\n"]}, {"block": 272, "type": "markdown", "linesLength": 1, "startIndex": 1233, "lines": ["And now versus age:"]}, {"block": 273, "type": "code", "linesLength": 20, "startIndex": 1234, "lines": ["fig=plt.figure(1,(9,12)) # make the figure\n", "ax=fig.add_subplot(131) # make the first of three subplots\n", "pmagplotlib.plot_ts(ax,23,34,timescale='gts12') # plot on the time scale\n", "fig.add_subplot(132) # make the second of three subplots\n", "plt.plot(data.dir_inc,data.core_depth,'k-')\n", "plt.plot(data.dir_inc,data.core_depth,'co',markeredgecolor='black')\n", "plt.ylim(35,23)\n", "# calculate the geocentric axial dipole field for the site latitude\n", "gad=np.degrees(np.arctan(2.*np.tan(np.radians(lat)))) # tan (I) = 2 tan (lat)\n", "# put it on the plot as a green dashed line\n", "plt.axvline(gad,color='green',linestyle='dashed',linewidth=2)\n", "plt.axvline(-gad,color='green',linestyle='dashed',linewidth=2)\n", "plt.title('Inclinations')\n", "plt.ylim(150,50)\n", "fig.add_subplot(133) # make the third of three plots\n", "# plot the intensity data on semi-log plot\n", "plt.semilogx(data.int_rel/data.int_rel.mean(),data.core_depth,'k-')\n", "plt.semilogx(data.int_rel/data.int_rel.mean(),data.core_depth,'co',markeredgecolor='black')\n", "plt.ylim(150,50)\n", "plt.title('Relative Intensity');\n"]}, {"block": 274, "type": "markdown", "linesLength": 6, "startIndex": 1254, "lines": ["### curie \n", "\n", "[\\[Essentials Chapter 6\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch6.html#x15-1560006)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#curie.py)\n", "\n", "\n", "Curie Temperature experiments, saved in MagIC formatted files, can be plotted using **ipmag.curie()**."]}, {"block": 275, "type": "code", "linesLength": 1, "startIndex": 1260, "lines": ["help(ipmag.curie)"]}, {"block": 276, "type": "code", "linesLength": 2, "startIndex": 1261, "lines": ["ipmag.curie(path_to_file='data_files/curie',file_name='curie_example.dat',\\\n", "           window_length=10)"]}, {"block": 277, "type": "markdown", "linesLength": 6, "startIndex": 1263, "lines": ["### dayplot_magic\n", "\n", "[\\[Essentials Chapter 5\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch5.html#x15-1560005)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#dayplot_magic.py)\n", "\n", "The program **dayplot_magic**   makes Day (Day et al., 1977), or Squareness-Coercivity and Squareness-Coercivity of Remanence plots (e.g., Tauxe et al., 2002) from the MagIC formatted data.\n", "To do this, we will call **ipmag.dayplot()**."]}, {"block": 278, "type": "code", "linesLength": 1, "startIndex": 1269, "lines": ["help(ipmag.dayplot)"]}, {"block": 279, "type": "code", "linesLength": 1, "startIndex": 1270, "lines": ["ipmag.dayplot(path_to_file='data_files/dayplot_magic',hyst_file='specimens.txt')"]}, {"block": 280, "type": "markdown", "linesLength": 8, "startIndex": 1271, "lines": ["### di_eq\n", "\n", "[\\[Essentials Appendix B\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap2.html#equal_area) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#di_eq.py)\n", "\n", "Paleomagnetic data are frequently plotted in equal area projection. PmagPy has several plotting options which do this (e.g., [**eqarea**](#eqarea), but occasionally it is handy to be able to convert the directions to X,Y coordinates directly, without plotting them at all.  Here is an example transcript of a session using the datafile di_eq_example.dat: \n", "\n", "The program **di_eq**  program calls **pmag.dimap()** which we can do from within a Jupyter notebook."]}, {"block": 281, "type": "code", "linesLength": 1, "startIndex": 1279, "lines": ["help(pmag.dimap)"]}, {"block": 282, "type": "code", "linesLength": 2, "startIndex": 1280, "lines": ["DIs=np.loadtxt('data_files/di_eq/di_eq_example.dat').transpose() # load in the data\n", "print (pmag.dimap(DIs[0],DIs[1])) # call the function"]}, {"block": 283, "type": "markdown", "linesLength": 9, "startIndex": 1282, "lines": ["### di_geo\n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html) \n", "and [Changing coordinate systems](http://earthref.org/MAGIC/books/Tauxe/Essentials/WebBook3ap1.html#Changing_coordinate_systems)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#di_geo.py)\n", "\n", "Here we will   convert D = 8.1,I = 45.2 from specimen coordinates to geographic adjusted coordinates. The orientation of laboratory arrow on the specimen was: azimuth = 347; plunge = 27. To do this we will call **pmag.dogeo()**. There is also **pmag.dogeo_V** for arrays of data. \n", "\n", "So let's start with **pmag.dogeo()**."]}, {"block": 284, "type": "code", "linesLength": 1, "startIndex": 1291, "lines": ["help(pmag.dogeo)"]}, {"block": 285, "type": "code", "linesLength": 1, "startIndex": 1292, "lines": ["pmag.dogeo(dec=81,inc=45.2,az=347,pl=27)"]}, {"block": 286, "type": "markdown", "linesLength": 1, "startIndex": 1293, "lines": ["Now let's check out the version that takes many data points at once. "]}, {"block": 287, "type": "code", "linesLength": 1, "startIndex": 1294, "lines": ["help(pmag.dogeo_V)"]}, {"block": 288, "type": "code", "linesLength": 2, "startIndex": 1295, "lines": ["indata=np.loadtxt('data_files/di_geo/di_geo_example.dat')\n", "print (indata)"]}, {"block": 289, "type": "markdown", "linesLength": 1, "startIndex": 1297, "lines": ["Let's take a look at these data in equal area projection: (see [eqarea](#eqarea) for details)"]}, {"block": 290, "type": "code", "linesLength": 2, "startIndex": 1298, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(dec=indata.transpose()[0],inc=indata.transpose()[1],color='red',edge='black')"]}, {"block": 291, "type": "markdown", "linesLength": 1, "startIndex": 1300, "lines": ["The data are highly scattered and we hope that the geographic coordinate system looks better! To find out try: "]}, {"block": 292, "type": "code", "linesLength": 3, "startIndex": 1301, "lines": ["decs,incs=pmag.dogeo_V(indata)\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(dec=decs,inc=incs,color='red',edge='black')"]}, {"block": 293, "type": "markdown", "linesLength": 3, "startIndex": 1304, "lines": ["These data are clearly much better grouped. \n", "\n", "And here they are printed out."]}, {"block": 294, "type": "code", "linesLength": 1, "startIndex": 1307, "lines": ["print (np.column_stack([decs,incs]))"]}, {"block": 295, "type": "markdown", "linesLength": 7, "startIndex": 1308, "lines": ["### di_rot \n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#di_rot.py)\n", "\n", "\n", "**di_rot**   rotates dec inc pairs to a new origin.  We can call **pmag.dodirot()** for single [dec,inc,Dbar,Ibar] data or **pmag.dodirot_V()** for an array of Dec, Inc pairs.  We can use the data from the [di_geo](#di_geo) example and rotate the geographic coordinate data such that the center of the distribution is the principal direction.   "]}, {"block": 296, "type": "markdown", "linesLength": 6, "startIndex": 1315, "lines": ["We do it like this: \n", "- read in a data set with dec inc pairs\n", "- make an equal area projection of the data to remind us what they look like\n", "- calculate the principal component with **pmag.doprinc())**\n", "- rotate the data to the principal direction\n", "- plot the rotated data in an equal area projection. "]}, {"block": 297, "type": "code", "linesLength": 3, "startIndex": 1321, "lines": ["di_block=np.loadtxt('data_files/di_rot/di_rot_example.txt') # read in some data\n", "ipmag.plot_net(1) # make the plot\n", "ipmag.plot_di(di_block=di_block,title='geographic',color='red',edge='black')"]}, {"block": 298, "type": "markdown", "linesLength": 1, "startIndex": 1324, "lines": ["Now we calculate the principal direction using the method described inthe [goprinc](#goprinc) section."]}, {"block": 299, "type": "code", "linesLength": 1, "startIndex": 1325, "lines": ["princ=pmag.doprinc(di_block)"]}, {"block": 300, "type": "markdown", "linesLength": 1, "startIndex": 1326, "lines": ["And note we use **pmag.dodirot_V** to do the rotation.  "]}, {"block": 301, "type": "code", "linesLength": 1, "startIndex": 1327, "lines": ["help(pmag.dodirot_V)"]}, {"block": 302, "type": "code", "linesLength": 2, "startIndex": 1328, "lines": ["rot_block=pmag.dodirot_V(di_block,princ['dec'],princ['inc'])\n", "rot_block"]}, {"block": 303, "type": "markdown", "linesLength": 1, "startIndex": 1330, "lines": ["And of course look at what we have done!"]}, {"block": 304, "type": "code", "linesLength": 2, "startIndex": 1331, "lines": ["ipmag.plot_net(1) # make the plot\n", "ipmag.plot_di(di_block=rot_block,color='red',title='rotated',edge='black')"]}, {"block": 305, "type": "markdown", "linesLength": 8, "startIndex": 1333, "lines": ["### di_tilt\n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html) [\\[Changing coordinate systems\\]](http://earthref.org/MAGIC/books/Tauxe/Essentials/WebBook3ap1.html#Changing_coordinate_systems)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#di_tilt.py)\n", "\n", "**di_tilt** can rotate a direction of Declination = 5.3 and Inclination = 71.6 to \u201cstratigraphic\u201d coordinates, assuming the  strike was 135 and the dip was 21. The convention in this program is to use the dip direction, which is to the \u201cright\u201d of this strike. \n", "\n", "We can perform this calculation by calling  **pmag.dotilt** or **pmag.dotilt_V()** depending on if we have a single point or an array to rotate."]}, {"block": 306, "type": "code", "linesLength": 1, "startIndex": 1341, "lines": ["help(pmag.dotilt)"]}, {"block": 307, "type": "code", "linesLength": 1, "startIndex": 1342, "lines": ["help(pmag.dotilt_V)"]}, {"block": 308, "type": "code", "linesLength": 5, "startIndex": 1343, "lines": ["# read in some data\n", "data=np.loadtxt('data_files/di_tilt/di_tilt_example.dat') # load up the data\n", "di_block=data[:,[0,1]] # let's look at the data first! \n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block)"]}, {"block": 309, "type": "markdown", "linesLength": 1, "startIndex": 1348, "lines": ["Now we can rotate them"]}, {"block": 310, "type": "code", "linesLength": 3, "startIndex": 1349, "lines": ["Dt,It=pmag.dotilt_V(data) # rotate them\n", "ipmag.plot_net(1) # and take another look\n", "ipmag.plot_di(dec=Dt,inc=It)"]}, {"block": 311, "type": "markdown", "linesLength": 1, "startIndex": 1352, "lines": ["Use the handy function **np.column_stack** to pair the decs and incs together"]}, {"block": 312, "type": "code", "linesLength": 1, "startIndex": 1353, "lines": ["np.column_stack((Dt,It)) # if you want to see the output: "]}, {"block": 313, "type": "markdown", "linesLength": 8, "startIndex": 1354, "lines": ["### di_vgp\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#di_vgp.py)\n", "\n", "\n", "**di_vgp** converts directions (declination,inclination) to Virtual Geomagnetic Pole positions.   This is the inverse of [**vgp_di**](#vgp_di). \n", "To do so, we will call **pmag.dia_vgp()** from within the notebook."]}, {"block": 314, "type": "code", "linesLength": 1, "startIndex": 1362, "lines": ["help(pmag.dia_vgp)"]}, {"block": 315, "type": "code", "linesLength": 2, "startIndex": 1363, "lines": ["data=np.loadtxt('data_files/di_vgp/di_vgp_example.dat') # read in some data\n", "print (data)"]}, {"block": 316, "type": "markdown", "linesLength": 1, "startIndex": 1365, "lines": ["The data are almost in the correct format, but there is no a95 field, so that will have to be inserted (as zeros). "]}, {"block": 317, "type": "code", "linesLength": 2, "startIndex": 1366, "lines": ["a95=np.zeros(len(data))\n", "a95"]}, {"block": 318, "type": "code", "linesLength": 4, "startIndex": 1368, "lines": ["DIs=data.transpose()[0:2].transpose() # get the DIs\n", "LatLons=data.transpose()[2:].transpose() # get the Lat Lons\n", "newdata=np.column_stack((DIs,a95,LatLons)) # stitch them back together\n", "print (newdata)"]}, {"block": 319, "type": "code", "linesLength": 2, "startIndex": 1372, "lines": ["vgps=np.array(pmag.dia_vgp(newdata)) # get a tuple with lat,lon,dp,dm, convert to array\n", "print (vgps.transpose()) #  print out the vgps"]}, {"block": 320, "type": "markdown", "linesLength": 6, "startIndex": 1374, "lines": ["### dipole_pinc\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#dipole_pinc.py)\n", "\n", "If we assume a geocentric axial dipole, we can calculate an expected inclination at a given latitude and that is what **dipole_pinc** does.   It calls **pmag.pinc()** and so will we to find the expected inclination at a paleolatitude of 24$^{\\circ}$S! \n"]}, {"block": 321, "type": "code", "linesLength": 1, "startIndex": 1380, "lines": ["help(pmag.pinc)"]}, {"block": 322, "type": "code", "linesLength": 2, "startIndex": 1381, "lines": ["lat=-24\n", "pmag.pinc(-24)"]}, {"block": 323, "type": "markdown", "linesLength": 1, "startIndex": 1383, "lines": ["Or as an array"]}, {"block": 324, "type": "code", "linesLength": 8, "startIndex": 1384, "lines": ["lats=range(-90,100,10)\n", "incs=pmag.pinc(lats)\n", "plt.plot(incs,lats)\n", "plt.ylim(100,-100)\n", "plt.xlabel('Latitude')\n", "plt.ylabel('Inclination')\n", "plt.axhline(0,color='black')\n", "plt.axvline(0,color='black');"]}, {"block": 325, "type": "markdown", "linesLength": 6, "startIndex": 1392, "lines": ["### dipole_plat\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#dipole_plat.py)\n", "\n", "**dipole_plat** is similar to [dipole_pinc](#dipole_pinc) but calculates the paleolatitude from the inclination.  We will call **pmag.plat()**:"]}, {"block": 326, "type": "code", "linesLength": 1, "startIndex": 1398, "lines": ["help(pmag.plat)"]}, {"block": 327, "type": "code", "linesLength": 2, "startIndex": 1399, "lines": ["inc=42\n", "pmag.plat(inc)"]}, {"block": 328, "type": "markdown", "linesLength": 5, "startIndex": 1401, "lines": ["### dir_cart\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560002)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#dir_cart.py)\n", "\n", "**pmag.dir2cart()** converts directions (Declination, Inclination, Intensity) to cartesian coordinates (X,Y,Z). "]}, {"block": 329, "type": "code", "linesLength": 1, "startIndex": 1406, "lines": ["help(pmag.dir2cart)"]}, {"block": 330, "type": "code", "linesLength": 8, "startIndex": 1407, "lines": ["# read in data file from example file\n", "dirs=np.loadtxt('data_files/dir_cart/dir_cart_example.dat')\n", "print ('Input: \\n',dirs) # print out the cartesian coordinates\n", "# print out the  results\n", "carts = pmag.dir2cart(dirs)\n", "print (\"Output: \")\n", "for c in carts:\n", "    print ('%8.4e %8.4e %8.4e'%(c[0],c[1],c[2]))"]}, {"block": 331, "type": "markdown", "linesLength": 8, "startIndex": 1415, "lines": ["### dmag_magic\n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html#x15-15600089) [\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#dmag_magic.py)\n", "\n", "\n", "We use **dmag_magic** to plot out the decay of all alternating field demagnetization experiments in MagIC  formatted files.   Here we can take a look at some of the data from   from Cromwell et al.  (2013, doi: 10.1002/ggge.20174). \n", "\n", "This program calls **pmagplotlib.plot_mag()** to plot the demagnetization curve for a sample, site, or entire data file interactively.  There is a version that will prepare dataframes for plotting with this function called **ipmag.plot_dmag()**. So let's try that: "]}, {"block": 332, "type": "code", "linesLength": 1, "startIndex": 1423, "lines": ["help(ipmag.plot_dmag)"]}, {"block": 333, "type": "markdown", "linesLength": 1, "startIndex": 1424, "lines": ["Read in data from a MagIC data model 3 file.  Let's go ahead and read it in with the full data hierarchy. "]}, {"block": 334, "type": "code", "linesLength": 2, "startIndex": 1425, "lines": ["status,data=cb.add_sites_to_meas_table('data_files/dmag_magic')\n", "data.head()"]}, {"block": 335, "type": "markdown", "linesLength": 3, "startIndex": 1427, "lines": ["There are several forms of intensity measurements with different normalizations.  \n", "We could hunt through the magn\\_\\* columns to see what is non-blank or we can use the tool **contribution_builder.get_intensity_col()** which returns the first non-zero column.  \n", "\n"]}, {"block": 336, "type": "code", "linesLength": 2, "startIndex": 1430, "lines": ["magn_col=cb.get_intensity_col(data)\n", "print (magn_col)"]}, {"block": 337, "type": "markdown", "linesLength": 1, "startIndex": 1432, "lines": ["Let's look at what demagnetization data are available to us:"]}, {"block": 338, "type": "code", "linesLength": 1, "startIndex": 1433, "lines": ["data.method_codes.unique()"]}, {"block": 339, "type": "markdown", "linesLength": 1, "startIndex": 1434, "lines": ["Oops - at least one of our records has blank method_codes!  so, let's get rid of that one."]}, {"block": 340, "type": "code", "linesLength": 1, "startIndex": 1435, "lines": ["data=data.dropna(subset=['method_codes'])"]}, {"block": 341, "type": "markdown", "linesLength": 5, "startIndex": 1436, "lines": ["We can make the plots in this way: \n", "- select the AF demagnetization data with method_codes = 'LP-DIR-AF'\n", "- make a dataframe with these columns:\n", "     'specimen','treat_ac_field',magn_col,and 'quality'\n", "- call ipmag.plot_dmag() to view the plot: "]}, {"block": 342, "type": "code", "linesLength": 5, "startIndex": 1441, "lines": ["af_df=data[data.method_codes.str.contains('LP-DIR-AF')] # select the thermal demag data\n", "af_df=af_df.dropna(subset=['treat_ac_field'])\n", "df=af_df[['specimen','treat_ac_field',magn_col,'quality']]\n", "\n", "df.head()"]}, {"block": 343, "type": "code", "linesLength": 1, "startIndex": 1446, "lines": ["ipmag.plot_dmag(data=df,title=\"AF demag\",fignum=1)"]}, {"block": 344, "type": "markdown", "linesLength": 2, "startIndex": 1447, "lines": ["This plotted all the data in the file.  we could also plot the data by site \n", "by getting a unique list of site names and then walk through them one by one"]}, {"block": 345, "type": "code", "linesLength": 8, "startIndex": 1449, "lines": ["sites=af_df.site.unique()\n", "cnt=1\n", "for site in sites:\n", "    site_df=af_df[af_df.site==site] # fish out this site\n", "    # trim to only AF data. \n", "    site_df=site_df[['specimen','treat_ac_field',magn_col,'quality']] \n", "    ipmag.plot_dmag(data=site_df,title=site,fignum=cnt)\n", "    cnt+=1"]}, {"block": 346, "type": "markdown", "linesLength": 2, "startIndex": 1457, "lines": ["We could repeat for thermal data if we felt like it using 'LT-T-Z' as the method_code key\n", "and treat_temp as the step.  We could also save the plots using plt.savefig('FIGNAME.FMT') where FIGNAME could be the site, location, demag type as you wish.  "]}, {"block": 347, "type": "markdown", "linesLength": 2, "startIndex": 1459, "lines": ["#### dmag_magic with a downloaded file\n", "Now let's look at a [downloaded](#download_magic) contribution using [dmag_magic](#dmag_magic) as before, but this time with thermal demagnetization. "]}, {"block": 348, "type": "code", "linesLength": 7, "startIndex": 1461, "lines": ["ipmag.download_magic(\"magic_contribution_16533.txt\", dir_path=\"data_files/download_magic\", \n", "                     input_dir_path=\"data_files/download_magic\")\n", "status,data=cb.add_sites_to_meas_table('data_files/download_magic')\n", "df=data[data.method_codes.str.contains('LT-T-Z')] # select the thermal demag data\n", "df=df[['specimen','treat_temp','magn_moment','quality']]\n", "df=df.dropna(subset=['treat_temp','magn_moment'])\n", "ipmag.plot_dmag(data=df,title=\"Thermal demag\",fignum=1)"]}, {"block": 349, "type": "markdown", "linesLength": 6, "startIndex": 1468, "lines": ["### eigs_s\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#eigs_s.py)\n", "\n", "This program converts eigenparameters to the six tensor elements.  \n", "There is a function **ipmag.eigs_s()** which will do this in a notebook:"]}, {"block": 350, "type": "code", "linesLength": 1, "startIndex": 1474, "lines": ["help(ipmag.eigs_s)"]}, {"block": 351, "type": "code", "linesLength": 3, "startIndex": 1475, "lines": ["Ss=ipmag.eigs_s(infile=\"eigs_s_example.dat\", dir_path='data_files/eigs_s')\n", "for s in Ss:\n", "    print (s)"]}, {"block": 352, "type": "markdown", "linesLength": 11, "startIndex": 1478, "lines": ["### eq_di\n", "\n", "[\\[Essentials Appendix B\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap2.html#x21-227000B#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#eq_di.py)\n", "\n", " Data are frequently published as equal area projections and not listed in data tables. These data can be digitized as x,y data (assuming the outer rim is unity) and converted to approximate directions with the program **eq_di**. To use this program, install a graph digitizer (GraphClick from http://www.arizona-software.ch/graphclick/ works on Macs).\n", "\n", "Digitize the data from the equal area projection saved in the file eqarea.png in the eq_di directory. You should only work on one hemisphere at a time (upper or lower) and save each hemisphere in its own file. Then you can convert the X,Y data to approximate dec and inc data - the quality of the data depends on your care in digitizing and the quality of the figure that you are digitizing.\n", "\n", "Here we will try this out on a datafile already prepared, which are the digitized data from the lower hemisphere of a plot.  You  check your work with [eqarea](#eqarea).  \n", "\n", "To do this in a notebook, we can use **pmag.doeqdi()**.  "]}, {"block": 353, "type": "code", "linesLength": 1, "startIndex": 1489, "lines": ["help(pmag.doeqdi)"]}, {"block": 354, "type": "code", "linesLength": 6, "startIndex": 1490, "lines": ["# read in the data into an array\n", "# x is assumed first column, y, second\n", "xy=np.loadtxt('data_files/eq_di/eq_di_example.dat').transpose()\n", "decs,incs=pmag.doeqdi(xy[0],xy[1])\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(dec=decs,inc=incs,color='r',edge='black')"]}, {"block": 355, "type": "markdown", "linesLength": 5, "startIndex": 1496, "lines": ["### eqarea\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-156000813)[\\[Essentials Appendix B\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap2.html#x21-227000B#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#eqarea.py)\n", "\n", "The problem of plotting equal area projections in Jupyter notebooks was solved by Nick Swanson-Hysell who started the **ipmag** module just for this purpose!  We use **ipmag.plot_net()** to plot the net, then **ipmag.plot_di()** to plot the directions.  "]}, {"block": 356, "type": "code", "linesLength": 1, "startIndex": 1501, "lines": ["help(ipmag.plot_di)"]}, {"block": 357, "type": "code", "linesLength": 3, "startIndex": 1502, "lines": ["di_block=np.loadtxt('data_files/eqarea/fishrot.out')\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')"]}, {"block": 358, "type": "markdown", "linesLength": 29, "startIndex": 1505, "lines": ["### eqarea_ell\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html)\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html)\n", "[\\[Essentials Appendix B\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap2.html#x21-227000B#x15-156000813) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#eqarea_ell.py)\n", "\n", "\n", "\n", "This programe makes  plots of eqarea area projections and confidence ellipses for dec,inc pairs\n", "We make the equal area projects with the **ipmag.plot_net()** and **ipmag.plot_di()** functions.  The options in eqarea_ell are: \n", "    - Bingham mean and ellipse(s)\n", "    - Fisher mean(s) and alpha_95(s)\n", "    - Kent mean(s) - same as Fisher - and Kent ellipse(s)\n", "    - Bootstrapped mean(s)  - same as Fisher - and ellipse(s) \n", "    - Bootstrapped eigenvectors\n", "For Bingham mean, the N/R data are assumed antipodal and the procedure would be:\n", "    - plot the data\n", "    - calculate the bingham ellipse with **pmag.dobingham()**\n", "    - plot the ellipse using **pmag.plot_di_mean_ellipse()**\n", "All others, the data are not assumed antipodal, and must be separated into normal and reverse modes. To do that you can either use **pmag.separate_directions()** to calculate ellipses for each mode, OR use **pmag.flip()** to flip the reverse mode to the normal mode.  To calculate the ellipses: \n", "    - calculate the ellipses for each mode (or the flipped data set):\n", "        - Kent: use **pmag.dokent()**, setting NN to the number of data points\n", "        - Bootstrap : use **pmag.di_boot()** to generate the bootstrapped means\n", "            - either just plot the eigenvectors (ipmag.plot_di()) OR\n", "            - calcualate the bootstrapped ellipses with **pmag.dokent()** setting NN to 1\n", "        - Parametric bootstrap : you need a pandas data frame with the site mean directions, n and kappa.  Then you can use **pmag.dir_df_boot()**.  \n", "    - plot the ellipses if desired. \n", "    "]}, {"block": 359, "type": "code", "linesLength": 4, "startIndex": 1534, "lines": ["#read in the data into an array\n", "vectors=np.loadtxt('data_files/eqarea_ell/tk03.out').transpose()\n", "di_block=vectors[0:2].transpose() # decs are di_block[0], incs are di_block[1]\n", "di_block"]}, {"block": 360, "type": "markdown", "linesLength": 1, "startIndex": 1538, "lines": ["### Bingham ellipses"]}, {"block": 361, "type": "code", "linesLength": 1, "startIndex": 1539, "lines": ["help(pmag.dobingham)"]}, {"block": 362, "type": "code", "linesLength": 1, "startIndex": 1540, "lines": ["help(ipmag.plot_di_mean_ellipse)"]}, {"block": 363, "type": "code", "linesLength": 4, "startIndex": 1541, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block)\n", "bpars=pmag.dobingham(di_block)\n", "ipmag.plot_di_mean_ellipse(bpars,color='red',marker='^',markersize=50)"]}, {"block": 364, "type": "markdown", "linesLength": 1, "startIndex": 1545, "lines": ["## Fisher mean, a95"]}, {"block": 365, "type": "code", "linesLength": 1, "startIndex": 1546, "lines": ["help(pmag.separate_directions)"]}, {"block": 366, "type": "code", "linesLength": 3, "startIndex": 1547, "lines": ["vectors=np.loadtxt('data_files/eqarea_ell/tk03.out').transpose()\n", "di_block=vectors[0:2].transpose() # decs are di_block[0], incs are di_block[1]\n", "mode_1,mode_2=pmag.separate_directions(di_block)"]}, {"block": 367, "type": "code", "linesLength": 1, "startIndex": 1550, "lines": ["help(ipmag.fisher_mean)"]}, {"block": 368, "type": "code", "linesLength": 2, "startIndex": 1551, "lines": ["mode_1_fpars=ipmag.fisher_mean(di_block=mode_1)\n", "mode_2_fpars=ipmag.fisher_mean(di_block=mode_2)"]}, {"block": 369, "type": "code", "linesLength": 1, "startIndex": 1553, "lines": ["help(ipmag.plot_di_mean)"]}, {"block": 370, "type": "code", "linesLength": 9, "startIndex": 1554, "lines": ["# plot the data\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')\n", "# draw on the means and lpha95\n", "ipmag.plot_di_mean(dec=mode_1_fpars['dec'],inc=mode_1_fpars['inc'],a95=mode_1_fpars['alpha95'],\\\n", "                  marker='*',color='blue',markersize=50)\n", "\n", "ipmag.plot_di_mean(dec=mode_2_fpars['dec'],inc=mode_2_fpars['inc'],a95=mode_2_fpars['alpha95'],\\\n", "                  marker='*',color='blue',markersize=50)\n"]}, {"block": 371, "type": "markdown", "linesLength": 1, "startIndex": 1563, "lines": ["### Kent mean and ellipse"]}, {"block": 372, "type": "code", "linesLength": 1, "startIndex": 1564, "lines": ["help(pmag.dokent)"]}, {"block": 373, "type": "code", "linesLength": 2, "startIndex": 1565, "lines": ["mode_1_kpars=pmag.dokent(mode_1,len(mode_1))\n", "mode_2_kpars=pmag.dokent(mode_2,len(mode_2))"]}, {"block": 374, "type": "code", "linesLength": 6, "startIndex": 1567, "lines": ["# plot the data\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')\n", "# draw on the means and lpha95\n", "ipmag.plot_di_mean_ellipse(mode_1_kpars,marker='*',color='cyan',markersize=20)\n", "ipmag.plot_di_mean_ellipse(mode_2_kpars,marker='*',color='cyan',markersize=20)"]}, {"block": 375, "type": "markdown", "linesLength": 1, "startIndex": 1573, "lines": ["### Bootstrap eigenvectors"]}, {"block": 376, "type": "code", "linesLength": 1, "startIndex": 1574, "lines": ["help(pmag.di_boot)"]}, {"block": 377, "type": "code", "linesLength": 2, "startIndex": 1575, "lines": ["mode_1_BDIs=pmag.di_boot(mode_1)\n", "mode_2_BDIs=pmag.di_boot(mode_2)"]}, {"block": 378, "type": "code", "linesLength": 4, "startIndex": 1577, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=mode_1_BDIs,color='cyan',markersize=1)\n", "ipmag.plot_di(di_block=mode_2_BDIs,color='cyan',markersize=1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')\n"]}, {"block": 379, "type": "markdown", "linesLength": 1, "startIndex": 1581, "lines": ["### Boostrapped ellipses"]}, {"block": 380, "type": "code", "linesLength": 2, "startIndex": 1582, "lines": ["mode_1_bpars=pmag.dokent(mode_1_BDIs,1)\n", "mode_2_bpars=pmag.dokent(mode_2_BDIs,1)"]}, {"block": 381, "type": "code", "linesLength": 6, "startIndex": 1584, "lines": ["# plot the data\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')\n", "# draw on the means and lpha95\n", "ipmag.plot_di_mean_ellipse(mode_1_bpars,marker='*',color='cyan',markersize=20)\n", "ipmag.plot_di_mean_ellipse(mode_2_bpars,marker='*',color='cyan',markersize=20)"]}, {"block": 382, "type": "markdown", "linesLength": 15, "startIndex": 1590, "lines": ["### eqarea_magic\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560008) [\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#eqarea_magic.py)\n", "\n", "\n", "**eqarea_magic** takes MagIC data model 3 files and makes equal area projections of declination, inclination data for a variety of  selections, \n", "i.e. all the data, by site, by sample, or by specimen\n", "It has the option to plot in different coordinate systems (if available) and various ellipses.  It will also make a color contour plot if desired.  \n", "We will do this with **ipmag.plot_net()** and **ipmag_plot_di()** using **Pandas** filtering capability.  \n", "\n", "Let's start with a simple plot of site mean directions, assuming that they were interpreted from measurements using **pmag_gui.py** or some such program and have all the required meta-data.  \n", "\n", "We want data in geographic coordinates (dir_tilt_correction=0).  The keys for directions are dir_dec and dir_inc.     One could add the ellipses using **ipmag.plot_di_mean_ellipse()**.  \n", "\n", "#### whole study\n"]}, {"block": 383, "type": "code", "linesLength": 6, "startIndex": 1605, "lines": ["sites=pd.read_csv('data_files/eqarea_magic/sites.txt',sep='\\t',header=1)\n", "site_dirs=sites[sites['dir_tilt_correction']==0]\n", "ipmag.plot_net(1)\n", "di_block=sites[['dir_dec','dir_inc']].values\n", "#ipmag.plot_di(sites['dir_dec'].values,sites['dir_inc'].values,color='blue',markersize=50)\n", "ipmag.plot_di(di_block=di_block,color='blue',markersize=50)"]}, {"block": 384, "type": "code", "linesLength": 2, "startIndex": 1611, "lines": ["# or, using ipmag.eqarea_magic:\n", "ipmag.eqarea_magic('data_files/eqarea_magic/sites.txt', save_plots=False)"]}, {"block": 385, "type": "markdown", "linesLength": 2, "startIndex": 1613, "lines": ["#### whole study with color contour option\n", "for this we can use the function **pmagplotlib.plot_eq_cont()** which makes a color contour of a dec, inc data"]}, {"block": 386, "type": "code", "linesLength": 1, "startIndex": 1615, "lines": ["help(pmagplotlib.plot_eq_cont)"]}, {"block": 387, "type": "code", "linesLength": 2, "startIndex": 1616, "lines": ["ipmag.plot_net(1)\n", "pmagplotlib.plot_eq_cont(1,di_block)"]}, {"block": 388, "type": "code", "linesLength": 2, "startIndex": 1618, "lines": ["# with ipmag.eqarea_magic\n", "ipmag.eqarea_magic('data_files/eqarea_magic/sites.txt', save_plots=False, contour=True)"]}, {"block": 389, "type": "markdown", "linesLength": 7, "startIndex": 1620, "lines": ["#### specimens by site\n", "This study averaged specimens (not samples) by site, so we would like to make plots of all the specimen data for each site.   We can do things the in a similar way to what we did in the **dmag_magic** example.  \n", "A few particulars:\n", "- We will be plotting specimen interpetations in geographic coordinates (dir_tilt_correction=0)\n", "- We need to look at the method codes as there might be fisher means, principal components, great circles, etc.  A complete list of method codes for Direction Estimation can be found here:  https://www2.earthref.org/MagIC/method-codes\n", "- There might be 'bad' directions - 'result_quality'='b' as opposed to 'g'.  \n", "- There are a lot of sites in this study, so let's just look at the first 10...   "]}, {"block": 390, "type": "code", "linesLength": 10, "startIndex": 1627, "lines": ["# read in specimen table\n", "spec_df=pd.read_csv('data_files/eqarea_magic/specimens.txt',sep='\\t',header=1) \n", "# read in sample table\n", "samp_df=pd.read_csv('data_files/eqarea_magic/samples.txt',sep='\\t',header=1) \n", "# get only what we need from samples (sample to site mapping)\n", "samp_df=samp_df[['sample','site']] \n", "# merge site to specimen name in the specimen data frame\n", "df_ext=pd.merge(spec_df,samp_df,how='inner',on='sample') \n", "# truncate to the first 10 sites\n", "sites=df_ext.site.unique()[0:11]"]}, {"block": 391, "type": "markdown", "linesLength": 2, "startIndex": 1637, "lines": ["We need to filter specimen data for dir_tilt_correction=0\n", "and separate into DE-BFP (best fit planes) and not."]}, {"block": 392, "type": "code", "linesLength": 6, "startIndex": 1639, "lines": ["# get the geographic coordinates\n", "spec_df=df_ext[spec_df.dir_tilt_correction==0]\n", "# filter to exclude planes\n", "spec_lines=spec_df[spec_df.method_codes.str.contains('DE-BFP')==False]\n", "# filter for planes\n", "spec_df_gc=spec_df[spec_df.method_codes.str.contains('DE-BFP')==True]"]}, {"block": 393, "type": "code", "linesLength": 2, "startIndex": 1645, "lines": ["# here's a new one:\n", "help(ipmag.plot_gc)"]}, {"block": 394, "type": "code", "linesLength": 12, "startIndex": 1647, "lines": ["cnt=1\n", "for site in sites:\n", "    plt.figure(cnt)\n", "    ipmag.plot_net(cnt)\n", "    plt.title(site)\n", "    site_lines=spec_lines[spec_lines.site==site] # fish out this site\n", "    ipmag.plot_di(site_lines.dir_dec.values,site_lines.dir_inc.values)\n", "    site_planes=spec_df_gc[spec_df_gc.site==site]\n", "    poles=site_planes[['dir_dec','dir_inc']].values\n", "    if poles.shape[0]>0:\n", "        ipmag.plot_gc(poles,fignum=cnt,color='r')\n", "    cnt+=1"]}, {"block": 395, "type": "code", "linesLength": 2, "startIndex": 1659, "lines": ["# using ipmag.eqarea_magic:\n", "ipmag.eqarea_magic('specimens.txt', 'data_files/eqarea_magic', plot_by='sit', save_plots=False)"]}, {"block": 396, "type": "markdown", "linesLength": 8, "startIndex": 1661, "lines": ["#### measurements by specimen\n", "\n", "We can do this like this:\n", "\n", "- read in the MagIC data model 3 measurements table into a **Pandas** data frame\n", "- get a list of unique specimen names\n", "- truncate this to the first 10 for this purpose\n", "- plot the dir_dec and dir_inc fields by specimen\n"]}, {"block": 397, "type": "code", "linesLength": 11, "startIndex": 1669, "lines": ["# read in measurements table\n", "meas_df=pd.read_csv('data_files/eqarea_magic/measurements.txt',sep='\\t',header=1) \n", "specimens=meas_df.specimen.unique()[0:11]\n", "cnt=1\n", "for spec in specimens:\n", "    meas_spc=meas_df[meas_df.specimen==spec]\n", "    plt.figure(cnt)\n", "    ipmag.plot_net(cnt)\n", "    plt.title(spec)\n", "    ipmag.plot_di(meas_spc.dir_dec.values,meas_spc.dir_inc.values)\n", "    cnt+=1"]}, {"block": 398, "type": "markdown", "linesLength": 1, "startIndex": 1680, "lines": ["#### Individual specimens"]}, {"block": 399, "type": "code", "linesLength": 2, "startIndex": 1681, "lines": ["# using ipmag.eqarea_magic:\n", "ipmag.eqarea_magic('specimens.txt', 'data_files/eqarea_magic', plot_by='spc', save_plots=False)"]}, {"block": 400, "type": "markdown", "linesLength": 9, "startIndex": 1683, "lines": ["### find_ei\n", "\n", "[\\[Essentials Chapter 14\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch14.html#x15-1560008) [\\[MagIC Database\\]](https://earthref.org/MagIC)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#find_ei.py)\n", "\n", "This program is meant to find the unflattening factor (see [unsquish](#unsquish) documentation) that brings a sedimentary data set into agreement with the statistical field model TK03 of Tauxe and Kent (2004, doi: 10.1029/145GM08).  It  has been implemented for notebooks as **ipmag.find_ei()**.\n", "\n", "\n", "A data file (data_files/find_EI/find_EI_example.dat) was prepared using the program **[tk03](#tk03)**  to simulate directions at a latitude of 42$^{\\circ}$. with an expected inclination of 61$^{\\circ}$ (which could be gotten using **[dipole_pinc](#dipole_pinc)** of course.  \n", "\n"]}, {"block": 401, "type": "code", "linesLength": 1, "startIndex": 1692, "lines": ["help(ipmag.find_ei)"]}, {"block": 402, "type": "code", "linesLength": 2, "startIndex": 1693, "lines": ["data=np.loadtxt('data_files/find_EI/find_EI_example.dat')\n", "ipmag.find_ei(data)"]}, {"block": 403, "type": "markdown", "linesLength": 2, "startIndex": 1695, "lines": ["In this example, the original expected inclination at paleolatitude of 42 (61$^{\\circ}$) is recovered within the 95% confidence bounds.\n", "\n"]}, {"block": 404, "type": "markdown", "linesLength": 3, "startIndex": 1697, "lines": ["### fcalc\n", "\n", "**pmag.fcalc()** returns the values of an F-test from  an F table."]}, {"block": 405, "type": "code", "linesLength": 1, "startIndex": 1700, "lines": ["help(pmag.fcalc)"]}, {"block": 406, "type": "markdown", "linesLength": 6, "startIndex": 1701, "lines": ["### fisher\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#fisher.py)\n", "\n", "**fisher**  draws $N$  directions  from a Fisher distribution with specified $\\kappa$ and a vertical mean. (For other directions see [fishrot](#fishrot)).  To do this, we can just call the function **pmag.fshdev()** $N$ times."]}, {"block": 407, "type": "code", "linesLength": 1, "startIndex": 1707, "lines": ["help(pmag.fshdev)"]}, {"block": 408, "type": "code", "linesLength": 10, "startIndex": 1708, "lines": ["# set the number, N, and kappa\n", "N,kappa=100,20\n", "# a basket to put our fish in\n", "fish=[]\n", "# get the Fisherian deviates\n", "for i in range(N):\n", "    d,i=pmag.fshdev(kappa)\n", "    fish.append([d,i])\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=fish,color='r',edge='black')"]}, {"block": 409, "type": "markdown", "linesLength": 8, "startIndex": 1718, "lines": ["### fishqq\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#fishqq.py)\n", "\n", "This program was meant to test whether a given directional data set is Fisher distributed using a Quantile-Quantile plot (see also [qqunf](#qqunf) or [qqplot](#qqplot) for more on Quantile-Quantile plots).  \n", "\n", "Blessedly, **fishqq** has been incorporated into **ipmag.fishqq()** for use within notebooks.  "]}, {"block": 410, "type": "code", "linesLength": 1, "startIndex": 1726, "lines": ["help(ipmag.fishqq)"]}, {"block": 411, "type": "code", "linesLength": 3, "startIndex": 1727, "lines": ["di_block=np.loadtxt('data_files/fishqq/fishqq_example.txt')\n", "fqpars=ipmag.fishqq(di_block=di_block)\n", "print (fqpars['Test_result'])"]}, {"block": 412, "type": "markdown", "linesLength": 8, "startIndex": 1730, "lines": ["### fishrot\n", "\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#fishrot.py)\n", "\n", "This program is similar to [fisher](#fisher), but allows you to specify the mean direction. \n", "This has been implemented as **ipmag.fishrot()**. "]}, {"block": 413, "type": "code", "linesLength": 1, "startIndex": 1738, "lines": ["help(ipmag.fishrot)"]}, {"block": 414, "type": "code", "linesLength": 3, "startIndex": 1739, "lines": ["rotdi=ipmag.fishrot(k=50,n=5,dec=33,inc=41)\n", "for di in rotdi:\n", "    print ('%7.1f %7.1f'%(di[0],di[1]))"]}, {"block": 415, "type": "code", "linesLength": 2, "startIndex": 1742, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=rotdi)"]}, {"block": 416, "type": "markdown", "linesLength": 3, "startIndex": 1744, "lines": ["### flip\n", "\n", "Fisher statistics requires unimodal data (all in one direction with no reversals) but many paleomagnetic data sets are bimodal.  To flip bimodal data into a single mode, we can use **pmag.flip( )**.  This function calculates the principle direction and flips all the 'reverse' data to the 'normal' direction along the principle axis.  "]}, {"block": 417, "type": "code", "linesLength": 1, "startIndex": 1747, "lines": ["help(pmag.flip)"]}, {"block": 418, "type": "code", "linesLength": 9, "startIndex": 1748, "lines": ["#read in the data into an array\n", "vectors=np.loadtxt('data_files/eqarea_ell/tk03.out').transpose()\n", "di_block=vectors[0:2].transpose() # decs are di_block[0], incs are di_block[1]\n", "# flip the reverse directions to their normal antipodes\n", "normal,flipped=pmag.flip(di_block)\n", "# and plot them up\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red')\n", "ipmag.plot_di(di_block=flipped,color='b')"]}, {"block": 419, "type": "markdown", "linesLength": 8, "startIndex": 1757, "lines": ["### foldtest\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#foldtest.py)\n", "\n", "**foldtest** uses the fold test of Tauxe and Watson (1994, 10.1016/0012-821x(94)90006-x  ) to find the degree of unfolding that produces the tightest distribution of directions (using the eigenvalue $\\tau_1$ as the criterion.  \n", "\n", "This can be done via **pmag.bootstrap_fold_test()**. Note that this can take several minutes.   "]}, {"block": 420, "type": "code", "linesLength": 1, "startIndex": 1765, "lines": ["help(ipmag.bootstrap_fold_test)"]}, {"block": 421, "type": "code", "linesLength": 2, "startIndex": 1766, "lines": ["data=np.loadtxt('data_files/foldtest/foldtest_example.dat')\n", "ipmag.bootstrap_fold_test(data, num_sims=300)"]}, {"block": 422, "type": "markdown", "linesLength": 8, "startIndex": 1768, "lines": ["### foldtest_magic\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#foldtest_magic.py])\n", "\n", "This is just the MagIC formatted file version of **foldtest** and can be done using **ipmag.bootstrap_fold_test()** as above.  We just have to read in the MagIC formattest files and make a data matrix of the format expected by **ipmag.bootstrap_fold_test()**.  Here, **Pandas** is our friend.  We will: \n", "- Read in the MagIC (data model 3) formatted file\n", "- Make a **Numpy** array with the required fields\n", "- call **ipmag.bootstrap_foldtest_magic()**\n"]}, {"block": 423, "type": "code", "linesLength": 2, "startIndex": 1776, "lines": ["sites=pd.read_csv('data_files/foldtest_magic/sites.txt',sep='\\t',header=1)\n", "sites.columns"]}, {"block": 424, "type": "markdown", "linesLength": 3, "startIndex": 1778, "lines": ["The columns we need are: dir_dec, dir_inc, bed_dip_direction, bed_dip\n", "The dir_dec and dir_inc have to have a dir_tilt_correction of 0 (geographic coordinates).\n", "A little looking through the sites data file shows that the bed_dip_direction are on a separate line (oh database conversion tool maestro, how clever!).  So we will have to pair the bedding orientations with the geographic directional info.  Thank goodness for **Pandas**!\n"]}, {"block": 425, "type": "code", "linesLength": 14, "startIndex": 1781, "lines": ["# read in data file\n", "sites=pd.read_csv('data_files/foldtest_magic/sites.txt',sep='\\t',header=1)\n", "# get the records with bed_dip and bed_dip_direction\n", "sites_bedding=sites.dropna(subset=['bed_dip','bed_dip_direction'])\n", "# get rid of them out of the original data frame\n", "sites.drop(['bed_dip','bed_dip_direction'],axis=1,inplace=True)\n", "# just pick out what we want (bedding orientation of the sites)\n", "sites_bedding=sites_bedding[['site','bed_dip','bed_dip_direction']]\n", "# put them back into the original data frame\n", "sites=pd.merge(sites,sites_bedding,how='inner',on='site')\n", "# now we can pick out the desired coordinate system\n", "sites_geo=sites[sites.dir_tilt_correction==0]\n", "# and make our data array\n", "data=sites_geo[['dir_dec','dir_inc','bed_dip_direction','bed_dip']].values\n"]}, {"block": 426, "type": "markdown", "linesLength": 1, "startIndex": 1795, "lines": ["NB: One unfortunate thing about the MagIC data model is that bedding orientation information can be either in the samples.txt or the sites.txt file.  This example assumes the data are in the _sites.txt_ file.  If not, you can read in the _samples.txt_ file and merge the bedding information with the site directions.  "]}, {"block": 427, "type": "code", "linesLength": 2, "startIndex": 1796, "lines": ["# and off we go! \n", "ipmag.bootstrap_fold_test(data, num_sims=300)"]}, {"block": 428, "type": "markdown", "linesLength": 2, "startIndex": 1798, "lines": ["### forc_diagram\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#forc_diagram.py)"]}, {"block": 429, "type": "code", "linesLength": 22, "startIndex": 1800, "lines": ["from programs.forc_diagram import *\n", "\n", "forc = Forc(fileAdres='data_files/forc_diagram/conventional_example.forc',SF=3)\n", "\n", "fig = plt.figure(figsize=(6,5), facecolor='white')\n", "\n", "fig.subplots_adjust(left=0.18, right=0.97,\n", "                    bottom=0.18, top=0.9, wspace=0.5, hspace=0.5)\n", "plt.contour(forc.xi*1000,\n", "            forc.yi*1000,\n", "            forc.zi,9,\n", "            colors='k',linewidths=0.5)#mt to T\n", "\n", "plt.pcolormesh(forc.xi*1000,\n", "               forc.yi*1000,\n", "               forc.zi,\n", "               cmap=plt.get_cmap('rainbow'))#vmin=np.min(rho)-0.2)\n", "plt.colorbar()\n", "plt.xlabel('B$_{c}$ (mT)',fontsize=12)\n", "plt.ylabel('B$_{i}$ (mT)',fontsize=12)\n", "\n", "plt.show()"]}, {"block": 430, "type": "markdown", "linesLength": 6, "startIndex": 1822, "lines": ["### gaussian\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#gaussian.py)\n", "\n", "This program generates sets of data drawn from a normal distribution with a given mean and standard deviation.  It is just a wrapper for a call to  **pmag.gaussdev()** which just calls **numpy.random.normal()** which we could do, but we would have to import it, so it is easiest just to call the **pmag** version which we have already imported.  "]}, {"block": 431, "type": "code", "linesLength": 1, "startIndex": 1828, "lines": ["help(pmag.gaussdev)"]}, {"block": 432, "type": "code", "linesLength": 6, "startIndex": 1829, "lines": ["N=1000\n", "bins=100\n", "norm=pmag.gaussdev(10,3,N)\n", "plt.hist(norm,bins=bins,color='black',histtype='step',density=True)\n", "plt.xlabel('Gaussian Deviates')\n", "plt.ylabel('Frequency');"]}, {"block": 433, "type": "markdown", "linesLength": 7, "startIndex": 1835, "lines": ["### gobing\n", "\n", " \n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#gobing.py)\n", "\n", "**gobing** calculates Bingham statistics for sets of directional data (see documentation for [eqarea_ell](#eqarea_ell) for nice examples.  We do this by calling **pmag.dobingham()**."]}, {"block": 434, "type": "code", "linesLength": 1, "startIndex": 1842, "lines": ["help(pmag.dobingham)"]}, {"block": 435, "type": "code", "linesLength": 2, "startIndex": 1843, "lines": ["di_block=np.loadtxt('data_files/gobing/gobing_example.txt')\n", "pmag.dobingham(di_block)\n"]}, {"block": 436, "type": "markdown", "linesLength": 7, "startIndex": 1845, "lines": ["### gofish\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#gofish.py)\n", "\n", "**gofish** calculates Fisher statistics for sets of directional data.  (see documentation for [eqarea_ell](#eqarea_ell) for nice examples.\n", "This can be done with **ipmag.fisher_mean()**.\n"]}, {"block": 437, "type": "code", "linesLength": 1, "startIndex": 1852, "lines": ["help(ipmag.fisher_mean)"]}, {"block": 438, "type": "code", "linesLength": 2, "startIndex": 1853, "lines": ["di_block=np.loadtxt('data_files/gofish/fishrot.out')\n", "ipmag.fisher_mean(di_block=di_block)"]}, {"block": 439, "type": "markdown", "linesLength": 2, "startIndex": 1855, "lines": ["### fisher mean on pandas DataFrames\n", "There is also a function **pmag.dir_df_fisher_mean()** that calculates Fisher statistics on a Pandas DataFrame with directional data"]}, {"block": 440, "type": "code", "linesLength": 1, "startIndex": 1857, "lines": ["help(pmag.dir_df_fisher_mean)"]}, {"block": 441, "type": "code", "linesLength": 4, "startIndex": 1858, "lines": ["# make the data frame\n", "dir_df=pd.read_csv('data_files/gofish/fishrot.out',delim_whitespace=True, header=None)\n", "dir_df.columns=['dir_dec','dir_inc']\n", "pmag.dir_df_fisher_mean(dir_df)"]}, {"block": 442, "type": "markdown", "linesLength": 8, "startIndex": 1862, "lines": ["### gokent\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#gokent.py)\n", "\n", "With **gokent** we can calculate Kent statistics on sets of directional data (see documentation for [eqarea_ell](#eqarea_ell) for nice examples..  \n", "\n", "This calls **pmag.dokent()** (see also **eqarea_ell** example)"]}, {"block": 443, "type": "code", "linesLength": 1, "startIndex": 1870, "lines": ["help(pmag.dokent)"]}, {"block": 444, "type": "code", "linesLength": 2, "startIndex": 1871, "lines": ["di_block=np.loadtxt('data_files/gokent/gokent_example.txt')\n", "pmag.dokent(di_block,di_block.shape[0])"]}, {"block": 445, "type": "markdown", "linesLength": 7, "startIndex": 1873, "lines": ["### goprinc\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#goprinc.py)\n", "\n", "**goprinc** calculates the principal directions (and their eigenvalues) for sets of paleomagnetic vectors.  It doesn't do any statistics on them, unlike the other programs. \n", "We will call **pmag.doprinc()**:"]}, {"block": 446, "type": "code", "linesLength": 1, "startIndex": 1880, "lines": ["help(pmag.doprinc)"]}, {"block": 447, "type": "code", "linesLength": 2, "startIndex": 1881, "lines": ["di_block=np.loadtxt('data_files/goprinc/goprinc_example.txt')\n", "pmag.doprinc(di_block)"]}, {"block": 448, "type": "markdown", "linesLength": 4, "startIndex": 1883, "lines": ["### histplot\n", "\n", "\n", "You should use the function **plt.hist()** for this - see **[gaussian](#gaussian)** example."]}, {"block": 449, "type": "markdown", "linesLength": 9, "startIndex": 1887, "lines": ["### hysteresis_magic\n", "\n", "[\\[Essentials Chapter 5\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch5.html#x15-156000813)\n", "[\\[Essentials Chapter 7\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch7.html#x15-156000813)\n", "[\\[Essentials Appendix C\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap3.html#x21-227000B#x15-156000813)\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#hysteresis_magic.py)\n", "\n", "This program plots MagIC formatted measurement data as hysteresis loops, $\\Delta$M, d$\\Delta$M and backfield curves, depending on what data are available.  There is an **ipmag.hysteresis_magic** function that does this for us.  "]}, {"block": 450, "type": "code", "linesLength": 1, "startIndex": 1896, "lines": ["help(ipmag.hysteresis_magic)"]}, {"block": 451, "type": "markdown", "linesLength": 1, "startIndex": 1897, "lines": ["So let's try this out with some data from Ben-Yosef et al., (2008;doi: 10.1029/2007JB005235). The default is to plot the first 5 specimens and that is enough for us.  We also do not need to save plots at this point.  "]}, {"block": 452, "type": "code", "linesLength": 1, "startIndex": 1898, "lines": ["ipmag.hysteresis_magic(output_dir_path='data_files/hysteresis_magic/',save_plots=False)"]}, {"block": 453, "type": "markdown", "linesLength": 7, "startIndex": 1899, "lines": ["### igrf\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#igrf.py)\n", "\n", "\n", "This program gives geomagnetic field vector data for a specified place at a specified time.  It has many built in models including  IGRFs, GUFM and several archeomagnetic models.   It calls the  function **ipmag.igrf()** for this so that is what we will do.  "]}, {"block": 454, "type": "code", "linesLength": 1, "startIndex": 1906, "lines": ["help(ipmag.igrf)"]}, {"block": 455, "type": "markdown", "linesLength": 1, "startIndex": 1907, "lines": ["We will calculate the field for San Diego from 3000 BCE to 1950 in 50 year increments using the hfm.OL1.A1 model of Constable et al. (2016, doi: 10.1016/j.epsl.2016.08.015).  "]}, {"block": 456, "type": "code", "linesLength": 28, "startIndex": 1908, "lines": ["# make a list of desired dates\n", "dates=range(-3000,1950,50) # list of dates in +/- Common Era\n", "mod = 'hfm10k' # choose the desired model\n", "lat,lon,alt=33,-117,0 # desired latitude, longitude and alitude\n", "Vecs=[] # list for Dec,Inc,Int outputs\n", "for date in dates: # step through the dates\n", "    Vecs.append(ipmag.igrf([date,alt,lat,lon],mod=mod)) # append to list\n", "vector_df = pd.DataFrame(Vecs)   # make it into a Pandas dataframe\n", "vector_df.columns=['dec','inc','int']\n", "vector_df['vadms']=pmag.b_vdm(vector_df.int.values*1e-9, lat) # calculate the VADMs\n", "vector_df['dec_adj']=vector_df['dec'] \n", "vector_df.loc[vector_df.dec>180,['dec_adj']]=vector_df.dec-360 # adjust declinations to be -180 => 180\n", "fig=plt.figure(1,figsize=(7,9)) # set up the figure\n", "fig.add_subplot(411) # make 4 rows of plots, this is the first\n", "plt.plot(dates,vector_df.dec_adj) # plot the adjusted declinations\n", "plt.ylabel('Declination ($^{\\circ}$)')\n", "plt.title('Geomagnetic field evaluated at Lat: '+str(lat)+' / Lon: '+str(lon))\n", "fig.add_subplot(412) # this is the second\n", "plt.plot(dates,vector_df.inc) # plot  the inclinations\n", "plt.ylabel('Inclination ($^{\\circ}$)')\n", "fig.add_subplot(413)\n", "plt.plot(dates,vector_df.int*1e-3) # plot the intensites (in uT instead of nT)\n", "plt.ylabel('Intensity ($\\mu$T)')\n", "fig.add_subplot(414) # plot the VADMs \n", "plt.plot(dates,vector_df.vadms*1e-21) # plot as ZAm^2\n", "plt.ylabel('VADM (ZAm$^2$)')\n", "plt.xlabel('Dates (CE)');\n", "\n"]}, {"block": 457, "type": "markdown", "linesLength": 7, "startIndex": 1936, "lines": ["### incfish\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#incfish.py)\n", "\n", "You can't get a meaningful average inclination from inclination only data because of the exponential relationship between inclinations and the true mean inclination for Fisher distributions (except exactly at the pole and the equator).  So, McFadden and Reid (1982, doi:  10.1111/j.1365-246X.1982.tb04950.x) developed a maximum liklihood estimate for getting an estimate for true mean absent declination.  **incfish.py** is an implementation of that concept.  It calls \n", " **pmag.doincfish()** so that is what we will do. "]}, {"block": 458, "type": "code", "linesLength": 1, "startIndex": 1943, "lines": ["help(pmag.doincfish)"]}, {"block": 459, "type": "code", "linesLength": 2, "startIndex": 1944, "lines": ["incs=np.loadtxt('data_files/incfish/incfish_example_inc.dat')\n", "pmag.doincfish(incs)"]}, {"block": 460, "type": "markdown", "linesLength": 1, "startIndex": 1946, "lines": ["### irm_unmix"]}, {"block": 461, "type": "code", "linesLength": 13, "startIndex": 1947, "lines": ["import matplotlib\n", "from programs.irm_unmix import dataFit, fit_plots\n", "fitResult = dataFit(filePath='data_files/irm_unmix/irm_unmix_example.dat',fitNumber=3)\n", "\n", "xfit=fitResult.fitDf['field']\n", "xraw=fitResult.rawDf['field_log']\n", "yfit=fitResult.pdf_best\n", "yraw=fitResult.rawDf['rem_grad_norm']\n", "\n", "fig = plt.figure(1, figsize=(5, 5))\n", "ax = fig.add_subplot(111)\n", "\n", "fit_plots(ax,xfit,xraw,yfit,yraw)"]}, {"block": 462, "type": "markdown", "linesLength": 8, "startIndex": 1960, "lines": ["### irmaq_magic\n", "\n", "[\\[Essentials Chapter 8\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch8.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#irmaq_magic.py)\n", "\n", "Someone (Saiko Sugisaki) measured a number of samples from IODP Expedition 318 Hole U1359A for IRM acquisition curves. These were converted to the MagIC measurements format and saved in ../irmaq_magic/measurements.txt.  \n", "\n", "This program reads in a MagIC data model 3 file with IRM acquisition data and plots it by calling **pmagplotlib.plot_mag()** with options to plot by entire data file, site, sample or individual specimen.  We can do that too!  All we need to know is the method_code for IRM acquisition (which I do), and to propogate specimen => sample => site identities if any other plotting option besides \"entire file\" or by specimen is desired.  "]}, {"block": 463, "type": "code", "linesLength": 2, "startIndex": 1968, "lines": ["plt.clf()\n", "help(pmagplotlib.plot_mag)"]}, {"block": 464, "type": "code", "linesLength": 19, "startIndex": 1970, "lines": ["# make the figure\n", "plt.figure(1,(5,5))\n", "#read in the data\n", "data=pd.read_csv('data_files/irmaq_magic/measurements.txt',sep='\\t',header=1)\n", "# fish out the IRM data\n", "data=data[data.method_codes.str.contains('LP-IRM')] # \n", "data['zero']=0 # make a dummy field initialized with zero\n", "data['one']=1 # make a dummy field initialized with one\n", "# make the required list\n", "# possible intensity fields are:\n", "#['magn_moment', 'magn_volume', 'magn_mass', 'magnitude']\n", "# this data file has magn_moment data\n", "# pmagplotlib.plotMT plots data by specimen, so get list of specimens\n", "specimens=data.specimen.unique()\n", "for specimen in specimens: # step through one by one\n", "    spec_df=data[data.specimen==specimen] # get data for this specimen\n", "    # make the data block required\n", "    datablock=np.array(spec_df[['treat_dc_field','zero','zero','magn_moment','one','quality']]).tolist()\n", "    pmagplotlib.plot_mag(1,datablock,'Example',0,'T',1)"]}, {"block": 465, "type": "markdown", "linesLength": 16, "startIndex": 1989, "lines": ["### lnp_magic\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html#x15-156000813)\n", "[\\[Essentials Appendix C\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap3.html#x21-227000B#x15-156000813)\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)  \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#lnp_magic.py)\n", "\n", "\n", "This program makes equal area projections site by site along with the \n", "Fisher confidence ellipses using the McFadden and McElhinny (1988, doi: 10.1016/0012-821X(88)90072-6) \n", "method for combining lines and planes.  Options are to plot in specimen, geographic or tilt corrected coordinate systems (although the specimen coordinate system is a bit silly if the specimens were not mutually oriented and the geographic and tilt correctioed would presumably be identical except for a coherent rotation of the site.)\n", "It also builds in filters for MAD or $\\alpha_{95}$ cutoffs at the specimen level.\n", "\n", "After filtering, the site level data are processed by **pmag.dolnp()** which calculates the MM88 statistics.  These, along with the data are then plotted by **pmagplotlib.plot_lnp()**.  \n", "\n", "We can do all that from within the notebook, using the wonders of Pandas."]}, {"block": 466, "type": "code", "linesLength": 1, "startIndex": 2005, "lines": ["help(pmagplotlib.plot_lnp)"]}, {"block": 467, "type": "code", "linesLength": 6, "startIndex": 2006, "lines": ["# read in specimen data\n", "spec_df=pd.read_csv('data_files/lnp_magic/specimens.txt',sep='\\t',header=1)\n", "# filter for quality = 'g'\n", "if 'quality'  in spec_df.columns:\n", "    spec_df=spec_df[spec_df.quality=='g']\n", "spec_df.head()\n"]}, {"block": 468, "type": "markdown", "linesLength": 1, "startIndex": 2012, "lines": ["Of course, this being a data file conerted from data model 2.5 there are several lines per specimen. we want the non-blank dir_dec info with the desired (0) tilt correction"]}, {"block": 469, "type": "code", "linesLength": 3, "startIndex": 2013, "lines": ["spec_df=spec_df.dropna(subset=['dir_dec','dir_inc','dir_tilt_correction'])\n", "spec_df=spec_df[spec_df.dir_tilt_correction==0]\n", "spec_df.head()"]}, {"block": 470, "type": "markdown", "linesLength": 3, "startIndex": 2016, "lines": ["Let's proceed this way:\n", "- get a list of all the site names. for this we will have to pair the sample with the site name from the samples.txt file.\n", "- look at the data (only quality = 'g'), site by site, sending it to first **pmag.dolnp()**, then to **pmagplotlib.plot_lnp()**."]}, {"block": 471, "type": "code", "linesLength": 3, "startIndex": 2019, "lines": ["# read in samples table in order to pair site name to specimen data\n", "samp_df=pd.read_csv('data_files/lnp_magic/samples.txt',sep='\\t',header=1)\n", "samp_df.head()"]}, {"block": 472, "type": "markdown", "linesLength": 1, "startIndex": 2022, "lines": ["Of course there are duplicate sample records, so let's drop the blank lat rows (to make sure we have all the blank specimens rows, then make the data frame with just 'sample' and site' columns. Then we can merge it with the spec_df dataframe. "]}, {"block": 473, "type": "code", "linesLength": 4, "startIndex": 2023, "lines": ["samp_df=samp_df.dropna(subset=['specimens'])\n", "samp_df=samp_df[['sample','site']]\n", "spec_df=pd.merge(spec_df,samp_df,on='sample')\n", "spec_df"]}, {"block": 474, "type": "code", "linesLength": 3, "startIndex": 2027, "lines": ["# get the site names\n", "sites=spec_df.site.unique()\n", "sites"]}, {"block": 475, "type": "markdown", "linesLength": 1, "startIndex": 2030, "lines": ["Let's plot up the first 10 or so."]}, {"block": 476, "type": "code", "linesLength": 1, "startIndex": 2031, "lines": ["help(pmag.dolnp)"]}, {"block": 477, "type": "code", "linesLength": 1, "startIndex": 2032, "lines": ["help(pmagplotlib.plot_lnp)"]}, {"block": 478, "type": "code", "linesLength": 7, "startIndex": 2033, "lines": ["cnt=1\n", "for site in sites[0:10]:\n", "    pmagplotlib.plot_init(cnt, 5, 5)\n", "    site_data=spec_df[spec_df.site==site].to_dict('records')\n", "    fpars=pmag.dolnp(site_data,'specimen_direction_type')\n", "    pmagplotlib.plot_lnp(cnt,site,site_data,fpars,'specimen_direction_type')\n", "    cnt+=1\n"]}, {"block": 479, "type": "markdown", "linesLength": 7, "startIndex": 2040, "lines": ["### lowes\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-156000813)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#lowes.py)\n", "\n", "\n", "This program generates a Lowes (1974, doi: 10.1111/j.1365-246X.1974.tb00622.x)  spectrum from igrf-like field models.  It will take a specified date, get the gauss coefficients from [**pmag.doigrf()**](#igrf), unpack them into a usable format with **pmag.unpack()** and calculate the spectrum with **pmag.lowes()**.  "]}, {"block": 480, "type": "code", "linesLength": 1, "startIndex": 2047, "lines": ["help(pmag.unpack)"]}, {"block": 481, "type": "code", "linesLength": 1, "startIndex": 2048, "lines": ["help(pmag.lowes)"]}, {"block": 482, "type": "markdown", "linesLength": 1, "startIndex": 2049, "lines": ["So let's do it!"]}, {"block": 483, "type": "code", "linesLength": 4, "startIndex": 2050, "lines": ["date=1956 # pick a date and what better one than my birth year?  \n", "coeffs=pmag.doigrf(0,0,0,date,coeffs=1) # get the gauss coefficients\n", "data=pmag.unpack(coeffs) # unpack them into the form that lowes likes\n", "Ls,Rs=pmag.lowes(data) # get the power spectrum\n"]}, {"block": 484, "type": "code", "linesLength": 6, "startIndex": 2054, "lines": ["plt.plot(Ls,Rs,linewidth=2,label=str(date)) # make the plot\n", "plt.semilogy() # semi log it\n", "plt.xlabel('Degree (l)')\n", "plt.ylabel('Power ($\\mu$T$^2$)')\n", "plt.legend();\n", "\n"]}, {"block": 485, "type": "markdown", "linesLength": 13, "startIndex": 2060, "lines": ["### lowrie and lowrie_magic\n", "\n", "[\\[Essentials Chapter 8\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch8.html#x15-156000813)\n", "[\\[command line versions\\]](http://pmagpy.github.io/PmagPy-cli.html#lowrie.py)\n", "\n", " Someone (Saiko Sugisaki) subjected a number of specimens from IODP Expedition 318 Site U1361 specimens to a Lowrie (1990, doi: 10.1029/GL017i002p00159) 3-D IRM experiment (published as Tauxe et al., 2015, doi:10.1016/j.epsl.2014.12.034). **lowrie** makes plots of blocking temperature for the three coercivity fractions.\n", "\n", "\n", "Both **lowrie** and **lowrie_magic**   take specimen level 3D-IRM data, break them into the cartesian coordinates  of the three IRM field directions and plot the different components versus demagnetizing temperature.  We can  do this with our powerful **Pandas** and **matplotlib**.  \n", "The relevent MagIC database method code is 'LP-IRM-3D', magnetization code is one of the usual, but in this example it is 'magn_moment' and the temperature step is the usual data model 3.0 ('treat_temp') in kelvin.\n", "\n", "\n", "We will use **pmag.dir2cart()** for the heavy lifting.  I also happen to know (because I wrote the original paper), that the X direction was the 1.0 tesla step, Y was 0.5 tesla and Z was .1 tesla, so we can put these in the legend. "]}, {"block": 486, "type": "code", "linesLength": 1, "startIndex": 2073, "lines": ["help(pmag.dir2cart)"]}, {"block": 487, "type": "code", "linesLength": 25, "startIndex": 2074, "lines": ["# read in the data file\n", "meas_df=pd.read_csv('data_files/lowrie_magic/measurements.txt',sep='\\t',header=1)\n", "# pick out the 3d-IRM data\n", "meas_df=meas_df[meas_df.method_codes.str.contains('LP-IRM-3D')]\n", "# get a list of specimen names\n", "specimens=meas_df.specimen.unique()\n", "cnt=1 # set figure counter\n", "for specimen in specimens[0:10]: # step through first 10\n", "    spec_df=meas_df[meas_df.specimen==specimen] # collect this specimen's data    \n", "    dirs=np.array(spec_df[['dir_dec','dir_inc','magn_moment']])\n", "    norm=dirs[0][2] # let's normalize to the initial intensity\n", "    carts=np.absolute((pmag.dir2cart(dirs)/norm)).transpose() # get the X,Y,Z data\n", "    temps=spec_df['treat_temp']-273 # convert to Celcius\n", "    plt.figure(cnt,(6,6))\n", "    plt.plot(temps,carts[0],'ro',label='1 T')\n", "    plt.plot(temps,carts[0],'r-')\n", "    plt.plot(temps,carts[1],'cs',label='0.5 T')\n", "    plt.plot(temps,carts[1],'c-')\n", "    plt.plot(temps,carts[2],'k^',label='0.1 T')\n", "    plt.plot(temps,carts[2],'k-')\n", "    plt.title(specimen+' : Lowrie 3-D IRM')\n", "    plt.legend();\n", "    cnt+=1\n", "\n", "        "]}, {"block": 488, "type": "markdown", "linesLength": 5, "startIndex": 2099, "lines": ["### pca\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#pca.py)\n", "\n", "**pca**  calculates best-fit lines, planes or Fisher means through selected treatment steps along with Kirschvink (1980, doi:  10.1111/j.1365-246X.1980.tb02601.x) MAD values. The file format is a simple space delimited file with specimen name, treatment step, intensity, declination and inclination. **pca**  calls **pmag.domean()**, so that is what we will do here. "]}, {"block": 489, "type": "code", "linesLength": 1, "startIndex": 2104, "lines": ["help(pmag.domean)"]}, {"block": 490, "type": "code", "linesLength": 9, "startIndex": 2105, "lines": ["# read in data as space delimited file\n", "data=pd.read_csv('data_files/pca/pca_example.txt',\\\n", "                 delim_whitespace=True,header=None)\n", "# we need to add a column for quality\n", "data['quality']='g'\n", "# strip off the specimen name and reorder records \n", "#  from:  int,dec,inc to: dec,inc,int \n", "data=data[[1,3,4,2,'quality']].values.tolist()\n", "pmag.domean(data,1,10,'DE-BFL')"]}, {"block": 491, "type": "markdown", "linesLength": 3, "startIndex": 2114, "lines": ["### plotXY\n", "\n", "This can be done directly with matplotlib."]}, {"block": 492, "type": "markdown", "linesLength": 5, "startIndex": 2117, "lines": ["### plot_cdf\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#plot_cdf.py)\n", "\n", "This program reads in a data file, sorts it and plots the data as a cumulative distribution function (using **pmagplotlib.plot_cdf()**.  But we can do this directly from within the notebook without much fuss. And for plot_2cdfs, just do this twice.  \n"]}, {"block": 493, "type": "code", "linesLength": 10, "startIndex": 2122, "lines": ["# read the data in\n", "data=np.loadtxt('data_files/plot_cdf/gaussian.out')\n", "# sort the data\n", "x=np.sort(data)\n", "# create a y array\n", "y=np.linspace(0,1,data.shape[0])\n", "plt.plot(x,y,'r-')\n", "# label\n", "plt.xlabel('Data')\n", "plt.ylabel('Cumulative Distribution');"]}, {"block": 494, "type": "markdown", "linesLength": 7, "startIndex": 2132, "lines": ["### plot_geomagia\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#plot_geomagia.py)\n", "\n", "Geomagia is a database specially designed for archaeomagnetic and volcanic data for the last 50 kyr with a friendly search interface.   **plot_geomagia**   is meant to plot data from files downloaded from the geomagia website: http://geomagia.gfz-potsdam.de/geomagiav3/AAquery.php.  We can do this within the notebook.  The example used here  was for Sicily so if we felt like it, we could combine it with the **ipmag.igrf()** using one of the data models (which are in large part based on data in the geomagia database.  \n", "\n", "Here we want to plot inclination as a function of age.  "]}, {"block": 495, "type": "code", "linesLength": 2, "startIndex": 2139, "lines": ["geomagia=pd.read_csv('data_files/geomagia/geomagia_sel.txt',header=1)\n", "geomagia.head()"]}, {"block": 496, "type": "markdown", "linesLength": 1, "startIndex": 2141, "lines": ["We have to 'clean' the dataset by getting rid of the records with no inclinations (-999)  We can use Panda's filtering power for that: "]}, {"block": 497, "type": "code", "linesLength": 2, "startIndex": 2142, "lines": ["geomagia_incs=geomagia[geomagia['Inc[deg.]']>-90]\n", "geomagia_incs['Inc[deg.]']"]}, {"block": 498, "type": "code", "linesLength": 3, "startIndex": 2144, "lines": ["plt.plot(geomagia_incs['Age[yr.AD]'],geomagia_incs['Inc[deg.]'],'ro')\n", "plt.xlabel('Age (CE)')\n", "plt.ylabel('Inclination');"]}, {"block": 499, "type": "markdown", "linesLength": 6, "startIndex": 2147, "lines": ["### plot_mag_map\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#plot_mag_map.py)\n", "\n", "This program was designed to make color contour maps of geomagnetic field elements drawn from various IGRF-like field models (see also [igrf](#igrf)).  \n", "It calls **pmag.do_mag_map())** to generate arrays for plotting with the **pmagplotlib.plot_mag_map()** function.   We can do that from within this notebook.  NB: The cartopy version of this is still a bit buggy and functions best with the PlateCarree projection.  "]}, {"block": 500, "type": "code", "linesLength": 1, "startIndex": 2153, "lines": ["help(pmag.do_mag_map)"]}, {"block": 501, "type": "code", "linesLength": 3, "startIndex": 2154, "lines": ["# define some useful parameters\n", "date,mod,lon_0,alt,ghfile=1956.0725,'cals10k.2',0,0,\"\" # only date is required\n", "Ds,Is,Bs,Brs,lons,lats=pmag.do_mag_map(date,mod=mod,lon_0=lon_0,alt=alt,file=ghfile)"]}, {"block": 502, "type": "code", "linesLength": 1, "startIndex": 2157, "lines": ["help(pmagplotlib.plot_mag_map)"]}, {"block": 503, "type": "code", "linesLength": 10, "startIndex": 2158, "lines": ["cmap='RdYlBu' # nice color map for contourf\n", "if has_cartopy:\n", "    pmagplotlib.plot_mag_map(1,Bs,lons,lats,'B',date=date,proj='Mollweide',contours=True) # plot the field strength\n", "    pmagplotlib.plot_mag_map(2,Is,lons,lats,'I',date=date,proj='Mollweide',contours=True)# plot the inclination\n", "    pmagplotlib.plot_mag_map(3,Ds,lons,lats,'D',date=date,contours=True)# plot the declination    \n", "elif has_basemap:\n", "    pmagplotlib.plot_mag_map_basemap(1,Bs,lons,lats,'B',date=date) # plot the field strength\n", "    pmagplotlib.plot_mag_map_basemap(2,Is,lons,lats,'I',date=date)# plot the inclination\n", "    pmagplotlib.plot_mag_map_basemap(3,Ds,lons,lats,'D',date=date)# plot the declination\n", "    "]}, {"block": 504, "type": "markdown", "linesLength": 7, "startIndex": 2168, "lines": ["### plot_map_pts\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#plot_map_pts.py)\n", "\n", "This program will generate a simple map of the data points read from a file (lon lat) on the desired projection. If you want to use high resolution or the etopo20 meshgrid with basemap, you must install the etopo20 data files (run  **install_etopo.py** from the command line).\n", "\n", "This program sets  a bunch of options and calls **pmagplotlib.plot_map()**.  Note, if Basemap is  installed, you can use **pmagplotlib.plot_map_basemap()** instead which uses the older (but less buggy) and soon to be deprecated **Basemap** plotting package.   \n"]}, {"block": 505, "type": "code", "linesLength": 1, "startIndex": 2175, "lines": ["help(pmagplotlib.plot_map)"]}, {"block": 506, "type": "code", "linesLength": 18, "startIndex": 2176, "lines": ["# read in some data: \n", "# this is the cartopy version\n", "data=np.loadtxt('data_files/plot_map_pts/uniform.out').transpose()\n", "lons=data[0] # longitudes array\n", "lats=data[1] # latitudes array\n", "# set some options \n", "Opts={}\n", "Opts['sym']='bo' # sets the symbol to white dots\n", "Opts['symsize']=3 # sets symbol size to 3 pts\n", "Opts['proj']='robin' # Robinson projection\n", "Opts['details']={}\n", "Opts['details']['coasts']=True\n", "plt.figure(1,(10,10)) # optional - make a map\n", "if has_cartopy:\n", "    pmagplotlib.plot_map(1, lats, lons, Opts)\n", "elif has_basemap:\n", "    pmagplotlib.plot_map_basemap(1, lats, lons, Opts)\n", "    "]}, {"block": 507, "type": "code", "linesLength": 19, "startIndex": 2194, "lines": ["# read in some data: \n", "data=np.loadtxt('data_files/plot_map_pts/uniform.out').transpose()\n", "lons=data[0] # longitudes array\n", "lats=data[1] # latitudes array\n", "# set some options \n", "Opts={}\n", "Opts['sym']='wo' # sets the symbol to white dots\n", "Opts['symsize']=3 # sets symbol size to 10 pts\n", "Opts['proj']='pc' # orthographic projection\n", "Opts['edge']='black'\n", "Opts['details']={}\n", "Opts['details']['fancy']=True # this option takes a while....   \n", "if has_cartopy:\n", "    plt.figure(1,(8,8)) # optional - make a map\n", "    pmagplotlib.plot_map(1, lats, lons, Opts)   \n", "elif has_basemap: # this only works if you have basemap installed\n", "    plt.figure(1,(6,6)) # optional - make a map\n", "    pmagplotlib.plot_map_basemap(1, lats, lons, Opts)\n", "    "]}, {"block": 508, "type": "markdown", "linesLength": 1, "startIndex": 2213, "lines": ["Here's an example with a simple site location."]}, {"block": 509, "type": "code", "linesLength": 25, "startIndex": 2214, "lines": ["Opts={}\n", "Opts['sym']='r*' # sets the symbol to white dots\n", "Opts['symsize']=100 # sets symbol size to 3 pts\n", "Opts['proj']='lcc' # Robinson projection\n", "Opts['pltgrid']=True\n", "Opts['lat_0']=33\n", "Opts['lon_0']=260\n", "Opts['latmin']=20\n", "Opts['latmax']=52\n", "Opts['lonmin']=-130\n", "Opts['lonmax']=-70\n", "Opts['gridspace']=10\n", "Opts['details']={}\n", "Opts['details']['coasts']=True\n", "Opts['details']['ocean']=True\n", "Opts['details']['countries']=True\n", "Opts['global']=False\n", "lats,lons=[33],[-117]\n", "plt.figure(1,(10,10)) # optional - make a map\n", "if has_cartopy:\n", "    pmagplotlib.plot_map(1, lats, lons, Opts)\n", "elif has_basemap:\n", "    pmagplotlib.plot_map_basemap(1, lats, lons, Opts)\n", "\n", "    \n"]}, {"block": 510, "type": "markdown", "linesLength": 8, "startIndex": 2239, "lines": ["### plotdi_a\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#plotdi_a.py)\n", "\n", "\n", "**plotdi_a** reads in a data file with declination, inclination and $\\alpha_{95}$ data in it and plots the directions along with the confidence circles.  \n", "\n", "We can use the function **ipmag.plot_di_mean()** for this.  \n"]}, {"block": 511, "type": "code", "linesLength": 1, "startIndex": 2247, "lines": ["help(ipmag.plot_di_mean)"]}, {"block": 512, "type": "code", "linesLength": 11, "startIndex": 2248, "lines": ["# read in some data\n", "data=np.loadtxt('data_files/plotdi_a/plotdi_a_example.dat').transpose()\n", "decs=data[0] # array of declinations\n", "incs=data[1] # array of inclinations\n", "a95s=data[2] # array of alpha95s\n", "# make the plots\n", "fignum=1\n", "plt.figure(num=fignum,figsize=(3,3)) # make a figure object\n", "ipmag.plot_net(fignum) # plot the equal area net\n", "for pt in range(decs.shape[0]): # step through the data\n", "    ipmag.plot_di_mean(dec=decs[pt],inc=incs[pt],a95=a95s[pt],color='blue')\n"]}, {"block": 513, "type": "markdown", "linesLength": 10, "startIndex": 2259, "lines": ["### polemap_magic\n", "\n", "\n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#polemap_magic.py)\n", "\n", "**polemap_magic** plots poles from a MagIC formatted **locations.txt** file.  Alternatively, we \n", " can use **ipmag.plot_vgp()** for this, but substituting paleomagnetic poles for VGPs (the math is the same).  We'll try this out on a set of poles downloaded from the MagIC database for the Cretaceous of Europe.   \n", " \n", " Let's try it both ways, first with **ipmag.plot_vgp( )**:\n"]}, {"block": 514, "type": "code", "linesLength": 1, "startIndex": 2269, "lines": ["help(ipmag.plot_vgp)"]}, {"block": 515, "type": "code", "linesLength": 1, "startIndex": 2270, "lines": ["help(ipmag.make_orthographic_map)"]}, {"block": 516, "type": "code", "linesLength": 18, "startIndex": 2271, "lines": ["data=pd.read_csv('data_files/polemap_magic/locations.txt',sep='\\t',header=1)\n", "lats=data['pole_lat'].values\n", "lons=data['pole_lon'].values\n", "if has_cartopy:\n", "    map_axis =ipmag.make_orthographic_map(central_latitude=90,figsize=(6,6),land_color='bisque')\n", "    ipmag.plot_vgp(map_axis, vgp_lon=lons, vgp_lat=lats,\\\n", "                   markersize=20, legend='no')    \n", "    \n", "elif has_basemap:\n", "    m = Basemap(projection='ortho',lat_0=90,lon_0=0)\n", "    plt.figure(figsize=(6, 6))\n", "    m.drawcoastlines(linewidth=0.25)\n", "    m.fillcontinents(color='bisque',lake_color='white',zorder=1)\n", "    m.drawmapboundary(fill_color='white')\n", "    m.drawmeridians(np.arange(0,360,30))\n", "    m.drawparallels(np.arange(-90,90,30))\n", "    ipmag.plot_vgp_basemap(m, vgp_lon=lons, vgp_lat=lats, color='k', marker='o', \\\n", "                   markersize=20, legend='no')"]}, {"block": 517, "type": "markdown", "linesLength": 1, "startIndex": 2289, "lines": ["Alternatively, you can use the function **ipmag.polemap_magic**."]}, {"block": 518, "type": "code", "linesLength": 1, "startIndex": 2290, "lines": ["help(ipmag.polemap_magic)"]}, {"block": 519, "type": "code", "linesLength": 1, "startIndex": 2291, "lines": ["ipmag.polemap_magic('data_files/polemap_magic/locations.txt', save_plots=False)"]}, {"block": 520, "type": "markdown", "linesLength": 11, "startIndex": 2292, "lines": ["### pt_rot\n", "\n", "\n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html) \n", "[\\[Essentials Appendix A.3.5\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap1.html)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#pt_rot.py)\n", "\n", "\n", "\n", "This program finds rotation poles  for a specified location, age and destination plate, then rotates the point into the destination plate coordinates using the roations and methods described in Essentials Appendix A.3.5.  \n", "This can be done for you using the function **frp.get_pole()** in the finite rotation pole module called **pmagpy.frp**. You then call **pmag.pt_rot()** to do the rotation.  Let's do this for to rotate the Cretaceous poles from Europe (sane data as in the polemap_magic example) and rotate them to South African coordinates.  \n"]}, {"block": 521, "type": "code", "linesLength": 3, "startIndex": 2303, "lines": ["# need to load this special module\n", "import pmagpy.frp as frp\n", "help(frp.get_pole)"]}, {"block": 522, "type": "code", "linesLength": 2, "startIndex": 2306, "lines": ["Prot=frp.get_pole('eur',100)\n", "Prot"]}, {"block": 523, "type": "code", "linesLength": 1, "startIndex": 2308, "lines": ["help(pmag.pt_rot)"]}, {"block": 524, "type": "code", "linesLength": 4, "startIndex": 2309, "lines": ["data=pd.read_csv('data_files/polemap_magic/locations.txt',sep='\\t',header=1)\n", "lats=data['pole_lat'].values\n", "lons=data['pole_lon'].values\n", "RLats,RLons=rot_pts=pmag.pt_rot(Prot,lats,lons)"]}, {"block": 525, "type": "markdown", "linesLength": 1, "startIndex": 2313, "lines": ["And now we can plot them using **pmagplotlib.plot_map()**"]}, {"block": 526, "type": "code", "linesLength": 18, "startIndex": 2314, "lines": ["Opts={}\n", "Opts['sym']='wo' # sets the symbol\n", "Opts['symsize']=10\n", "Opts['proj']='ortho'\n", "Opts['edge']='black'\n", "Opts['lat_0']=90\n", "Opts['details']={}\n", "Opts['details']['fancy']=True # warning : this option takes a few minutes\n", "if has_cartopy:\n", "    plt.figure(1,(6,6)) # optional - make a map\n", "    pmagplotlib.plot_map(1, RLats, RLons, Opts)\n", "elif has_basemap:\n", "    plt.figure(1,(6,6)) # optional - make a map\n", "    pmagplotlib.plot_map_basemap(1, RLats, RLons, Opts)\n", "\n", "\n", "    \n", "    "]}, {"block": 527, "type": "markdown", "linesLength": 6, "startIndex": 2332, "lines": ["### qqplot\n", "\n", "[\\[Essentials Appendix B.1.5\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ap2.html)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#qqplot.py)\n", "\n", "**qqplot** makes  a quantile-quantile plot of the input data file against a normal distribution. The plot has the mean, standard deviation and the $D$ statistic as well as the $D_c$ statistic expected from a normal distribution. We can read in a data file and then call **pmagplotlib.plot_qq_norm()**. Let's reprise the [**gaussian**](#gaussian) example from before and test if the data are in fact likely to be normally distributed.    \n"]}, {"block": 528, "type": "code", "linesLength": 1, "startIndex": 2338, "lines": ["data=list(pmag.gaussdev(10,3,100))"]}, {"block": 529, "type": "code", "linesLength": 1, "startIndex": 2339, "lines": ["help(pmagplotlib.plot_qq_norm)"]}, {"block": 530, "type": "code", "linesLength": 2, "startIndex": 2340, "lines": ["D,Dc=pmagplotlib.plot_qq_norm(1,data,'')\n", "print (D,Dc)"]}, {"block": 531, "type": "markdown", "linesLength": 1, "startIndex": 2342, "lines": ["Whew!  it worked this time.  It will fail about 5% of the time.  "]}, {"block": 532, "type": "markdown", "linesLength": 7, "startIndex": 2343, "lines": ["### qqunf\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#qqunf.py)\n", "\n", "This program is very much like [**qqplot**](#qqplot) and [**fishqq**](#fishqq) which plot data against a normal and Fisherian distributions respectively.  In fact **fishqq** plots the declination values against a uniform distribution just like **qqunf**. \n", "\n", "**qqunf.py** (the command line version) calls **pmagplotlib.plot_qq_unf()**.  To demonstrate the functionality of **qqplot**, we can generate a simulated data set with **random.uniform()**, inspect it with a histogram and then test whether it is likely to actually have been drawn from a uniform distribution (95% confidence) using **pmagplotlib.plot_qq_unf()**."]}, {"block": 533, "type": "code", "linesLength": 3, "startIndex": 2350, "lines": ["import numpy.random as random\n", "uniform=random.uniform(0,100,size=100)\n", "plt.hist(uniform,histtype='step',color='blue',density=True,facecolor='white')"]}, {"block": 534, "type": "code", "linesLength": 1, "startIndex": 2353, "lines": ["Mu,Mu_0=pmagplotlib.plot_qq_unf(1,uniform,\"\",degrees=False)"]}, {"block": 535, "type": "markdown", "linesLength": 6, "startIndex": 2354, "lines": ["### revtest\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#revtest.py)\n", "\n", "**revtest** uses the boostrap reversals test described in detail in [\\[Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html) of the online text book \"Essentials of Paleomagnetism\".  It splits the data into two polarity groups, flips the \"reverse\" mode to its antipodes and does the test for [common_mean](#common_mean) on the two groups.   It has been implemented for notebooks as **ipmag.reversal_test_bootstrap())**.  "]}, {"block": 536, "type": "code", "linesLength": 1, "startIndex": 2360, "lines": ["help(ipmag.reversal_test_bootstrap)"]}, {"block": 537, "type": "code", "linesLength": 2, "startIndex": 2361, "lines": ["di_block=np.loadtxt('data_files/revtest/revtest_example.txt')\n", "ipmag.reversal_test_bootstrap(di_block=di_block,plot_stereo=True)"]}, {"block": 538, "type": "markdown", "linesLength": 8, "startIndex": 2363, "lines": ["### revtest_magic\n", "\n", "[\\[Essentials Chapter 12\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch12.html)\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#revtest_magic.py)\n", "\n", "\n", "This is the same idea as **revtest** but reads in MagIC formatted data files.  We will do this the **Pandas** way.  "]}, {"block": 539, "type": "code", "linesLength": 4, "startIndex": 2371, "lines": ["data=pd.read_csv('data_files/revtest_magic/sites.txt',sep='\\t',header=1)\n", "decs=data.dir_dec.values\n", "incs=data.dir_inc.values\n", "ipmag.reversal_test_bootstrap(dec=decs,inc=incs,plot_stereo=True)"]}, {"block": 540, "type": "markdown", "linesLength": 3, "startIndex": 2375, "lines": ["### revtest_mm1990\n", "\n", "This program has been deprecated as it  is the same as [watsons_v](#watons_v) - check that one out. "]}, {"block": 541, "type": "markdown", "linesLength": 7, "startIndex": 2378, "lines": ["### s_eigs\n", "\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#s_eigs.py)\n", "\n", "This program converts  the six tensor elements to eigenparameters - the inverse of [eigs_s](#eigs_s).  \n", "We can call the function **pmag.doseigs()** from the notebook.  \n"]}, {"block": 542, "type": "code", "linesLength": 1, "startIndex": 2385, "lines": ["help(pmag.doseigs)"]}, {"block": 543, "type": "code", "linesLength": 5, "startIndex": 2386, "lines": ["Ss=np.loadtxt('data_files/s_eigs/s_eigs_example.dat')\n", "for s in Ss:\n", "    tau,V=pmag.doseigs(s)\n", "    print ('%f %8.2f %8.2f %f %8.2f %8.2f %f %8.2f %8.2f'%\\\n", "           (tau[2],V[2][0],V[2][1],tau[1],V[1][0],V[1][1],tau[0],V[0][0],V[0][1]))"]}, {"block": 544, "type": "markdown", "linesLength": 5, "startIndex": 2391, "lines": ["### s_geo\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#s_geo.py)\n", "\n", "**s_geo** takes the 6 tensor elements in specimen coordinates and applies the rotation similar to [**di_geo**](#di_geo).  To do this we will call **pmag.dosgeo()** from within the notebook.   \n"]}, {"block": 545, "type": "code", "linesLength": 1, "startIndex": 2396, "lines": ["help(pmag.dosgeo)"]}, {"block": 546, "type": "code", "linesLength": 3, "startIndex": 2397, "lines": ["Ss=np.loadtxt('data_files/s_geo/s_geo_example.dat')\n", "for s in Ss:\n", "    print(pmag.dosgeo(s[0:6],s[6],s[7]))\n"]}, {"block": 547, "type": "markdown", "linesLength": 6, "startIndex": 2400, "lines": ["### s_hext\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#s_hext.py)\n", "\n", "**s_hext** calculates Hext (1963, doi: 10.2307/2333905) statistics for anisotropy data in the six tensor element format.  \n", "It  calls **pmag.dohext()**.   \n"]}, {"block": 548, "type": "code", "linesLength": 1, "startIndex": 2406, "lines": ["help(pmag.dohext)"]}, {"block": 549, "type": "markdown", "linesLength": 1, "startIndex": 2407, "lines": ["We are working with data that have no sigmas attached to them and want to average all the values in the file together.  Let's look at the rotated data from the [**s_geo**](#s_geo) example.  "]}, {"block": 550, "type": "code", "linesLength": 9, "startIndex": 2408, "lines": ["# read in the data\n", "Ss=np.loadtxt('data_files/s_geo/s_geo_example.dat')\n", "# make a container for the rotated S values\n", "SGeos=[]\n", "for s in Ss:\n", "    SGeos.append(pmag.dosgeo(s[0:6],s[6],s[7]))\n", "nf,sigma,avs=pmag.sbar(SGeos)  # get the average over all the data\n", "hpars=pmag.dohext(nf,sigma,avs)\n", "print(hpars)"]}, {"block": 551, "type": "markdown", "linesLength": 5, "startIndex": 2417, "lines": ["### s_magic\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#s_magic.py)\n", "\n", "NEED TO ADD THIS ONE....  "]}, {"block": 552, "type": "markdown", "linesLength": 5, "startIndex": 2422, "lines": ["### s_tilt\n", "\n", "[\\[Essentials Chapter 13\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch13.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#s_tilt.py)\n", "\n", "**s_tilt** takes the 6 tensor elements in geographic coordinates and applies the rotation similar to [**di_tilt**](#di_tilt) into stratigraphic coordinates.  It  calls **pmag.dostilt()**.  But be careful!  **s_tilt.py** (the command line program) assumes that the bedding info is the strike, with the dip to the right of strike unlike **pmag.dostilt** which assumes that the azimuth is the dip direction.     "]}, {"block": 553, "type": "code", "linesLength": 1, "startIndex": 2427, "lines": ["help(pmag.dostilt)"]}, {"block": 554, "type": "code", "linesLength": 4, "startIndex": 2428, "lines": ["# note that the data in this example are Ss and strike and dip (not bed_az,bed_pl)\n", "Ss=np.loadtxt('data_files/s_tilt/s_tilt_example.dat')\n", "for s in Ss:\n", "    print(pmag.dostilt(s[0:6],s[6]+90.,s[7])) # make the bedding azimuth dip direction, not strike. \n"]}, {"block": 555, "type": "markdown", "linesLength": 17, "startIndex": 2432, "lines": ["### scalc\n", "\n", "[\\[Essentials Chapter 14\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch14.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#scalc.py)\n", "\n", "\n", "This program reads in data files with vgp_lon, vgp_lat and optional kappa, N, and site latitude.\n", "It allows some filtering based on the requirements of the study, such as:\n", "- Fisher k cutoff\n", "- VGP latitudinal cutoff\n", "- Vandamme (1994, doi: 10.1016/0031-9201(94)90012-4) iterative cutoff\n", "- flipping the reverse mode to antipodes\n", "- rotating principle direction to the spin axis\n", "- bootstrap confidence bounds\n", "- optionally calculates the scatter (Sp or Sf of McElhinny & McFadden, 1997) of VGPs\n", "with  correction for within site scatter.  \n", "\n", "The filtering is just what **Pandas** was designed for, so we can  calls **pmag.scalc_vgp_df()** which works on a suitably constructed  **Pandas** DataFrame.   \n"]}, {"block": 556, "type": "code", "linesLength": 1, "startIndex": 2449, "lines": ["help(pmag.scalc_vgp_df)"]}, {"block": 557, "type": "markdown", "linesLength": 1, "startIndex": 2450, "lines": ["To just calculate the value of S (without the within site scatter) we read in a data file and attach the correct headers to it depending on what is in it."]}, {"block": 558, "type": "code", "linesLength": 11, "startIndex": 2451, "lines": ["vgp_df=pd.read_csv('data_files/scalc/scalc_example.txt',delim_whitespace=True,header=None)\n", "if len(list(vgp_df.columns))==2:\n", "    vgp_df.columns=['vgp_lon','vgp_lat']\n", "    vgp_df['dir_k'],vgp_df['dir_n'],vgp_df['lat']=0,0,0\n", "else:\n", "    vgp_df.columns=['vgp_lon','vgp_lat','dir_k','dir_n_samples','lat']\n", "pmag.scalc_vgp_df\n", "N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n", "\n", "\n"]}, {"block": 559, "type": "markdown", "linesLength": 1, "startIndex": 2462, "lines": ["To apply a cutoff for the Fisher k value, we just filter the DataFrame prior to calculating S_b. Let's filter for kappa>50"]}, {"block": 560, "type": "code", "linesLength": 4, "startIndex": 2463, "lines": ["N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,kappa=50)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n", "\n", "\n"]}, {"block": 561, "type": "markdown", "linesLength": 1, "startIndex": 2467, "lines": ["To apply the Vandamme (1994) approach, we set v to True"]}, {"block": 562, "type": "code", "linesLength": 2, "startIndex": 2468, "lines": ["N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,v=True)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n"]}, {"block": 563, "type": "markdown", "linesLength": 1, "startIndex": 2470, "lines": ["To flip the \"reverse\" directions, we set anti to 1"]}, {"block": 564, "type": "code", "linesLength": 2, "startIndex": 2471, "lines": ["N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,anti=True)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n"]}, {"block": 565, "type": "markdown", "linesLength": 1, "startIndex": 2473, "lines": ["And, to do relative to the spin axis, set spin to True: "]}, {"block": 566, "type": "code", "linesLength": 2, "startIndex": 2474, "lines": ["N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,spin=True)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n"]}, {"block": 567, "type": "markdown", "linesLength": 6, "startIndex": 2476, "lines": ["### scalc_magic\n", "\n", "[\\[Essentials Chapter 14\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch14.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#scalc_magic.py)\n", "\n", "\n", "This program does the same thing as [**scalc**](#scalc), but reads in a MagIC formatted file. So, we can do that easy-peasy."]}, {"block": 568, "type": "code", "linesLength": 3, "startIndex": 2482, "lines": ["vgp_df=pd.read_csv('data_files/scalc_magic/sites.txt',sep='\\t',header=1)\n", "N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,anti=True)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))\n"]}, {"block": 569, "type": "code", "linesLength": 3, "startIndex": 2485, "lines": ["vgp_df=pd.read_csv('data_files/scalc_magic/sites.txt',sep='\\t',header=1)\n", "N,S_B,low,high,cutoff=pmag.scalc_vgp_df(vgp_df,anti=True,spin=True)\n", "print(N, '%7.1f  %7.1f ' % (S_B, cutoff))"]}, {"block": 570, "type": "markdown", "linesLength": 3, "startIndex": 2488, "lines": ["### separate_directions\n", "\n", "Like [pmag.flip( )](#flip), **pmag.separate_directions** divides a directional data set into two modes.  Unlike [pmag.flip( )](#flip), it returns the two separate modes (e.g., normal and reverse)"]}, {"block": 571, "type": "code", "linesLength": 1, "startIndex": 2491, "lines": ["help(pmag.separate_directions)"]}, {"block": 572, "type": "code", "linesLength": 9, "startIndex": 2492, "lines": ["#read in the data into an array\n", "vectors=np.loadtxt('data_files/eqarea_ell/tk03.out').transpose()\n", "di_block=vectors[0:2].transpose() # decs are di_block[0], incs are di_block[1]\n", "# flip the reverse directions to their normal antipodes\n", "normal,reverse=pmag.separate_directions(di_block)\n", "# and plot them up\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=normal,color='red')\n", "ipmag.plot_di(di_block=reverse,color='b')"]}, {"block": 573, "type": "markdown", "linesLength": 9, "startIndex": 2501, "lines": ["### squish\n", "\n", "[\\[Essentials Chapter 7\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch7.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#squish.py)\n", "\n", "\n", "\n", "This program reads in dec/inc data and \"squishes\" the inclinations using the formula from King \n", "(1955, doi: 10.1111/j.1365-246X.1955.tb06558.x)  $\\tan(I_o)=flat \\tan(I_f)$.  \\[See also [unsquish](#unsquish)\\]. \n", "We can call **pmag.squish()** from within the notebook.  "]}, {"block": 574, "type": "code", "linesLength": 1, "startIndex": 2510, "lines": ["help(pmag.squish)"]}, {"block": 575, "type": "code", "linesLength": 5, "startIndex": 2511, "lines": ["di_block=np.loadtxt('data_files/squish/squish_example.dat').transpose()\n", "decs=di_block[0]\n", "incs=di_block[1]\n", "flat=.4\n", "fincs=pmag.squish(incs,flat)"]}, {"block": 576, "type": "code", "linesLength": 4, "startIndex": 2516, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(dec=decs,inc=incs,title='Original',color='blue')\n", "ipmag.plot_net(2)\n", "ipmag.plot_di(dec=decs,inc=fincs,title='Squished',color='red')"]}, {"block": 577, "type": "markdown", "linesLength": 5, "startIndex": 2520, "lines": ["### stats\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html#x15-156000813) [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#/stats.py)\n", "\n", "This program just calculates the N, mean, sum, sigma and sigma % for data.  Obviously, there are numerous ways to do that in **Numpy**, so let's just use those."]}, {"block": 578, "type": "code", "linesLength": 2, "startIndex": 2525, "lines": ["data=np.loadtxt('data_files/gaussian/gauss.out')\n", "print (data.shape[0],data.mean(),data.sum(),data.std())"]}, {"block": 579, "type": "markdown", "linesLength": 9, "startIndex": 2527, "lines": ["### strip_magic\n", "\n", "[\\[Essentials Chapter 15\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch15.html)\n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#strip_magic.py)\n", "\n", "\n", "\n", "This is program is a dinosaur and can be much more easily done using the wonders of **Pandas** and **matplotlib** as demonstrated here.  "]}, {"block": 580, "type": "code", "linesLength": 7, "startIndex": 2536, "lines": ["# read in the data\n", "data=pd.read_csv('data_files/strip_magic/sites.txt',sep='\\t',header=1)\n", "# see what's there\n", "data.columns\n", "\n", "# you might have to use **df.dropna()** to clean off unwanted NaN lines or other data massaging\n", "# but not for this example"]}, {"block": 581, "type": "code", "linesLength": 7, "startIndex": 2543, "lines": ["plt.figure(1,(10,4)) # make the figure\n", "plt.plot(data.age,data.vgp_lat,'b-') # plot as blue line\n", "plt.plot(data.age,data.vgp_lat,'ro',markeredgecolor=\"black\") # plot as red dots with black rims\n", "plt.xlabel('Age (Ma)') # label the time axis\n", "plt.ylabel('VGP Lat.$^{\\circ}$')\n", "plt.ylim(-90,90) # set the plot limits\n", "plt.axhline(color='black'); # put on a zero line"]}, {"block": 582, "type": "markdown", "linesLength": 9, "startIndex": 2550, "lines": ["### sundec\n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#sundec.py)\n", "\n", "Paleomagnetists often use the sun to orient their cores, especially if the sampling site is strongly magnetic and would deflect the magnetic compass.  The information required is: where are you (e.g., latitude and longitude), what day is it, what time is it in Greenwhich Mean Time (a.k.a. Universal Time) and where is the sun (e.g., the antipode of the angle the shadow of a gnomon makes with the desired direction)?\n", "\n", "This calculation is surprisingly accurate and was implemented in the function \n", " **pmag.dosundec()**.  "]}, {"block": 583, "type": "code", "linesLength": 1, "startIndex": 2559, "lines": ["help(pmag.dosundec)"]}, {"block": 584, "type": "markdown", "linesLength": 2, "startIndex": 2560, "lines": ["\n", "Say you (or your elderly colleague) were located at 35$^{\\circ}$ N and 33$^{\\circ}$ E. The local time was three hours ahead of Universal Time. The shadow angle for the drilling direction was 68$^{\\circ}$  measured at 16:09 on May 23, 1994. **pmag.dosundec()** requires a dictionary with the necessary information: "]}, {"block": 585, "type": "code", "linesLength": 3, "startIndex": 2562, "lines": ["sundata={'delta_u':3,'lat':35,'lon':33,\\\n", "         'date':'1994:05:23:16:9','shadow_angle':68}\n", "print ('%7.1f'%(pmag.dosundec(sundata)))\n"]}, {"block": 586, "type": "markdown", "linesLength": 6, "startIndex": 2565, "lines": ["### tk03\n", "\n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#tk03.py)\n", "\n", "Sometimes it is useful to generate a distribution of synthetic geomagnetic field vectors that you might expect to find from paleosecular variation of the geomagnetic field. The program **tk03** generates distributions of field vectors from the PSV model of Tauxe and Kent (2004, doi: 10.1029/145GM08).  This program was implemented for notebook use as **ipmag.tk03()**.  \\[See also [**find_ei**](#find_ei)\\]. "]}, {"block": 587, "type": "code", "linesLength": 1, "startIndex": 2571, "lines": ["help(ipmag.tk03)"]}, {"block": 588, "type": "code", "linesLength": 3, "startIndex": 2572, "lines": ["di_block=ipmag.tk03(lat=30)\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')"]}, {"block": 589, "type": "markdown", "linesLength": 13, "startIndex": 2575, "lines": ["### thellier_magic\n", "\n", "[\\[Essentials Chapter 10\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch10.html) \n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#thellier_magic.py)\n", "\n", "**thellier_magic** makes plots for Thellier-Thellier (Thellier E and Thellier O, 1959, Annales de Geophysique 15: 285\u2013378) type experimental data.   \n", "It reads in MagIC formatted data, sorts the data into datablocks for plotting as Arai (Nagata et al., 1963, doi: 10.1029/JZ068i018p05277) or  Zijderveld (Zijderveld, J. D. A. (1967). A.C. demagnetization of rocks: analysis of results. In D. Collinson, K. Creer, & S. Runcorn (Eds.), Methods in Paleomagnetism (pp. 254\u2013286). Amsterdam: Elsevier) as well as equal area projections and de (re) magnetization plots. \n", "\n", "For full functionality, you should use the Thellier GUI program (in **pmag_gui.py** from the command line), but within a notebook you can take a quick look using **ipmag.thellier_magic()**.  \n", "\n", "Here we will look at some data from Shaar et al. (2011, doi: 10.1016/j.epsl.2010.11.013).   \n", "\n"]}, {"block": 590, "type": "code", "linesLength": 3, "startIndex": 2588, "lines": ["# plot the first five specimens\n", "ipmag.thellier_magic(input_dir_path='data_files/thellier_magic/', \n", "                     n_specs=5, save_plots=False, fmt=\"png\") # s2s0-05 "]}, {"block": 591, "type": "markdown", "linesLength": 5, "startIndex": 2591, "lines": ["### uniform\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#uniform.py)\n", "\n", "It is at times handy to be able to generate a uniformly distributed set of directions (or geographic locations). This is done using a technique described by Fisher et al. (Fisher, N. I., Lewis, T., & Embleton, B. J. J. (1987). Statistical Analysis of Spherical Data. Cambridge: Cambridge University Press).   **uniform** does that by calling  **pmag.get_unf()**.   "]}, {"block": 592, "type": "code", "linesLength": 1, "startIndex": 2596, "lines": ["help(pmag.get_unf)"]}, {"block": 593, "type": "code", "linesLength": 3, "startIndex": 2597, "lines": ["di_block=pmag.get_unf()\n", "ipmag.plot_net(1)\n", "ipmag.plot_di(di_block=di_block,color='red',edge='black')"]}, {"block": 594, "type": "markdown", "linesLength": 11, "startIndex": 2600, "lines": ["### unsquish\n", "\n", "[\\[Essentials Chapter 7\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch7.html#x15-156000813) \n", "[\\[Essentials Chapter 16\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch16.html#x15-156000813) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#unsquish.py)\n", "\n", "\n", "\n", "This program is just the inverse of [**squish**](#squish) in that it takes \"squished\" data and \"unsquishes\" them, assuming a King (1955, doi: 10.1111/j.1365-246X.1955.tb06558.x)  relationship:  $\\tan(I_o)=flat \\tan(I_f)$. So, $\\tan(I_f) = \\tan(I_o)/flat$. \n", "\n", "It calls **pmag.unquish()**.  "]}, {"block": 595, "type": "code", "linesLength": 1, "startIndex": 2611, "lines": ["help(pmag.unsquish)"]}, {"block": 596, "type": "code", "linesLength": 5, "startIndex": 2612, "lines": ["di_block=np.loadtxt('data_files/unsquish/unsquish_example.dat').transpose()\n", "decs=di_block[0]\n", "incs=di_block[1]\n", "flat=.4\n", "fincs=pmag.unsquish(incs,flat)"]}, {"block": 597, "type": "code", "linesLength": 4, "startIndex": 2617, "lines": ["ipmag.plot_net(1)\n", "ipmag.plot_di(dec=decs,inc=incs,title='Squished',color='red')\n", "ipmag.plot_net(2)\n", "ipmag.plot_di(dec=decs,inc=fincs,title='Unsquished',color='blue')"]}, {"block": 598, "type": "markdown", "linesLength": 7, "startIndex": 2621, "lines": ["### vdm_b\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560002)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#vdm_b.py)\n", "\n", "\n", "\n", "**vdm_b** is the inverse of [**b_vdm**](#b_vdm) in that it converts a  Virtual \\[Axial\\] Dipole Moment (vdm or vadm) to a predicted geomagnetic field intensity observed at the earth's surface at a particular (paleo)latitude.  This  program calls **pmag.vdm_b()**."]}, {"block": 599, "type": "code", "linesLength": 1, "startIndex": 2628, "lines": ["help(pmag.vdm_b)"]}, {"block": 600, "type": "code", "linesLength": 1, "startIndex": 2629, "lines": ["print ('%7.1f microtesla'%(pmag.vdm_b(7.159e22,22)*1e6))"]}, {"block": 601, "type": "markdown", "linesLength": 6, "startIndex": 2630, "lines": ["### vector_mean\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html#x15-1560002)  [\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#vector_mean.py)\n", "\n", "**vector_mean** calculates the vector mean for a set of vectors in polar coordinates (e.g., declination, inclination, intensity).  This is similar to the Fisher mean ([**gofish**](#gofish)) but uses vector length instead of unit vectors.  It calls\n", "calls **pmag.vector_mean()**."]}, {"block": 602, "type": "code", "linesLength": 1, "startIndex": 2636, "lines": ["help(pmag.vector_mean)"]}, {"block": 603, "type": "code", "linesLength": 3, "startIndex": 2637, "lines": ["data=np.loadtxt('data_files/vector_mean/vector_mean_example.dat')\n", "Dir,R=pmag.vector_mean(data)\n", "print (('%i %7.1f %7.1f %f')%(data.shape[0],Dir[0],Dir[1],R))"]}, {"block": 604, "type": "markdown", "linesLength": 9, "startIndex": 2640, "lines": ["### vgp_di\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#vgp_di.py)\n", "\n", "\n", "We use **vgp_di** to convert Virtual Geomagnetic Pole positions to predicted directions.  \\[See also [**di_vgp**](#di_vgp)\\].\n", "\n", "This program uses the function **pmag.vgp_di()**.  "]}, {"block": 605, "type": "code", "linesLength": 1, "startIndex": 2649, "lines": ["help(pmag.vgp_di)"]}, {"block": 606, "type": "code", "linesLength": 2, "startIndex": 2650, "lines": ["d,i=pmag.vgp_di(68,191,33,243)\n", "print ('%7.1f %7.1f'%(d,i))"]}, {"block": 607, "type": "markdown", "linesLength": 10, "startIndex": 2652, "lines": ["### vgpmap_magic\n", "\n", "[\\[Essentials Chapter 2\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch2.html) \n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#vgpmap_magic.py)\n", "\n", "Plotting distributions of Virtual Geomagnetic Poles on many desired map projections is a frequent need in paleomagnetism.  **vgpmap_magic** reads in MagIC formatted files and has a number of plotting options.  It has been implemented into the **ipmag** module by Nick Swanson-Hysell as **ipmag.plot_vgp()**.  \n", "We cam use  **ipmag.plot_vgp()** after reading in a MagIC formatted sites.txt file. \n", "\n", "NB: you could also use **pmagplotlib.plot_map()** (see [**plot_map_pts**](#plot_map_pts)) if more options are desired. "]}, {"block": 608, "type": "code", "linesLength": 1, "startIndex": 2662, "lines": ["help(ipmag.plot_vgp)"]}, {"block": 609, "type": "code", "linesLength": 2, "startIndex": 2663, "lines": ["data=pd.read_csv('data_files/vgpmap_magic/sites.txt',sep='\\t',header=1)\n", "data.columns"]}, {"block": 610, "type": "code", "linesLength": 1, "startIndex": 2665, "lines": ["help(ipmag.make_orthographic_map)"]}, {"block": 611, "type": "code", "linesLength": 18, "startIndex": 2666, "lines": ["lats=data['vgp_lat'].values\n", "lons=data['vgp_lon'].values\n", "if has_cartopy:\n", "    map_axis =ipmag.make_orthographic_map(central_latitude=60,figsize=(6,6),land_color='bisque',\\\n", "                                          add_ocean=True,ocean_color='azure')\n", "    ipmag.plot_vgp(map_axis, vgp_lon=lons, vgp_lat=lats,\\\n", "                   markersize=50, legend='no',color='red')    \n", "    \n", "elif has_basemap:\n", "    m = Basemap(projection='ortho',lat_0=60,lon_0=0)\n", "    plt.figure(figsize=(6, 6))\n", "    m.drawcoastlines(linewidth=0.25)\n", "    m.fillcontinents(color='bisque',lake_color='azure',zorder=1)\n", "    m.drawmapboundary(fill_color='azure')\n", "    m.drawmeridians(np.arange(0,360,30))\n", "    m.drawparallels(np.arange(-90,90,30))\n", "    ipmag.plot_vgp_basemap(m, vgp_lon=lons, vgp_lat=lats, color='r', marker='o', \\\n", "                   markersize=50, legend='no')"]}, {"block": 612, "type": "markdown", "linesLength": 9, "startIndex": 2684, "lines": ["### watsons_f\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#watsons_f.py)\n", "\n", "There are several different ways of testing whether two sets of directional data share a common mean.  One popular (although perhaps not the best) way is to use Watson's F test (Watson, 1956, doi: 10.1111/j.1365-246X.1956.tb05560.x).   \\[See also [**watsons_v**](#watsons_v) or  Lisa Tauxe's bootstrap way: [**common_mean**](#common_mean)\\].  \n", "\n", "If you still want to use Waston's F, then try \n", " **pmag.watsons_f()** for this."]}, {"block": 613, "type": "code", "linesLength": 1, "startIndex": 2693, "lines": ["help(pmag.watsons_f)"]}, {"block": 614, "type": "code", "linesLength": 4, "startIndex": 2694, "lines": ["DI1=np.loadtxt('data_files/watsons_f/watsons_f_example_file1.dat')\n", "DI2=np.loadtxt('data_files/watsons_f/watsons_f_example_file2.dat')\n", "F,Fcrit=pmag.watsons_f(DI1,DI2)\n", "print ('%7.2f %7.2f'%(F,Fcrit))"]}, {"block": 615, "type": "markdown", "linesLength": 7, "startIndex": 2698, "lines": ["### watsons_v\n", "\n", "[\\[Essentials Chapter 11\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch11.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#watsons_v.py)\n", "\n", "Watson (1983, doi: 10.1016/0378-3758(83)90043-5) proposed a clever Monte Carlo type test for a common mean direction for two data sets.  This was implemented as \n", " **ipmag.common_mean_watson()**. \n"]}, {"block": 616, "type": "code", "linesLength": 1, "startIndex": 2705, "lines": ["help(ipmag.common_mean_watson)"]}, {"block": 617, "type": "code", "linesLength": 6, "startIndex": 2706, "lines": ["# use the same data as for watsons_f\n", "DI1=np.loadtxt('data_files/watsons_f/watsons_f_example_file1.dat')\n", "DI2=np.loadtxt('data_files/watsons_f/watsons_f_example_file2.dat')\n", "\n", "plt.figure(1,(5,5))\n", "ipmag.common_mean_watson(DI1,DI2,plot='yes')\n"]}, {"block": 618, "type": "markdown", "linesLength": 9, "startIndex": 2712, "lines": ["### zeq \n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html) \n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#zeq.py)\n", "\n", "**zeq** is a quick and dirty plotter for Zijderveld (Zijderveld, J. D. A. (1967). A.C. demagnetization of rocks: analysis of results. In D. Collinson, K. Creer, & S. Runcorn (Eds.), Methods in Paleomagnetism (pp. 254\u2013286). Amsterdam: Elsevier) diagrams.  It calls **pmagplotlib.plot_zed()** to do the plotting. \n", "\n", "This example plots the data in specimen coordinates = if other coordinate systems are desired, perform [**di_geo**](#di_geo) and [**di_tilt**](#di_tilt) steps first.  \n", "\n"]}, {"block": 619, "type": "code", "linesLength": 1, "startIndex": 2721, "lines": ["help(pmagplotlib.plot_zed)"]}, {"block": 620, "type": "code", "linesLength": 21, "startIndex": 2722, "lines": ["# we can make the figure dictionary that pmagplotlib likes:\n", "ZED={'eqarea':1,'zijd':2, 'demag':3}# make datablock\n", " # read in data\n", "data=pd.read_csv('data_files/zeq/zeq_example.dat',delim_whitespace=True,header=None)\n", "data.columns=['specimen','step','m (emu)','dec','inc']\n", "data['m SI']=data['m (emu)']*1e-3 # convert to SI units from lab (emu) units\n", "data['quality']='g' # add in default \"good\" quality designation\n", "data['step SI']=data['step']*1e-3 # convert to tesla \n", "data['blank']=\"\" # this is a dummy variable expected by plotZED\n", "specimens=data.specimen.unique()\n", "angle=0\n", "units='T' # these are AF data\n", "cnt=1\n", "for s in specimens:\n", "    # we can make the figure dictionary that pmagplotlib likes:\n", "    ZED={'eqarea':cnt,'zijd':cnt+1, 'demag':cnt+2}# make datablock\n", "    cnt+=3\n", "    spec_df=data[data.specimen==s]\n", "    datablock=spec_df[['step SI','dec','inc','m SI','blank','quality']].values.tolist()\n", "    pmagplotlib.plot_zed(ZED,datablock,angle,s,units)\n", "    \n"]}, {"block": 621, "type": "markdown", "linesLength": 8, "startIndex": 2743, "lines": ["### zeq_magic\n", "\n", "[\\[Essentials Chapter 9\\]](https://earthref.org/MagIC/books/Tauxe/Essentials/WebBook3ch9.html) \n", "[\\[MagIC Database\\]](https://earthref.org/MagIC)\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#zeq_magic.py)\n", "\n", "This program is the same as [**zeq**](#zeq) but for MagIC formatted input files.  This example plots the data in specimen coordinates = if other coordinate systems are desired, perform [**di_geo**](#di_geo) and [**di_tilt**](#di_tilt) steps first.\n", "\n"]}, {"block": 622, "type": "code", "linesLength": 3, "startIndex": 2751, "lines": [" # read in MagIC foramatted data\n", "dir_path='data_files/zeq_magic/'\n", "ipmag.zeq_magic(input_dir_path=dir_path, save_plots=False)"]}, {"block": 623, "type": "markdown", "linesLength": 1, "startIndex": 2754, "lines": ["## Other handy scripts"]}, {"block": 624, "type": "markdown", "linesLength": 5, "startIndex": 2755, "lines": ["### chartmaker\n", "\n", "[\\[command line version\\]](http://pmagpy.github.io/PmagPy-cli.html#chartmaker.py)\n", "\n", "Chartmaker makes a chart like this: "]}, {"block": 625, "type": "code", "linesLength": 1, "startIndex": 2760, "lines": ["Image('data_files/Figures/chartmaker.png')"]}, {"block": 626, "type": "markdown", "linesLength": 3, "startIndex": 2761, "lines": ["You can print it out and tape it to the oven in the lab to help keep track of this annoyingly complicated experiment.  :)  \n", "\n", "To make this from within a notebook, call **pmag.chart_maker()**. "]}, {"block": 627, "type": "code", "linesLength": 1, "startIndex": 2764, "lines": ["help(pmag.chart_maker)"]}, {"block": 628, "type": "markdown", "linesLength": 1, "startIndex": 2765, "lines": ["To perform 50 degree intervals from 100 to 500, followed by 10 degree intervals from 500 to 600 set up the Int and Top lists like this:"]}, {"block": 629, "type": "code", "linesLength": 2, "startIndex": 2766, "lines": ["Int=[50,10]\n", "Top=[500,600]"]}, {"block": 630, "type": "code", "linesLength": 1, "startIndex": 2768, "lines": ["pmag.chart_maker(Int,Top)"]}, {"block": 631, "type": "markdown", "linesLength": 1, "startIndex": 2769, "lines": ["You can now print out chart.txt.  Happy IZZI-ing.  "]}, {"block": 632, "type": "markdown", "linesLength": 1, "startIndex": 2770, "lines": ["## Clean up"]}, {"block": 633, "type": "code", "linesLength": 63, "startIndex": 2771, "lines": ["import glob\n", "\n", "# remove some individual files\n", "\n", "filenames = ['chart.txt',\n", "            'data_files/azdip_magic/samples.txt', 'data_files/download_magic/criteria.txt', \n", "            'data_files/orientation_magic/samples.txt', 'data_files/orientation_magic/sites.txt',\n", "            'data_files/download_magic/ages.txt', 'data_files/download_magic/contribution.txt', \n", "            'data_files/download_magic/measurements.txt', 'data_files/download_magic/samples.txt',\n", "            'data_files/download_magic/specimens.txt', 'data_files/download_magic/locations.txt']\n", "\n", "\n", "for fname in filenames:\n", "    try:\n", "        os.remove(fname)\n", "    except FileNotFoundError:\n", "        pass\n", "  \n", "\n", "# remove all MagIC-generated files from a given directory\n", "\n", "def remove_magic_files(directory):\n", "    magic_files = ['specimens.txt', 'samples.txt', 'sites.txt', 'locations.txt', 'measurements.txt', \n", "                   'contribution.txt', 'ages.txt']\n", "    dir_files = os.listdir(directory)\n", "    for dtype in magic_files:\n", "        try:\n", "            os.remove(dtype)\n", "        except FileNotFoundError:\n", "            pass\n", "        for fname in dir_files:\n", "            if fname.endswith(dtype):\n", "                try:\n", "                    os.remove(os.path.join(directory, fname))\n", "                except FileNotFoundError:\n", "                    pass\n", "    for full_fname in glob.glob(os.path.join(directory, '*.magic')):\n", "        os.remove(full_fname)\n", "        \n", "        \n", "        \n", "# not convert_2_magic/jr6_magic\n", "\n", "for directory in ['.', 'data_files/convert_2_magic/2g_bin_magic/mn1', 'data_files/convert_2_magic/pmd_magic/PMD/',\n", "                  'data_files', 'data_files/k15_s', 'data_files/convert_2_magic/agm_magic', \n", "                  'data_files/convert_2_magic/huji_magic', 'data_files/convert_2_magic/bgc_magic',\n", "                  'data_files/convert_2_magic/kly4s_magic', 'data_files/convert_2_magic/mst_magic',\n", "                  'data_files/convert_ages', 'data_files/convert_2_magic/cit_magic/MIT/7325B',\n", "                  'data_files/convert_2_magic/cit_magic/USGS/bl9-1', 'data_files/convert_2_magic/tdt_magic',\n", "                  'data_files/convert_2_magic/ldeo_magic', 'data_files/convert_2_magic/k15_magic',\n", "                  'data_files/convert_2_magic/generic_magic']:\n", "    remove_magic_files(directory)\n", "\n", "\n", "lst = ['*.png', './data_files/convert_2_magic/jr6_magic/SML*.txt', './data_files/download_magic/Snake*',\n", "      './data_files/convert_2_magic/jr6_magic/AP12_*.txt', \n", "      './data_files/convert_2_magic/jr6_magic/*_measurements.txt', './data_files/convert_2_magic/jr6_magic/*.magic',\n", "      './data_files/3_0/McMurdo/*.tex', './data_files/3_0/McMurdo/*.xls', './data_files/3_0/Megiddo/*.tex',\n", "      'data_files/3_0/Megiddo/*.xls']\n", "for directory in lst:\n", "    for fname in glob.glob(directory):\n", "        os.remove(fname)\n", "    "]}, {"block": 634, "type": "markdown", "linesLength": 0, "startIndex": 2834, "lines": []}, {"block": 635, "type": "code", "linesLength": 0, "startIndex": 2834, "lines": []}]
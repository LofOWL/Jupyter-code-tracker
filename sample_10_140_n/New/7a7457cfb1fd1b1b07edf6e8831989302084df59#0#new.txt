[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Poisson Process and Poisson Distribution\n", "\n", "In this notebook, we'll look at a Poisson process and model both the probability of the expected number of events and the waiting time between events. Poisson processes occur frequently in real life (or many phenomonenon can be approximated by a Poisson process) and provide a relatively simple distribution to explore. "]}, {"block": 1, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["# Poisson Process: Observing shooting stars\n", "\n", "We'll work through the following Poisson Process:\n", "\n", "The average time between shooting stars = 12 minutes (5 meteors / hour). "]}, {"block": 2, "type": "code", "linesLength": 19, "startIndex": 8, "lines": ["# Standard data science\n", "import pandas as pd\n", "import numpy as np\n", "\n", "np.random.seed(42)\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "# Visualizations\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot\n", "\n", "# Cufflinks for dataframes\n", "import cufflinks as cf\n", "cf.go_offline()\n", "cf.set_config_file(world_readable=True, theme='pearl')"]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["from scipy.special import factorial"]}, {"block": 4, "type": "markdown", "linesLength": 7, "startIndex": 28, "lines": ["The only parameter of the Poisson distribution is $\\lambda$, the event rate, (or rate parameter). This represents the expected number of events in an interval. If we have a rate in events / time, we can get to the expected events by multiplying the time.\n", "\n", "We find the probability of a number of events, k, in an interval using the Poisson Probability Density Function:\n", "\n", "$$P(k{\\text{ events in interval}})=e^{-\\lambda }{\\frac {\\lambda ^{k}}{k!}}$$\n", "\n", "Let's work through an example."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["### Poisson Probabilities"]}, {"block": 6, "type": "code", "linesLength": 9, "startIndex": 36, "lines": ["events_per_minute = 1/12\n", "minutes = 60\n", "\n", "# Expected events\n", "lam = events_per_minute * minutes\n", "\n", "k = 3\n", "p_k = np.exp(-lam) * np.power(lam, k) / factorial(k)\n", "print(f'The probability of {k} meteors in {minutes} minutes is {100*p_k:.2f}%.')"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["We can do the same calculation by simulating 10,000 hours."]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 46, "lines": ["x = np.random.poisson(lam, 10000)\n", "(x == 3).mean()"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Let's write a quick function to calculate probabilities for a number of events. "]}, {"block": 10, "type": "code", "linesLength": 6, "startIndex": 49, "lines": ["def calc_prob(events_per_minute, minutes, k):\n", "    # Calculate probability of k events in specified number of minutes\n", "    lam = events_per_minute * minutes\n", "    return np.exp(-lam) * np.power(lam, k) / factorial(k)\n", "    \n", "calc_prob(events_per_minute, minutes, 3)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["We can use this function to generate a distribution of probabilities for different numbers of events."]}, {"block": 12, "type": "code", "linesLength": 5, "startIndex": 56, "lines": ["# Different numbers\n", "ns = np.arange(12)\n", "p_n = calc_prob(events_per_minute, minutes, ns)\n", "\n", "print(f'The most likely value is {np.argmax(p_n)} with probability {np.max(p_n):.4f}')"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["It turns out in this situation, 4 and 5 events have the exact same probability (because our rate parameter is a whole number)."]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["p_n[4:6]"]}, {"block": 15, "type": "markdown", "linesLength": 3, "startIndex": 63, "lines": ["## Poisson Distribution\n", "\n", "To show the distribution, we plot the probabiliy on the y-axis versus the number of events on the x-axis. This represents the probability density function of the Poisson process."]}, {"block": 16, "type": "code", "linesLength": 10, "startIndex": 66, "lines": ["def plot_pdf(x, p_x, title=''):\n", "    # Plot PDF of Poisson distribution\n", "    df = pd.DataFrame({'x': x, 'y': p_x})\n", "    print(f'The most likely value is {np.argmax(p_x)} with probability {np.max(p_x):.4f}')\n", "    annotations = [dict(x=x, y=y+0.01, text=f'{y:.2f}', \n", "                        showarrow=False, textangle=0) for x, y in zip(df['x'], df['y'])]\n", "    df.iplot(kind='scatter', mode='markers+lines',\n", "             x='x', y='y', xTitle='Number of Events',\n", "             yTitle='Probability', annotations=annotations,\n", "             title=title)"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["plot_pdf(ns, p_n, title='Probability of Number of Meteors in One Hour')"]}, {"block": 18, "type": "markdown", "linesLength": 3, "startIndex": 77, "lines": ["### Distribution with Differing Rates\n", "\n", "Let's make the probability density function with differing numbers of meteors per hour."]}, {"block": 19, "type": "code", "linesLength": 15, "startIndex": 80, "lines": ["def plot_different_rates(events_per_minute, minutes, ns, title=''):\n", "    df = pd.DataFrame()\n", "    annotations=[]\n", "    colors = ['orange', 'green', 'red', 'blue', 'purple', 'brown']\n", "    for i, events in enumerate(events_per_minute):\n", "        probs = calc_prob(events, minutes, ns)\n", "        annotations.append(dict(x=np.argmax(probs), y=np.max(probs)+0.025, \n", "                                text=f'{int(1/events)} MPH<br>Meteors = {np.argmax(probs)}<br>P = {np.max(probs):.2f}',\n", "                                color=colors[i],\n", "                               showarrow=False, textangle=0))\n", "        df[f'Meteors per Hour = {int(1/events)}'] = probs\n", "    df.index = ns\n", "    df.iplot(kind='scatter', mode='markers+lines', colors=colors, size=8, annotations=annotations,\n", "             xTitle='Events', yTitle='Probability', title=title, dimensions=(1000, 600))\n", "    return df"]}, {"block": 20, "type": "code", "linesLength": 4, "startIndex": 95, "lines": ["df = plot_different_rates(events_per_minute=np.array([1/5, 1/12, 1/10, 1/15, 1/20, 1/30]),\n", "                          minutes=60,\n", "                          ns=list(range(15)), \n", "                          title='Probability of Meteors in 1 Hour at Different Rates')"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["We can also keep the rate the same, but try different lengths of time."]}, {"block": 22, "type": "code", "linesLength": 16, "startIndex": 100, "lines": ["def plot_different_times(events_per_minute, minutes, ns, title=''):\n", "    df = pd.DataFrame()\n", "    annotations = []\n", "    colors = ['orange', 'green', 'red', 'blue', 'purple', 'brown']\n", "    for i, minute in enumerate(minutes):\n", "        probs =  calc_prob(events_per_minute, minute, ns)\n", "        annotations.append(dict(x=np.argmax(probs), y=np.max(probs)+0.025, \n", "                                color=colors[i],\n", "                                text=f'{minute} Minutes<br>Meteors = {np.argmax(probs)}<br>P = {np.max(probs):.2f}',\n", "                               showarrow=False, textangle=0))\n", "        df[f'Minutes = {minute}'] = probs\n", "    df.index = ns\n", "    df.iplot(kind='scatter', mode='markers+lines', colors=colors,\n", "             size=8, annotations=annotations,\n", "             xTitle='Events', yTitle='Probability', title=title)\n", "    return df"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 116, "lines": ["df = plot_different_times(events_per_minute=1/12, minutes=np.array([30, 60, 90, 120]),\n", "                         ns=list(range(15)), title='Probability of Meteors in Time Intervals')"]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 118, "lines": ["## Simulation of Observations\n", "\n", "We can use `np.random.poisson` to simulate 10,000 hours of observation and then make a histogram of observations. We expect to see a peak at 4 or 5 meteors since that is the most likely value."]}, {"block": 25, "type": "code", "linesLength": 6, "startIndex": 121, "lines": ["def plot_hist(x, title='',summary=True):\n", "    df = pd.DataFrame(x)\n", "    df.iplot(kind='hist', xTitle='Events', \n", "             yTitle='Count', title=title)\n", "    if summary:\n", "        print(df.describe())"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 127, "lines": ["N = 10000\n", "counts = np.random.poisson(lam, size=N)\n", "plot_hist(counts, title=f'Distribution of Number of Meteors in 1 Hour Simulated {N} Times')"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 130, "lines": ["counts = np.random.poisson(lam * 3, size=N)\n", "plot_hist(counts, title=f'Distribution of Number of Meteors in 3 Hours Simulated {N} Times')"]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 132, "lines": ["# Probability of Different Numbers of Events\n", "\n", "Now let's take a look at the probability of seeing different numbers of meteors. We can find the probability by summing up the probabilities of more than a given number of events or less than or equal to a given number of events."]}, {"block": 29, "type": "code", "linesLength": 14, "startIndex": 135, "lines": ["def pr_less_than_or_equal(events_per_minute, minutes, n_query, quiet=False):\n", "    p_n = calc_prob(events_per_minute, minutes, np.arange(100))\n", "    p = p_n[:n_query+1].sum() / p_n.sum()\n", "    if not quiet:\n", "        print(f'{int(events_per_minute*minutes)} Meteors Per Hour. Probability of {n_query} or fewer meteors in {int(minutes/60)} hour: {100*p:.2f}%.')\n", "    return p\n", "\n", "def pr_greater_than(events_per_minute, minutes, n_query, quiet=False):\n", "    p = 1 - pr_less_than_or_equal(events_per_minute, minutes, n_query)\n", "    if not quiet:\n", "        print(f'{int(events_per_minute*minutes)} Meteors Per Hour. Probability of more than {n_query} meteors in {int(minutes/60)} hour: {100*p:.2f}%.')\n", "    return p\n", "\n", "assert pr_less_than_or_equal(events_per_minute, minutes, 10, True) + pr_greater_than(events_per_minute, minutes, 10, True) == 1"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 149, "lines": ["_ = pr_greater_than(events_per_minute=1/12, minutes=60, n_query=10)"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 150, "lines": ["_ = pr_greater_than(events_per_minute=1/12, minutes=60, n_query=3)"]}, {"block": 32, "type": "markdown", "linesLength": 5, "startIndex": 151, "lines": ["# Waiting Time\n", "\n", "Next, let's look at the waiting time between events in a Poisson Process. This is a decaying exponential.\n", "\n", "$$P(T > t) = e^{-\\text{events per minute} * {t}}$$"]}, {"block": 33, "type": "code", "linesLength": 20, "startIndex": 156, "lines": ["def waiting_time_more_than(events_per_minute, t, quiet=False):\n", "    p = np.exp(-events_per_minute * t)\n", "    if not quiet:\n", "        print(f'{int(events_per_minute*60)} Meteors per hour. Probability of waiting more than {t} minutes: {100*p:.2f}%.')\n", "    return p\n", "    \n", "def waiting_time_less_than_or_equal(events_per_minute, t, quiet=False):\n", "    p = 1 - waiting_time_more_than(events_per_minute, t, quiet=quiet)\n", "    if not quiet:\n", "        print(f'{int(events_per_minute*60)} Meteors per hour. Probability of waiting at most {t} minutes: {100*p:.2f}%.')\n", "    return p\n", "\n", "def waiting_time_between(events_per_minute, t1, t2):\n", "    p1 = waiting_time_less_than_or_equal(events_per_minute, t1, True)\n", "    p2 = waiting_time_less_than_or_equal(events_per_minute, t2, True)\n", "    p = p2-p1\n", "    print(f'Probability of waiting between {t1} and {t2} minutes: {100*p:.2f}%.')\n", "    return p\n", "\n", "assert waiting_time_more_than(events_per_minute, 15, True) + waiting_time_less_than_or_equal(events_per_minute, 15, True) == 1"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 176, "lines": ["_ = waiting_time_less_than_or_equal(events_per_minute, 5)"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 177, "lines": ["_ = waiting_time_less_than_or_equal(events_per_minute=1/2, t=5)"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 178, "lines": ["_ = waiting_time_between(events_per_minute, 5, 15)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 179, "lines": ["_ = waiting_time_between(events_per_minute, 0, 15)"]}, {"block": 38, "type": "code", "linesLength": 10, "startIndex": 180, "lines": ["def plot_waiting_time(events_per_minute, ts, title=''):\n", "    p_t = waiting_time_more_than(events_per_minute, ts, quiet=True)\n", "    \n", "    df = pd.DataFrame({'x': ts, 'y': p_t})\n", "    df.iplot(kind='scatter', mode='markers+lines', size=8,\n", "             x='x', y='y', xTitle='Waiting Time',\n", "             yTitle='Probability', \n", "             title=title)\n", "    \n", "    return p_t"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 190, "lines": ["p_t = plot_waiting_time(events_per_minute, np.arange(100), title='Probability (T > t)')"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 191, "lines": ["## Average Waiting Time\n", "\n", "The average waiting time is simply 1 / events per minute. We can illustrate this by simulating 100,000 minutes of waiting. "]}, {"block": 41, "type": "code", "linesLength": 8, "startIndex": 194, "lines": ["np.random.seed(42)\n", "\n", "events = np.random.choice([0, 1], size = 100000, replace=True, \n", "                          p=[1-events_per_minute, events_per_minute])\n", "\n", "success_times = np.where(events==1)[0]\n", "waiting_times = np.diff(success_times)\n", "waiting_times[:10]"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 202, "lines": ["np.mean(waiting_times)"]}, {"block": 43, "type": "code", "linesLength": 4, "startIndex": 203, "lines": ["def plot_hist_waiting_time(x, title=''):\n", "    df = pd.DataFrame(x)\n", "    df.iplot(kind='hist', xTitle='Waiting Time between Events', bins=(0, 100, 1),\n", "             yTitle='Count', title=title)"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 207, "lines": ["plot_hist_waiting_time(waiting_times, title='Waiting Time Distribution')"]}, {"block": 45, "type": "markdown", "linesLength": 3, "startIndex": 208, "lines": ["## Visualizing Successes\n", "\n", "Finally, let's look at 1 hour of observations and when we actually see the meteors. "]}, {"block": 46, "type": "code", "linesLength": 8, "startIndex": 211, "lines": ["np.random.seed(6)\n", "\n", "events = np.random.choice([0, 1], size = minutes, replace=True, \n", "                          p=[1-events_per_minute, events_per_minute])\n", "\n", "success_times = np.where(events==1)[0]\n", "waiting_times = np.diff(success_times)\n", "success_times"]}, {"block": 47, "type": "code", "linesLength": 9, "startIndex": 219, "lines": ["annotations = [go.layout.Annotation(x=x, y=1, text=f'Time: {x}', ax=0, ay=250) for x in success_times]\n", "\n", "figure = go.Figure(data=[go.Scatter(x=success_times, \n", "                                    y=np.ones(shape=len(success_times)), \n", "                                    mode='markers')], \n", "                   \n", "                   layout=go.Layout(annotations=annotations, yaxis=dict(range=(0, 1.1)), \n", "                                   xaxis=dict(title=\"Minutes\", range=(0, 60)), title='Meteors over One Hour'))\n", "iplot(figure)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 228, "lines": ["# Binomial Versus Poisson Distribution"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 229, "lines": ["trials = np.random.binomial(minutes, events_per_minute, size=10000)\n", "trials.mean()"]}, {"block": 50, "type": "code", "linesLength": 2, "startIndex": 231, "lines": ["trials_poisson = np.random.poisson(lam, size=10000)\n", "trials_poisson.mean()"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 233, "lines": ["plot_hist(trials, title='Binomial Distribution')"]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 234, "lines": ["plot_hist(trials_poisson, title='Poisson Distribution')"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 235, "lines": ["The Poisson and Binomial approximations are nearly identical when the number of trials is large and the probability of success is relatively small. The Poisson distribution can be thought of as a special case of the Binomial where the number of trials goes to infinity."]}, {"block": 54, "type": "markdown", "linesLength": 3, "startIndex": 236, "lines": ["# Conclusions\n", "\n", "In this notebook, we briefly outlined the basics of a Poisson process and Poisson distribution. We also walked through an example that you can adapt to different situations. "]}, {"block": 55, "type": "code", "linesLength": 0, "startIndex": 239, "lines": []}]
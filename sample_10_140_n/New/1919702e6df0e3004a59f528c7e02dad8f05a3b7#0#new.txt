[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Fisheries competition"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 1, "lines": ["In this notebook we're going to investigate a range of different techniques for the [Kaggle fisheries competition](https://www.kaggle.com/c/the-nature-conservancy-fisheries-monitoring). In this competition, The Nature Conservancy asks you to help them detect which species of fish appears on a fishing boat, based on images captured from boat cameras of various angles. Your goal is to predict the likelihood of fish species in each picture. Eight target categories are available in this dataset: Albacore tuna, Bigeye tuna, Yellowfin tuna, Mahi Mahi, Opah, Sharks, Other \n", "\n", "You can use [this](https://github.com/floydwch/kaggle-cli) api to download the data from Kaggle."]}, {"block": 2, "type": "code", "linesLength": 9, "startIndex": 4, "lines": ["# Put these at the top of every notebook, to get automatic reloading and inline plotting\n", "%reload_ext autoreload\n", "%autoreload 2\n", "%matplotlib inline\n", "\n", "# This file contains all the main external libs we'll use\n", "from fastai.imports import *\n", "\n", "PATH = \"data/fish/\""]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["from fastai.plots import *"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["from fastai.io import get_data"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["## First look at fish pictures"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 16, "lines": ["!ls {PATH}"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["!ls {PATH}train"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["files = !ls {PATH}train/ALB | head\n", "files"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 20, "lines": ["img = plt.imread(f'{PATH}valid/ALB/{files[0]}')\n", "plt.imshow(img);"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["## Data pre-processing"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Here we are changing the structure of the training data to make it more convinient. We will have all images in a common directory `images` and will have a file `train.csv` with all labels. "]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 24, "lines": ["from os import listdir\n", "from os.path import join\n", "train_path = f'{PATH}/train'"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["dirs = [d for d in listdir(train_path) if os.path.isdir(join(train_path,d))]\n", "print(dirs)"]}, {"block": 14, "type": "code", "linesLength": 7, "startIndex": 29, "lines": ["n = 0\n", "train_dict = {}\n", "for d in dirs:\n", "    train_dict[d] = []\n", "    train_dict[d] = listdir(join(train_path, d))\n", "    n += len(train_dict[d])\n", "print(n)"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 36, "lines": ["train_dict[\"LAG\"][:10]"]}, {"block": 16, "type": "code", "linesLength": 8, "startIndex": 37, "lines": ["columnTitleRow = \"img,label\\n\"\n", "\n", "with open(f\"{PATH}train.csv\", \"w\") as csv:\n", "    csv.write(columnTitleRow)\n", "    for d in dirs:\n", "        for f in train_dict[d]:\n", "            row = f'{f},{d}\\n'\n", "            csv.write(row)"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 45, "lines": ["img_path = f'{PATH}images'\n", "if not os.path.exists(img_path):\n", "    os.makedirs(img_path)"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["!cp {PATH}train/*/*.jpg {PATH}images/"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["## Our first model"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Here we import the libraries we need. We'll learn about what each does during the course."]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 51, "lines": ["from fastai.transforms import *\n", "from fastai.conv_learner import *\n", "from fastai.model import *\n", "from fastai.dataset import *\n", "from fastai.sgdr import *"]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 56, "lines": ["sz=299\n", "csv_fname = os.path.join(PATH, \"train.csv\")\n", "n = len(list(open(csv_fname)))-1\n", "val_idxs = get_cv_idxs(n)"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["tfms = tfms_from_model(resnet34, sz)\n", "data = ImageClassifierData.from_csv(PATH, \"images\", csv_fname, bs, tfms, val_idxs)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["learn = ConvLearner.pretrained(resnet34, data, precompute=True, opt_fn=optim.Adam)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["lrf=learn.lr_find()"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["learn.sched.plot()"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["learn.fit(0.01, 3)"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 66, "lines": ["lrs=np.array([1e-4,1e-3,1e-2])\n", "learn.precompute=False"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["learn.freeze_to(6)"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 69, "lines": ["learn.fit(lrs/10, 2, cycle_len=1)"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["learn.freeze_to(5)"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 71, "lines": ["learn.lr_find(lrs/1e3)"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 72, "lines": ["learn.sched.plot()"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 73, "lines": ["learn.fit(lrs/10, 2, cycle_len=1)"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["## Predicting bounding boxes"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["### Getting bounding boxes data"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["This part needs to run just the first time to get the file `trn_bb_labels`"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["import json\n", "anno_classes = ['alb', 'bet', 'dol', 'lag', 'other', 'shark', 'yft']"]}, {"block": 39, "type": "code", "linesLength": 12, "startIndex": 79, "lines": ["def get_annotations():\n", "    annot_urls = [\n", "        '5458/bet_labels.json', '5459/shark_labels.json', '5460/dol_labels.json',\n", "        '5461/yft_labels.json', '5462/alb_labels.json', '5463/lag_labels.json'\n", "    ]\n", "    cache_subdir = os.path.abspath(os.path.join(PATH, 'annos'))\n", "    url_prefix = 'https://kaggle2.blob.core.windows.net/forum-message-attachments/147157/'\n", "    os.makedirs(cache_subdir, exist_ok=True)\n", "    \n", "    for url_suffix in annot_urls:\n", "        fname = url_suffix.rsplit('/', 1)[-1]\n", "        get_data(url_prefix + url_suffix, f'{cache_subdir}/{fname}')"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 91, "lines": ["# run this code to get annotation files\n", "get_annotations()"]}, {"block": 41, "type": "code", "linesLength": 10, "startIndex": 93, "lines": ["# creates a dictionary of all annotations per file\n", "bb_json = {}\n", "for c in anno_classes:\n", "    if c == 'other': continue # no annotation file for \"other\" class\n", "    j = json.load(open(f'{PATH}annos/{c}_labels.json', 'r'))\n", "    for l in j:\n", "        if 'annotations' in l.keys() and len(l['annotations'])>0:\n", "            bb_json[l['filename'].split('/')[-1]] = sorted(\n", "                l['annotations'], key=lambda x: x['height']*x['width'])[-1]\n", "bb_json['img_04908.jpg']"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["# file names\n", "raw_filenames = pd.read_csv(csv_fname)[\"img\"].values"]}, {"block": 43, "type": "code", "linesLength": 12, "startIndex": 105, "lines": ["file2idx = {o:i for i,o in enumerate(raw_filenames)}\n", "\n", "empty_bbox = {'height': 0., 'width': 0., 'x': 0., 'y': 0.}\n", "for f in raw_filenames:\n", "    if not f in bb_json.keys(): bb_json[f] = empty_bbox\n", "\n", "bb_params = ['height', 'width', 'x', 'y']\n", "def convert_bb(bb):\n", "    bb = [bb[p] for p in bb_params]\n", "    bb[2] = max(bb[2], 0)\n", "    bb[3] = max(bb[3], 0)\n", "    return bb"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["trn_bbox = np.stack([convert_bb(bb_json[f]) for f in raw_filenames]).astype(np.float32)"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["trn_bb_labels = [f + ',' + ' '.join(map(str,o))+'\\n' for f,o in zip(raw_filenames,trn_bbox)]"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 119, "lines": ["open(f'{PATH}trn_bb_labels', 'w').writelines(trn_bb_labels)"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["### Looking at bounding boxes"]}, {"block": 48, "type": "code", "linesLength": 3, "startIndex": 121, "lines": ["# reading bb file\n", "bbox = {}\n", "bb_data = pd.read_csv(f'{PATH}trn_bb_labels', header=None)"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["fnames,csv_labels,_,_ = parse_csv_labels(f'{PATH}trn_bb_labels', skip_header=False)"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 125, "lines": ["csv_labels[\"img_06297.jpg\"]"]}, {"block": 51, "type": "code", "linesLength": 8, "startIndex": 126, "lines": ["def create_rect(bb, color='red'):\n", "    return plt.Rectangle((bb[2], bb[3]), bb[1], bb[0], color=color, fill=False, lw=3)\n", "\n", "def show_bb(path, f='img_04908.jpg'):\n", "    file_path = f'{path}images/{f}'\n", "    bb = csv_labels[f]\n", "    plots_from_files([file_path])\n", "    plt.gca().add_patch(create_rect(bb))"]}, {"block": 52, "type": "code", "linesLength": 3, "startIndex": 134, "lines": ["f='img_04908.jpg'\n", "bb = csv_labels[f]\n", "create_rect(bb)"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 137, "lines": ["show_bb(PATH, f=\"img_06297.jpg\")"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["### Model predicting bounding boxes"]}, {"block": 55, "type": "code", "linesLength": 3, "startIndex": 139, "lines": ["label_csv=f'{PATH}trn_bb_labels'\n", "n = len(list(open(label_csv)))-1\n", "val_idxs = get_cv_idxs(n)"]}, {"block": 56, "type": "code", "linesLength": 2, "startIndex": 142, "lines": ["data = ImageClassifierData.from_csv(PATH, 'train', label_csv, tfms=tfms, val_idxs=val_idxs,\n", "                                    continuous=True, skip_header=False)"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["## Looking into size of images"]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 145, "lines": ["f=\"img_06297.jpg\"\n", "PIL.Image.open(PATH+\"images/\" + f).size"]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["sizes = [PIL.Image.open(PATH+f).size for f in data.trn_ds.fnames]\n", "raw_val_sizes = [PIL.Image.open(PATH+f).size for f in data.val_ds.fnames]"]}]
[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 5: Autocorrelation\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 12, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "import math\n", "import numpy as np\n", "\n", "PI2 = 2 * math.pi\n", "\n", "%precision 3\n", "%matplotlib inline"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["To investigate serial correlation of signals, let's start with a sine wave at 440 Hz."]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 20, "lines": ["def make_wave(offset):\n", "    signal = thinkdsp.SinSignal(freq=440, offset=offset)\n", "    wave = signal.make_wave(duration=0.5, framerate=10000)\n", "    return wave"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["I'll make two waves with different phase offsets."]}, {"block": 5, "type": "code", "linesLength": 7, "startIndex": 25, "lines": ["wave1 = make_wave(0)\n", "wave2 = make_wave(offset=1)\n", "\n", "thinkplot.preplot(2)\n", "wave1.segment(duration=0.01).plot()\n", "wave2.segment(duration=0.01).plot()\n", "thinkplot.config(xlabel='time (s)', ylim=[-1.05, 1.05], legend=False)"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 32, "lines": ["The two waves appears correlated: when one is high, the other is usually high, too.\n", "\n", "We can use `np.corrcoef` to compute the correlation matrix."]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["print(np.corrcoef(wave1.ys, wave2.ys))"]}, {"block": 8, "type": "markdown", "linesLength": 6, "startIndex": 36, "lines": ["The diagonal elements are the correlations of the waves with themselves, which is why they are 1.\n", "The off-diagonal elements are the correlations between the two waves.  In this case, 0.54 indicates that there is a moderate correlation between these waves.\n", "\n", "The correlation matrix is more interesting when there are more than two waves.  With only two waves, there is really only one number in the matrix we care about.\n", "\n", "`thinkdsp.Wave` provides `corr`, which computes the correlation between waves:"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["wave1.corr(wave2)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["To investigate the relationship between phase offset and correlation, I'll make an interactive function that computes correlation for each offset:"]}, {"block": 11, "type": "code", "linesLength": 12, "startIndex": 44, "lines": ["def compute_corr(offset):\n", "    wave1 = make_wave(0)\n", "    wave2 = make_wave(offset=-offset)\n", "    \n", "    thinkplot.preplot(2)\n", "    wave1.segment(duration=0.01).plot()\n", "    wave2.segment(duration=0.01).plot()\n", "    \n", "    corr = wave1.corr(wave2)\n", "    print('corr =', corr)\n", "    \n", "    thinkplot.config(xlabel='time (s)', legend=False, ylim=[-1.05, 1.05])"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["The following interaction plots waves with different phase offsets and prints their correlations:"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 57, "lines": ["from IPython.html.widgets import interact, fixed\n", "from IPython.html import widgets\n", "\n", "slider = widgets.FloatSliderWidget(min=0, max=PI2, value=0)\n", "interact(compute_corr, offset=slider);"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Finally, we can plot correlation as a function of offset:"]}, {"block": 15, "type": "code", "linesLength": 14, "startIndex": 63, "lines": ["PI2 = 2 * math.pi\n", "offsets = np.linspace(0, PI2, 101)\n", "\n", "corrs = []\n", "for offset in offsets:\n", "    wave2 = make_wave(offset)\n", "    corr = np.corrcoef(wave1.ys, wave2.ys)[0, 1]\n", "    corrs.append(corr)\n", "    \n", "thinkplot.plot(offsets, corrs)\n", "thinkplot.config(xlabel='offset (radians)',\n", "                 ylabel='correlation', \n", "                 axis=[0, PI2, -1.05, 1.05],\n", "                 legend=False)"]}, {"block": 16, "type": "markdown", "linesLength": 3, "startIndex": 77, "lines": ["That curve is a cosine.\n", "\n", "Next we'll compute serial correlations for different kinds of noise."]}, {"block": 17, "type": "code", "linesLength": 9, "startIndex": 80, "lines": ["def corrcoef(xs, ys):\n", "    return np.corrcoef(xs, ys, ddof=0)[0, 1]\n", "\n", "def serial_corr(wave, lag=1):\n", "    N = len(wave)\n", "    y1 = wave.ys[lag:]\n", "    y2 = wave.ys[:N-lag]\n", "    corr = corrcoef(y1, y2)\n", "    return corr"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["We expect uncorrelated noise to be... well... uncorrelated."]}, {"block": 19, "type": "code", "linesLength": 5, "startIndex": 90, "lines": ["%precision 10\n", "\n", "signal = thinkdsp.UncorrelatedGaussianNoise()\n", "wave = signal.make_wave(duration=0.5, framerate=11025)\n", "serial_corr(wave)"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 95, "lines": ["As expected, the serial correlation is small.\n", "\n", "In Brownian noise, each value is the sum of the previous value and a random \"step\", so we expect a strong serial correlation:"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 98, "lines": ["signal = thinkdsp.BrownianNoise()\n", "wave = signal.make_wave(duration=0.5, framerate=11025)\n", "serial_corr(wave)"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 101, "lines": ["In fact, the correlation is near 1.\n", "\n", "Since pink noise is between white and Brownian, we expect an intermediate correlation."]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 104, "lines": ["signal = thinkdsp.PinkNoise(beta=1)\n", "wave = signal.make_wave(duration=0.5, framerate=11025)\n", "serial_corr(wave)"]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 107, "lines": ["And we get one.\n", "\n", "Now we can plot serial correlation as a function of the pink noise parameter $\\beta$."]}, {"block": 25, "type": "code", "linesLength": 16, "startIndex": 110, "lines": ["np.random.seed(19)\n", "\n", "betas = np.linspace(0, 2, 21)\n", "corrs = []\n", "\n", "for beta in betas:\n", "    signal = thinkdsp.PinkNoise(beta=beta)\n", "    wave = signal.make_wave(duration=1.0, framerate=11025)\n", "    corr = serial_corr(wave)\n", "    corrs.append(corr)\n", "    \n", "thinkplot.preplot(1)\n", "thinkplot.plot(betas, corrs)\n", "thinkplot.config(xlabel=r'pink noise parameter, $\\beta$',\n", "                 ylabel='serial correlation', \n", "                 ylim=[0, 1.05])"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["The autocorrelation function calls `serial_corr` with different values of `lag`."]}, {"block": 27, "type": "code", "linesLength": 8, "startIndex": 127, "lines": ["def autocorr(wave):\n", "    \"\"\"Computes and plots the autocorrelation function.\n", "\n", "    wave: Wave\n", "    \"\"\"\n", "    lags = range(len(wave.ys)//2)\n", "    corrs = [serial_corr(wave, lag) for lag in lags]\n", "    return lags, corrs"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 135, "lines": ["Now we can plot autocorrelation for pink noise with various values of $\\beta$."]}, {"block": 29, "type": "code", "linesLength": 5, "startIndex": 136, "lines": ["def plot_pink_autocorr(beta, label):\n", "    signal = thinkdsp.PinkNoise(beta=beta)\n", "    wave = signal.make_wave(duration=1.0, framerate=10000)\n", "    lags, corrs = autocorr(wave)\n", "    thinkplot.plot(lags, corrs, label=label)"]}, {"block": 30, "type": "code", "linesLength": 12, "startIndex": 141, "lines": ["np.random.seed(19)\n", "thinkplot.preplot(3)\n", "\n", "for beta in [1.7, 1.0, 0.3]:\n", "    label = r'$\\beta$ = %.1f' % beta\n", "    plot_pink_autocorr(beta, label)\n", "\n", "thinkplot.config(xlabel='lag', \n", "                 ylabel='correlation',\n", "                 xlim=[-1, 1000], \n", "                 ylim=[-0.05, 1.05],\n", "                 legend=True)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 153, "lines": ["For low values of $\\beta$, the autocorrelation function drops off quickly.  As $\\beta$ increases, pink noise shows more long range dependency."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 154, "lines": ["Now let's investigate using autocorrelation for pitch tracking.  I'll load a recording of someone singing a chirp:"]}, {"block": 33, "type": "code", "linesLength": 3, "startIndex": 155, "lines": ["wave = thinkdsp.read_wave('28042__bcjordan__voicedownbew.wav')\n", "wave.normalize()\n", "wave.make_audio()"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 158, "lines": ["The spectrum tells us what frequencies are present, but for chirps, the frequency components are blurred over a range:"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 159, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot()"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 161, "lines": ["The spectrogram gives a better picture of how the components vary over time:"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 162, "lines": ["gram = wave.make_spectrogram(seg_length=1024)\n", "gram.plot(high=100)\n", "thinkplot.config(xlabel='time (s)', ylabel='frequency (Hz)')"]}, {"block": 38, "type": "markdown", "linesLength": 3, "startIndex": 165, "lines": ["We can see the fundamental frequency clearly, starting near 500 Hz and dropping.  Some of the harmonics are also clear.\n", "\n", "To track the fundamental frequency, we can take a short window:"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 168, "lines": ["duration = 0.01\n", "segment = wave.segment(start=0.2, duration=duration)\n", "segment.plot()"]}, {"block": 40, "type": "code", "linesLength": 3, "startIndex": 171, "lines": ["spectrum = segment.make_spectrum()\n", "spectrum.plot(high=16)\n", "thinkplot.config(xlabel='frequency (Hz)', ylabel='amplitude')"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 174, "lines": ["The spectrum shows a clear peak near 400 Hz, but we can't get an very accurate estimate of frequency, partly because the peak is blurry, and partly because even if it were a perfect spike, the frequency resolution is not very good."]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 175, "lines": ["len(segment), segment.framerate, spectrum.freq_res"]}, {"block": 43, "type": "markdown", "linesLength": 5, "startIndex": 176, "lines": ["Each element of the spectrum spans a range of 100 Hz, so we can't get an accurate estimate of the fundamental frequency.  \n", "\n", "For signals that are at least approximately periodic, we can do better by estimating the length of the period.\n", "\n", "The following function plots the segment, and a shifted version of the segment, and computes the correlation between them:"]}, {"block": 44, "type": "code", "linesLength": 14, "startIndex": 181, "lines": ["def plot_shifted(wave, shift=0.002, start=0.2):\n", "    thinkplot.preplot(2)\n", "    segment1 = wave.segment(start=start, duration=0.01)\n", "    segment1.plot(linewidth=2, alpha=0.8)\n", "\n", "    segment2 = wave.segment(start=start-shift, duration=0.01)\n", "    segment2.plot(linewidth=2, alpha=0.4)\n", "\n", "    corr = segment1.corr(segment2)\n", "    text = r'$\\rho =$ %.2g' % corr\n", "    thinkplot.text(0.0005, -0.8, text)\n", "    thinkplot.config(xlabel='time (s)', ylim=[-1, 1])\n", "\n", "plot_shifted(wave, 0.0001)"]}, {"block": 45, "type": "markdown", "linesLength": 3, "startIndex": 195, "lines": ["With a small shift the segments are still moderately correlated.  As the shift increases, the correlation falls for a while, then rises again, peaking when the shift equals the period of the signal.\n", "\n", "You can use the following interaction to search for the shift that maximizes correlation:"]}, {"block": 46, "type": "code", "linesLength": 5, "startIndex": 198, "lines": ["end = 0.004\n", "slider1 = widgets.FloatSliderWidget(min=0, max=end, step=end/40, value=0)\n", "slider2 = widgets.FloatSliderWidget(min=0.1, max=0.5, step=0.05, value=0.2)\n", "interact(plot_shifted, wave=fixed(wave), shift=slider1, start=slider2)\n", "None"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 203, "lines": ["The `autocorr` function automates this process by computing the correlation for each possible lag, up to half the length of the wave."]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["The following figure shows this autocorrelation as a function of lag:"]}, {"block": 49, "type": "code", "linesLength": 4, "startIndex": 205, "lines": ["wave = thinkdsp.read_wave('28042__bcjordan__voicedownbew.wav')\n", "wave.normalize()\n", "duration = 0.01\n", "segment = wave.segment(start=0.2, duration=duration)"]}, {"block": 50, "type": "code", "linesLength": 3, "startIndex": 209, "lines": ["lags, corrs = autocorr(segment)\n", "thinkplot.plot(lags, corrs)\n", "thinkplot.config(xlabel='lag (index)', ylabel='correlation', ylim=[-1, 1])"]}, {"block": 51, "type": "markdown", "linesLength": 3, "startIndex": 212, "lines": ["The first peak (other than 0) is near lag=100.\n", "\n", "We can use `argmax` to find the index of that peak:"]}, {"block": 52, "type": "code", "linesLength": 3, "startIndex": 215, "lines": ["low, high = 90, 110\n", "lag = np.array(corrs[low:high]).argmax() + low\n", "lag"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 218, "lines": ["We can convert from an index to a time in seconds:"]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 219, "lines": ["period = lag / segment.framerate\n", "period"]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 221, "lines": ["Given the period in seconds, we can compute frequency:"]}, {"block": 56, "type": "code", "linesLength": 2, "startIndex": 222, "lines": ["frequency = 1 / period\n", "frequency"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 224, "lines": ["This should be a better estimate of the fundamental frequency.  We can approximate the resolution of this estimate by computing how much we would be off by if the index were off by 1:"]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 225, "lines": ["segment.framerate / 102, segment.framerate / 100"]}, {"block": 59, "type": "markdown", "linesLength": 3, "startIndex": 226, "lines": ["The range is less than 10 Hz.\n", "\n", "The function I wrote to compute autocorrelations is slow; `np.correlate` is much faster."]}, {"block": 60, "type": "code", "linesLength": 3, "startIndex": 229, "lines": ["corrs2 = np.correlate(segment.ys, segment.ys, mode='same')\n", "thinkplot.plot(corrs2)\n", "thinkplot.config(xlabel='lag', ylabel='correlation')"]}, {"block": 61, "type": "markdown", "linesLength": 5, "startIndex": 232, "lines": ["`np.correlate` computes correlations for positive and negative lags, so lag=0 is in the middle.  For our purposes, we only care about positive lags.\n", "\n", "Also, `np.correlate` doesn't correct for the fact that the number of overlapping elements changes as the lag increases.\n", "\n", "The following code selects the second half of the results and corrects for the length of the overlap:"]}, {"block": 62, "type": "code", "linesLength": 8, "startIndex": 237, "lines": ["N = len(corrs2)\n", "lengths = range(N, N//2, -1)\n", "\n", "half = corrs2[N//2:].copy()\n", "half /= lengths\n", "half /= half[0]\n", "thinkplot.plot(half)\n", "thinkplot.config(xlabel='lag', ylabel='correlation', ylim=[-1.05, 1.05])"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 245, "lines": ["Now the result is similar to what we computed before, although the vertical scale is different."]}, {"block": 64, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["lags, corrs = autocorr(segment)\n", "len(half), len(corrs)"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 248, "lines": ["If we plot the results computed by NumPy and my implementation, they are visually similar.  They are not quite identical because my version and theirs are normalized differently."]}, {"block": 66, "type": "code", "linesLength": 3, "startIndex": 249, "lines": ["thinkplot.plot(half)\n", "thinkplot.plot(corrs)\n", "thinkplot.config(xlabel='lag', ylabel='correlation', ylim=[-1.05, 1.05])"]}, {"block": 67, "type": "code", "linesLength": 2, "startIndex": 252, "lines": ["diff = corrs - half[:-1]\n", "thinkplot.plot(diff)"]}, {"block": 68, "type": "code", "linesLength": 0, "startIndex": 254, "lines": []}, {"block": 69, "type": "code", "linesLength": 0, "startIndex": 254, "lines": []}]
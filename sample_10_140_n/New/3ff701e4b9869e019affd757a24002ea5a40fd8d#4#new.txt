[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["## ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 8: Filtering and Convolution\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 6, "startIndex": 7, "lines": ["# Get thinkdsp.py\n", "\n", "import os\n", "\n", "if not os.path.exists('thinkdsp.py'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/thinkdsp.py"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 13, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "\n", "from thinkdsp import decorate"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["# suppress scientific notation for small numbers\n", "np.set_printoptions(precision=3, suppress=True)"]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["### Smoothing\n", "\n", "As the first example, I'll look at [daily closing stock prices for Facebook](https://finance.yahoo.com/quote/FB/history?period1=1337299200&period2=1585353600&interval=1d&filter=history&frequency=1d), from its IPO on 2012-05-18 to 2020-03-27 (note: the dataset includes only trading days )"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["if not os.path.exists('FB.csv'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/FB.csv"]}, {"block": 6, "type": "code", "linesLength": 4, "startIndex": 24, "lines": ["import pandas as pd\n", "\n", "df = pd.read_csv('FB.csv', header=0, parse_dates=[0])\n", "df.head()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["df.tail()"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Extract the close prices and days since start of series:"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 30, "lines": ["close = df['Close']\n", "dates = df['Date']\n", "days = (dates - dates[0]) / np.timedelta64(1,'D')"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Make a window to compute a 30-day moving average and convolve the window with the data.  The `valid` flag means the convolution is only computed where the window completely overlaps with the signal."]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 34, "lines": ["M = 30\n", "window = np.ones(M)\n", "window /= sum(window)\n", "smoothed = np.convolve(close, window, mode='valid')\n", "smoothed_days = days[M//2: len(smoothed) + M//2]"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Plot the original and smoothed signals."]}, {"block": 13, "type": "code", "linesLength": 4, "startIndex": 40, "lines": ["plt.plot(days, close, color='gray', alpha=0.6, label='daily close')\n", "plt.plot(smoothed_days, smoothed, color='C1', alpha=0.6, label='30 day average')\n", "\n", "decorate(xlabel='Time (days)', ylabel='Price ($)')"]}, {"block": 14, "type": "markdown", "linesLength": 3, "startIndex": 44, "lines": ["## Smoothing sound signals\n", "\n", "Generate a 440 Hz sawtooth signal."]}, {"block": 15, "type": "code", "linesLength": 5, "startIndex": 47, "lines": ["from thinkdsp import SawtoothSignal\n", "\n", "signal = SawtoothSignal(freq=440)\n", "wave = signal.make_wave(duration=1.0, framerate=44100)\n", "wave.make_audio()"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["Make a moving average window."]}, {"block": 17, "type": "code", "linesLength": 4, "startIndex": 53, "lines": ["window = np.ones(11)\n", "window /= sum(window)\n", "plt.plot(window)\n", "decorate(xlabel='Index')"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Plot the wave."]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 58, "lines": ["segment = wave.segment(duration=0.01)\n", "segment.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["Pad the window so it's the same length as the signal, and plot it."]}, {"block": 21, "type": "code", "linesLength": 11, "startIndex": 62, "lines": ["def zero_pad(array, n):\n", "    \"\"\"Extends an array with zeros.\n", "\n", "    array: NumPy array\n", "    n: length of result\n", "\n", "    returns: new NumPy array\n", "    \"\"\"\n", "    res = np.zeros(n)\n", "    res[:len(array)] = array\n", "    return res"]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 73, "lines": ["N = len(segment)\n", "padded = zero_pad(window, N)\n", "plt.plot(padded)\n", "decorate(xlabel='Index')"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["Apply the window to the signal (with lag=0)."]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 78, "lines": ["prod = padded * segment.ys\n", "np.sum(prod)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["Compute a convolution by rolling the window to the right."]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 81, "lines": ["smoothed = np.zeros(N)\n", "rolled = padded.copy()\n", "for i in range(N):\n", "    smoothed[i] = sum(rolled * segment.ys)\n", "    rolled = np.roll(rolled, 1)"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["plt.plot(rolled)\n", "decorate(xlabel='Index')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Plot the result of the convolution and the original."]}, {"block": 29, "type": "code", "linesLength": 6, "startIndex": 89, "lines": ["from thinkdsp import Wave\n", "\n", "segment.plot(color='gray')\n", "smooth = Wave(smoothed, framerate=wave.framerate)\n", "smooth.plot()\n", "decorate(xlabel='Time(s)')"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["Compute the same convolution using `numpy.convolve`."]}, {"block": 31, "type": "code", "linesLength": 5, "startIndex": 96, "lines": ["segment.plot(color='gray')\n", "ys = np.convolve(segment.ys, window, mode='valid')\n", "smooth2 = Wave(ys, framerate=wave.framerate)\n", "smooth2.plot()\n", "decorate(xlabel='Time(s)', ylim=[-1.05, 1.05])"]}, {"block": 32, "type": "markdown", "linesLength": 3, "startIndex": 101, "lines": ["## Frequency domain\n", "\n", "Let's see what's happening in the frequency domain."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["Compute the smoothed wave using `np.convolve`, which is much faster than my version above."]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 105, "lines": ["convolved = np.convolve(wave.ys, window, mode='same')\n", "smooth = Wave(convolved, framerate=wave.framerate)\n", "smooth.make_audio()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["Plot spectrums of the original and smoothed waves:"]}, {"block": 36, "type": "code", "linesLength": 7, "startIndex": 109, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot(color='gray')\n", "\n", "spectrum2 = smooth.make_spectrum()\n", "spectrum2.plot()\n", "\n", "decorate(xlabel='Frequency (Hz)', ylabel='Amplitude')"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["For each harmonic, compute the ratio of the amplitudes before and after smoothing."]}, {"block": 38, "type": "code", "linesLength": 7, "startIndex": 117, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<280] = 0\n", "\n", "plt.plot(ratio)\n", "decorate(xlabel='Frequency (Hz)', ylabel='Amplitude ratio')"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 124, "lines": ["Plot the ratios again, but also plot the FFT of the window."]}, {"block": 40, "type": "code", "linesLength": 7, "startIndex": 125, "lines": ["padded =  zero_pad(window, len(wave))\n", "dft_window = np.fft.rfft(padded)\n", "\n", "plt.plot(np.abs(dft_window), color='gray', label='DFT(window)')\n", "plt.plot(ratio, label='amplitude ratio')\n", "\n", "decorate(xlabel='Frequency (Hz)', ylabel='Amplitude ratio')"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 132, "lines": ["### Gaussian window\n", "\n", "Let's compare boxcar and Gaussian windows."]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 135, "lines": ["Make the boxcar window."]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 136, "lines": ["boxcar = np.ones(11)\n", "boxcar /= sum(boxcar)"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["Make the Gaussian window."]}, {"block": 45, "type": "code", "linesLength": 4, "startIndex": 139, "lines": ["import scipy.signal\n", "\n", "gaussian = scipy.signal.gaussian(M=11, std=2)\n", "gaussian /= sum(gaussian)"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["Plot the two windows."]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 144, "lines": ["plt.plot(boxcar, label='boxcar')\n", "plt.plot(gaussian, label='Gaussian')\n", "decorate(xlabel='Index')"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["Convolve the square wave with the Gaussian window."]}, {"block": 49, "type": "code", "linesLength": 3, "startIndex": 148, "lines": ["ys = np.convolve(wave.ys, gaussian, mode='same')\n", "smooth = Wave(ys, framerate=wave.framerate)\n", "spectrum2 = smooth.make_spectrum()"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["Compute the ratio of the amplitudes."]}, {"block": 51, "type": "code", "linesLength": 4, "startIndex": 152, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<560] = 0"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 156, "lines": ["Compute the FFT of the window."]}, {"block": 53, "type": "code", "linesLength": 2, "startIndex": 157, "lines": ["padded =  zero_pad(gaussian, len(wave))\n", "dft_gaussian = np.fft.rfft(padded)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 159, "lines": ["Plot the ratios and the FFT of the window."]}, {"block": 55, "type": "code", "linesLength": 4, "startIndex": 160, "lines": ["plt.plot(np.abs(dft_gaussian), color='0.7', label='Gaussian filter')\n", "plt.plot(ratio, label='amplitude ratio')\n", "\n", "decorate(xlabel='Frequency (Hz)', ylabel='Amplitude ratio')"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 164, "lines": ["Combine the preceding example into one big function so we can interact with it."]}, {"block": 57, "type": "code", "linesLength": 29, "startIndex": 165, "lines": ["from thinkdsp import SquareSignal\n", "\n", "def plot_filter(M=11, std=2):\n", "    signal = SquareSignal(freq=440)\n", "    wave = signal.make_wave(duration=1, framerate=44100)\n", "    spectrum = wave.make_spectrum()\n", "\n", "    gaussian = scipy.signal.gaussian(M=M, std=std)\n", "    gaussian /= sum(gaussian)\n", "\n", "    ys = np.convolve(wave.ys, gaussian, mode='same')\n", "    smooth =  Wave(ys, framerate=wave.framerate)\n", "    spectrum2 = smooth.make_spectrum()\n", "\n", "    # plot the ratio of the original and smoothed spectrum\n", "    amps = spectrum.amps\n", "    amps2 = spectrum2.amps\n", "    ratio = amps2 / amps    \n", "    ratio[amps<560] = 0\n", "\n", "    # plot the same ratio along with the FFT of the window\n", "    padded =  zero_pad(gaussian, len(wave))\n", "    dft_gaussian = np.fft.rfft(padded)\n", "\n", "    plt.plot(np.abs(dft_gaussian), color='gray', label='Gaussian filter')\n", "    plt.plot(ratio, label='amplitude ratio')\n", "\n", "    decorate(xlabel='Frequency (Hz)', ylabel='Amplitude ratio')\n", "    plt.show()"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 194, "lines": ["Try out different values of `M` and `std`."]}, {"block": 59, "type": "code", "linesLength": 6, "startIndex": 195, "lines": ["from ipywidgets import interact, interactive, fixed\n", "import ipywidgets as widgets\n", "\n", "slider = widgets.IntSlider(min=2, max=100, value=11)\n", "slider2 = widgets.FloatSlider(min=0, max=20, value=2)\n", "interact(plot_filter, M=slider, std=slider2);"]}, {"block": 60, "type": "markdown", "linesLength": 7, "startIndex": 201, "lines": ["## Convolution theorem\n", "\n", "Let's use the Convolution theorem to compute convolutions using FFT.  \n", "\n", "I'll use the Facebook data again, and smooth it using `np.convolve` and a 30-day Gaussian window.\n", "\n", "I ignore the dates and treat the values as if they are equally spaced in time."]}, {"block": 61, "type": "code", "linesLength": 5, "startIndex": 208, "lines": ["window = scipy.signal.gaussian(M=30, std=6)\n", "window /= window.sum()\n", "smoothed = np.convolve(close, window, mode='valid')\n", "\n", "len(close), len(smoothed)"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 213, "lines": ["Plot the original and smoothed data."]}, {"block": 63, "type": "code", "linesLength": 3, "startIndex": 214, "lines": ["plt.plot(close, color='gray')\n", "plt.plot(smoothed)\n", "decorate(xlabel='Time (days)', ylabel='Price ($)')"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 217, "lines": ["Pad the window and compute its FFT."]}, {"block": 65, "type": "code", "linesLength": 5, "startIndex": 218, "lines": ["N = len(close)\n", "padded = zero_pad(window, N)\n", "fft_window = np.fft.fft(padded)\n", "plt.plot(np.abs(fft_window))\n", "decorate(xlabel='Index')"]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 223, "lines": ["Apply the convolution theorem."]}, {"block": 67, "type": "code", "linesLength": 4, "startIndex": 224, "lines": ["fft_signal = np.fft.fft(close)\n", "smoothed2 = np.fft.ifft(fft_signal * fft_window)\n", "M = len(window)\n", "smoothed2 = smoothed2[M-1:]"]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 228, "lines": ["Plot the two signals (smoothed with numpy and FFT)."]}, {"block": 69, "type": "code", "linesLength": 3, "startIndex": 229, "lines": ["plt.plot(smoothed)\n", "plt.plot(smoothed2.real)\n", "decorate(xlabel='Time (days)', ylabel='Price ($)')"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 232, "lines": ["Confirm that the difference is small."]}, {"block": 71, "type": "code", "linesLength": 2, "startIndex": 233, "lines": ["diff = smoothed - smoothed2\n", "np.max(np.abs(diff))"]}, {"block": 72, "type": "markdown", "linesLength": 1, "startIndex": 235, "lines": ["`scipy.signal` provides `fftconvolve`, which computes convolutions using FFT."]}, {"block": 73, "type": "code", "linesLength": 1, "startIndex": 236, "lines": ["smoothed3 = scipy.signal.fftconvolve(close, window, mode='valid')"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 237, "lines": ["Confirm that it gives the same answer, at least approximately."]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 238, "lines": ["diff = smoothed - smoothed3\n", "np.max(np.abs(diff))"]}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 240, "lines": ["We can encapsulate the process in a function:"]}, {"block": 77, "type": "code", "linesLength": 4, "startIndex": 241, "lines": ["def fft_convolve(signal, window):\n", "    fft_signal = np.fft.fft(signal)\n", "    fft_window = np.fft.fft(window)\n", "    return np.fft.ifft(fft_signal * fft_window)"]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 245, "lines": ["And confirm that it gives the same answer."]}, {"block": 79, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["smoothed4 = fft_convolve(close, padded)[M-1:]\n", "len(smoothed4)"]}, {"block": 80, "type": "code", "linesLength": 2, "startIndex": 248, "lines": ["diff = smoothed - smoothed4\n", "np.max(np.abs(diff))"]}, {"block": 81, "type": "markdown", "linesLength": 5, "startIndex": 250, "lines": ["### Autocorrelation\n", "\n", "We can also use the convolution theorem to compute autocorrelation functions.\n", "\n", "Compute autocorrelation using `numpy.correlate`:\n"]}, {"block": 82, "type": "code", "linesLength": 2, "startIndex": 255, "lines": ["corrs = np.correlate(close, close, mode='same')\n", "corrs[:7]"]}, {"block": 83, "type": "markdown", "linesLength": 1, "startIndex": 257, "lines": ["Compute autocorrelation using my `fft_convolve`.  The window is a reversed copy of the signal.  We have to pad the window and signal with zeros and then select the middle half from the result."]}, {"block": 84, "type": "code", "linesLength": 8, "startIndex": 258, "lines": ["def fft_autocorr(signal):\n", "    N = len(signal)\n", "    signal = zero_pad(signal, 2*N)\n", "    window = np.flipud(signal)\n", "\n", "    corrs = fft_convolve(signal, window)\n", "    corrs = np.roll(corrs, N//2+1)[:N]\n", "    return corrs"]}, {"block": 85, "type": "markdown", "linesLength": 1, "startIndex": 266, "lines": ["Test the function."]}, {"block": 86, "type": "code", "linesLength": 2, "startIndex": 267, "lines": ["corrs2 = fft_autocorr(close)\n", "corrs2[:7]"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 269, "lines": ["Plot the results."]}, {"block": 88, "type": "code", "linesLength": 5, "startIndex": 270, "lines": ["lags = np.arange(N) - N//2\n", "plt.plot(lags, corrs, color='gray', alpha=0.5, label='np.convolve')\n", "plt.plot(lags, corrs2.real, color='C1', alpha=0.5, label='fft_convolve')\n", "decorate(xlabel='Lag', ylabel='Correlation')\n", "len(corrs), len(corrs2)"]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 275, "lines": ["Confirm that the difference is small."]}, {"block": 90, "type": "code", "linesLength": 2, "startIndex": 276, "lines": ["diff = corrs - corrs2.real\n", "np.max(np.abs(diff))"]}, {"block": 91, "type": "code", "linesLength": 0, "startIndex": 278, "lines": []}]
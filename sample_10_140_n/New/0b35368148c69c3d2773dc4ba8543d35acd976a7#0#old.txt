[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 6: Discrete Cosine Transform\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 16, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "\n", "import numpy as np\n", "\n", "import warnings\n", "warnings.filterwarnings('ignore')\n", "\n", "from IPython.html.widgets import interact, interact_manual, fixed\n", "from IPython.html import widgets\n", "from IPython.display import display\n", "\n", "%matplotlib inline\n", "PI2 = np.pi * 2"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 23, "lines": ["###Synthesis\n", "\n", "The simplest way to synthesize a mixture of sinusoids is to evaluate the sinusoids and add them up."]}, {"block": 3, "type": "code", "linesLength": 7, "startIndex": 26, "lines": ["def synthesize1(amps, freqs, ts):\n", "    components = [thinkdsp.CosSignal(freq, amp)\n", "                  for amp, freq in zip(amps, freqs)]\n", "    signal = thinkdsp.SumSignal(*components)\n", "\n", "    ys = signal.evaluate(ts)\n", "    return ys"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Here's an example that's a mixture of 4 components."]}, {"block": 5, "type": "code", "linesLength": 9, "startIndex": 34, "lines": ["amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "freqs = [100, 200, 300, 400]\n", "framerate = 11025\n", "\n", "ts = np.linspace(0, 1, framerate)\n", "ys = synthesize1(amps, freqs, ts)\n", "wave = thinkdsp.Wave(ys, ts, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["We can express the same process using matrix multiplication."]}, {"block": 7, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["def synthesize2(amps, freqs, ts):\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    ys = np.dot(M, amps)\n", "    return ys"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["And it should sound the same."]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 50, "lines": ["ys = synthesize2(amps, freqs, ts)\n", "wave = thinkdsp.Wave(ys, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["And we can confirm that the differences are small."]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 55, "lines": ["ys1 = synthesize1(amps, freqs, ts)\n", "ys2 = synthesize2(amps, freqs, ts)\n", "max(abs(ys1 - ys2))"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 58, "lines": ["### Analysis\n", "\n", "The simplest way to analyze a signal---that is, find the amplitude for each component---is to create the same matrix we used for synthesis and then solve the system of linear equations."]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 61, "lines": ["def analyze1(ys, freqs, ts):\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    amps = np.linalg.solve(M, ys)\n", "    return amps"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Using the first 4 values from the wave array, we can recover the amplitudes."]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["n = len(freqs)\n", "amps2 = analyze1(ys[:n], freqs, ts[:n])\n", "amps2"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["What we have so far is a simple version of a discrete cosine tranform (DCT), but it is not an efficient implementation because the matrix we get is not orthogonal."]}, {"block": 17, "type": "code", "linesLength": 14, "startIndex": 71, "lines": ["def test1():\n", "    amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    time_unit = 0.001\n", "    ts = np.arange(N) / N * time_unit\n", "    max_freq = N / time_unit / 2\n", "    freqs = np.arange(N) / N * max_freq\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    return M\n", "\n", "M = test1()\n", "%precision 3\n", "print(M)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["To check whether a matrix is orthogonal, we can compute $M^T M$, which should be the identity matrix:"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 86, "lines": ["print(M.transpose().dot(M))"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 87, "lines": ["But it's not.\n", "\n", "Solving a linear system with a general matrix (that is, one that does not have nice properties like orthogonality) takes time proportional to $N^3$.  With an orthogonal matrix, we can get that down to $N^2$.  Here's how:"]}, {"block": 21, "type": "code", "linesLength": 11, "startIndex": 90, "lines": ["def test2():\n", "    amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    ts = (0.5 + np.arange(N)) / N\n", "    freqs = (0.5 + np.arange(N)) / 2\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    return M\n", "    \n", "M = test2()\n", "print(M)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["Now $M^T M$ is $2I$ (approximately), so M is orthogonal except for a factor of two."]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 102, "lines": ["print(M.transpose().dot(M))"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["And that means we can solve the analysis problem using matrix multiplication."]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 104, "lines": ["def analyze2(ys, freqs, ts):\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    amps = M.dot(ys) / 2\n", "    return amps"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["It works:"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 110, "lines": ["n = len(freqs)\n", "amps2 = analyze1(ys[:n], freqs, ts[:n])\n", "amps2"]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 113, "lines": ["###DCT\n", "\n", "What we've implemented is DCT-IV, which is one of several versions of DCT using orthogonal matrices."]}, {"block": 29, "type": "code", "linesLength": 8, "startIndex": 116, "lines": ["def dct_iv(ys):\n", "    N = len(ys)\n", "    ts = (0.5 + np.arange(N)) / N\n", "    freqs = (0.5 + np.arange(N)) / 2\n", "    args = np.outer(ts, freqs)\n", "    M = np.cos(PI2 * args)\n", "    amps = np.dot(M, ys) / 2\n", "    return amps"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 124, "lines": ["We can check that it works:"]}, {"block": 31, "type": "code", "linesLength": 8, "startIndex": 125, "lines": ["amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "N = 4.0\n", "ts = (0.5 + np.arange(N)) / N\n", "freqs = (0.5 + np.arange(N)) / 2\n", "ys = synthesize2(amps, freqs, ts)\n", "\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 133, "lines": ["DCT and inverse DCT are the same thing except for a factor of 2."]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 134, "lines": ["def inverse_dct_iv(amps):\n", "    return dct_iv(amps) * 2"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 136, "lines": ["And it works:"]}, {"block": 35, "type": "code", "linesLength": 4, "startIndex": 137, "lines": ["amps = [0.6, 0.25, 0.1, 0.05]\n", "ys = inverse_dct_iv(amps)\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}]
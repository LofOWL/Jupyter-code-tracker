[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["**Important: This notebook will only work with fastai-0.7.x. Do not try to run any fastai-1.x code from this path in the repository because it will load fastai-0.7.x**"]}, {"block": 1, "type": "code", "linesLength": 3, "startIndex": 1, "lines": ["%matplotlib inline\n", "%reload_ext autoreload\n", "%autoreload 2"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["## Style transfer net"]}, {"block": 3, "type": "code", "linesLength": 5, "startIndex": 5, "lines": ["from fastai.conv_learner import *\n", "from pathlib import Path\n", "torch.cuda.set_device(0)\n", "\n", "torch.backends.cudnn.benchmark=True"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 10, "lines": ["PATH = Path('data/imagenet')\n", "PATH_TRN = PATH/'train'"]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 12, "lines": ["fnames_full,label_arr_full,all_labels = folder_source(PATH, 'train')\n", "fnames_full = ['/'.join(Path(fn).parts[-2:]) for fn in fnames_full]\n", "list(zip(fnames_full[:5],label_arr_full[:5]))"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 15, "lines": ["all_labels[:5]"]}, {"block": 7, "type": "code", "linesLength": 7, "startIndex": 16, "lines": ["np.random.seed(42)\n", "# keep_pct = 1.\n", "# keep_pct = 0.01\n", "keep_pct = 0.1\n", "keeps = np.random.rand(len(fnames_full)) < keep_pct\n", "fnames = np.array(fnames_full, copy=False)[keeps]\n", "label_arr = np.array(label_arr_full, copy=False)[keeps]"]}, {"block": 8, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["arch = vgg16\n", "# sz,bs = 96,32\n", "sz,bs = 256,24\n", "# sz,bs = 128,32"]}, {"block": 9, "type": "code", "linesLength": 7, "startIndex": 27, "lines": ["class MatchedFilesDataset(FilesDataset):\n", "    def __init__(self, fnames, y, transform, path):\n", "        self.y=y\n", "        assert(len(fnames)==len(y))\n", "        super().__init__(fnames, transform, path)\n", "    def get_y(self, i): return open_image(os.path.join(self.path, self.y[i]))\n", "    def get_c(self): return 0"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 34, "lines": ["val_idxs = get_cv_idxs(len(fnames), val_pct=min(0.01/keep_pct, 0.1))\n", "((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, np.array(fnames), np.array(fnames))\n", "len(val_x),len(trn_x)"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["img_fn = PATH/'train'/'n01558993'/'n01558993_9684.JPEG'"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 38, "lines": ["tfms = tfms_from_model(arch, sz, tfm_y=TfmType.PIXEL)\n", "datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), (val_x,val_y), tfms, path=PATH_TRN)\n", "md = ImageData(PATH, datasets, bs, num_workers=16, classes=None)"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 41, "lines": ["denorm = md.val_ds.denorm"]}, {"block": 14, "type": "code", "linesLength": 6, "startIndex": 42, "lines": ["def show_img(ims, idx, figsize=(5,5), normed=True, ax=None):\n", "    if ax is None: fig,ax = plt.subplots(figsize=figsize)\n", "    if normed: ims = denorm(ims)\n", "    else:      ims = np.rollaxis(to_np(ims),1,4)\n", "    ax.imshow(np.clip(ims,0,1)[idx])\n", "    ax.axis('off')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["## Model"]}, {"block": 16, "type": "code", "linesLength": 6, "startIndex": 49, "lines": ["def conv(ni, nf, kernel_size=3, stride=1, actn=True, pad=None, bn=True):\n", "    if pad is None: pad = kernel_size//2\n", "    layers = [nn.Conv2d(ni, nf, kernel_size, stride=stride, padding=pad, bias=not bn)]\n", "    if actn: layers.append(nn.ReLU(inplace=True))\n", "    if bn: layers.append(nn.BatchNorm2d(nf))\n", "    return nn.Sequential(*layers)"]}, {"block": 17, "type": "code", "linesLength": 6, "startIndex": 55, "lines": ["class ResSequentialCenter(nn.Module):\n", "    def __init__(self, layers):\n", "        super().__init__()\n", "        self.m = nn.Sequential(*layers)\n", "\n", "    def forward(self, x): return x[:, :, 2:-2, 2:-2] + self.m(x)"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 61, "lines": ["def res_block(nf):\n", "    return ResSequentialCenter([conv(nf, nf, actn=True, pad=0), conv(nf, nf, pad=0)])"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 63, "lines": ["def upsample(ni, nf):\n", "    return nn.Sequential(nn.Upsample(scale_factor=2), conv(ni, nf))"]}, {"block": 20, "type": "code", "linesLength": 12, "startIndex": 65, "lines": ["class StyleResnet(nn.Module):\n", "    def __init__(self):\n", "        super().__init__()\n", "        features = [nn.ReflectionPad2d(40),\n", "                    conv(3, 32, 9),\n", "                    conv(32, 64, stride=2), conv(64, 128, stride=2)]\n", "        for i in range(5): features.append(res_block(128))\n", "        features += [upsample(128, 64), upsample(64, 32),\n", "                     conv(32, 3, 9, actn=False)]\n", "        self.features = nn.Sequential(*features)\n", "        \n", "    def forward(self, x): return self.features(x)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["## Style Image"]}, {"block": 22, "type": "code", "linesLength": 3, "startIndex": 78, "lines": ["style_fn = PATH/'style'/'starry_night.jpg'\n", "style_img = open_image(style_fn)\n", "style_img.shape"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 81, "lines": ["plt.imshow(style_img);"]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 82, "lines": ["h,w,_ = style_img.shape\n", "rat = max(sz/h,sz/h)\n", "res = cv2.resize(style_img, (int(w*rat), int(h*rat)), interpolation=cv2.INTER_AREA)\n", "resz_style = res[:sz,-sz:]"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 86, "lines": ["plt.imshow(resz_style);"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 87, "lines": ["style_tfm,_ = tfms[1](resz_style,resz_style)"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["style_tfm = np.broadcast_to(style_tfm[None], (bs,)+style_tfm.shape)"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 89, "lines": ["style_tfm.shape"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["## Perceptual loss"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 91, "lines": ["m_vgg = vgg16(True)"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 92, "lines": ["blocks = [i-1 for i,o in enumerate(children(m_vgg))\n", "              if isinstance(o,nn.MaxPool2d)]\n", "blocks, [m_vgg[i] for i in blocks[1:]]"]}, {"block": 32, "type": "code", "linesLength": 3, "startIndex": 95, "lines": ["vgg_layers = children(m_vgg)[:43]\n", "m_vgg = nn.Sequential(*vgg_layers).cuda().eval()\n", "set_trainable(m_vgg, False)"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["def flatten(x): return x.view(x.size(0), -1)"]}, {"block": 34, "type": "code", "linesLength": 5, "startIndex": 99, "lines": ["class SaveFeatures():\n", "    features=None\n", "    def __init__(self, m): self.hook = m.register_forward_hook(self.hook_fn)\n", "    def hook_fn(self, module, input, output): self.features = output\n", "    def remove(self): self.hook.remove()        "]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 104, "lines": ["def ct_loss(input, target): return F.mse_loss(input,target)\n", "\n", "def gram(input):\n", "        b,c,h,w = input.size()\n", "        x = input.view(b, c, -1)\n", "        return torch.bmm(x, x.transpose(1,2))/(c*h*w)*1e6\n", "\n", "def gram_loss(input, target):\n", "    return F.mse_loss(gram(input), gram(target[:input.size(0)]))"]}, {"block": 36, "type": "code", "linesLength": 23, "startIndex": 113, "lines": ["class CombinedLoss(nn.Module):\n", "    def __init__(self, m, layer_ids, style_im, ct_wgt, style_wgts):\n", "        super().__init__()\n", "        self.m,self.ct_wgt,self.style_wgts = m,ct_wgt,style_wgts\n", "        self.sfs = [SaveFeatures(m[i]) for i in layer_ids]\n", "        m(VV(style_im))\n", "        self.style_feat = [V(o.features.data.clone()) for o in self.sfs]\n", "\n", "    def forward(self, input, target, sum_layers=True):\n", "        self.m(VV(target.data))\n", "        targ_feat = self.sfs[2].features.data.clone()\n", "        self.m(input)\n", "        inp_feat = [o.features for o in self.sfs]\n", "        \n", "        res = [ct_loss(inp_feat[2],V(targ_feat)) * self.ct_wgt]\n", "        res += [gram_loss(inp,targ)*wgt for inp,targ,wgt\n", "                in zip(inp_feat, self.style_feat, self.style_wgts)]\n", "        \n", "        if sum_layers: res = sum(res)\n", "        return res\n", "    \n", "    def close(self):\n", "        for o in self.sfs: o.remove()"]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 136, "lines": ["m = StyleResnet()\n", "m = to_gpu(m)"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 138, "lines": ["learn = Learner(md, SingleModel(m), opt_fn=optim.Adam)"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 139, "lines": ["learn.crit = CombinedLoss(m_vgg, blocks[1:], style_tfm, 1e4, [0.025,0.275,5.,0.2])"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 140, "lines": ["wd=1e-7"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 141, "lines": ["learn.lr_find(wds=wd)\n", "learn.sched.plot(n_skip_end=1)"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 143, "lines": ["lr=5e-3"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 144, "lines": ["learn.fit(lr, 1, cycle_len=1, wds=wd, use_clr=(20,10))"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 145, "lines": ["learn.save('style-2')"]}, {"block": 45, "type": "code", "linesLength": 0, "startIndex": 146, "lines": []}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 146, "lines": ["x,y=md.val_ds[len(val_x)-1]"]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 147, "lines": ["learn.model.eval()\n", "preds = learn.model(VV(x[None]))\n", "x.shape,y.shape,preds.shape"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 150, "lines": ["learn.crit(preds, VV(y[None]), sum_layers=False)"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 151, "lines": ["learn.crit.close()"]}, {"block": 50, "type": "code", "linesLength": 3, "startIndex": 152, "lines": ["_,axes=plt.subplots(1,2,figsize=(14,7))\n", "show_img(x[None], 0, ax=axes[0])\n", "show_img(preds, 0, ax=axes[1])"]}, {"block": 51, "type": "code", "linesLength": 0, "startIndex": 155, "lines": []}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["## Fin"]}, {"block": 53, "type": "code", "linesLength": 0, "startIndex": 156, "lines": []}]
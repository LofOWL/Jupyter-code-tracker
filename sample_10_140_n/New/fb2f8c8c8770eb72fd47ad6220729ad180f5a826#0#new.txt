[{"block": 0, "type": "markdown", "linesLength": 4, "startIndex": 0, "lines": ["<i>Copyright (c) Microsoft Corporation. All rights reserved.<br>\n", "Licensed under the MIT License.</i>\n", "<br>\n", "# Hyperparameter Tuning for Matrix Factorization Using the Neural Network Intelligence Toolkit"]}, {"block": 1, "type": "markdown", "linesLength": 7, "startIndex": 4, "lines": ["This notebook shows how to use the **[Neural Network Intelligence](https://nni.readthedocs.io/en/latest/) toolkit (NNI)** for tuning hyperparameters of a matrix factorization model. In particular, we optimize the hyperparameters of [Surprise SVD](https://surprise.readthedocs.io/en/stable/matrix_factorization.html).\n", "\n", "NNI is a toolkit to help users design and tune machine learning models (e.g., hyperparameters), neural network architectures, or complex system\u2019s parameters, in an efficient and automatic way. NNI has several appealing properties: ease of use, scalability, flexibility and efficiency. NNI comes with [several tuning algorithms](https://nni.readthedocs.io/en/latest/Builtin_Tuner.html) built in. It also allows users to [define their own general purpose tuners](https://nni.readthedocs.io/en/latest/Customize_Tuner.html). NNI can be executed in a distributed way on a local machine, a remote server, or a large scale training platform such as OpenPAI or Kubernetes. \n", "\n", "In this notebook we execute several NNI _experiments_ on the same data sets obtained from Movielens with a training-validation-test split. Each experiment corresponds to one of the built-in tuning algorithms. It consists of many parallel _trials_, each of which corresponds to a choice of hyperparameters sampled by the tuning algorithm. All the experiments require a call to the same [python script](../../reco_utils/nni/svd_training.py) for training the SVD model and evaluating rating and ranking metrics on the test data. This script has been adapted from the [Surprise SVD notebook](../02_model/surprise_svd_deep_dive.ipynb) with only a few changes. In all experiments, we maximize precision@10. \n", "\n", "For this notebook we use a _local machine_ as the training platform (this can be any machine running the `reco_base` conda environment). In this case, NNI uses the available processors of the machine to parallelize the trials, subject to the value of `trialConcurrency` we specify in the configuration. Our runs and the results we report were obtained on a [Standard_D16_v3 virtual machine](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes-general#dv3-series-1) with 16 vcpus and 64 GB memory."]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["### 1. Global Settings"]}, {"block": 3, "type": "code", "linesLength": 24, "startIndex": 12, "lines": ["import sys\n", "sys.path.append(\"../../\")\n", "import json\n", "import os\n", "import surprise\n", "import papermill as pm\n", "import pandas as pd\n", "import shutil\n", "import subprocess\n", "import time\n", "import yaml\n", "from tempfile import TemporaryDirectory\n", "\n", "import reco_utils\n", "from reco_utils.dataset import movielens\n", "from reco_utils.dataset.python_splitters import python_random_split\n", "from reco_utils.evaluation.python_evaluation import rmse, precision_at_k, ndcg_at_k\n", "from reco_utils.nni.nni_utils import check_experiment_status, check_stopped, check_metrics_written, get_trials\n", "from reco_utils.recommender.surprise.surprise_utils import compute_rating_predictions, compute_ranking_predictions\n", "\n", "print(\"System version: {}\".format(sys.version))\n", "print(\"Surprise version: {}\".format(surprise.__version__))\n", "\n", "tmp_dir = TemporaryDirectory()"]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["### 2. Prepare Dataset\n", "1. Download data and split into training, validation and test sets\n", "2. Store the data sets to a local directory."]}, {"block": 5, "type": "code", "linesLength": 6, "startIndex": 39, "lines": ["# Parameters used by papermill\n", "# Select Movielens data size: 100k, 1m\n", "MOVIELENS_DATA_SIZE = '100k'\n", "SURPRISE_READER = 'ml-100k'\n", "TMP_DIR = tmp_dir.name\n", "MAX_TRIAL_NUM = 100"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 45, "lines": ["data = movielens.load_pandas_df(\n", "    size=MOVIELENS_DATA_SIZE,\n", "    header=[\"userID\", \"itemID\", \"rating\"]\n", ")\n", "\n", "data.head()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["train, validation, test = python_random_split(data, [0.7, 0.15, 0.15])"]}, {"block": 8, "type": "code", "linesLength": 11, "startIndex": 52, "lines": ["DATA_DIR = os.path.join(TMP_DIR, 'aml_data') \n", "os.makedirs(DATA_DIR, exist_ok=True)\n", "\n", "TRAIN_FILE_NAME = \"movielens_\" + MOVIELENS_DATA_SIZE + \"_train.pkl\"\n", "train.to_pickle(os.path.join(DATA_DIR, TRAIN_FILE_NAME))\n", "\n", "VAL_FILE_NAME = \"movielens_\" + MOVIELENS_DATA_SIZE + \"_val.pkl\"\n", "validation.to_pickle(os.path.join(DATA_DIR, VAL_FILE_NAME))\n", "\n", "TEST_FILE_NAME = \"movielens_\" + MOVIELENS_DATA_SIZE + \"_test.pkl\"\n", "test.to_pickle(os.path.join(DATA_DIR, TEST_FILE_NAME))"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["### 3. Prepare Hyperparameter Tuning "]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 64, "lines": ["We now prepare a training script [svd_training_nni.py](../../reco_utils/nni/svd_training.py) for the hyperparameter tuning, which will log our target metrics such as precision, NDCG, RMSE.\n", "We define the arguments of the script and the search space for the hyperparameters. All the parameter values will be passed to our training script.<br>\n", "Note that we specify _precision@10_ as the primary metric. We will also instruct NNI (in the configuration file) to _maximize_ the primary metric. This is passed as an argument in the training script and the evaluated metric is returned through the NNI python library. In addition, we also evaluate RMSE and NDCG@10.   "]}, {"block": 11, "type": "code", "linesLength": 34, "startIndex": 67, "lines": ["EXP_NAME = \"movielens_\" + MOVIELENS_DATA_SIZE + \"_svd_model\"\n", "PRIMARY_METRIC = 'precision_at_k'\n", "RATING_METRICS = ['rmse']\n", "RANKING_METRICS = ['precision_at_k', 'ndcg_at_k']  \n", "USERCOL = 'userID'\n", "ITEMCOL = 'itemID'\n", "RECOMMEND_SEEN = False\n", "K = 10\n", "RANDOM_STATE = 0\n", "VERBOSE = True\n", "NUM_EPOCHS = 30\n", "BIASED = True\n", "\n", "script_params = \" \".join([\n", "    '--datastore', DATA_DIR,\n", "    '--train-datapath', TRAIN_FILE_NAME,\n", "    '--validation-datapath', VAL_FILE_NAME,\n", "    '--surprise-reader', SURPRISE_READER,\n", "    '--rating-metrics', \" \".join(RATING_METRICS),\n", "    '--ranking-metrics', \" \".join(RANKING_METRICS),\n", "    '--usercol', USERCOL,\n", "    '--itemcol', ITEMCOL,\n", "    '--k', str(K),\n", "    '--random-state', str(RANDOM_STATE),\n", "    '--epochs', str(NUM_EPOCHS),\n", "    '--primary-metric', PRIMARY_METRIC\n", "])\n", "\n", "if BIASED:\n", "    script_params += ' --biased'\n", "if VERBOSE:\n", "    script_params += ' --verbose'\n", "if RECOMMEND_SEEN:\n", "    script_params += ' --recommend-seen'"]}, {"block": 12, "type": "code", "linesLength": 16, "startIndex": 101, "lines": ["# hyperparameters search space\n", "# We do not set 'lr_all' and 'reg_all' because they will be overriden by the other lr_ and reg_ parameters\n", "\n", "hyper_params = {\n", "    'n_factors': {\"_type\": \"choice\", \"_value\": [10, 50, 100, 150, 200]},\n", "    'init_mean': {\"_type\": \"uniform\", \"_value\": [-0.5, 0.5]},\n", "    'init_std_dev': {\"_type\": \"uniform\", \"_value\": [0.01, 0.2]},\n", "    'lr_bu': {\"_type\": \"uniform\", \"_value\": [1e-6, 0.1]}, \n", "    'lr_bi': {\"_type\": \"uniform\", \"_value\": [1e-6, 0.1]}, \n", "    'lr_pu': {\"_type\": \"uniform\", \"_value\": [1e-6, 0.1]}, \n", "    'lr_qi': {\"_type\": \"uniform\", \"_value\": [1e-6, 0.1]}, \n", "    'reg_bu': {\"_type\": \"uniform\", \"_value\": [1e-6, 1]},\n", "    'reg_bi': {\"_type\": \"uniform\", \"_value\": [1e-6, 1]}, \n", "    'reg_pu': {\"_type\": \"uniform\", \"_value\": [1e-6, 1]}, \n", "    'reg_qi': {\"_type\": \"uniform\", \"_value\": [1e-6, 1]}\n", "}"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 117, "lines": ["with open(os.path.join(TMP_DIR, 'search_space_svd.json'), 'w') as fp:\n", "    json.dump(hyper_params, fp)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["We also create a yaml file for the configuration of the trials and the tuning algorithm to be used (in this experiment we use the [TPE tuner](https://nni.readthedocs.io/en/latest/hyperoptTuner.html)). "]}, {"block": 15, "type": "code", "linesLength": 27, "startIndex": 120, "lines": ["config = {\n", "    'authorName': 'default',\n", "    'experimentName': 'surprise_svd',\n", "    'trialConcurrency': 8,\n", "    'maxExecDuration': '1h',\n", "    'maxTrialNum': MAX_TRIAL_NUM,\n", "    'trainingServicePlatform': 'local',\n", "    # The path to Search Space\n", "    'searchSpacePath': 'search_space_svd.json',\n", "    'useAnnotation': False,\n", "    'tuner': {\n", "        'builtinTunerName': 'TPE',\n", "        'classArgs': {\n", "            #choice: maximize, minimize\n", "            'optimize_mode': 'maximize'\n", "        }\n", "    },\n", "    # The path and the running command of trial\n", "    'trial':  {\n", "      'command': 'python3 svd_training.py' + \" \" + script_params,\n", "      'codeDir': os.path.join(os.path.split(os.path.abspath(reco_utils.__file__))[0], 'nni'),\n", "      'gpuNum': 0\n", "    }\n", "}\n", " \n", "with open(os.path.join(TMP_DIR, 'config_svd.yml'), 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 16, "type": "markdown", "linesLength": 13, "startIndex": 147, "lines": ["### 4. Execute NNI Trials\n", "\n", "The conda environment comes with NNI installed, which includes the command line tool `nnictl` for controlling and getting information about NNI experiments. <br>\n", "To start the NNI tuning trials from the command line, execute the following command: <br>\n", "`nnictl create --config <path of config_svd.yml>` <br>\n", "In the cell below, we call this command programmatically. <br>\n", "You can see the progress of the experiment by using the URL links output by the above command.\n", "\n", "![](https://recodatasets.blob.core.windows.net/images/nn1.png)\n", "\n", "![](https://recodatasets.blob.core.windows.net/images/nn2.png)\n", "\n", "![](https://recodatasets.blob.core.windows.net/images/nn3.png)"]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 160, "lines": ["config_path = os.path.join(TMP_DIR, 'config_svd.yml')\n", "os.environ['PATH'] = sys.prefix + '/bin:' + os.environ['PATH']\n", "proc = subprocess.run([sys.prefix + '/bin/nnictl', 'create', '--config', config_path])\n", "if proc.returncode != 0:\n", "    raise RuntimeError(\"'nnictl create' failed with code %d\" % proc.returncode)"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 165, "lines": ["t = time.time()\n", "check_experiment_status()\n", "time_tpe = time.time() - t"]}, {"block": 19, "type": "markdown", "linesLength": 7, "startIndex": 168, "lines": ["### 5. Show Results\n", "\n", "The trial with the best metric and the corresponding metrics and hyperparameters can also be read from the Web UI\n", "\n", "![](https://recodatasets.blob.core.windows.net/images/nni4.png)\n", "\n", "or from the JSON file created by the training script. Below, we do this programmatically using [nni_utils.py](../../reco_utils/nni/nni_utils.py) "]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 175, "lines": ["check_metrics_written()\n", "trials, best_metrics, best_params, best_trial_path = get_trials('maximize')"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 177, "lines": ["best_metrics"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 178, "lines": ["best_params"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 179, "lines": ["best_trial_path"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 180, "lines": ["This directory path is where info about the trial can be found, including logs, parameters and the model that was learned. To evaluate the metrics on the test data, we get the SVD model that was saved as `model.dump` in the training script."]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 181, "lines": ["svd = surprise.dump.load(os.path.join(best_trial_path, \"model.dump\"))[1]"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 182, "lines": ["The following function computes all the metrics given an SVD model."]}, {"block": 27, "type": "code", "linesLength": 10, "startIndex": 183, "lines": ["def compute_test_results(svd):\n", "    test_results = {}\n", "    predictions = compute_rating_predictions(svd, test, usercol=\"userID\", itemcol=\"itemID\")\n", "    for metric in RATING_METRICS:\n", "        test_results[metric] = eval(metric)(test, predictions)\n", "\n", "    all_predictions = compute_ranking_predictions(svd, train, usercol=\"userID\", itemcol=\"itemID\", recommend_seen=RECOMMEND_SEEN)\n", "    for metric in RANKING_METRICS:\n", "        test_results[metric] = eval(metric)(test, all_predictions, col_prediction='prediction', k=K)\n", "    return test_results"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 193, "lines": ["test_results_tpe = compute_test_results(svd)\n", "print(test_results_tpe)"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 195, "lines": ["### 6. More Tuning Algorithms\n", "We now apply other tuning algorithms supported by NNI to the same problem. For details about these tuners, see the [NNI docs.](https://nni.readthedocs.io/en/latest/tuners.html#)\n", "The only change needed is in the relevant entry in the configuration file."]}, {"block": 30, "type": "markdown", "linesLength": 10, "startIndex": 198, "lines": ["In summary, the tuners used in this notebook are the following:\n", "- Tree-structured Parzen Estimator (TPE), within the Sequential Model-Based Optimization (SMBO) framework,\n", "- SMAC, also an instance of SMBO,\n", "- Hyperband\n", "- Metis, an implementation of Bayesian optimization with Gaussian Processes\n", "- a Naive Evolutionary algorithm\n", "- an Annealing method for sampling, and  \n", "- plain Random Search as a baseline.  \n", "<br>\n", "For more details and references to the relevant literature, see the [NNI github](https://github.com/Microsoft/nni/blob/master/docs/en_US/Builtin_Tuner.md)."]}, {"block": 31, "type": "code", "linesLength": 9, "startIndex": 208, "lines": ["def stop_and_restart():\n", "    proc = subprocess.run([sys.prefix + '/bin/nnictl', 'stop'])\n", "    if proc.returncode != 0:\n", "        raise RuntimeError(\"'nnictl stop' failed with code %d\" % proc.returncode)\n", "    check_stopped()\n", "    proc = subprocess.run([sys.prefix + '/bin/nnictl', 'create', '--config', config_path])\n", "    if proc.returncode != 0: \n", "        raise RuntimeError(\"'nnictl create' failed with code %d\" % proc.returncode)\n", "    check_experiment_status()"]}, {"block": 32, "type": "code", "linesLength": 4, "startIndex": 217, "lines": ["# Random search\n", "config['tuner']['builtinTunerName'] = 'Random'\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 33, "type": "code", "linesLength": 3, "startIndex": 221, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_random = time.time() - t"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 224, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_random = compute_test_results(svd)"]}, {"block": 35, "type": "code", "linesLength": 4, "startIndex": 227, "lines": ["# Annealing\n", "config['tuner']['builtinTunerName'] = 'Anneal'\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 231, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_anneal = time.time() - t"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 234, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_anneal = compute_test_results(svd)"]}, {"block": 38, "type": "code", "linesLength": 4, "startIndex": 237, "lines": ["# Naive evolutionary search\n", "config['tuner']['builtinTunerName'] = 'Evolution'\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 241, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_evolution = time.time() - t"]}, {"block": 40, "type": "code", "linesLength": 3, "startIndex": 244, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_evolution = compute_test_results(svd)"]}, {"block": 41, "type": "markdown", "linesLength": 2, "startIndex": 247, "lines": ["The SMAC tuner requires to have been installed with the following command <br>\n", "`nnictl package install --name=SMAC`"]}, {"block": 42, "type": "code", "linesLength": 4, "startIndex": 249, "lines": ["# SMAC\n", "config['tuner']['builtinTunerName'] = 'SMAC'\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 43, "type": "code", "linesLength": 3, "startIndex": 253, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_smac = time.time() - t"]}, {"block": 44, "type": "code", "linesLength": 3, "startIndex": 256, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_smac = compute_test_results(svd)"]}, {"block": 45, "type": "code", "linesLength": 4, "startIndex": 259, "lines": ["# Metis\n", "config['tuner']['builtinTunerName'] = 'MetisTuner'\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 263, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_metis = time.time() - t"]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 266, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_metis = compute_test_results(svd)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 269, "lines": ["Hyperband follows a different style of configuration from other tuners. See [the NNI documentation](https://nni.readthedocs.io/en/latest/hyperbandAdvisor.html). Note that the [training script](../../reco_utils/nni/svd_training.py) needs to be adjusted as well, since each Hyperband trial receives an additional parameter `STEPS`, which corresponds to the resource allocation _r<sub>i</sub>_ in the [Hyperband algorithm](https://arxiv.org/pdf/1603.06560.pdf). In this example, we used `STEPS` in combination with `R` to determine the number of epochs that SVD will run for in every trial."]}, {"block": 49, "type": "code", "linesLength": 12, "startIndex": 270, "lines": ["# Hyperband\n", "config['advisor'] = {\n", "  'builtinAdvisorName': 'Hyperband',\n", "  'classArgs': {\n", "    'R': NUM_EPOCHS,\n", "    'eta': 3,\n", "    'optimize_mode': 'maximize'\n", "  }\n", "}\n", "config.pop('tuner')\n", "with open(config_path, 'w') as fp:\n", "    fp.write(yaml.dump(config, default_flow_style=False))"]}, {"block": 50, "type": "code", "linesLength": 3, "startIndex": 282, "lines": ["t = time.time()\n", "stop_and_restart()\n", "time_hyperband = time.time() - t"]}, {"block": 51, "type": "code", "linesLength": 3, "startIndex": 285, "lines": ["check_metrics_written()\n", "svd = surprise.dump.load(os.path.join(get_trials('maximize')[3], \"model.dump\"))[1]\n", "test_results_hyperband = compute_test_results(svd)"]}, {"block": 52, "type": "code", "linesLength": 7, "startIndex": 288, "lines": ["test_results_tpe.update({'time': time_tpe})\n", "test_results_random.update({'time': time_random})\n", "test_results_anneal.update({'time': time_anneal})\n", "test_results_evolution.update({'time': time_evolution})\n", "test_results_smac.update({'time': time_smac})\n", "test_results_metis.update({'time': time_metis})\n", "test_results_hyperband.update({'time': time_hyperband})"]}, {"block": 53, "type": "code", "linesLength": 4, "startIndex": 295, "lines": ["res_df = pd.DataFrame(index=['TPE', 'Random Search', 'Annealing', 'Evolution', 'SMAC', 'Metis', 'Hyperband'],\n", "                      data=[res for res in [test_results_tpe, test_results_random, test_results_anneal, test_results_evolution, \n", "                                            test_results_smac, test_results_metis, test_results_hyperband]] \n", "                     )"]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 299, "lines": ["res_df.sort_values(by='precision_at_k', ascending=False).round(3)"]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 300, "lines": ["As we see in the table above, _annealing_ performs best with respect to the primary metric (precision@10) that all the tuners optimized. Also the best NDCG@10 is obtained for annealing and correlates well with precision@10. RMSE on the other hand does not correlate well and is not optimized for annealing, since finding the top k recommendations in the right order is a different task from predicting ratings (high and low) accurately.     \n", "We have also observed that the above ranking of the tuners is not consistent and may change when trying these experiments multiple times. Since some of these tuners rely heavily on randomized sampling, a larger number of trials is required to get more consistent metrics.\n", "In addition, some of the tuning algorithms themselves come with parameters, which can affect their performance."]}, {"block": 56, "type": "code", "linesLength": 2, "startIndex": 303, "lines": ["# Record the location of logs with papermill for testing\n", "pm.record(\"nni_path\", os.path.normpath(best_trial_path + '/../../..'))"]}, {"block": 57, "type": "code", "linesLength": 4, "startIndex": 305, "lines": ["# Stop the NNI experiment \n", "proc = subprocess.run([sys.prefix + '/bin/nnictl', 'stop'])\n", "if proc.returncode != 0:\n", "    raise RuntimeError(\"'nnictl stop' failed with code %d\" % proc.returncode)"]}, {"block": 58, "type": "markdown", "linesLength": 4, "startIndex": 309, "lines": ["### 7. Concluding Remarks\n", "\n", "We showed how to tune **all** the hyperparameters accepted by Surprise SVD simultaneously, by utilizing the NNI toolkit. \n", "For example, training and evaluation of a single SVD model takes about 50 seconds on the 100k MovieLens data on a Standard D2_V2 VM. Searching through 100 different combinations of hyperparameters sequentially would take about 80 minutes whereas each of the above experiments took about 10. With NNI, one can take advantage of concurrency and multiple processors on a virtual machine and can use a variety of methods to navigate efficiently through a large space of hyperparameters."]}, {"block": 59, "type": "markdown", "linesLength": 5, "startIndex": 313, "lines": ["### References\n", "\n", "* [Matrix factorization algorithms in Surprise](https://surprise.readthedocs.io/en/stable/matrix_factorization.html) \n", "* [Surprise SVD deep-dive notebook](../02_model/surprise_svd_deep_dive.ipynb)\n", "* [Neural Network Intelligence toolkit](https://github.com/Microsoft/nni)"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["## NLP model creation and training"]}, {"block": 1, "type": "code", "linesLength": 2, "startIndex": 1, "lines": ["from fastai.gen_doc.nbdoc import *\n", "from fastai.text import * \n"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["The main thing here is [`RNNLearner`](/text.learner.html#RNNLearner). There are also some utility functions to help create and update text models."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["## Quickly get a learner"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 5, "lines": ["show_doc(language_model_learner)"]}, {"block": 5, "type": "markdown", "linesLength": 7, "startIndex": 6, "lines": ["The model used is given by `arch` and `config`. It can be:\n", "\n", "- an [<code>AWD_LSTM</code>](/text.models.html#AWD_LSTM)([Merity et al.](https://arxiv.org/abs/1708.02182))\n", "- a [<code>Transformer</code>](/text.models.html#Transformer) decoder ([Vaswani et al.](https://arxiv.org/abs/1706.03762))\n", "- a [<code>TransformerXL</code>](/text.models.html#TransformerXL) ([Dai et al.](https://arxiv.org/abs/1901.02860))\n", "\n", "They each have a default config for language modelling that is in <code>{lower_case_class_name}_lm_config</code> if you want to change the default parameter. At this stage, only the AWD LSTM support `pretrained=True` but we hope to add more pretrained models soon. `drop_mult` is applied to all the dropouts weights of the `config`, `learn_kwargs` are passed to the [`Learner`](/basic_train.html#Learner) initialization."]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["jekyll_note(\"Using QRNN (change the flag in the config of the AWD LSTM) requires to have cuda installed (same version as pytorch is using).\")"]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 14, "lines": ["path = untar_data(URLs.IMDB_SAMPLE)\n", "data = TextLMDataBunch.from_csv(path, 'texts.csv')\n", "learn = language_model_learner(data, AWD_LSTM, drop_mult=0.5)"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["show_doc(text_classifier_learner)"]}, {"block": 9, "type": "markdown", "linesLength": 5, "startIndex": 18, "lines": ["Here again, the backbone of the model is determined by `arch` and `config`. The input texts are fed into that model by bunch of `bptt` and only the last `max_len` activations are considered. This gives us the backbone of our model. The head then consists of:\n", "- a layer that concatenates the final outputs of the RNN with the maximum and average of all the intermediate outputs (on the sequence length dimension),\n", "- blocks of ([`nn.BatchNorm1d`](https://pytorch.org/docs/stable/nn.html#torch.nn.BatchNorm1d), [`nn.Dropout`](https://pytorch.org/docs/stable/nn.html#torch.nn.Dropout), [`nn.Linear`](https://pytorch.org/docs/stable/nn.html#torch.nn.Linear), [`nn.ReLU`](https://pytorch.org/docs/stable/nn.html#torch.nn.ReLU)) layers.\n", "\n", "The blocks are defined by the `lin_ftrs` and `drops` arguments. Specifically, the first block will have a number of inputs inferred from the backbone arch and the last one will have a number of outputs equal to data.c (which contains the number of classes of the data) and the intermediate blocks have a number of inputs/outputs determined by `lin_ftrs` (of course a block has a number of inputs equal to the number of outputs of the previous block). The dropouts all have a the same value ps if you pass a float, or the corresponding values if you pass a list. Default is to have an intermediate hidden size of 50 (which makes two blocks model_activation -> 50 -> n_classes) with a dropout of 0.1."]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["path = untar_data(URLs.IMDB_SAMPLE)\n", "data = TextClasDataBunch.from_csv(path, 'texts.csv')\n", "learn = text_classifier_learner(data, AWD_LSTM, drop_mult=0.5)"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 26, "lines": ["show_doc(RNNLearner)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Handles the whole creation from <code>data</code> and a `model` with a text data using a certain `bptt`. The `split_func` is used to properly split the model in different groups for gradual unfreezing and differential learning rates. Gradient clipping of `clip` is optionally applied. `alpha` and `beta` are all passed to create an instance of [`RNNTrainer`](/callbacks.rnn.html#RNNTrainer). Can be used for a language model or an RNN classifier. It also handles the conversion of weights from a pretrained model as well as saving or loading the encoder."]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["show_doc(RNNLearner.get_preds)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["If `ordered=True`, returns the predictions in the order of the dataset, otherwise they will be ordered by the sampler (from the longest text to the shortest). The other arguments are passed [`Learner.get_preds`](/basic_train.html#Learner.get_preds)."]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["show_doc(TextClassificationInterpretation,title_level=3)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["The darker the word-shading in the below example, the more it contributes to the classification.  Results here are without any fitting.  After fitting to acceptable accuracy, this class can show you what is being used to produce the classification of a particular case."]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 32, "lines": ["import matplotlib.cm as cm\n", "\n", "txt_ci = TextClassificationInterpretation.from_learner(learn)\n", "test_text = \"Zombiegeddon was perhaps the GREATEST movie i have ever seen!\"\n", "txt_ci.show_intrinsic_attention(test_text,cmap=cm.Purples)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["You can also view the raw attention values with `.intrinsic_attention(text)`"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 38, "lines": ["txt_ci.intrinsic_attention(test_text)[1]"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Create a tabulation showing the first `k` texts in top_losses along with their prediction, actual,loss, and probability of actual class. `max_len` is the maximum number of tokens displayed. If `max_len=None`, it will display all tokens."]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["txt_ci.show_top_losses(5)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["### Loading and saving"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["show_doc(RNNLearner.load_encoder)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["show_doc(RNNLearner.save_encoder)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["show_doc(RNNLearner.load_pretrained)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Opens the weights in the `wgts_fname` of `self.model_dir` and the dictionary in `itos_fname` then adapts the pretrained weights to the vocabulary of the <code>data</code>. The two files should be in the models directory of the `learner.path`."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["## Utility functions"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["show_doc(convert_weights)"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Uses the dictionary `stoi_wgts` (mapping of word to id) of the weights to map them to a new dictionary `itos_new` (mapping id to word)."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["## Get predictions"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["show_doc(LanguageLearner, title_level=3)"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["show_doc(LanguageLearner.predict)"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["If `no_unk=True` the unknown token is never picked. Words are taken randomly with the distribution of probabilities returned by the model. If `min_p` is not `None`, that value is the minimum probability to be considered in the pool of words. Lowering `temperature` will make the texts less randomized. "]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["show_doc(LanguageLearner.beam_search)"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["## Basic functions to get a model"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["show_doc(get_language_model)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["show_doc(get_text_classifier)"]}, {"block": 38, "type": "markdown", "linesLength": 5, "startIndex": 57, "lines": ["This model uses an encoder taken from the `arch` on `config`. This encoder is fed the sequence by successive bits of size `bptt` and we only keep the last `max_seq` outputs for the pooling layers.\n", "\n", "The decoder use a concatenation of the last outputs, a `MaxPooling` of all the outputs and an `AveragePooling` of all the outputs. It then uses a list of `BatchNorm`, `Dropout`, `Linear`, `ReLU` blocks (with no `ReLU` in the last one), using a first layer size of `3*emb_sz` then following the numbers in `n_layers`. The dropouts probabilities are read in `drops`.\n", "\n", "Note that the model returns a list of three things, the actual output being the first, the two others being the intermediate hidden states before and after dropout (used by the [`RNNTrainer`](/callbacks.rnn.html#RNNTrainer)). Most loss functions expect one output, so you should use a Callback to remove the other two if you're not using [`RNNTrainer`](/callbacks.rnn.html#RNNTrainer)."]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["## Undocumented Methods - Methods moved below this line will intentionally be hidden"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["## New Methods - Please document or move to the undocumented section"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["show_doc(MultiBatchEncoder.forward)"]}, {"block": 42, "type": "markdown", "linesLength": 0, "startIndex": 65, "lines": []}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["show_doc(LanguageLearner.show_results)"]}, {"block": 44, "type": "markdown", "linesLength": 0, "startIndex": 66, "lines": []}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["show_doc(MultiBatchEncoder.concat)"]}, {"block": 46, "type": "markdown", "linesLength": 0, "startIndex": 67, "lines": []}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["show_doc(MultiBatchEncoder)"]}, {"block": 48, "type": "markdown", "linesLength": 0, "startIndex": 68, "lines": []}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["show_doc(decode_spec_tokens)"]}, {"block": 50, "type": "markdown", "linesLength": 0, "startIndex": 69, "lines": []}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 69, "lines": ["show_doc(MultiBatchEncoder.reset)"]}, {"block": 52, "type": "markdown", "linesLength": 0, "startIndex": 70, "lines": []}]
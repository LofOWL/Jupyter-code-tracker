[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["##ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 6: Discrete Cosine Transform\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 16, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "import thinkdsp\n", "import thinkplot\n", "\n", "import numpy as np\n", "\n", "import warnings\n", "warnings.filterwarnings('ignore')\n", "\n", "from IPython.html.widgets import interact, interact_manual, fixed\n", "from IPython.html import widgets\n", "from IPython.display import display\n", "\n", "%matplotlib inline\n", "PI2 = np.pi * 2"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 23, "lines": ["###Synthesis\n", "\n", "The simplest way to synthesize a mixture of sinusoids is to evaluate the sinusoids and add them up."]}, {"block": 3, "type": "code", "linesLength": 7, "startIndex": 26, "lines": ["def synthesize1(amps, fs, ts):\n", "    components = [thinkdsp.CosSignal(freq, amp)\n", "                  for amp, freq in zip(amps, fs)]\n", "    signal = thinkdsp.SumSignal(*components)\n", "\n", "    ys = signal.evaluate(ts)\n", "    return ys"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Here's an example that's a mixture of 4 components."]}, {"block": 5, "type": "code", "linesLength": 9, "startIndex": 34, "lines": ["amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "fs = [100, 200, 300, 400]\n", "framerate = 11025\n", "\n", "ts = np.linspace(0, 1, framerate)\n", "ys = synthesize1(amps, fs, ts)\n", "wave = thinkdsp.Wave(ys, ts, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["We can express the same process using matrix multiplication."]}, {"block": 7, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["def synthesize2(amps, fs, ts):\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    ys = np.dot(M, amps)\n", "    return ys"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["And it should sound the same."]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 50, "lines": ["ys = synthesize2(amps, fs, ts)\n", "wave = thinkdsp.Wave(ys, framerate)\n", "wave.apodize()\n", "wave.make_audio()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["And we can confirm that the differences are small."]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 55, "lines": ["ys1 = synthesize1(amps, fs, ts)\n", "ys2 = synthesize2(amps, fs, ts)\n", "max(abs(ys1 - ys2))"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 58, "lines": ["### Analysis\n", "\n", "The simplest way to analyze a signal---that is, find the amplitude for each component---is to create the same matrix we used for synthesis and then solve the system of linear equations."]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 61, "lines": ["def analyze1(ys, fs, ts):\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    amps = np.linalg.solve(M, ys)\n", "    return amps"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Using the first 4 values from the wave array, we can recover the amplitudes."]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["n = len(fs)\n", "amps2 = analyze1(ys[:n], fs, ts[:n])\n", "amps2"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["What we have so far is a simple version of a discrete cosine tranform (DCT), but it is not an efficient implementation because the matrix we get is not orthogonal."]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["# suppress scientific notation for small numbers\n", "np.set_printoptions(precision=3, suppress=True)"]}, {"block": 18, "type": "code", "linesLength": 13, "startIndex": 73, "lines": ["def test1():\n", "    amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    time_unit = 0.001\n", "    ts = np.arange(N) / N * time_unit\n", "    max_freq = N / time_unit / 2\n", "    fs = np.arange(N) / N * max_freq\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    return M\n", "\n", "M = test1()\n", "M"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["To check whether a matrix is orthogonal, we can compute $M^T M$, which should be the identity matrix:"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 87, "lines": ["M.transpose().dot(M)"]}, {"block": 21, "type": "markdown", "linesLength": 3, "startIndex": 88, "lines": ["But it's not.\n", "\n", "Solving a linear system with a general matrix (that is, one that does not have nice properties like orthogonality) takes time proportional to $N^3$.  With an orthogonal matrix, we can get that down to $N^2$.  Here's how:"]}, {"block": 22, "type": "code", "linesLength": 11, "startIndex": 91, "lines": ["def test2():\n", "    amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "    N = 4.0\n", "    ts = (0.5 + np.arange(N)) / N\n", "    fs = (0.5 + np.arange(N)) / 2\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    return M\n", "    \n", "M = test2()\n", "M"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["Now $M^T M$ is $2I$ (approximately), so M is orthogonal except for a factor of two."]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 103, "lines": ["M.transpose().dot(M)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["And that means we can solve the analysis problem using matrix multiplication."]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 105, "lines": ["def analyze2(ys, fs, ts):\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    amps = M.dot(ys) / 2\n", "    return amps"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["It works:"]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 111, "lines": ["n = len(fs)\n", "amps2 = analyze1(ys[:n], fs, ts[:n])\n", "amps2"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 114, "lines": ["###DCT\n", "\n", "What we've implemented is DCT-IV, which is one of several versions of DCT using orthogonal matrices."]}, {"block": 30, "type": "code", "linesLength": 8, "startIndex": 117, "lines": ["def dct_iv(ys):\n", "    N = len(ys)\n", "    ts = (0.5 + np.arange(N)) / N\n", "    fs = (0.5 + np.arange(N)) / 2\n", "    args = np.outer(ts, fs)\n", "    M = np.cos(PI2 * args)\n", "    amps = np.dot(M, ys) / 2\n", "    return amps"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 125, "lines": ["We can check that it works:"]}, {"block": 32, "type": "code", "linesLength": 8, "startIndex": 126, "lines": ["amps = np.array([0.6, 0.25, 0.1, 0.05])\n", "N = 4.0\n", "ts = (0.5 + np.arange(N)) / N\n", "fs = (0.5 + np.arange(N)) / 2\n", "ys = synthesize2(amps, fs, ts)\n", "\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["DCT and inverse DCT are the same thing except for a factor of 2."]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 135, "lines": ["def inverse_dct_iv(amps):\n", "    return dct_iv(amps) * 2"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 137, "lines": ["And it works:"]}, {"block": 36, "type": "code", "linesLength": 4, "startIndex": 138, "lines": ["amps = [0.6, 0.25, 0.1, 0.05]\n", "ys = inverse_dct_iv(amps)\n", "amps2 = dct_iv(ys)\n", "print(max(abs(amps - amps2)))"]}, {"block": 37, "type": "markdown", "linesLength": 4, "startIndex": 142, "lines": ["###thinkdsp.Dct\n", "\n", "`thinkdsp` provides a Dct class that encapsulates the\n", "DCT in the same way the Spectrum class encapsulates the FFT."]}, {"block": 38, "type": "code", "linesLength": 3, "startIndex": 146, "lines": ["signal = thinkdsp.TriangleSignal(freq=400)\n", "wave = signal.make_wave(duration=1.0, framerate=10000)\n", "wave.make_audio()"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 149, "lines": ["To make a Dct object, you can invoke `make_dct` on a Wave."]}, {"block": 40, "type": "code", "linesLength": 3, "startIndex": 150, "lines": ["dct = wave.make_dct()\n", "dct.plot()\n", "thinkplot.config(xlabel='Frequency (Hz)', ylabel='DCT')"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 153, "lines": ["Dct provides `make_wave`, which performs the inverse DCT."]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 154, "lines": ["wave2 = dct.make_wave()"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["The result is very close to the wave we started with."]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 156, "lines": ["max(abs(wave.ys-wave2.ys))"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 157, "lines": ["Negating the signal changes the sign of the DCT."]}, {"block": 46, "type": "code", "linesLength": 4, "startIndex": 158, "lines": ["signal = thinkdsp.TriangleSignal(freq=400, offset=0)\n", "wave = signal.make_wave(duration=1.0, framerate=10000)\n", "wave.ys *= -1\n", "wave.make_dct().plot()"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 162, "lines": ["Adding phase offset $\\phi=\\pi$ has the same effect."]}, {"block": 48, "type": "code", "linesLength": 3, "startIndex": 163, "lines": ["signal = thinkdsp.TriangleSignal(freq=400, offset=np.pi)\n", "wave = signal.make_wave(duration=1.0, framerate=10000)\n", "wave.make_dct().plot()"]}, {"block": 49, "type": "code", "linesLength": 0, "startIndex": 166, "lines": []}]
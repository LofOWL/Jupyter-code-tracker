[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["<i>Copyright (c) Microsoft Corporation. All rights reserved.</i>\n", "\n", "<i>Licensed under the MIT License.</i>"]}, {"block": 1, "type": "markdown", "linesLength": 3, "startIndex": 3, "lines": ["# Neural Collaborative Filtering (NCF)\n", "\n", "This notebook serves as an introduction to Neural Collaborative Filtering (NCF), which is an innovative algorithm based on deep neural networks to tackle the key problem in recommendation \u2014 collaborative filtering \u2014 on the basis of implicit feedback."]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## 0 Global Settings and Imports"]}, {"block": 3, "type": "code", "linesLength": 18, "startIndex": 7, "lines": ["import sys\n", "sys.path.append(\"../../\")\n", "import time\n", "import os\n", "import shutil\n", "import pandas as pd\n", "import numpy as np\n", "import tensorflow as tf\n", "from reco_utils.recommender.ncf.ncf_singlenode import NCF\n", "from reco_utils.recommender.ncf.dataset import Dataset as NCFDataset\n", "from reco_utils.dataset import movielens\n", "from reco_utils.dataset.python_splitters import python_chrono_split\n", "from reco_utils.evaluation.python_evaluation import (rmse, mae, rsquared, exp_var, map_at_k, ndcg_at_k, precision_at_k, \n", "                                                     recall_at_k, get_top_k_items)\n", "\n", "print(\"System version: {}\".format(sys.version))\n", "print(\"Pandas version: {}\".format(pd.__version__))\n", "print(\"Tensorflow version: {}\".format(tf.__version__))"]}, {"block": 4, "type": "code", "linesLength": 9, "startIndex": 25, "lines": ["# top k items to recommend\n", "TOP_K = 10\n", "\n", "# Select Movielens data size: 100k, 1m, 10m, or 20m\n", "MOVIELENS_DATA_SIZE = '100k'\n", "\n", "# Model parameters\n", "EPOCHS = 200\n", "BATCH_SIZE = 256"]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 34, "lines": ["## 1 Matrix factorization algorithm\n", "\n", "NCF is new neural matrix factorization model, which ensembles Generalized Matrix Factorization (GMF) and Multi-Layer Perceptron (MLP) to unify the strengths of linearity of MF and non-linearity of MLP for modelling the user\u2013item latent structures. NCF can be demonstrated as a framework for GMF and MLP, which is illustrated as below:"]}, {"block": 6, "type": "markdown", "linesLength": 67, "startIndex": 37, "lines": ["<img src=\"https://recodatasets.blob.core.windows.net/images/NCF.svg?sanitize=true\">\n", "\n", "This figure shows how to utilize latent vectors of items and users, and then how to fuse outputs from GMF Layer (left) and MLP Layer (right). We will introduce this framework and show how to learn the model parameters in following sections.\n", "\n", "### 1.1 The GMF model\n", "\n", "In ALS, the ratings are modeled as follows:\n", "\n", "$$\\hat { r } _ { u , i } = q _ { i } ^ { T } p _ { u }$$\n", "\n", "GMF introduces neural CF layer as the output layer of standard MF. In this way, MF can be easily generalized\n", "and extended. For example, if we allow the edge weights of this output layer to be learnt from data without the uniform constraint, it will result in a variant of MF that allows varying importance of latent dimensions. And if we use a non-linear function for activation, it will generalize MF to a non-linear setting which might be more expressive than the linear MF model. GMF can be shown as follows:\n", "\n", "$$\\hat { r } _ { u , i } = a _ { o u t } \\left( h ^ { T } \\left( q _ { i } \\odot p _ { u } \\right) \\right)$$\n", "\n", "where $\\odot$ is element-wise product of vectors. Additionally, ${a}_{out}$ and ${h}$ denote the activation function and edge weights of the output layer respectively. MF can be interpreted as a special case of GMF. Intuitively, if we use an identity function for aout and enforce h to be a uniform vector of 1, we can exactly recover the MF model.\n", "\n", "### 1.2 The MLP model\n", "\n", "NCF adopts two pathways to model users and items: 1) element-wise product of vectors, 2) concatenation of vectors. To learn interactions after concatenating of users and items lantent features, the standard MLP model is applied. In this sense, we can endow the model a large level of flexibility and non-linearity to learn the interactions between $p_{u}$ and $q_{i}$. The details of MLP model are:\n", "\n", "For the input layer, there is concatention of user and item vectors:\n", "\n", "$$z _ { 1 } = \\phi _ { 1 } \\left( p _ { u } , q _ { i } \\right) = \\left[ \\begin{array} { c } { p _ { u } } \\\\ { q _ { i } } \\end{array} \\right]$$\n", "\n", "So for the hidden layers and output layer of MLP, the details are:\n", "\n", "$$\n", "\\phi _ { l } \\left( z _ { l } \\right) = a _ { o u t } \\left( W _ { l } ^ { T } z _ { l } + b _ { l } \\right) , ( l = 2,3 , \\ldots , L - 1 )\n", "$$\n", "\n", "and:\n", "\n", "$$\n", "\\hat { r } _ { u , i } = \\sigma \\left( h ^ { T } \\phi \\left( z _ { L - 1 } \\right) \\right)\n", "$$\n", "\n", "where ${ W }_{ l }$, ${ b }_{ l }$, and ${ a }_{ out }$ denote the weight matrix, bias vector, and activation function for the $l$-th layer\u2019s perceptron, respectively. For activation functions of MLP layers, one can freely choose sigmoid, hyperbolic tangent (tanh), and Rectifier (ReLU), among others. Because of implicit data task, the activation function of the output layer is defined as sigmoid $\\sigma(x)=\\frac{1}{1+\\exp{(-x)}}$ to restrict the predicted score to be in (0,1).\n", "\n", "\n", "### 1.3 Fusion of GMF and MLP\n", "\n", "To provide more flexibility to the fused model, we allow GMF and MLP to learn separate embeddings, and combine the two models by concatenating their last hidden layer. We get $\\phi^{GMF}$ from GMF:\n", "\n", "$$\\phi _ { u , i } ^ { G M F } = p _ { u } ^ { G M F } \\odot q _ { i } ^ { G M F }$$\n", "\n", "and obtain $\\phi^{MLP}$ from MLP:\n", "\n", "$$\\phi _ { u , i } ^ { M L P } = a _ { o u t } \\left( W _ { L } ^ { T } \\left( a _ { o u t } \\left( \\ldots a _ { o u t } \\left( W _ { 2 } ^ { T } \\left[ \\begin{array} { c } { p _ { u } ^ { M L P } } \\\\ { q _ { i } ^ { M L P } } \\end{array} \\right] + b _ { 2 } \\right) \\ldots \\right) \\right) + b _ { L }\\right.$$\n", "\n", "Lastly, we fuse output from GMF and MLP:\n", "\n", "$$\\hat { r } _ { u , i } = \\sigma \\left( h ^ { T } \\left[ \\begin{array} { l } { \\phi ^ { G M F } } \\\\ { \\phi ^ { M L P } } \\end{array} \\right] \\right)$$\n", "\n", "This model combines the linearity of MF and non-linearity of DNNs for modelling user\u2013item latent structures.\n", "\n", "### 1.4 Objective Function\n", "\n", "We define the likelihood function as:\n", "\n", "$$P \\left( \\mathcal { R } , \\mathcal { R } ^ { - } | \\mathbf { P } , \\mathbf { Q } , \\Theta \\right) = \\prod _ { ( u , i ) \\in \\mathcal { R } } \\hat { r } _ { u , i } \\prod _ { ( u , j ) \\in \\mathcal { R } ^{ - } } \\left( 1 - \\hat { r } _ { u , j } \\right)$$\n", "\n", "Where $\\mathcal{R}$ denotes the set of observed interactions, and $\\mathcal{ R } ^ { - }$ denotes the set of negative instances. $\\mathbf{P}$ and $\\mathbf{Q}$ denotes the latent factor matrix for users and items, respectively; and $\\Theta$ denotes the model parameters. Taking the negative logarithm of the likelihood, we obatain the objective function to minimize for NCF method, which is known as *binary cross-entropy loss*:\n", "\n", "$$L = - \\sum _ { ( u , i ) \\in \\mathcal { R } \\cup { \\mathcal { R } } ^ { - } } r _ { u , i } \\log \\hat { r } _ { u , i } + \\left( 1 - r _ { u , i } \\right) \\log \\left( 1 - \\hat { r } _ { u , i } \\right)$$\n", "\n", "The optimization can be done by performing Stochastic Gradient Descent (SGD), which has been introduced by the SVD algorithm in surprise svd deep dive notebook. Our SGD method is very similar to the SVD algorithm's."]}, {"block": 7, "type": "markdown", "linesLength": 7, "startIndex": 104, "lines": ["## 2 TensorFlow implementation of NCF\n", "\n", "We will use the Movielens dataset, which is composed of integer ratings from 1 to 5.\n", "\n", "We convert Movielens into implicit feedback, and evaluate under our *leave-one-out* evaluation protocol.\n", "\n", "You can check the details of implementation in `reco_utils/recommender/ncf`\n"]}, {"block": 8, "type": "markdown", "linesLength": 7, "startIndex": 111, "lines": ["## 3 TensorFlow NCF movie recommender\n", "\n", "### 3.1 Load and split data\n", "\n", "To evaluate the performance of item recommendation, we adopted the leave-one-out evaluation.\n", "\n", "For each user, we held out his/her latest interaction as the test set and utilized the remaining data for training. We use `python_chrono_split` to achieve this. And since it is too time-consuming to rank all items for every user during evaluation, we followed the common strategy that randomly samples 100 items that are not interacted by the user, ranking the test item among the 100 items. Our test samples will be constructed by `NCFDataset`."]}, {"block": 9, "type": "code", "linesLength": 6, "startIndex": 118, "lines": ["df = movielens.load_pandas_df(\n", "    size=MOVIELENS_DATA_SIZE,\n", "    header=[\"userID\", \"itemID\", \"rating\", \"timestamp\"]\n", ")\n", "\n", "df.head()"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 124, "lines": ["train, test = python_chrono_split(df, 0.75)"]}, {"block": 11, "type": "markdown", "linesLength": 9, "startIndex": 125, "lines": ["### 3.2 Functions of NCF Dataset \n", "\n", "Dataset Class for NCF, where important functions are:\n", "\n", "`negative_sampling()`, sample negative user & item pair for every positive instances, with parameter `n_neg`.\n", "\n", "`train_loader(batch_size, shuffle=True)`, generate training batch with `batch_size`, also we can set whether `shuffle` this training set.\n", "\n", "`test_loader()`, generate test batch by every positive test instance, (eg. \\[1, 2, 1\\] is a positive user & item pair in test set (\\[userID, itemID, rating\\] for this tuple). This function returns like \\[\\[1, 2, 1\\], \\[1, 3, 0\\], \\[1,6, 0\\], ...\\], ie. following our *leave-one-out* evaluation protocol."]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 134, "lines": ["data = NCFDataset(train=train, test=test, seed=123)"]}, {"block": 13, "type": "markdown", "linesLength": 13, "startIndex": 135, "lines": ["### 3.3 Train NCF based on TensorFlow\n", "The NCF has a lot of parameters. The most important ones are:\n", "\n", "`n_factors`, which controls the dimension of the latent space. Usually, the quality of the training set predictions grows with as n_factors gets higher.\n", "\n", "`layer_sizes`, sizes of input layer (and hidden layers) of MLP, input type is list.\n", "\n", "`n_epochs`, which defines the number of iteration of the SGD procedure.\n", "Note that both parameter also affect the training time.\n", "\n", "`model_type`, we can train single `\"MLP\"`, `\"GMF\"` or combined model `\"NCF\"` by changing the type of model.\n", "\n", "We will here set `n_factors` to `4`, `layer_sizes` to `[16,8,4]`,  `n_epochs` to `100`, `batch_size` to 256. To train the model, we simply need to call the `fit()` method."]}, {"block": 14, "type": "code", "linesLength": 11, "startIndex": 148, "lines": ["model = NCF (\n", "    n_users=data.n_users, \n", "    n_items=data.n_items,\n", "    model_type=\"NeuMF\",\n", "    n_factors=4,\n", "    layer_sizes=[16,8,4],\n", "    n_epochs=EPOCHS,\n", "    batch_size=BATCH_SIZE,\n", "    learning_rate=1e-3,\n", "    verbose=10,\n", ")"]}, {"block": 15, "type": "code", "linesLength": 7, "startIndex": 159, "lines": ["start_time = time.time()\n", "\n", "model.fit(data)\n", "\n", "train_time = time.time() - start_time\n", "\n", "print(\"Took {} seconds for training.\".format(train_time))"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 166, "lines": ["## 3.4 Prediction and Evaluation"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 167, "lines": ["### 3.4.1 Prediction\n", "\n", "Now that our model is fitted, we can call `predict` to get some `predictions`. `predict` returns an internal object Prediction which can be easily converted back to a dataframe:"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 170, "lines": ["predictions = [[row.userID, row.itemID, model.predict(row.userID, row.itemID)]\n", "               for (_, row) in test.iterrows()]\n", "\n", "test_time = time.time() - start_time\n", "\n", "predictions = pd.DataFrame(predictions, columns=['userID', 'itemID', 'prediction'])\n", "predictions.head()"]}, {"block": 19, "type": "markdown", "linesLength": 3, "startIndex": 177, "lines": ["### 3.4.2 Generic Evaluation\n", "We remove rated movies in the top k recommendations\n", "To compute ranking metrics, we need predictions on all user, item pairs. We remove though the items already watched by the user, since we choose not to recommend them again."]}, {"block": 20, "type": "code", "linesLength": 17, "startIndex": 180, "lines": ["start_time = time.time()\n", "\n", "users, items, preds = [], [], []\n", "item = list(train.itemID.unique())\n", "for user in train.userID.unique():\n", "    user = [user] * len(item) \n", "    users.extend(user)\n", "    items.extend(item)\n", "    preds.extend(list(model.predict(user, item, is_list=True)))\n", "\n", "all_predictions = pd.DataFrame(data={\"userID\": users, \"itemID\":items, \"prediction\":preds})\n", "\n", "merged = pd.merge(train, all_predictions, on=[\"userID\", \"itemID\"], how=\"outer\")\n", "all_predictions = merged[merged.rating.isnull()].drop('rating', axis=1)\n", "\n", "test_time = time.time() - start_time\n", "print(\"Took {} seconds for prediction.\".format(test_time))"]}, {"block": 21, "type": "code", "linesLength": 10, "startIndex": 197, "lines": ["\n", "eval_map = map_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_ndcg = ndcg_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_precision = precision_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_recall = recall_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "\n", "print(\"MAP:\\t%f\" % eval_map,\n", "      \"NDCG:\\t%f\" % eval_ndcg,\n", "      \"Precision@K:\\t%f\" % eval_precision,\n", "      \"Recall@K:\\t%f\" % eval_recall, sep='\\n')"]}, {"block": 22, "type": "markdown", "linesLength": 11, "startIndex": 207, "lines": ["### 3.4.3 \"Leave-one-out\" Evaluation\n", "\n", "We implement the functions to repoduce the leave-one-out evaluation protocol mentioned in original NCF paper.\n", "\n", "For each item in test data, we randomly samples 100 items that are not interacted by the user, ranking the test item among the 101 items (1 positive item and 100 negative items). The performance of a ranked list is judged by **Hit Ratio (HR)** and **Normalized Discounted Cumulative Gain (NDCG)**. Finally, we average the values of those ranked lists to obtain the overall HR and NDCG on test data.\n", "\n", "We truncated the ranked list at 10 for both metrics. As such, the HR intuitively measures whether the test item is present on the top-10 list, and the NDCG accounts for the position of the hit by assigning higher scores to hits at top ranks.\n", "\n", "**Note 1:** In exact leave-one-out evaluation protocol, we select only one of the latest items interacted with a user as test data for each user. But in this notebook, to compare with other algorithms, we select latest 25% dataset as test data. So this is an artificial \"leave-one-out\" evaluation only showing how to use `test_loader` and how to calculate metrics like the original paper. You can reproduce the real leave-one-out evaluation by changing the way of splitting data.\n", "\n", "**Note 2:** Because of sampling 100 negative items for each positive test item, "]}, {"block": 23, "type": "code", "linesLength": 23, "startIndex": 218, "lines": ["k = TOP_K\n", "\n", "ndcgs = []\n", "hit_ratio = []\n", "\n", "for b in data.test_loader():\n", "    user_input, item_input, labels = b\n", "    output = model.predict(user_input, item_input, is_list=True)\n", "\n", "    output = np.squeeze(output)\n", "    rank = sum(output >= output[0])\n", "    if rank <= k:\n", "        ndcgs.append(1 / np.log(rank + 1))\n", "        hit_ratio.append(1)\n", "    else:\n", "        ndcgs.append(0)\n", "        hit_ratio.append(0)\n", "\n", "eval_ndcg = np.mean(ndcgs)\n", "eval_hr = np.mean(hit_ratio)\n", "\n", "print(\"HR:\\t%f\" % eval_hr)\n", "print(\"NDCG:\\t%f\" % eval_ndcg)\n"]}, {"block": 24, "type": "markdown", "linesLength": 8, "startIndex": 241, "lines": ["## 3.5 Pre-training\n", "\n", "To get better performance of NeuMF, we can adopt pre-training strategy. We first train GMF and MLP with random initializations until convergence. Then use their model parameters as the initialization for the corresponding parts of NeuMF\u2019s parameters.  Please pay attention to the output layer, where we concatenate weights of the two models with\n", "\n", "$$h ^ { N C F } \\leftarrow \\left[ \\begin{array} { c } { \\alpha h ^ { G M F } } \\\\ { ( 1 - \\alpha ) h ^ { M L P } } \\end{array} \\right]$$\n", "\n", "where $h^{GMF}$ and $h^{MLP}$ denote the $h$ vector of the pretrained GMF and MLP model, respectively; and $\\alpha$ is a\n", "hyper-parameter determining the trade-off between the two pre-trained models. We set $\\alpha$ = 0.5."]}, {"block": 25, "type": "markdown", "linesLength": 2, "startIndex": 249, "lines": ["### 3.5.1 Training GMF and MLP model\n", "`model.save`, we can set the `dir_name` to store the parameters of GMF and MLP"]}, {"block": 26, "type": "code", "linesLength": 11, "startIndex": 251, "lines": ["model = NCF (\n", "    n_users=data.n_users, \n", "    n_items=data.n_items,\n", "    model_type=\"GMF\",\n", "    n_factors=4,\n", "    layer_sizes=[16,8,4],\n", "    n_epochs=EPOCHS,\n", "    batch_size=BATCH_SIZE,\n", "    learning_rate=1e-3,\n", "    verbose=10,\n", ")"]}, {"block": 27, "type": "code", "linesLength": 9, "startIndex": 262, "lines": ["start_time = time.time()\n", "\n", "model.fit(data)\n", "\n", "train_time = time.time() - start_time\n", "\n", "print(\"Took {} seconds for training.\".format(train_time))\n", "\n", "model.save(dir_name=\".pretrain/GMF\")"]}, {"block": 28, "type": "code", "linesLength": 13, "startIndex": 271, "lines": ["model = NCF (\n", "    n_users=data.n_users, \n", "    n_items=data.n_items,\n", "    model_type=\"MLP\",\n", "    n_factors=4,\n", "    layer_sizes=[16,8,4],\n", "    n_epochs=EPOCHS,\n", "    batch_size=BATCH_SIZE,\n", "    learning_rate=1e-3,\n", "    verbose=10,\n", ")\n", "\n", "start_time = time.time()"]}, {"block": 29, "type": "code", "linesLength": 7, "startIndex": 284, "lines": ["model.fit(data)\n", "\n", "train_time = time.time() - start_time\n", "\n", "print(\"Took {} seconds for training.\".format(train_time))\n", "\n", "model.save(dir_name=\".pretrain/MLP\")"]}, {"block": 30, "type": "markdown", "linesLength": 2, "startIndex": 291, "lines": ["### 3.5.2 Load pre-trained GMF and MLP model for NeuMF\n", "`model.load`, we can set the `gmf_dir` and `mlp_dir` to store the parameters for NeuMF."]}, {"block": 31, "type": "code", "linesLength": 13, "startIndex": 293, "lines": ["model = NCF (\n", "    n_users=data.n_users, \n", "    n_items=data.n_items,\n", "    model_type=\"NeuMF\",\n", "    n_factors=4,\n", "    layer_sizes=[16,8,4],\n", "    n_epochs=EPOCHS,\n", "    batch_size=BATCH_SIZE,\n", "    learning_rate=1e-3,\n", "    verbose=10,\n", ")\n", "\n", "model.load(gmf_dir=\".pretrain/GMF\", mlp_dir=\".pretrain/MLP\", alpha=0.5)"]}, {"block": 32, "type": "code", "linesLength": 7, "startIndex": 306, "lines": ["start_time = time.time()\n", "\n", "model.fit(data)\n", "\n", "train_time = time.time() - start_time\n", "\n", "print(\"Took {} seconds for training.\".format(train_time))"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 313, "lines": ["### 3.5.3 Compare with not pre-trained NeuMF\n", "\n", "You can use beforementioned evaluation methods to evaluate the pre-trained `NCF` Model. Usually, we will find the performance of pre-trained NCF is better than the not pre-trained."]}, {"block": 34, "type": "code", "linesLength": 17, "startIndex": 316, "lines": ["start_time = time.time()\n", "\n", "users, items, preds = [], [], []\n", "item = list(train.itemID.unique())\n", "for user in train.userID.unique():\n", "    user = [user] * len(item) \n", "    users.extend(user)\n", "    items.extend(item)\n", "    preds.extend(list(model.predict(user, item, is_list=True)))\n", "\n", "all_predictions = pd.DataFrame(data={\"userID\": users, \"itemID\":items, \"prediction\":preds})\n", "\n", "merged = pd.merge(train, all_predictions, on=[\"userID\", \"itemID\"], how=\"outer\")\n", "all_predictions = merged[merged.rating.isnull()].drop('rating', axis=1)\n", "\n", "test_time = time.time() - start_time\n", "print(\"Took {} seconds for prediction.\".format(test_time))"]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 333, "lines": ["eval_map = map_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_ndcg = ndcg_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_precision = precision_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "eval_recall = recall_at_k(test, all_predictions, col_prediction='prediction', k=TOP_K)\n", "\n", "print(\"MAP:\\t%f\" % eval_map,\n", "      \"NDCG:\\t%f\" % eval_ndcg,\n", "      \"Precision@K:\\t%f\" % eval_precision,\n", "      \"Recall@K:\\t%f\" % eval_recall, sep='\\n')"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 342, "lines": ["### 3.5.4 Delete pre-trained directory"]}, {"block": 37, "type": "code", "linesLength": 5, "startIndex": 343, "lines": ["save_dir = \".pretrain\"\n", "if os.path.exists(save_dir):\n", "    shutil.rmtree(save_dir)\n", "    \n", "print(\"Did \\'%s\\' existed?: %s\" % (save_dir, os.path.exists(save_dir)))"]}, {"block": 38, "type": "markdown", "linesLength": 6, "startIndex": 348, "lines": ["### Reference: \n", "1. Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu & Tat-Seng Chua Neural Collaborative Filtering: https://www.comp.nus.edu.sg/~xiangnan/papers/ncf.pdf\n", "\n", "2. Official NCF implementation [Keras with Theano]: https://github.com/hexiangnan/neural_collaborative_filtering\n", "\n", "3. Other nice NCF implementation [Pytorch]: https://github.com/LaceyChen17/neural-collaborative-filtering"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["## The data block API"]}, {"block": 1, "type": "code", "linesLength": 3, "startIndex": 1, "lines": ["from fastai.gen_doc.nbdoc import *\n", "from fastai.basics import *\n", "np.random.seed(42)"]}, {"block": 2, "type": "markdown", "linesLength": 15, "startIndex": 4, "lines": ["The data block API lets you customize the creation of a [`DataBunch`](/basic_data.html#DataBunch) by isolating the underlying parts of that process in separate blocks, mainly:\n", "  1. Where are the inputs and how to create them?\n", "  1. How to split the data into a training and validation sets?\n", "  1. How to label the inputs?\n", "  1. What transforms to apply?\n", "  1. How to add a test set?\n", "  1. How to wrap in dataloaders and create the [`DataBunch`](/basic_data.html#DataBunch)?\n", "  \n", "Each of these may be addressed with a specific block designed for your unique setup. Your inputs might be in a folder, a csv file, or a dataframe. You may want to split them randomly, by certain indices or depending on the folder they are in. You can have your labels in your csv file or your dataframe, but it may come from folders or a specific function of the input. You may choose to add data augmentation or not. A test set is optional too. Finally you have to set the arguments to put the data together in a [`DataBunch`](/basic_data.html#DataBunch) (batch size, collate function...)\n", "\n", "The data block API is called as such because you can mix and match each one of those blocks with the others, allowing for a total flexibility to create your customized [`DataBunch`](/basic_data.html#DataBunch) for training, validation and testing. The factory methods of the various [`DataBunch`](/basic_data.html#DataBunch) are great for beginners but you can't always make your data fit in the tracks they require.\n", "\n", "<img src=\"imgs/mix_match.png\" alt=\"Mix and match\" width=\"200\">\n", "\n", "As usual, we'll begin with end-to-end examples, then switch to the details of each of those parts."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["## Examples of use"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Let's begin with our traditional MNIST example."]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["from fastai.vision import *"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 22, "lines": ["path = untar_data(URLs.MNIST_TINY)\n", "tfms = get_transforms(do_flip=False)\n", "path.ls()"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["(path/'train').ls()"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["In [`vision.data`](/vision.data.html#vision.data), we can create a [`DataBunch`](/basic_data.html#DataBunch) suitable for image classification by simply typing:"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["data = ImageDataBunch.from_folder(path, ds_tfms=tfms, size=64)"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 28, "lines": ["This is a shortcut method which is aimed at data that is in folders following an ImageNet style, with the [`train`](/train.html#train) and `valid` directories, each containing one subdirectory per class, where all the labelled pictures are. There is also a `test` directory containing unlabelled pictures. \n", "\n", "Here is the same code, but this time using the data block API, which can work with any style of a dataset. All the stages, which will be explained below, can be grouped together like this:"]}, {"block": 11, "type": "code", "linesLength": 6, "startIndex": 31, "lines": ["data = (ImageList.from_folder(path) #Where to find the data? -> in path and its subfolders\n", "        .split_by_folder()              #How to split in train/valid? -> use the folders\n", "        .label_from_folder()            #How to label? -> depending on the folder of the filenames\n", "        .add_test_folder()              #Optionally add a test set (here default name is test)\n", "        .transform(tfms, size=64)       #Data augmentation? -> use tfms with a size of 64\n", "        .databunch())                   #Finally? -> use the defaults for conversion to ImageDataBunch"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["Now we can look at the created DataBunch:"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 38, "lines": ["data.show_batch(3, figsize=(6,6), hide_axis=False)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Let's look at another example from [`vision.data`](/vision.data.html#vision.data) with the planet dataset. This time, it's a multiclassification problem with the labels in a csv file and no given split between valid and train data, so we use a random split. The factory method is:"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 40, "lines": ["planet = untar_data(URLs.PLANET_TINY)\n", "planet_tfms = get_transforms(flip_vert=True, max_lighting=0.1, max_zoom=1.05, max_warp=0.)"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["pd.read_csv(planet/\"labels.csv\").head()"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["data = ImageDataBunch.from_csv(planet, folder='train', size=128, suffix='.jpg', label_delim = ' ', ds_tfms=planet_tfms)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["With the data block API we can rewrite this like that:"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["planet.ls()"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["pd.read_csv(planet/\"labels.csv\").head()"]}, {"block": 21, "type": "code", "linesLength": 10, "startIndex": 47, "lines": ["data = (ImageList.from_csv(planet, 'labels.csv', folder='train', suffix='.jpg')\n", "        #Where to find the data? -> in planet 'train' folder\n", "        .split_by_rand_pct()\n", "        #How to split in train/valid? -> randomly with the default 20% in valid\n", "        .label_from_df(label_delim=' ')\n", "        #How to label? -> use the second column of the csv file and split the tags by ' '\n", "        .transform(planet_tfms, size=128)\n", "        #Data augmentation? -> use tfms with a size of 128\n", "        .databunch())                          \n", "        #Finally -> use the defaults for conversion to databunch"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["data.show_batch(rows=2, figsize=(9,7))"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["The data block API also allows you to get your data together in problems for which there is no direct [`ImageDataBunch`](/vision.data.html#ImageDataBunch) factory method. For a segmentation task, for instance, we can use it to quickly get a [`DataBunch`](/basic_data.html#DataBunch). Let's take the example of the [camvid dataset](http://mi.eng.cam.ac.uk/research/projects/VideoRec/CamVid/). The images are in an 'images' folder and their corresponding mask is in a 'labels' folder."]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["camvid = untar_data(URLs.CAMVID_TINY)\n", "path_lbl = camvid/'labels'\n", "path_img = camvid/'images'"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["We have a file that gives us the names of the classes (what each code inside the masks corresponds to: a pedestrian, a tree, a road...)"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["codes = np.loadtxt(camvid/'codes.txt', dtype=str); codes"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["And we define the following function that infers the mask filename from the image filename."]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["get_y_fn = lambda x: path_lbl/f'{x.stem}_P{x.suffix}'"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Then we can easily define a [`DataBunch`](/basic_data.html#DataBunch) using the data block API. Here we need to use `tfm_y=True` in the transform call because we need the same transforms to be applied to the target mask as were applied to the image. Side note: For further control over which transformations are used on the target, each transformation has a `use_on_y` parameter"]}, {"block": 30, "type": "code", "linesLength": 10, "startIndex": 67, "lines": ["data = (SegmentationItemList.from_folder(path_img)\n", "        #Where to find the data? -> in path_img and its subfolders\n", "        .split_by_rand_pct()\n", "        #How to split in train/valid? -> randomly with the default 20% in valid\n", "        .label_from_func(get_y_fn, classes=codes)\n", "        #How to label? -> use the label function on the file name of the data\n", "        .transform(get_transforms(), tfm_y=True, size=128)\n", "        #Data augmentation? -> use tfms with a size of 128, also transform the label images\n", "        .databunch())\n", "        #Finally -> use the defaults for conversion to databunch"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["data.show_batch(rows=2, figsize=(7,5))"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["Another example for object detection. We use our tiny sample of the [COCO dataset](http://cocodataset.org/#home) here. There is a helper function in the library that reads the annotation file and returns the list of images names with the list of labelled bboxes associated to it. We convert it to a dictionary that maps image names with their bboxes and then write the function that will give us the target for each image filename."]}, {"block": 33, "type": "code", "linesLength": 4, "startIndex": 79, "lines": ["coco = untar_data(URLs.COCO_TINY)\n", "images, lbl_bbox = get_annotations(coco/'train.json')\n", "img2bbox = dict(zip(images, lbl_bbox))\n", "get_y_func = lambda o:img2bbox[o.name]"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["The following code is very similar to what we saw before. The only new addition is the use of a special function to collate the samples in batches. This comes from the fact that our images may have multiple bounding boxes, so we need to pad them to the largest number of bounding boxes."]}, {"block": 35, "type": "code", "linesLength": 11, "startIndex": 84, "lines": ["data = (ObjectItemList.from_folder(coco)\n", "        #Where are the images? -> in coco and its subfolders\n", "        .split_by_rand_pct()                          \n", "        #How to split in train/valid? -> randomly with the default 20% in valid\n", "        .label_from_func(get_y_func)\n", "        #How to find the labels? -> use get_y_func on the file name of the data\n", "        .transform(get_transforms(), tfm_y=True)\n", "        #Data augmentation? -> Standard transforms; also transform the label images\n", "        .databunch(bs=16, collate_fn=bb_pad_collate))   \n", "        #Finally we convert to a DataBunch, use a batch size of 16,\n", "        # and we use bb_pad_collate to collate the data into a mini-batch"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 95, "lines": ["data.show_batch(rows=2, ds_type=DatasetType.Valid, figsize=(6,6))"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["But vision isn't the only application where the data block API works. It can also be used for text and tabular data. With our sample of the IMDB dataset (labelled texts in a csv file), here is how to get the data together for a language model."]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 97, "lines": ["from fastai.text import *"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["imdb = untar_data(URLs.IMDB_SAMPLE)"]}, {"block": 40, "type": "code", "linesLength": 9, "startIndex": 99, "lines": ["data_lm = (TextList\n", "           .from_csv(imdb, 'texts.csv', cols='text')\n", "           #Where are the text? Column 'text' of texts.csv\n", "           .split_by_rand_pct()\n", "           #How to split it? Randomly with the default 20% in valid\n", "           .label_for_lm()\n", "           #Label it for a language model\n", "           .databunch())\n", "           #Finally we convert to a DataBunch"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 108, "lines": ["data_lm.show_batch()"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["For a classification problem, we just have to change the way labeling is done. Here we use the csv column `label`."]}, {"block": 43, "type": "code", "linesLength": 4, "startIndex": 110, "lines": ["data_clas = (TextList.from_csv(imdb, 'texts.csv', cols='text')\n", "                   .split_from_df(col='is_valid')\n", "                   .label_from_df(cols='label')\n", "                   .databunch())"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 114, "lines": ["data_clas.show_batch()"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["Lastly, for tabular data, we just have to pass the name of our categorical and continuous variables as an extra argument. We also add some [`PreProcessor`](/data_block.html#PreProcessor)s that are going to be applied to our data once the splitting and labelling is done."]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 116, "lines": ["from fastai.tabular import *"]}, {"block": 47, "type": "code", "linesLength": 6, "startIndex": 117, "lines": ["adult = untar_data(URLs.ADULT_SAMPLE)\n", "df = pd.read_csv(adult/'adult.csv')\n", "dep_var = 'salary'\n", "cat_names = ['workclass', 'education', 'marital-status', 'occupation', 'relationship', 'race', 'sex', 'native-country']\n", "cont_names = ['education-num', 'hours-per-week', 'age', 'capital-loss', 'fnlwgt', 'capital-gain']\n", "procs = [FillMissing, Categorify, Normalize]"]}, {"block": 48, "type": "code", "linesLength": 4, "startIndex": 123, "lines": ["data = (TabularList.from_df(df, path=adult, cat_names=cat_names, cont_names=cont_names, procs=procs)\n", "                           .split_by_idx(valid_idx=range(800,1000))\n", "                           .label_from_df(cols=dep_var)\n", "                           .databunch())"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 127, "lines": ["data.show_batch()"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 128, "lines": ["## Step 1: Provide inputs"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["The basic class to get your inputs is the following one. It's also the same class that will contain all of your labels (hence the name [`ItemList`](/data_block.html#ItemList))."]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 130, "lines": ["show_doc(ItemList, title_level=3)"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 131, "lines": ["This class regroups the inputs for our model in `items` and saves a `path` attribute which is where it will look for any files (image files, csv file with labels...). `label_cls` will be called to create the labels from the result of the label function, `inner_df` is an underlying dataframe, and `processor` is to be applied to the inputs after the splitting and labeling."]}, {"block": 54, "type": "markdown", "linesLength": 15, "startIndex": 132, "lines": ["It has multiple subclasses depending on the type of data you're handling. Here is a quick list:\n", "  - [`CategoryList`](/data_block.html#CategoryList) for labels in classification\n", "  - [`MultiCategoryList`](/data_block.html#MultiCategoryList) for labels in a multi classification problem\n", "  - [`FloatList`](/data_block.html#FloatList) for float labels in a regression problem\n", "  - [`ImageList`](/vision.data.html#ImageList) for data that are images\n", "  - [`SegmentationItemList`](/vision.data.html#SegmentationItemList) like [`ImageList`](/vision.data.html#ImageList) but will default labels to [`SegmentationLabelList`](/vision.data.html#SegmentationLabelList)\n", "  - [`SegmentationLabelList`](/vision.data.html#SegmentationLabelList) for segmentation masks\n", "  - [`ObjectItemList`](/vision.data.html#ObjectItemList) like [`ImageList`](/vision.data.html#ImageList) but will default labels to `ObjectLabelList`\n", "  - `ObjectLabelList` for object detection\n", "  - [`PointsItemList`](/vision.data.html#PointsItemList) for points (of the type [`ImagePoints`](/vision.image.html#ImagePoints))\n", "  - [`ImageImageList`](/vision.data.html#ImageImageList) for image to image tasks\n", "  - [`TextList`](/text.data.html#TextList) for text data\n", "  - [`TextList`](/text.data.html#TextList) for text data stored in files\n", "  - [`TabularList`](/tabular.data.html#TabularList) for tabular data\n", "  - [`CollabList`](/collab.html#CollabList) for collaborative filtering"]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["We can get a little glimpse of how [`ItemList`](/data_block.html#ItemList)'s basic attributes and methods behave with the following code examples."]}, {"block": 56, "type": "code", "linesLength": 4, "startIndex": 148, "lines": ["from fastai.vision import *\n", "path_data = untar_data(URLs.MNIST_TINY)\n", "il_data = ItemList.from_folder(path_data, extensions=['.csv'])\n", "il_data"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 152, "lines": ["Here is how to access the path of [`ItemList`](/data_block.html#ItemList) and the actual `items` (here files) in the path."]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 153, "lines": ["il_data.path"]}, {"block": 59, "type": "code", "linesLength": 1, "startIndex": 154, "lines": ["il_data.items"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["`len(il_data)` gives you the count of files inside `il_data` and you can access individual items using index. "]}, {"block": 61, "type": "code", "linesLength": 1, "startIndex": 156, "lines": ["len(il_data)"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 157, "lines": ["[`ItemList`](/data_block.html#ItemList) returns a single item with a single index, but returns an [`ItemList`](/data_block.html#ItemList) if given a list of indexes."]}, {"block": 63, "type": "code", "linesLength": 1, "startIndex": 158, "lines": ["il_data[1]"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 159, "lines": ["il_data[:1]"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 160, "lines": ["With `il_data.add` we can perform in_place concatenate another [`ItemList`](/data_block.html#ItemList) object."]}, {"block": 66, "type": "code", "linesLength": 1, "startIndex": 161, "lines": ["il_data.add(il_data); il_data"]}, {"block": 67, "type": "code", "linesLength": 1, "startIndex": 162, "lines": ["from fastai.vision import *"]}, {"block": 68, "type": "code", "linesLength": 1, "startIndex": 163, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 69, "type": "code", "linesLength": 2, "startIndex": 164, "lines": ["itemlist = ItemList.from_folder(path_data/'test')\n", "itemlist"]}, {"block": 70, "type": "markdown", "linesLength": 7, "startIndex": 166, "lines": ["As we can see, the files do not necesarily return in alpha-numeric order by default. In the above: 1503.png, ... 617.png, 585.png ...\n", "\n", "This is OK when you're always using the same machine, as the same dataset should return in the same order. But when building a datablock on one machine (say GCP) and then porting the same code to a different machine (say your laptop) that same dataset and code might return the files in a different order.\n", "\n", "Since all random operations use the loaded order of the dataset as the starting point, you will not be able to replicate any random operations, say randomly splitting the data into 80% train, and 20% validation, even while correctly seeding.\n", "\n", "The solution is to use `presort=True` in the `.from_folder()` method. As can be seen below, with that argument turned on, the file is returned in ascending order, and this behavior will match across machines and across platforms. Now you can reproduce any random operation you perform on the loaded data."]}, {"block": 71, "type": "code", "linesLength": 2, "startIndex": 173, "lines": ["itemlist = ItemList.from_folder(path_data/'test', presort=True)\n", "itemlist"]}, {"block": 72, "type": "markdown", "linesLength": 3, "startIndex": 175, "lines": ["How is the output above generated?\n", "\n", "behind the scenes, executing `itemlist` calls [`ItemList.__repr__`](/data_block.html#ItemList.__repr__) which basically prints out `itemlist[0]` to `itemlist[4]`"]}, {"block": 73, "type": "code", "linesLength": 1, "startIndex": 178, "lines": ["itemlist[0]"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 179, "lines": ["and `itemlist[0]` basically calls `itemlist.get(0)` which returns `itemlist.items[0]`. That's why we have outputs like above."]}, {"block": 75, "type": "code", "linesLength": 0, "startIndex": 180, "lines": []}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 180, "lines": ["Once you have selected the class that is suitable, you can instantiate it with one of the following factory methods"]}, {"block": 77, "type": "code", "linesLength": 1, "startIndex": 181, "lines": ["show_doc(ItemList.from_folder)"]}, {"block": 78, "type": "code", "linesLength": 2, "startIndex": 182, "lines": ["path = untar_data(URLs.MNIST_TINY)\n", "path.ls()"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 184, "lines": ["ImageList.from_folder(path)"]}, {"block": 80, "type": "markdown", "linesLength": 3, "startIndex": 185, "lines": ["`path` is your root data folder. In the `path` directory you have _train_ and _valid_ folders which would contain your images. For the below example, _train_ folder contains two folders/classes _cat_ and _dog_.\n", "\n", "<img src=\"imgs/from_folder.png\" alt=\"from_folder\">"]}, {"block": 81, "type": "code", "linesLength": 1, "startIndex": 188, "lines": ["show_doc(ItemList.from_df)"]}, {"block": 82, "type": "markdown", "linesLength": 5, "startIndex": 189, "lines": ["Dataframe has 2 columns. The first column is the path to the image and the second column contains label id for that image. In case you have multi-labels (i.e more than one label for a single image), you will have a space (as determined by `label_delim` argument of `label_from_df`) seperated string in the labels column.\n", "\n", "`from_df` and `from_csv` can be used in a more general way. In cases you are not able to figure out how to get your ImageList, it is very easy to make a csv file with the above format.\n", "\n", "How to set `path`? `path` refers to your root data directory. So the paths in your csv file should be relative to `path` and not absolute paths. In the below example, in _labels.csv_ the paths to the images are __path + train/3/7463.png__"]}, {"block": 83, "type": "code", "linesLength": 2, "startIndex": 194, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "path.ls()"]}, {"block": 84, "type": "code", "linesLength": 2, "startIndex": 196, "lines": ["df = pd.read_csv(path/'labels.csv')\n", "df.head()"]}, {"block": 85, "type": "code", "linesLength": 1, "startIndex": 198, "lines": ["ImageList.from_df(df, path)"]}, {"block": 86, "type": "code", "linesLength": 1, "startIndex": 199, "lines": ["show_doc(ItemList.from_csv)"]}, {"block": 87, "type": "code", "linesLength": 2, "startIndex": 200, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "path.ls()"]}, {"block": 88, "type": "code", "linesLength": 1, "startIndex": 202, "lines": ["ImageList.from_csv(path, 'labels.csv')"]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 203, "lines": ["### Optional step: filter your data"]}, {"block": 90, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["The factory method may have grabbed too many items. For instance, if you were searching sub folders with the `from_folder` method, you may have gotten files you don't want. To remove those, you can use one of the following methods."]}, {"block": 91, "type": "code", "linesLength": 1, "startIndex": 205, "lines": ["show_doc(ItemList.filter_by_func)"]}, {"block": 92, "type": "code", "linesLength": 3, "startIndex": 206, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "df = pd.read_csv(path/'labels.csv')\n", "df.head()"]}, {"block": 93, "type": "markdown", "linesLength": 1, "startIndex": 209, "lines": ["Suppose that you only want to keep images with a suffix \".png\". Well, this method will do magic for you."]}, {"block": 94, "type": "code", "linesLength": 1, "startIndex": 210, "lines": ["Path(df.name[0]).suffix"]}, {"block": 95, "type": "code", "linesLength": 1, "startIndex": 211, "lines": ["ImageList.from_df(df, path).filter_by_func(lambda fname: Path(fname).suffix == '.png')"]}, {"block": 96, "type": "code", "linesLength": 1, "startIndex": 212, "lines": ["show_doc(ItemList.filter_by_folder)"]}, {"block": 97, "type": "code", "linesLength": 1, "startIndex": 213, "lines": ["show_doc(ItemList.filter_by_rand)"]}, {"block": 98, "type": "code", "linesLength": 2, "startIndex": 214, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "ImageList.from_folder(path).filter_by_rand(0.5)"]}, {"block": 99, "type": "markdown", "linesLength": 1, "startIndex": 216, "lines": ["Contrast the number of items with the list created without the filter."]}, {"block": 100, "type": "code", "linesLength": 1, "startIndex": 217, "lines": ["ImageList.from_folder(path)"]}, {"block": 101, "type": "code", "linesLength": 1, "startIndex": 218, "lines": ["show_doc(ItemList.to_text)"]}, {"block": 102, "type": "code", "linesLength": 2, "startIndex": 219, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "pd.read_csv(path/'labels.csv').head()"]}, {"block": 103, "type": "code", "linesLength": 2, "startIndex": 221, "lines": ["file_name = \"item_list.txt\"\n", "ImageList.from_folder(path).to_text(file_name)"]}, {"block": 104, "type": "code", "linesLength": 1, "startIndex": 223, "lines": ["! cat {path/file_name} | head"]}, {"block": 105, "type": "code", "linesLength": 1, "startIndex": 224, "lines": ["show_doc(ItemList.use_partial_data)"]}, {"block": 106, "type": "code", "linesLength": 2, "startIndex": 225, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "ImageList.from_folder(path).use_partial_data(0.5)"]}, {"block": 107, "type": "markdown", "linesLength": 1, "startIndex": 227, "lines": ["Contrast the number of items with the list created without the filter."]}, {"block": 108, "type": "code", "linesLength": 1, "startIndex": 228, "lines": ["ImageList.from_folder(path)"]}, {"block": 109, "type": "markdown", "linesLength": 1, "startIndex": 229, "lines": ["### Writing your own [`ItemList`](/data_block.html#ItemList)"]}, {"block": 110, "type": "markdown", "linesLength": 7, "startIndex": 230, "lines": ["First check if you can't easily customize one of the existing subclass by:\n", "- subclassing an existing one and replacing the `get` method (or the `open` method if you're dealing with images)\n", "- applying a custom `processor` (see step 4)\n", "- changing the default `label_cls` for the label creation\n", "- adding a default [`PreProcessor`](/data_block.html#PreProcessor) with the `_processor` class variable\n", "\n", "If this isn't the case and you really need to write your own class, there is a [full tutorial](/tutorial.itemlist) that explains how to proceed."]}, {"block": 111, "type": "code", "linesLength": 1, "startIndex": 237, "lines": ["show_doc(ItemList.analyze_pred)"]}, {"block": 112, "type": "code", "linesLength": 1, "startIndex": 238, "lines": ["show_doc(ItemList.get)"]}, {"block": 113, "type": "markdown", "linesLength": 1, "startIndex": 239, "lines": ["We will have a glimpse of how `get` work with the following demo. "]}, {"block": 114, "type": "code", "linesLength": 1, "startIndex": 240, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 115, "type": "code", "linesLength": 2, "startIndex": 241, "lines": ["il_data_base = ItemList.from_folder(path=path_data, extensions=['.png'], include=['test'])\n", "il_data_base"]}, {"block": 116, "type": "markdown", "linesLength": 1, "startIndex": 243, "lines": ["`get` is used inexplicitly within `il_data_base[15]`. `il_data_base.get(15)` gives the same result here, because its defulat it's to return that."]}, {"block": 117, "type": "code", "linesLength": 1, "startIndex": 244, "lines": ["il_data_base[15]"]}, {"block": 118, "type": "markdown", "linesLength": 1, "startIndex": 245, "lines": ["While creating your custom [`ItemList`](/data_block.html#ItemList) however, you can override this function to do some things to your item (like opening an image)."]}, {"block": 119, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["il_data_image = ImageList.from_folder(path=path_data, extensions=['.png'], include=['test'])\n", "il_data_image"]}, {"block": 120, "type": "markdown", "linesLength": 1, "startIndex": 248, "lines": ["Again, normally `get` is used inexplicitly within `il_data_image[15]`."]}, {"block": 121, "type": "code", "linesLength": 1, "startIndex": 249, "lines": ["il_data_image[15]"]}, {"block": 122, "type": "markdown", "linesLength": 1, "startIndex": 250, "lines": ["The reason why an image is printed out instead of a FilePath object, is [`ImageList.get`](/vision.data.html#ImageList.get) overwrites [`ItemList.get`](/data_block.html#ItemList.get) and use [`ImageList.open`](/vision.data.html#ImageList.open) to print an image."]}, {"block": 123, "type": "code", "linesLength": 1, "startIndex": 251, "lines": ["show_doc(ItemList.new)"]}, {"block": 124, "type": "markdown", "linesLength": 1, "startIndex": 252, "lines": ["You'll never need to subclass this normally, just don't forget to add to `self.copy_new` the names of the arguments that needs to be copied each time `new` is called in `__init__`."]}, {"block": 125, "type": "markdown", "linesLength": 1, "startIndex": 253, "lines": ["We will get a feel of how `new` works with the following examples."]}, {"block": 126, "type": "code", "linesLength": 1, "startIndex": 254, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 127, "type": "code", "linesLength": 2, "startIndex": 255, "lines": ["itemlist1 = ItemList.from_folder(path=path_data/'valid', extensions=['.png'])\n", "itemlist1"]}, {"block": 128, "type": "markdown", "linesLength": 1, "startIndex": 257, "lines": ["As you will see below, `copy_new` allows us to borrow any argument and its value from `itemlist1`, and `itemlist1.new(itemlist1.items)` allows us to use `items` and arguments inside `copy_new` to create another [`ItemList`](/data_block.html#ItemList) by calling [`ItemList.__init__`](/data_block.html#ItemList.__init__)."]}, {"block": 129, "type": "code", "linesLength": 1, "startIndex": 258, "lines": ["itemlist1.copy_new == ['x', 'label_cls', 'path']"]}, {"block": 130, "type": "code", "linesLength": 2, "startIndex": 259, "lines": ["((itemlist1.x == itemlist1.label_cls == itemlist1.inner_df == None) \n", " and (itemlist1.path == Path('/Users/Natsume/.fastai/data/mnist_tiny/valid')))\n"]}, {"block": 131, "type": "markdown", "linesLength": 1, "startIndex": 261, "lines": ["You can select any argument from [`ItemList.__init__`](/data_block.html#ItemList.__init__)'s signature and change their values. "]}, {"block": 132, "type": "code", "linesLength": 3, "startIndex": 262, "lines": ["itemlist1.copy_new = ['x', 'label_cls', 'path', 'inner_df']\n", "itemlist1.x = itemlist1.label_cls = itemlist1.path = itemlist1.inner_df = 'test'\n", "itemlist2 = itemlist1.new(items=itemlist1.items)"]}, {"block": 133, "type": "code", "linesLength": 2, "startIndex": 265, "lines": ["(itemlist2.inner_df == itemlist2.x == itemlist2.label_cls == 'test' \n", "and itemlist2.path == Path('test'))"]}, {"block": 134, "type": "code", "linesLength": 1, "startIndex": 267, "lines": ["show_doc(ItemList.reconstruct)"]}, {"block": 135, "type": "markdown", "linesLength": 1, "startIndex": 268, "lines": ["## Step 2: Split the data between the training and the validation set"]}, {"block": 136, "type": "markdown", "linesLength": 1, "startIndex": 269, "lines": ["This step is normally straightforward, you just have to pick one of the following functions depending on what you need."]}, {"block": 137, "type": "code", "linesLength": 1, "startIndex": 270, "lines": ["show_doc(ItemList.split_none)"]}, {"block": 138, "type": "code", "linesLength": 1, "startIndex": 271, "lines": ["show_doc(ItemList.split_by_rand_pct)"]}, {"block": 139, "type": "code", "linesLength": 1, "startIndex": 272, "lines": ["show_doc(ItemList.split_subsets)"]}, {"block": 140, "type": "markdown", "linesLength": 1, "startIndex": 273, "lines": ["This function is handy if you want to work with subsets of specific sizes, e.g., you want to use 20% of the data for the validation dataset, but you only want to train on a small subset of the rest of the data: `split_subsets(train_size=0.08, valid_size=0.2)`."]}, {"block": 141, "type": "code", "linesLength": 1, "startIndex": 274, "lines": ["show_doc(ItemList.split_by_files)"]}, {"block": 142, "type": "code", "linesLength": 1, "startIndex": 275, "lines": ["show_doc(ItemList.split_by_fname_file)"]}, {"block": 143, "type": "markdown", "linesLength": 1, "startIndex": 276, "lines": ["Internally makes a call to `split_by_files`. `fname` contains your image file names like 0001.png."]}, {"block": 144, "type": "code", "linesLength": 1, "startIndex": 277, "lines": ["show_doc(ItemList.split_by_folder)"]}, {"block": 145, "type": "code", "linesLength": 1, "startIndex": 278, "lines": ["jekyll_note(\"This method looks at the folder immediately after `self.path` for `valid` and `train`.\")"]}, {"block": 146, "type": "markdown", "linesLength": 1, "startIndex": 279, "lines": ["Basically, `split_by_folder` takes in two folder names ('train' and 'valid' in the following example), to split `il` the large [`ImageList`](/vision.data.html#ImageList) into two smaller [`ImageList`](/vision.data.html#ImageList)s, one for training set and the other for validation set. Both [`ImageList`](/vision.data.html#ImageList)s are attached to a large [`ItemLists`](/data_block.html#ItemLists) which is the final output of `split_by_folder`."]}, {"block": 147, "type": "code", "linesLength": 1, "startIndex": 280, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 148, "type": "code", "linesLength": 1, "startIndex": 281, "lines": ["il = ItemList.from_folder(path=path_data); il"]}, {"block": 149, "type": "code", "linesLength": 1, "startIndex": 282, "lines": ["sd = il.split_by_folder(train='train', valid='valid'); sd"]}, {"block": 150, "type": "markdown", "linesLength": 1, "startIndex": 283, "lines": ["Behind the scenes, `split_by_folder` uses `_get_by_folder(name)`, to turn both 'train' and 'valid' folders into two list of indexes, and pass them onto `split_by_idxs` to split `il` into two [`ImageList`](/vision.data.html#ImageList)s, and finally attached to a [`ItemLists`](/data_block.html#ItemLists). "]}, {"block": 151, "type": "code", "linesLength": 2, "startIndex": 284, "lines": ["train_idx = il._get_by_folder(name='train')\n", "train_idx[:5], train_idx[-5:], len(train_idx)"]}, {"block": 152, "type": "code", "linesLength": 2, "startIndex": 286, "lines": ["valid_idx = il._get_by_folder(name='valid') \n", "valid_idx[:5], valid_idx[-5:],len(valid_idx)"]}, {"block": 153, "type": "markdown", "linesLength": 1, "startIndex": 288, "lines": ["By the way, `_get_by_folder(name)` works in the following way, first, index the entire `il.items`, loop every item and if an item belongs to the named folder, e.g., 'train', then put it into a list. The folder `name` is the only input, and output is the list."]}, {"block": 154, "type": "code", "linesLength": 1, "startIndex": 289, "lines": ["show_doc(ItemList.split_by_idx)"]}, {"block": 155, "type": "code", "linesLength": 3, "startIndex": 290, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "df = pd.read_csv(path/'labels.csv')\n", "df.head()"]}, {"block": 156, "type": "markdown", "linesLength": 1, "startIndex": 293, "lines": ["You can pass a list of indices that you want to put in the validation set like [1, 3, 10]. Or you can pass a contiguous list like `list(range(1000))`"]}, {"block": 157, "type": "code", "linesLength": 3, "startIndex": 294, "lines": ["data = (ImageList.from_df(df, path)\n", "                 .split_by_idx(list(range(1000))))\n", "data"]}, {"block": 158, "type": "code", "linesLength": 1, "startIndex": 297, "lines": ["show_doc(ItemList.split_by_idxs)"]}, {"block": 159, "type": "markdown", "linesLength": 1, "startIndex": 298, "lines": ["Behind the scenes, `split_by_idxs` turns two index lists (`train_idx` and `valid_idx`) into two [`ImageList`](/vision.data.html#ImageList)s, and then pass onto `split_by_list` to split `il` into two [`ImageList`](/vision.data.html#ImageList)s and attach to a [`ItemLists`](/data_block.html#ItemLists)."]}, {"block": 160, "type": "code", "linesLength": 1, "startIndex": 299, "lines": ["sd = il.split_by_idxs(train_idx=train_idx, valid_idx=valid_idx); sd"]}, {"block": 161, "type": "code", "linesLength": 1, "startIndex": 300, "lines": ["show_doc(ItemList.split_by_list)"]}, {"block": 162, "type": "markdown", "linesLength": 1, "startIndex": 301, "lines": ["`split_by_list` takes in two [`ImageList`](/vision.data.html#ImageList)s which in the case below are `il[train_idx]` and `il[valid_idx]`, and pass them onto `_split` ([`ItemLists`](/data_block.html#ItemLists)) to initialize an [`ItemLists`](/data_block.html#ItemLists) object, which basically takes in the training, valiation and testing (optionally) [`ImageList`](/vision.data.html#ImageList)s as its properties."]}, {"block": 163, "type": "code", "linesLength": 1, "startIndex": 302, "lines": ["sd = il.split_by_list(train=il[train_idx], valid=il[valid_idx]); sd"]}, {"block": 164, "type": "markdown", "linesLength": 1, "startIndex": 303, "lines": ["This is more of an internal method, you should be using `split_by_files` if you want to pass a list of filenames for the validation set."]}, {"block": 165, "type": "code", "linesLength": 1, "startIndex": 304, "lines": ["show_doc(ItemList.split_by_valid_func)"]}, {"block": 166, "type": "code", "linesLength": 1, "startIndex": 305, "lines": ["show_doc(ItemList.split_from_df)"]}, {"block": 167, "type": "markdown", "linesLength": 1, "startIndex": 306, "lines": ["To use this function, you need a boolean column `is_valid`. If `is_valid[index] = True`, then that example is put in the validation set and if `is_valid[index] = False` the example is put in the training set."]}, {"block": 168, "type": "code", "linesLength": 10, "startIndex": 307, "lines": ["path = untar_data(URLs.MNIST_SAMPLE)\n", "df = pd.read_csv(path/'labels.csv')\n", "\n", "# Create a new column for is_valid\n", "df['is_valid'] = [True]*(df.shape[0]//2) + [False]*(df.shape[0]//2)\n", "\n", "# Randomly shuffle dataframe\n", "df = df.reindex(np.random.permutation(df.index))\n", "print(df.shape)\n", "df.head()"]}, {"block": 169, "type": "code", "linesLength": 3, "startIndex": 317, "lines": ["data = (ImageList.from_df(df, path)\n", "                 .split_from_df())\n", "data"]}, {"block": 170, "type": "code", "linesLength": 1, "startIndex": 320, "lines": ["jekyll_warn(\"This method assumes the data has been created from a csv file or a dataframe.\")"]}, {"block": 171, "type": "markdown", "linesLength": 1, "startIndex": 321, "lines": ["## Step 3: Label the inputs"]}, {"block": 172, "type": "markdown", "linesLength": 1, "startIndex": 322, "lines": ["To label your inputs, use one of the following functions. Note that even if it's not in the documented arguments, you can always pass a `label_cls` that will be used to create those labels (the default is the one from your input [`ItemList`](/data_block.html#ItemList), and if there is none, it will go to [`CategoryList`](/data_block.html#CategoryList),  [`MultiCategoryList`](/data_block.html#MultiCategoryList) or [`FloatList`](/data_block.html#FloatList) depending on the type of the labels). This is implemented in the following function:"]}, {"block": 173, "type": "code", "linesLength": 1, "startIndex": 323, "lines": ["show_doc(ItemList.get_label_cls)"]}, {"block": 174, "type": "markdown", "linesLength": 1, "startIndex": 324, "lines": ["Behind the scenes, [`ItemList.get_label_cls`](/data_block.html#ItemList.get_label_cls) basically select a label class according to the item type of `labels`, whereas `labels` can be any of `Collection`, `pandas.core.frame.DataFrame`, `pandas.core.series.Series`. If the list elements are of type string or integer, `get_label_cls` will output [`CategoryList`](/data_block.html#CategoryList); if they are of type float, then it will output [`FloatList`](/data_block.html#FloatList); if they are of type Collection, then it will output [`MultiCategoryList`](/data_block.html#MultiCategoryList)."]}, {"block": 175, "type": "code", "linesLength": 1, "startIndex": 325, "lines": ["from fastai.vision import *"]}, {"block": 176, "type": "code", "linesLength": 2, "startIndex": 326, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "sd = ImageList.from_folder(path_data).split_by_folder('train', 'valid'); sd"]}, {"block": 177, "type": "code", "linesLength": 2, "startIndex": 328, "lines": ["labels = ['7', '3']\n", "label_cls = sd.train.get_label_cls(labels); label_cls"]}, {"block": 178, "type": "code", "linesLength": 2, "startIndex": 330, "lines": ["labels = [7, 3]\n", "label_cls = sd.train.get_label_cls(labels); label_cls"]}, {"block": 179, "type": "code", "linesLength": 2, "startIndex": 332, "lines": ["labels = [7.0, 3.0]\n", "label_cls = sd.train.get_label_cls(labels); label_cls"]}, {"block": 180, "type": "code", "linesLength": 2, "startIndex": 334, "lines": ["labels = [[7, 3],]\n", "label_cls = sd.train.get_label_cls(labels); label_cls"]}, {"block": 181, "type": "code", "linesLength": 2, "startIndex": 336, "lines": ["labels = [['7', '3'],]\n", "label_cls = sd.train.get_label_cls(labels); label_cls"]}, {"block": 182, "type": "markdown", "linesLength": 1, "startIndex": 338, "lines": ["If no `label_cls` argument is passed, the correct labeling type can usually be inferred based on the data (for classification or regression). If you have multiple regression targets (e.g. predict 5 different numbers from a single image/text), be aware that arrays of floats are by default considered to be targets for one-hot encoded classification. If your task is regression, be sure the pass `label_cls = FloatList` so that learners created from your databunch initialize correctly."]}, {"block": 183, "type": "markdown", "linesLength": 1, "startIndex": 339, "lines": ["The first example in these docs created labels as follows:"]}, {"block": 184, "type": "code", "linesLength": 2, "startIndex": 340, "lines": ["path = untar_data(URLs.MNIST_TINY)\n", "ll = ImageList.from_folder(path).split_by_folder().label_from_folder().train"]}, {"block": 185, "type": "markdown", "linesLength": 7, "startIndex": 342, "lines": ["If you want to save the data necessary to recreate your [`LabelList`](/data_block.html#LabelList) (not including saving the actual image/text/etc files), you can use `to_df` or `to_csv`:\n", "\n", "```python\n", "ll.train.to_csv('tmp.csv')\n", "```\n", "\n", "Or just grab a `pd.DataFrame` directly:"]}, {"block": 186, "type": "code", "linesLength": 1, "startIndex": 349, "lines": ["ll.to_df().head()"]}, {"block": 187, "type": "code", "linesLength": 1, "startIndex": 350, "lines": ["show_doc(ItemList.label_empty)"]}, {"block": 188, "type": "code", "linesLength": 1, "startIndex": 351, "lines": ["show_doc(ItemList.label_from_df)"]}, {"block": 189, "type": "code", "linesLength": 1, "startIndex": 352, "lines": ["jekyll_warn(\"This method only works with data objects created with either `from_csv` or `from_df` methods.\")"]}, {"block": 190, "type": "code", "linesLength": 1, "startIndex": 353, "lines": ["show_doc(ItemList.label_const)"]}, {"block": 191, "type": "code", "linesLength": 1, "startIndex": 354, "lines": ["show_doc(ItemList.label_from_folder)"]}, {"block": 192, "type": "code", "linesLength": 1, "startIndex": 355, "lines": ["jekyll_note(\"This method looks at the last subfolder in the path to determine the classes.\")"]}, {"block": 193, "type": "markdown", "linesLength": 1, "startIndex": 356, "lines": ["Behind the scenes, when an [`ItemList`](/data_block.html#ItemList) calls `label_from_folder`, it creates a lambda function which outputs a foldername which a file Path object immediately or directly belongs to, and then calls `label_from_func` with the lambda function as input. "]}, {"block": 194, "type": "markdown", "linesLength": 1, "startIndex": 357, "lines": ["On the practical and high level, `label_from_folder` is mostly used with [`ItemLists`](/data_block.html#ItemLists) rather than [`ItemList`](/data_block.html#ItemList) for simplicity and efficiency, for details see the `label_from_folder` example on [ItemLists](). Even when you just want a training set [`ItemList`](/data_block.html#ItemList), you still need to do `split_none` to create an [`ItemLists`](/data_block.html#ItemLists) and then do labeling with `label_from_folder`, as the example shown below."]}, {"block": 195, "type": "code", "linesLength": 1, "startIndex": 358, "lines": ["from fastai.vision import *"]}, {"block": 196, "type": "code", "linesLength": 1, "startIndex": 359, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 197, "type": "code", "linesLength": 2, "startIndex": 360, "lines": ["sd_train = ImageList.from_folder(path_data/'train').split_none()\n", "ll_train = sd_train.label_from_folder(); ll_train"]}, {"block": 198, "type": "code", "linesLength": 1, "startIndex": 362, "lines": ["show_doc(ItemList.label_from_func)"]}, {"block": 199, "type": "markdown", "linesLength": 1, "startIndex": 363, "lines": ["Inside `label_from_func`, it applies the input `func` to every item of an [`ItemList`](/data_block.html#ItemList) and puts all the function outputs into a list, and then passes the list onto [`ItemList._label_from_list`](/data_block.html#ItemList._label_from_list). Below is a simple example of using `label_from_func`."]}, {"block": 200, "type": "code", "linesLength": 1, "startIndex": 364, "lines": ["from fastai.vision import *"]}, {"block": 201, "type": "code", "linesLength": 2, "startIndex": 365, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "sd = ImageList.from_folder(path_data).split_by_folder('train', 'valid');sd"]}, {"block": 202, "type": "code", "linesLength": 1, "startIndex": 367, "lines": ["func=lambda o: (o.parts if isinstance(o, Path) else o.split(os.path.sep))[-2]"]}, {"block": 203, "type": "markdown", "linesLength": 1, "startIndex": 368, "lines": ["The lambda function above is to access the immediate foldername for a file Path object."]}, {"block": 204, "type": "code", "linesLength": 1, "startIndex": 369, "lines": ["ll = sd.label_from_func(func); ll"]}, {"block": 205, "type": "code", "linesLength": 1, "startIndex": 370, "lines": ["show_doc(ItemList.label_from_re)"]}, {"block": 206, "type": "code", "linesLength": 1, "startIndex": 371, "lines": ["show_doc(CategoryList, title_level=3)"]}, {"block": 207, "type": "markdown", "linesLength": 1, "startIndex": 372, "lines": ["[`ItemList`](/data_block.html#ItemList) suitable for storing labels in `items` belonging to `classes`. If `None` are passed, `classes` will be determined by the unique different labels. `processor` will default to [`CategoryProcessor`](/data_block.html#CategoryProcessor)."]}, {"block": 208, "type": "markdown", "linesLength": 1, "startIndex": 373, "lines": ["[`CategoryList`](/data_block.html#CategoryList) uses `labels` to create an [`ItemList`](/data_block.html#ItemList) for dealing with categorical labels. Behind the scenes, [`CategoryList`](/data_block.html#CategoryList) is a subclass of [`CategoryListBase`](/data_block.html#CategoryListBase) which is a subclass of [`ItemList`](/data_block.html#ItemList). [`CategoryList`](/data_block.html#CategoryList) inherits from [`CategoryListBase`](/data_block.html#CategoryListBase) the properties such as `classes` (default as `None`), `filter_missing_y` (default as `True`), and has its own unique property `loss_func` (default as `CrossEntropyFlat()`), and its own class attribute `_processor` (default as [`CategoryProcessor`](/data_block.html#CategoryProcessor)). "]}, {"block": 209, "type": "code", "linesLength": 1, "startIndex": 374, "lines": ["from fastai.vision import *"]}, {"block": 210, "type": "code", "linesLength": 3, "startIndex": 375, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "ll = ImageList.from_folder(path_data).split_by_folder('train', 'valid').label_from_folder()\n", "ll.train.y.items, ll.train.y.classes, ll.train.y[0]"]}, {"block": 211, "type": "code", "linesLength": 1, "startIndex": 378, "lines": ["cl = CategoryList(ll.train.y.items, ll.train.y.classes); cl"]}, {"block": 212, "type": "markdown", "linesLength": 1, "startIndex": 379, "lines": ["For the behavior of printing out [`CategoryList`](/data_block.html#CategoryList) object or access an element using index, please see [`CategoryList.get`](/data_block.html#CategoryList.get) below."]}, {"block": 213, "type": "markdown", "linesLength": 1, "startIndex": 380, "lines": ["Behind the scenes, [`CategoryList.get`](/data_block.html#CategoryList.get) is used inexplicitly when printing out the [`CategoryList`](/data_block.html#CategoryList) object or `cl[idx]`. According to the source of [`CategoryList.get`](/data_block.html#CategoryList.get), each `item` is used to get its own `class`. When 'classes' is a list of strings, then elements of `items` are used as index of a list, therefore they must be integers in the range from 0 to `len(classes)-1`; if `classes` is a dictionary, then elements of `items` are used as keys, therefore they can be strings too. See examples below for details."]}, {"block": 214, "type": "code", "linesLength": 1, "startIndex": 381, "lines": ["from fastai.vision import *"]}, {"block": 215, "type": "code", "linesLength": 2, "startIndex": 382, "lines": ["items = np.array([0, 1, 2, 1, 0])\n", "cl = CategoryList(items, classes=['3', '7', '9']); cl"]}, {"block": 216, "type": "code", "linesLength": 3, "startIndex": 384, "lines": ["items = np.array(['3', '7', '9', '7', '3'])\n", "classes = {'3':3, '7':7, '9':9}\n", "cl = CategoryList(items, classes); cl"]}, {"block": 217, "type": "code", "linesLength": 1, "startIndex": 387, "lines": ["show_doc(MultiCategoryList, title_level=3)"]}, {"block": 218, "type": "markdown", "linesLength": 3, "startIndex": 388, "lines": ["It will store a list of labels in `items` belonging to `classes`. If `None` are passed, `classes` will be determined by the different unique labels. `sep` is used to split the content of `items` in a list of tags.\n", "\n", "If `one_hot=True`, the items contain the labels one-hot encoded. In this case, it is mandatory to pass a list of `classes` (as we can't use the different labels)."]}, {"block": 219, "type": "code", "linesLength": 1, "startIndex": 391, "lines": ["show_doc(FloatList, title_level=3)"]}, {"block": 220, "type": "code", "linesLength": 1, "startIndex": 392, "lines": ["show_doc(EmptyLabelList, title_level=3)"]}, {"block": 221, "type": "markdown", "linesLength": 1, "startIndex": 393, "lines": ["## Invisible step: preprocessing"]}, {"block": 222, "type": "markdown", "linesLength": 7, "startIndex": 394, "lines": ["This isn't seen here in the API, but if you passed a `processor` (or a list of them) in your initial [`ItemList`](/data_block.html#ItemList) during step 1, it will be applied here. If you didn't pass any processor, a list of them might still be created depending on what is in the `_processor` variable of your class of items (this can be a list of [`PreProcessor`](/data_block.html#PreProcessor) classes).\n", "\n", "A processor is a transformation that is applied to all the inputs once at initialization, with a state computed on the training set that is then applied without modification on the validation set (and maybe the test set). For instance, it can be processing texts to tokenize then numericalize them. In that case we want the validation set to be numericalized with exactly the same vocabulary as the training set.\n", "\n", "Another example is in tabular data, where we fill missing values with (for instance) the median computed on the training set. That statistic is stored in the inner state of the [`PreProcessor`](/data_block.html#PreProcessor) and applied on the validation set.\n", "\n", "This is the generic class for all processors."]}, {"block": 223, "type": "code", "linesLength": 1, "startIndex": 401, "lines": ["show_doc(PreProcessor, title_level=3)"]}, {"block": 224, "type": "code", "linesLength": 1, "startIndex": 402, "lines": ["show_doc(PreProcessor.process_one)"]}, {"block": 225, "type": "markdown", "linesLength": 1, "startIndex": 403, "lines": ["Process one `item`. This method needs to be written in any subclass."]}, {"block": 226, "type": "code", "linesLength": 1, "startIndex": 404, "lines": ["show_doc(PreProcessor.process)"]}, {"block": 227, "type": "markdown", "linesLength": 2, "startIndex": 405, "lines": ["`ds`: an object of [`ItemList`](/data_block.html#ItemList)       \n", "Process a dataset. This default to apply `process_one` on every `item` of `ds`."]}, {"block": 228, "type": "code", "linesLength": 1, "startIndex": 407, "lines": ["show_doc(CategoryProcessor, title_level=3)"]}, {"block": 229, "type": "code", "linesLength": 1, "startIndex": 408, "lines": ["show_doc(CategoryProcessor.generate_classes)"]}, {"block": 230, "type": "code", "linesLength": 1, "startIndex": 409, "lines": ["show_doc(CategoryProcessor.process)"]}, {"block": 231, "type": "markdown", "linesLength": 2, "startIndex": 410, "lines": ["`ds` is an object of [`CategoryList`](/data_block.html#CategoryList).     \n", "It basically generates a list of unique labels (assigned to `ds.classes`) and a dictionary mapping `classes` to indexes (assigned to `ds.c2i`)."]}, {"block": 232, "type": "markdown", "linesLength": 1, "startIndex": 412, "lines": ["It is an internal function only called to apply processors to training, validation and testing datasets after the labeling step."]}, {"block": 233, "type": "code", "linesLength": 1, "startIndex": 413, "lines": ["show_doc(MultiCategoryProcessor, title_level=3)"]}, {"block": 234, "type": "code", "linesLength": 1, "startIndex": 414, "lines": ["show_doc(MultiCategoryProcessor.generate_classes)"]}, {"block": 235, "type": "markdown", "linesLength": 1, "startIndex": 415, "lines": ["## Optional steps"]}, {"block": 236, "type": "markdown", "linesLength": 1, "startIndex": 416, "lines": ["### Add transforms"]}, {"block": 237, "type": "markdown", "linesLength": 1, "startIndex": 417, "lines": ["Transforms differ from processors in the sense they are applied on the fly when we grab one item. They also may change each time we ask for the same item in the case of random transforms."]}, {"block": 238, "type": "code", "linesLength": 1, "startIndex": 418, "lines": ["show_doc(LabelLists.transform)"]}, {"block": 239, "type": "markdown", "linesLength": 3, "startIndex": 419, "lines": ["This is primary for the vision application. The `kwargs` arguments are the ones expected by the type of transforms you pass. `tfm_y` is among them and if set to `True`, the transforms will be applied to input and target.\n", "\n", "For examples see: [vision.transforms](vision.transform.html)."]}, {"block": 240, "type": "markdown", "linesLength": 1, "startIndex": 422, "lines": ["### Add a test set"]}, {"block": 241, "type": "markdown", "linesLength": 1, "startIndex": 423, "lines": ["To add a test set, you can use one of the two following methods."]}, {"block": 242, "type": "code", "linesLength": 1, "startIndex": 424, "lines": ["show_doc(LabelLists.add_test)"]}, {"block": 243, "type": "code", "linesLength": 1, "startIndex": 425, "lines": ["jekyll_note(\"Here `items` can be an `ItemList` or a collection.\")"]}, {"block": 244, "type": "code", "linesLength": 1, "startIndex": 426, "lines": ["show_doc(LabelLists.add_test_folder)"]}, {"block": 245, "type": "code", "linesLength": 1, "startIndex": 427, "lines": ["jekyll_warn(\"In fastai the test set is unlabeled! No labels will be collected even if they are available.\")"]}, {"block": 246, "type": "markdown", "linesLength": 38, "startIndex": 428, "lines": ["Instead, either the passed `label` argument or an empty label will be used for all entries of this dataset (this is required by the internal pipeline of fastai). \n", "\n", "In the `fastai` framework `test` datasets have no labels - this is the unknown data to be predicted. If you want to validate your model on a `test` dataset with labels, you probably need to use it as a validation set, as in:\n", "\n", "```\n", "data_test = (ImageList.from_folder(path)\n", "        .split_by_folder(train='train', valid='test')\n", "        .label_from_folder()\n", "        ...)\n", "```\n", "\n", "Another approach, where you do use a normal validation set, and then when the training is over, you just want to validate the test set w/ labels as a validation set, you can do this:\n", "\n", "```\n", "tfms = []\n", "path = Path('data').resolve()\n", "data = (ImageList.from_folder(path)\n", "        .split_by_pct()\n", "        .label_from_folder()\n", "        .transform(tfms)\n", "        .databunch()\n", "        .normalize() ) \n", "learn = cnn_learner(data, models.resnet50, metrics=accuracy)\n", "learn.fit_one_cycle(5,1e-2)\n", "\n", "# now replace the validation dataset entry with the test dataset as a new validation dataset: \n", "# everything is exactly the same, except replacing `split_by_pct` w/ `split_by_folder` \n", "# (or perhaps you were already using the latter, so simply switch to valid='test')\n", "data_test = (ImageList.from_folder(path)\n", "        .split_by_folder(train='train', valid='test')\n", "        .label_from_folder()\n", "        .transform(tfms)\n", "        .databunch()\n", "        .normalize()\n", "       ) \n", "learn.validate(data_test.valid_dl)\n", "```\n", "Of course, your data block can be totally different, this is just an example."]}, {"block": 247, "type": "markdown", "linesLength": 1, "startIndex": 466, "lines": ["## Step 4: convert to a [`DataBunch`](/basic_data.html#DataBunch)"]}, {"block": 248, "type": "markdown", "linesLength": 1, "startIndex": 467, "lines": ["This last step is usually pretty straightforward. You just have to include all the arguments we pass to [`DataBunch.create`](/basic_data.html#DataBunch.create) (`bs`, `num_workers`,  `collate_fn`). The class called to create a [`DataBunch`](/basic_data.html#DataBunch) is set in the `_bunch` attribute of the inputs of the training set if you need to modify it. Normally, the various subclasses we showed before handle that for you."]}, {"block": 249, "type": "code", "linesLength": 1, "startIndex": 468, "lines": ["show_doc(LabelLists.databunch)"]}, {"block": 250, "type": "markdown", "linesLength": 1, "startIndex": 469, "lines": ["## Inner classes"]}, {"block": 251, "type": "code", "linesLength": 1, "startIndex": 470, "lines": ["show_doc(LabelList, title_level=3)"]}, {"block": 252, "type": "markdown", "linesLength": 1, "startIndex": 471, "lines": ["Optionally apply `tfms` to `y` if `tfm_y` is `True`. "]}, {"block": 253, "type": "markdown", "linesLength": 1, "startIndex": 472, "lines": ["Behind the scenes, it takes inputs [`ItemList`](/data_block.html#ItemList) and labels [`ItemList`](/data_block.html#ItemList) as its properties `x` and `y`, sets property `item` to `None`, and uses [`LabelList.transform`](/data_block.html#LabelList.transform) to apply a list of transforms `TfmList` to `x` and `y` if `tfm_y` is set `True`."]}, {"block": 254, "type": "code", "linesLength": 1, "startIndex": 473, "lines": ["from fastai.vision import *"]}, {"block": 255, "type": "code", "linesLength": 3, "startIndex": 474, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "ll = ImageList.from_folder(path_data).split_by_folder('train', 'valid').label_from_folder()\n", "ll.train.x, ll.train.y"]}, {"block": 256, "type": "code", "linesLength": 1, "startIndex": 477, "lines": ["LabelList(x=ll.train.x, y=ll.train.y)"]}, {"block": 257, "type": "code", "linesLength": 1, "startIndex": 478, "lines": ["show_doc(LabelList.export)"]}, {"block": 258, "type": "code", "linesLength": 1, "startIndex": 479, "lines": ["show_doc(LabelList.transform_y)"]}, {"block": 259, "type": "code", "linesLength": 1, "startIndex": 480, "lines": ["show_doc(LabelList.get_state)"]}, {"block": 260, "type": "code", "linesLength": 1, "startIndex": 481, "lines": ["show_doc(LabelList.load_empty)"]}, {"block": 261, "type": "code", "linesLength": 1, "startIndex": 482, "lines": ["show_doc(LabelList.load_state)"]}, {"block": 262, "type": "code", "linesLength": 1, "startIndex": 483, "lines": ["show_doc(LabelList.process)"]}, {"block": 263, "type": "markdown", "linesLength": 1, "startIndex": 484, "lines": ["Behind the scenes, [`LabelList.process`](/data_block.html#LabelList.process) does 3 three things: 1. ask labels `y` to be processed by `yp` with `y.process(yp)`; 2. if `y.filter_missing_y` is `True`, then removes the missing data samples from `x` and `y`; 3. ask inputs `x` to be processed by `xp` with `x.process(xp)`"]}, {"block": 264, "type": "code", "linesLength": 1, "startIndex": 485, "lines": ["from fastai.vision import *"]}, {"block": 265, "type": "code", "linesLength": 2, "startIndex": 486, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "sd = ImageList.from_folder(path_data).split_by_folder('train', 'valid')"]}, {"block": 266, "type": "code", "linesLength": 3, "startIndex": 488, "lines": ["sd.train = sd.train.label_from_folder(from_item_lists=True)\n", "sd.valid = sd.valid.label_from_folder(from_item_lists=True)\n", "sd.__class__ = LabelLists"]}, {"block": 267, "type": "code", "linesLength": 2, "startIndex": 491, "lines": ["xp,yp = sd.get_processors()\n", "xp,yp"]}, {"block": 268, "type": "code", "linesLength": 1, "startIndex": 493, "lines": ["sd.train.process(xp, yp)"]}, {"block": 269, "type": "code", "linesLength": 1, "startIndex": 494, "lines": ["show_doc(LabelList.set_item)"]}, {"block": 270, "type": "code", "linesLength": 1, "startIndex": 495, "lines": ["show_doc(LabelList.to_df)"]}, {"block": 271, "type": "code", "linesLength": 1, "startIndex": 496, "lines": ["show_doc(LabelList.to_csv)"]}, {"block": 272, "type": "code", "linesLength": 1, "startIndex": 497, "lines": ["show_doc(LabelList.transform)"]}, {"block": 273, "type": "code", "linesLength": 1, "startIndex": 498, "lines": ["show_doc(ItemLists, title_level=3)"]}, {"block": 274, "type": "markdown", "linesLength": 3, "startIndex": 499, "lines": ["It initializes an [`ItemLists`](/data_block.html#ItemLists) object, which basically brings in the training, valiation and testing (optionally) [`ItemList`](/data_block.html#ItemList)s as its properties. It also offers helpful warning messages on situations when the training or validation [`ItemList`](/data_block.html#ItemList) is empty. \n", "\n", "See the following example for how to create an [`ItemLists`](/data_block.html#ItemLists) object. "]}, {"block": 275, "type": "code", "linesLength": 1, "startIndex": 502, "lines": ["from fastai.vision import *"]}, {"block": 276, "type": "code", "linesLength": 1, "startIndex": 503, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 277, "type": "code", "linesLength": 3, "startIndex": 504, "lines": ["il_train = ImageList.from_folder(path_data/'train')\n", "il_valid = ImageList.from_folder(path_data/'valid')\n", "il_test = ImageList.from_folder(path_data/'test')"]}, {"block": 278, "type": "code", "linesLength": 1, "startIndex": 507, "lines": ["ils = ItemLists(path=path_data, train=il_train, valid=il_valid); ils"]}, {"block": 279, "type": "code", "linesLength": 1, "startIndex": 508, "lines": ["ils.test = il_test; ils"]}, {"block": 280, "type": "markdown", "linesLength": 3, "startIndex": 509, "lines": ["However, we are most likely to see an [`ItemLists`](/data_block.html#ItemLists), right after a large [`ItemList`](/data_block.html#ItemList) is splitted and turned into an [`ItemLists`](/data_block.html#ItemLists) by methods like [`ItemList.split_by_folder`](/data_block.html#ItemList.split_by_folder). Then, we will add labels to all training and validation simply using `sd.label_from_folder()` (`sd` is an [`ItemLists`](/data_block.html#ItemLists), see example below). Now, some of you may be surprised because `label_from_folder` is a method of [`ItemList`](/data_block.html#ItemList) not [`ItemLists`](/data_block.html#ItemLists). Well, this is a magic of fastai data_block api.\n", "\n", "With the following example, we may understand a little better how to get labelling done by calling [`ItemLists.__getattr__`](/data_block.html#ItemLists.__getattr__) with [`ItemList.label_from_folder`](/data_block.html#ItemList.label_from_folder)."]}, {"block": 281, "type": "code", "linesLength": 1, "startIndex": 512, "lines": ["il = ImageList.from_folder(path_data); il"]}, {"block": 282, "type": "markdown", "linesLength": 1, "startIndex": 513, "lines": ["An [`ItemList`](/data_block.html#ItemList) or its subclass object must do a split to turn itself into an [`ItemLists`](/data_block.html#ItemLists) before doing labeling to become a [`LabelLists`](/data_block.html#LabelLists) object."]}, {"block": 283, "type": "code", "linesLength": 1, "startIndex": 514, "lines": ["sd = il.split_by_folder(train='train', valid='valid'); sd\n"]}, {"block": 284, "type": "code", "linesLength": 1, "startIndex": 515, "lines": ["ll = sd.label_from_folder(); ll"]}, {"block": 285, "type": "markdown", "linesLength": 1, "startIndex": 516, "lines": ["Even when there is just an [`ImageList`](/vision.data.html#ImageList) from a training set folder with no split needed, we still must do `split_none()` in order to create an [`ItemLists`](/data_block.html#ItemLists), and only then we can do `ItemLists.label_from_folder()` nicely."]}, {"block": 286, "type": "code", "linesLength": 2, "startIndex": 517, "lines": ["il_train = ImageList.from_folder(path_data/'train')\n", "sd_train = il_train.split_none(); sd_train"]}, {"block": 287, "type": "code", "linesLength": 1, "startIndex": 519, "lines": ["ll_valid_empty = sd_train.label_from_folder(); ll_valid_empty"]}, {"block": 288, "type": "markdown", "linesLength": 1, "startIndex": 520, "lines": ["So practially, although `label_from_folder` is not an [`ItemLists`](/data_block.html#ItemLists) method, we can call `ItemLists.label_from_folder()` to label training, validation and test [`ItemList`](/data_block.html#ItemList)s once for all."]}, {"block": 289, "type": "markdown", "linesLength": 3, "startIndex": 521, "lines": ["Behind the scenes, `ItemLists.label_from_folder()` actually calls `ItemLists.__getattr__('label_from_folder')`, in which all training, validation even testing [`ItemList`](/data_block.html#ItemList) get to call `label_from_folder`, and then turns the [`ItemLists`](/data_block.html#ItemLists) into a [`LabelLists`](/data_block.html#LabelLists) and calls [`LabelLists.process`](/data_block.html#LabelLists.process) at last.\n", "\n", "You can directly use `LabelLists.__getattr__` to do labelling as below."]}, {"block": 290, "type": "code", "linesLength": 1, "startIndex": 524, "lines": ["ld_inner = sd.__getattr__('label_from_folder'); ld_inner()"]}, {"block": 291, "type": "code", "linesLength": 1, "startIndex": 525, "lines": ["show_doc(ItemLists.label_from_lists)"]}, {"block": 292, "type": "code", "linesLength": 1, "startIndex": 526, "lines": ["show_doc(ItemLists.transform)"]}, {"block": 293, "type": "code", "linesLength": 1, "startIndex": 527, "lines": ["show_doc(ItemLists.transform_y)"]}, {"block": 294, "type": "code", "linesLength": 1, "startIndex": 528, "lines": ["show_doc(LabelLists, title_level=3)"]}, {"block": 295, "type": "markdown", "linesLength": 1, "startIndex": 529, "lines": ["Creating a [`LabelLists`](/data_block.html#LabelLists) object is exactly the same way as creating an [`ItemLists`](/data_block.html#ItemLists) object, because its base class is [`ItemLists`](/data_block.html#ItemLists) and does not overwrite [`ItemLists.__init__`](/data_block.html#ItemLists.__init__). The example below shows how to build a [`LabelLists`](/data_block.html#LabelLists) object."]}, {"block": 296, "type": "code", "linesLength": 1, "startIndex": 530, "lines": ["from fastai.vision import *"]}, {"block": 297, "type": "code", "linesLength": 1, "startIndex": 531, "lines": ["path_data = untar_data(URLs.MNIST_TINY); path_data.ls()"]}, {"block": 298, "type": "code", "linesLength": 2, "startIndex": 532, "lines": ["il_train = ImageList.from_folder(path_data/'train')\n", "il_valid = ImageList.from_folder(path_data/'valid')"]}, {"block": 299, "type": "code", "linesLength": 3, "startIndex": 534, "lines": ["ll_test = LabelLists(path_data, il_train, il_valid); \n", "ll_test.test = il_valid = ImageList.from_folder(path_data/'test')\n", "ll_test"]}, {"block": 300, "type": "code", "linesLength": 1, "startIndex": 537, "lines": ["show_doc(LabelLists.get_processors)"]}, {"block": 301, "type": "markdown", "linesLength": 1, "startIndex": 538, "lines": ["Behind the scenes, `LabelLists.get_processors()` first puts `train.x._processor` classes and `train.y._processor` classes into separate lists, and then instantiates those processors and puts them into `xp` and `yp`."]}, {"block": 302, "type": "code", "linesLength": 1, "startIndex": 539, "lines": ["from fastai.vision import *"]}, {"block": 303, "type": "code", "linesLength": 2, "startIndex": 540, "lines": ["path_data = untar_data(URLs.MNIST_TINY)\n", "sd = ImageList.from_folder(path_data).split_by_folder('train', 'valid')"]}, {"block": 304, "type": "code", "linesLength": 3, "startIndex": 542, "lines": ["sd.train = sd.train.label_from_folder(from_item_lists=True)\n", "sd.valid = sd.valid.label_from_folder(from_item_lists=True)\n", "sd.__class__ = LabelLists"]}, {"block": 305, "type": "code", "linesLength": 2, "startIndex": 545, "lines": ["xp,yp = sd.get_processors()\n", "xp,yp"]}, {"block": 306, "type": "code", "linesLength": 1, "startIndex": 547, "lines": ["show_doc(LabelLists.load_empty)"]}, {"block": 307, "type": "code", "linesLength": 1, "startIndex": 548, "lines": ["show_doc(LabelLists.load_state)"]}, {"block": 308, "type": "code", "linesLength": 1, "startIndex": 549, "lines": ["show_doc(LabelLists.process)"]}, {"block": 309, "type": "code", "linesLength": 1, "startIndex": 550, "lines": ["show_doc(ItemList.process)"]}, {"block": 310, "type": "markdown", "linesLength": 2, "startIndex": 551, "lines": ["`processor` is one or more `PreProcessors` objects    \n", "Behind the scenes, we put all of `processor` into a list and apply them all to an object of [`ItemList`](/data_block.html#ItemList) or its subclasses."]}, {"block": 311, "type": "markdown", "linesLength": 1, "startIndex": 553, "lines": ["## Helper functions"]}, {"block": 312, "type": "code", "linesLength": 1, "startIndex": 554, "lines": ["show_doc(get_files)"]}, {"block": 313, "type": "markdown", "linesLength": 3, "startIndex": 555, "lines": ["To be more precise, this function returns a list of FilePath objects using files in `path` that must have a suffix in `extensions`, and hidden folders and files are ignored. If `recurse=True`, all files in subfolders will be applied; `include` is used to select particular folders to apply.\n", "\n", "Inside [`get_files`](/data_block.html#get_files), there is [`_get_files`](/data_block.html#_get_files) which turns all filenames inside `f` from directory `parent/p` into a list of FilePath objects. All filenames must have a suffix in `extensions`. All hidden files are ignored."]}, {"block": 314, "type": "code", "linesLength": 1, "startIndex": 558, "lines": ["path_data = untar_data(URLs.MNIST_TINY) "]}, {"block": 315, "type": "code", "linesLength": 1, "startIndex": 559, "lines": ["path_data.ls()"]}, {"block": 316, "type": "markdown", "linesLength": 1, "startIndex": 560, "lines": ["With `recurse=False`, no subfolder files are made available."]}, {"block": 317, "type": "code", "linesLength": 2, "startIndex": 561, "lines": ["list_FilePath_noRecurse = get_files(path_data) \n", "list_FilePath_noRecurse"]}, {"block": 318, "type": "markdown", "linesLength": 1, "startIndex": 563, "lines": ["With `recurse=True`, all subfolder files are made available, except hidden files."]}, {"block": 319, "type": "code", "linesLength": 2, "startIndex": 564, "lines": ["list_FilePath_recurse = get_files(path_data, recurse=True)\n", "list_FilePath_recurse[:3]"]}, {"block": 320, "type": "code", "linesLength": 1, "startIndex": 566, "lines": ["list_FilePath_recurse[-2:]"]}, {"block": 321, "type": "markdown", "linesLength": 1, "startIndex": 567, "lines": ["With `extensions=['.csv']`, only files with the suffix of `.csv` are made available."]}, {"block": 322, "type": "code", "linesLength": 2, "startIndex": 568, "lines": ["list_FilePath_recurse_csv = get_files(path_data, recurse=True, extensions=['.csv'])\n", "list_FilePath_recurse_csv"]}, {"block": 323, "type": "markdown", "linesLength": 1, "startIndex": 570, "lines": ["With `include=['test']`, only files in `path_data` and its subfolder `test` are made available."]}, {"block": 324, "type": "code", "linesLength": 3, "startIndex": 571, "lines": ["list_FilePath_include = get_files(path_data, recurse=True, extensions=['.png','.jpg','.jpeg'],\n", "                                  include=['test'])\n", "list_FilePath_include[:3]"]}, {"block": 325, "type": "code", "linesLength": 1, "startIndex": 574, "lines": ["list_FilePath_include[-3:]"]}, {"block": 326, "type": "markdown", "linesLength": 1, "startIndex": 575, "lines": ["## Undocumented Methods - Methods moved below this line will intentionally be hidden"]}, {"block": 327, "type": "code", "linesLength": 1, "startIndex": 576, "lines": ["show_doc(CategoryList.new)"]}, {"block": 328, "type": "code", "linesLength": 1, "startIndex": 577, "lines": ["show_doc(LabelList.new)"]}, {"block": 329, "type": "code", "linesLength": 1, "startIndex": 578, "lines": ["show_doc(CategoryList.get)"]}, {"block": 330, "type": "code", "linesLength": 1, "startIndex": 579, "lines": ["show_doc(LabelList.predict)"]}, {"block": 331, "type": "code", "linesLength": 1, "startIndex": 580, "lines": ["show_doc(ItemList.new)"]}, {"block": 332, "type": "code", "linesLength": 1, "startIndex": 581, "lines": ["show_doc(ItemList.process_one)"]}, {"block": 333, "type": "code", "linesLength": 1, "startIndex": 582, "lines": ["show_doc(MultiCategoryProcessor.process_one)"]}, {"block": 334, "type": "code", "linesLength": 1, "startIndex": 583, "lines": ["show_doc(FloatList.get)"]}, {"block": 335, "type": "code", "linesLength": 1, "startIndex": 584, "lines": ["show_doc(CategoryProcessor.process_one)"]}, {"block": 336, "type": "markdown", "linesLength": 1, "startIndex": 585, "lines": ["It basically converts `item` which is a category name to an index."]}, {"block": 337, "type": "markdown", "linesLength": 2, "startIndex": 586, "lines": ["`classes`: a list of unique and sorted labels;    \n", "It creates the inner mapping from category name to index (stored in `c2i`) from the `classes`."]}, {"block": 338, "type": "code", "linesLength": 1, "startIndex": 588, "lines": ["show_doc(CategoryProcessor.create_classes)"]}, {"block": 339, "type": "code", "linesLength": 1, "startIndex": 589, "lines": ["show_doc(MultiCategoryList.get)"]}, {"block": 340, "type": "code", "linesLength": 1, "startIndex": 590, "lines": ["show_doc(FloatList.new)"]}, {"block": 341, "type": "code", "linesLength": 1, "startIndex": 591, "lines": ["show_doc(FloatList.reconstruct)"]}, {"block": 342, "type": "code", "linesLength": 1, "startIndex": 592, "lines": ["show_doc(MultiCategoryList.analyze_pred)"]}, {"block": 343, "type": "code", "linesLength": 1, "startIndex": 593, "lines": ["show_doc(MultiCategoryList.reconstruct)"]}, {"block": 344, "type": "code", "linesLength": 1, "startIndex": 594, "lines": ["show_doc(CategoryList.reconstruct)"]}, {"block": 345, "type": "code", "linesLength": 1, "startIndex": 595, "lines": ["show_doc(CategoryList.analyze_pred)"]}, {"block": 346, "type": "code", "linesLength": 1, "startIndex": 596, "lines": ["show_doc(EmptyLabelList.reconstruct)"]}, {"block": 347, "type": "code", "linesLength": 1, "startIndex": 597, "lines": ["show_doc(EmptyLabelList.get)"]}, {"block": 348, "type": "code", "linesLength": 1, "startIndex": 598, "lines": ["show_doc(LabelList.databunch)"]}, {"block": 349, "type": "markdown", "linesLength": 1, "startIndex": 599, "lines": ["## New Methods - Please document or move to the undocumented section"]}, {"block": 350, "type": "code", "linesLength": 1, "startIndex": 600, "lines": ["show_doc(ItemList.add)"]}, {"block": 351, "type": "markdown", "linesLength": 0, "startIndex": 601, "lines": []}]
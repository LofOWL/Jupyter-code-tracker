[{"block": 0, "type": "markdown", "linesLength": 3, "startIndex": 0, "lines": ["# Introduction: Simulating Asteroid Impacts with a Poisson Process\n", "\n", "In this notebook, we will simulate impacts of near Earth asteroids into Earth using a Poisson process. Through this method, we can come up with a likely number of impacts during an individual's life and figure out how long it will be until the Earth is hit by a massive asteroid! "]}, {"block": 1, "type": "code", "linesLength": 25, "startIndex": 3, "lines": ["import pandas as pd\n", "import numpy as np\n", "\n", "%load_ext autoreload\n", "%autoreload 2\n", "\n", "import sys\n", "sys.path.append('../..')\n", "\n", "# Options for pandas\n", "pd.options.display.max_columns = 20\n", "pd.options.display.max_rows = 10\n", "\n", "# Display all cell outputs\n", "from IPython.core.interactiveshell import InteractiveShell\n", "InteractiveShell.ast_node_interactivity = 'all'\n", "\n", "import plotly.plotly as py\n", "import plotly.graph_objs as go\n", "from plotly.offline import iplot, init_notebook_mode\n", "init_notebook_mode(connected=True)\n", "\n", "import cufflinks as cf\n", "cf.go_offline(connected=True)\n", "cf.set_config_file(theme='pearl')\n"]}, {"block": 2, "type": "markdown", "linesLength": 7, "startIndex": 28, "lines": ["## Data on Impacts\n", "\n", "The data on impact frequency, impact energy, and number of objects is from the NASA 2017 Report of the Near Earth Object Science Definition Team. It is available [online here](https://cneos.jpl.nasa.gov/doc/2017_neo_sdt_final_e-version.pdf).\n", "\n", "The average impact frequecy is $1.66 x 10^{-9} yr^{-1}$. Therefore, a single Near Earth Object will impact the Earth once in 600 million years. Or, if there are 600 million near earth objects, there should b eone collison every year. \n", "\n", "PHA = Potentially Hazardous Asteroids"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["df = pd.read_parquet('data/asteroid-impact-data')\n", "df.head()"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["df['impact_energy'].iplot(kind='bar')"]}, {"block": 5, "type": "markdown", "linesLength": 0, "startIndex": 38, "lines": []}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 38, "lines": ["# Simulations\n", "\n", "Here we will run 10000 simluations of a human lifetime (at 100 years). For each impact frequency, we can calculate the expected number of impacts. "]}, {"block": 7, "type": "code", "linesLength": 15, "startIndex": 41, "lines": ["np.random.seed(100)\n", "\n", "# Each simulation is a human lifetime\n", "simulations = 10000\n", "years = 100\n", "\n", "# Empty array to hold simulations\n", "impacts = np.zeros((len(df), simulations))\n", "\n", "# Iterate through each frequency\n", "for i, freq in enumerate(df['impact_frequency']):\n", "    # The expected number of impacts is the frequency times the length of time\n", "    lam = freq * years\n", "    # Run simulations with a poisson process\n", "    impacts[i] = np.random.poisson(lam, simulations)"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["If we take the average value across the 10,000 simulations, we come up with an estimated number of impacts. These should be close to `lambda` for each impact frequency as `lambda` is the expected number of impacts."]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["impacts.mean(axis=1)"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 58, "lines": ["impact_df = pd.DataFrame(impacts.T, columns=list(df['range_diameter']))\n", "impact_df.mean().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Average Impacts',\n", "                      title='Average Impacts per Human Lifetime')"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 61, "lines": ["impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Number of Impacts per Human Lifetime')"]}, {"block": 12, "type": "code", "linesLength": 15, "startIndex": 63, "lines": ["np.random.seed(100)\n", "\n", "# Each simulation is a human lifetime\n", "simulations = 10000\n", "years = 1000000\n", "\n", "# Empty array to hold simulations\n", "impacts = np.zeros((len(df), simulations))\n", "\n", "# Iterate through each frequency\n", "for i, freq in enumerate(df['impact_frequency']):\n", "    # The expected number of impacts is the frequency times the length of time\n", "    lam = freq * years\n", "    # Run simulations with a poisson process\n", "    impacts[i] = np.random.poisson(lam, simulations)"]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 78, "lines": ["impact_df = pd.DataFrame(impacts.T, columns=list(df['range_diameter']))\n", "impact_df.mean().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Average Impacts',\n", "                      title='Average Impacts per Million Years')"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 81, "lines": ["impact_df = pd.DataFrame(impacts.T, columns=list(df['range_diameter']))\n", "impact_df.max().iplot(kind='bar', xTitle='Diameter Range (km)', yTitle='Maximum Impacts',\n", "                      title='Maximum Impacts per Million Years')"]}, {"block": 15, "type": "code", "linesLength": 0, "startIndex": 84, "lines": []}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["lam = years * df['impact_frequency'].iloc[-1]\n", "lam"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["# Waiting Time"]}, {"block": 18, "type": "code", "linesLength": 14, "startIndex": 87, "lines": ["# Smallest asteroids\n", "freq = df['impact_frequency'].iloc[0]\n", "lam = freq * years\n", "\n", "np.random.seed(100)\n", "\n", "# Simulate 1 million years\n", "years = 1000000\n", "wait_times = np.zeros((len(df), years))\n", "\n", "\n", "for i, freq in enumerate(df['impact_frequency']):\n", "    a = np.random.choice([0, 1], size=1000000, p=[1-freq, freq])\n", "    wait_times[i] = a"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 101, "lines": ["np.bincount(np.diff(np.where(wait_times[0] == 1)[0]))"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 102, "lines": ["from collections import Counter\n", "wait_time_counts = Counter(np.diff(np.where(wait_times[-20] == 1)[0]))"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["wait_time_counts"]}, {"block": 22, "type": "code", "linesLength": 22, "startIndex": 105, "lines": ["def plot_wait_times(wait_times_counts, step=50):\n", "    \n", "    wait_time_df = pd.DataFrame({'waiting_time': list(wait_time_counts.keys()),\n", "                                 'count': list(wait_time_counts.values())}).sort_values('waiting_time')\n", "    \n", "    min_wait = wait_time_df['waiting_time'].min()\n", "    max_wait = wait_time_df['waiting_time'].max()\n", "    \n", "    bins = np.arange(0, max_wait, step=step)\n", "    print(bins)\n", "    # Bins the waiting times\n", "    wait_time_df['binned_wait'] = pd.cut(wait_time_df['waiting_time'], \n", "                                          bins=bins)\n", "    \n", "    # Sum the number of each waiting time\n", "    wait_time_sums = wait_time_df.groupby('binned_wait').sum()['count']\n", "    \n", "    # Convert to a string index for plotting\n", "    wait_time_sums.index = wait_time_sums.index.astype(str)\n", "    wait_time_sums.iplot(kind='bar')\n", "    wait_time_df.iplot(kind='scatter', mode='markers', x='waiting_time', y='count')\n", "    return wait_time_df"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 127, "lines": ["i = plot_wait_times(wait_time_counts, step=15000)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 128, "lines": ["i"]}, {"block": 25, "type": "code", "linesLength": 4, "startIndex": 129, "lines": ["wait_time_df = pd.DataFrame(wait_time_counts.values(), index=wait_time_counts.keys(), columns=['number']).sort_index()\n", "wait_time_df['binned_wait'] = (pd.cut(wait_time_df.index, bins=range(0, 2001, 100)))\n", "\n", "wait_time_sums"]}, {"block": 26, "type": "code", "linesLength": 13, "startIndex": 133, "lines": ["bins = wait_time_sums.index\n", "\n", "bins_ordered = []\n", "\n", "for b in bins:\n", "    if len(b.split(',')[0]) == 4:\n", "        bins_ordered.append(b.replace('(', '(0'))\n", "    elif len(b.split(',')[0]) == 3:\n", "        bins_ordered.append(b.replace('(', '(00'))\n", "    else:\n", "        bins_ordered.append(b)\n", "        \n", "wait_time_sums.index = bins_ordered"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 146, "lines": ["wait_time_sums"]}, {"block": 28, "type": "code", "linesLength": 0, "startIndex": 147, "lines": []}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["np.bincount(a\n", "           )"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 149, "lines": ["bins = np.logspace(0, 10, 11)\n", "bins"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 151, "lines": ["np.diff(np.where(wait_times == 1))"]}, {"block": 32, "type": "code", "linesLength": 4, "startIndex": 152, "lines": ["import seaborn as sns\n", "%matplotlib inline\n", "\n", "p = sns.kdeplot(np.random.poisson(lam, 10000))"]}, {"block": 33, "type": "code", "linesLength": 0, "startIndex": 156, "lines": []}, {"block": 34, "type": "code", "linesLength": 6, "startIndex": 156, "lines": ["from scipy.special import factorial\n", "k = np.arange(0, 5, 0.01)\n", "probs = np.exp(-lam) * np.power(lam, k) / factorial(k)\n", "\n", "figure = go.Figure(data=[dict(x=k, y=probs)], layout=go.Layout())\n", "iplot(figure)"]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 162, "lines": ["lam = 4\n", "\n", "from scipy.special import factorial\n", "\n", "k = np.arange(0, 20, 0.1)\n", "probs = np.exp(-lam) * np.power(lam, k) / factorial(k)\n", "\n", "figure = go.Figure(data=[dict(x=k, y=probs)], layout=go.Layout())\n", "iplot(figure)"]}, {"block": 36, "type": "code", "linesLength": 0, "startIndex": 171, "lines": []}]
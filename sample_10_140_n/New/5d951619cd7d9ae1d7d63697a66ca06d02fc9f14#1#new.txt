[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["# ThinkDSP\n", "\n", "This notebook contains solutions to exercises in Chapter 9: Differentiation and Integration\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 6, "startIndex": 7, "lines": ["# Get thinkdsp.py\n", "\n", "import os\n", "\n", "if not os.path.exists('thinkdsp.py'):\n", "    !wget https://github.com/AllenDowney/ThinkDSP/raw/master/code/thinkdsp.py"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 13, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "\n", "from thinkdsp import decorate"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 17, "lines": ["## Exercise 1\n", "\n", "The goal of this exercise is to explore the effect of `diff` and `differentiate` on a signal.  Create a triangle wave and plot it.  Apply the `diff` operator and plot the result.  Compute the spectrum of the triangle wave, apply `differentiate`, and plot the result.  Convert the spectrum back to a wave and plot it.  Are there differences between the effect of `diff` and `differentiate` for this wave?"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["*Solution:* Here's the triangle wave."]}, {"block": 5, "type": "code", "linesLength": 5, "startIndex": 21, "lines": ["from thinkdsp import TriangleSignal\n", "\n", "in_wave = TriangleSignal(freq=50).make_wave(duration=0.1, framerate=44100)\n", "in_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["The diff of a triangle wave is a square wave, which explains why the harmonics in a square wave drop off like $1/f$, compared to the triangle wave, which drops off like $1/f^2$."]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["out_wave = in_wave.diff()\n", "out_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 30, "lines": ["When we take the spectral derivative, we get \"ringing\" around the discontinuities: https://en.wikipedia.org/wiki/Ringing_(signal)\n", "\n", "Mathematically speaking, the problem is that the derivative of the triangle wave is undefined at the points of the triangle."]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 33, "lines": ["out_wave2 = in_wave.make_spectrum().differentiate().make_wave()\n", "out_wave2.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["## Exercise 2\n", "\n", "The goal of this exercise is to explore the effect of `cumsum` and `integrate` on a signal.  Create a square wave and plot it.  Apply the `cumsum` operator and plot the result.  Compute the spectrum of the square wave, apply `integrate`, and plot the result.  Convert the spectrum back to a wave and plot it.  Are there differences between the effect of `cumsum` and `integrate` for this wave?"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["*Solution:* Here's the square wave."]}, {"block": 12, "type": "code", "linesLength": 5, "startIndex": 40, "lines": ["from thinkdsp import SquareSignal\n", "\n", "in_wave = SquareSignal(freq=50).make_wave(duration=0.1, framerate=44100)\n", "in_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["The cumulative sum of a square wave is a triangle wave.  After the previous exercise, that should come as no surprise."]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 46, "lines": ["out_wave = in_wave.cumsum()\n", "out_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["The spectral integral is also a triangle wave, although the amplitude is very different."]}, {"block": 16, "type": "code", "linesLength": 5, "startIndex": 50, "lines": ["spectrum = in_wave.make_spectrum().integrate()\n", "spectrum.hs[0] = 0\n", "out_wave2 = spectrum.make_wave()\n", "out_wave2.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["If we unbias and normalize the two waves, they are visually similar."]}, {"block": 18, "type": "code", "linesLength": 5, "startIndex": 56, "lines": ["out_wave.unbias()\n", "out_wave.normalize()\n", "out_wave2.normalize()\n", "out_wave.plot()\n", "out_wave2.plot()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["And they are numerically similar, but with only about 3 digits of precision."]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["max(abs(out_wave.ys - out_wave2.ys))"]}, {"block": 21, "type": "markdown", "linesLength": 3, "startIndex": 63, "lines": ["## Exercise 3\n", "\n", "The goal of this exercise is the explore the effect of integrating twice.  Create a sawtooth wave, compute its spectrum, then apply `integrate` twice.  Plot the resulting wave and its spectrum.  What is the mathematical form of the wave?  Why does it resemble a sinusoid? "]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Here's the sawtooth."]}, {"block": 23, "type": "code", "linesLength": 5, "startIndex": 67, "lines": ["from thinkdsp import SawtoothSignal\n", "\n", "in_wave = SawtoothSignal(freq=50).make_wave(duration=0.1, framerate=44100)\n", "in_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["The first cumulative sum of a sawtooth is a parabola:"]}, {"block": 25, "type": "code", "linesLength": 4, "startIndex": 73, "lines": ["out_wave = in_wave.cumsum()\n", "out_wave.unbias()\n", "out_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["The second cumulative sum is a cubic curve:"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 78, "lines": ["out_wave = out_wave.cumsum()\n", "out_wave.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Integrating twice also yields a cubic curve."]}, {"block": 29, "type": "code", "linesLength": 5, "startIndex": 82, "lines": ["spectrum = in_wave.make_spectrum().integrate().integrate()\n", "spectrum.hs[0] = 0\n", "out_wave2 = spectrum.make_wave()\n", "out_wave2.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["At this point, the result looks more and more like a sinusoid.  The reason is that integration acts like a low pass filter.  At this point we have filtered out almost everything except the fundamental, as shown in the spectrum below:"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["out_wave2.make_spectrum().plot(high=500)"]}, {"block": 32, "type": "markdown", "linesLength": 5, "startIndex": 89, "lines": ["## Exercise 4 \n", "\n", "The goal of this exercise is to explore the effect of the 2nd difference and 2nd derivative.  Create a `CubicSignal`, which is defined in `thinkdsp`.  Compute the second difference by applying `diff` twice.  What does the result look like.  Compute the second derivative by applying `differentiate` twice.  Does the result look the same?\n", "\n", "Plot the filters that corresponds to the 2nd difference and the 2nd derivative and compare them.  Hint: In order to get the filters on the same scale, use a wave with framerate 1."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["*Solution:* Here's the cubic signal"]}, {"block": 34, "type": "code", "linesLength": 4, "startIndex": 95, "lines": ["from thinkdsp import CubicSignal\n", "\n", "in_wave = CubicSignal(freq=0.0005).make_wave(duration=10000, framerate=1)\n", "in_wave.plot()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["The first difference is a parabola and the second difference is a sawtooth wave (no surprises so far):"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 100, "lines": ["out_wave = in_wave.diff()\n", "out_wave.plot()"]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 102, "lines": ["out_wave = out_wave.diff()\n", "out_wave.plot()"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["When we differentiate twice, we get a sawtooth with some ringing.  Again, the problem is that the deriviative of the parabolic signal is undefined at the points."]}, {"block": 39, "type": "code", "linesLength": 4, "startIndex": 105, "lines": ["spectrum = in_wave.make_spectrum().differentiate().differentiate()\n", "out_wave2 = spectrum.make_wave()\n", "out_wave2.plot()\n", "decorate(xlabel='Time (s)')"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["The window of the second difference is -1, 2, -1.  By computing the DFT of the window, we can find the corresponding filter."]}, {"block": 41, "type": "code", "linesLength": 11, "startIndex": 110, "lines": ["from thinkdsp import zero_pad\n", "from thinkdsp import Wave\n", "\n", "diff_window = np.array([-1.0, 2.0, -1.0])\n", "padded = zero_pad(diff_window, len(in_wave))\n", "diff_wave = Wave(padded, framerate=in_wave.framerate)\n", "diff_filter = diff_wave.make_spectrum()\n", "diff_filter.plot(label='2nd diff')\n", "\n", "decorate(xlabel='Frequency (Hz)',\n", "                 ylabel='Amplitude ratio')"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 121, "lines": ["And for the second derivative, we can find the corresponding filter by computing the filter of the first derivative and squaring it."]}, {"block": 43, "type": "code", "linesLength": 8, "startIndex": 122, "lines": ["PI2 = np.pi * 2\n", "\n", "deriv_filter = in_wave.make_spectrum()\n", "deriv_filter.hs = (PI2 * 1j * deriv_filter.fs)**2\n", "deriv_filter.plot(label='2nd deriv')\n", "\n", "decorate(xlabel='Frequency (Hz)',\n", "                 ylabel='Amplitude ratio')"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 130, "lines": ["Here's what the two filters look like on the same scale:"]}, {"block": 45, "type": "code", "linesLength": 5, "startIndex": 131, "lines": ["diff_filter.plot(label='2nd diff')\n", "deriv_filter.plot(label='2nd deriv')\n", "\n", "decorate(xlabel='Frequency (Hz)',\n", "                 ylabel='Amplitude ratio')"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 136, "lines": ["Both are high pass filters that amplify the highest frequency components.  The 2nd derivative is parabolic, so it amplifies the highest frequencies the most.  The 2nd difference is a good approximation of the 2nd derivative only at the lowest frequencies, then it deviates substantially."]}, {"block": 47, "type": "code", "linesLength": 0, "startIndex": 137, "lines": []}]
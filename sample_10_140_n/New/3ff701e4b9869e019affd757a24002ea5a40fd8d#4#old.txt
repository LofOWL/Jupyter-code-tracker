[{"block": 0, "type": "markdown", "linesLength": 7, "startIndex": 0, "lines": ["## ThinkDSP\n", "\n", "This notebook contains code examples from Chapter 8: Filtering and Convolution\n", "\n", "Copyright 2015 Allen Downey\n", "\n", "License: [Creative Commons Attribution 4.0 International](http://creativecommons.org/licenses/by/4.0/)"]}, {"block": 1, "type": "code", "linesLength": 13, "startIndex": 7, "lines": ["from __future__ import print_function, division\n", "\n", "%matplotlib inline\n", "\n", "import thinkdsp\n", "import thinkplot\n", "import thinkstats2\n", "\n", "import numpy as np\n", "import pandas as pd\n", "import scipy.signal\n", "\n", "np.set_printoptions(precision=3, suppress=True)"]}, {"block": 2, "type": "code", "linesLength": 2, "startIndex": 20, "lines": ["PI2 = 2 * np.pi\n", "GRAY = '0.7'"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 22, "lines": ["### Smoothing\n", "\n", "As the first example, I'll look at daily closing stock prices for Facebook, from its IPO on 17 May 2012 to 8 December 2015 (note: the dataset includes only trading days )"]}, {"block": 4, "type": "code", "linesLength": 3, "startIndex": 25, "lines": ["names = ['date', 'open', 'high', 'low', 'close', 'volume']\n", "df = pd.read_csv('fb.csv', header=0, names=names, parse_dates=[0])\n", "df.head()"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Extract the close prices and days since start of series:"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 29, "lines": ["close = df.close.values[::-1]\n", "dates = df.date.values[::-1]\n", "days = (dates - dates[0]) / np.timedelta64(1,'D')"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Make a window to compute a 30-day moving average and convolve the window with the data.  The `valid` flag means the convolution is only computed where the window completely overlaps with the signal."]}, {"block": 8, "type": "code", "linesLength": 5, "startIndex": 33, "lines": ["M = 30\n", "window = np.ones(M)\n", "window /= sum(window)\n", "smoothed = np.convolve(close, window, mode='valid')\n", "smoothed_days = days[M//2: len(smoothed) + M//2]"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Plot the original and smoothed signals."]}, {"block": 10, "type": "code", "linesLength": 9, "startIndex": 39, "lines": ["thinkplot.plot(days, close, color=GRAY, label='daily close')\n", "thinkplot.plot(smoothed_days, smoothed, label='30 day average')\n", "\n", "last = days[-1]\n", "thinkplot.config(xlabel='Time (days)', \n", "                 ylabel='Price ($)',\n", "                 xlim=[-7, last+7],\n", "                 legend=True,\n", "                 loc='lower right')"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 48, "lines": ["### Smoothing sound signals\n", "\n", "Generate a 440 Hz sawtooth signal."]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 51, "lines": ["signal = thinkdsp.SawtoothSignal(freq=440)\n", "wave = signal.make_wave(duration=1.0, framerate=44100)\n", "wave.make_audio()"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Make a moving average window."]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 55, "lines": ["window = np.ones(11)\n", "window /= sum(window)\n", "thinkplot.plot(window)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Plot the wave."]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["segment = wave.segment(duration=0.01)\n", "segment.plot()\n", "thinkplot.config(xlabel='Time (s)', ylim=[-1.05, 1.05])"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Pad the window so it's the same length as the signal, and plot it."]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 63, "lines": ["N = len(segment)\n", "padded = thinkdsp.zero_pad(window, N)\n", "thinkplot.plot(padded)\n", "thinkplot.config(xlabel='Index')"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Apply the window to the signal (with lag=0)."]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 68, "lines": ["prod = padded * segment.ys\n", "print(sum(prod))"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Compute a convolution by rolling the window to the right."]}, {"block": 22, "type": "code", "linesLength": 5, "startIndex": 71, "lines": ["smoothed = np.zeros(N)\n", "rolled = padded.copy()\n", "for i in range(N):\n", "    smoothed[i] = sum(rolled * segment.ys)\n", "    rolled = np.roll(rolled, 1)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Plot the result of the convolution and the original."]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 77, "lines": ["segment.plot(color=GRAY)\n", "smooth = thinkdsp.Wave(smoothed, framerate=wave.framerate)\n", "smooth.plot()\n", "thinkplot.config(xlabel='Time(s)', ylim=[-1.05, 1.05])"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Compute the same convolution using `numpy.convolve`."]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 82, "lines": ["segment.plot(color=GRAY)\n", "ys = np.convolve(segment.ys, window, mode='valid')\n", "smooth2 = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "smooth2.plot()\n", "thinkplot.config(xlabel='Time(s)', ylim=[-1.05, 1.05])"]}, {"block": 27, "type": "markdown", "linesLength": 3, "startIndex": 87, "lines": ["## Frequency domain\n", "\n", "Let's see what's happening in the frequency domain."]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["Compute the smoothed wave using `np.convolve`, which is much faster than my version above."]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 91, "lines": ["convolved = np.convolve(wave.ys, window, mode='same')\n", "smooth = thinkdsp.Wave(convolved, framerate=wave.framerate)\n", "smooth.make_audio()"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["Plot spectrums of the original and smoothed waves:"]}, {"block": 31, "type": "code", "linesLength": 9, "startIndex": 95, "lines": ["spectrum = wave.make_spectrum()\n", "spectrum.plot(color=GRAY)\n", "\n", "spectrum2 = smooth.make_spectrum()\n", "spectrum2.plot()\n", "\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                 ylabel='Amplitude',\n", "                 xlim=[0, 22050])"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["For each harmonic, compute the ratio of the amplitudes before and after smoothing."]}, {"block": 33, "type": "code", "linesLength": 9, "startIndex": 105, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<280] = 0\n", "\n", "thinkplot.plot(ratio)\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                     ylabel='Amplitude ratio',\n", "                     xlim=[0, 22050])"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Plot the ratios again, but also plot the FFT of the window."]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 115, "lines": ["padded = thinkdsp.zero_pad(window, len(wave))\n", "dft_window = np.fft.rfft(padded)\n", "\n", "thinkplot.plot(abs(dft_window), color=GRAY, label='DFT(window)')\n", "thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                     ylabel='Amplitude ratio',\n", "                     xlim=[0, 22050], loc='upper right')"]}, {"block": 36, "type": "markdown", "linesLength": 3, "startIndex": 124, "lines": ["### Gaussian window\n", "\n", "Let's compare boxcar and Gaussian windows."]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["Make the boxcar window."]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 128, "lines": ["boxcar = np.ones(11)\n", "boxcar /= sum(boxcar)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 130, "lines": ["Make the Gaussian window."]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 131, "lines": ["gaussian = scipy.signal.gaussian(M=11, std=2)\n", "gaussian /= sum(gaussian)"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 133, "lines": ["Plot the two windows."]}, {"block": 42, "type": "code", "linesLength": 5, "startIndex": 134, "lines": ["thinkplot.preplot(2)\n", "thinkplot.plot(boxcar, label='boxcar')\n", "thinkplot.plot(gaussian, label='Gaussian')\n", "thinkplot.config(xlabel='Index',\n", "                 loc='upper right')"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["Convolve the square wave with the Gaussian window."]}, {"block": 44, "type": "code", "linesLength": 3, "startIndex": 140, "lines": ["ys = np.convolve(wave.ys, gaussian, mode='same')\n", "smooth = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "spectrum2 = smooth.make_spectrum()"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["Compute the ratio of the amplitudes."]}, {"block": 46, "type": "code", "linesLength": 4, "startIndex": 144, "lines": ["amps = spectrum.amps\n", "amps2 = spectrum2.amps\n", "ratio = amps2 / amps    \n", "ratio[amps<560] = 0"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 148, "lines": ["Compute the FFT of the window."]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 149, "lines": ["padded = thinkdsp.zero_pad(gaussian, len(wave))\n", "dft_gaussian = np.fft.rfft(padded)"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["Plot the ratios and the FFT of the window."]}, {"block": 50, "type": "code", "linesLength": 6, "startIndex": 152, "lines": ["thinkplot.plot(abs(dft_gaussian), color='0.7', label='Gaussian filter')\n", "thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "thinkplot.config(xlabel='Frequency (Hz)',\n", "                 ylabel='Amplitude ratio',\n", "                 xlim=[0, 22050])"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 158, "lines": ["Combine the preceding example into one big function so we can interact with it."]}, {"block": 52, "type": "code", "linesLength": 36, "startIndex": 159, "lines": ["def plot_filter(M=11, std=2):\n", "    signal = thinkdsp.SquareSignal(freq=440)\n", "    wave = signal.make_wave(duration=1, framerate=44100)\n", "    spectrum = wave.make_spectrum()\n", "\n", "    gaussian = scipy.signal.gaussian(M=M, std=std)\n", "    gaussian /= sum(gaussian)\n", "    high = gaussian.max()\n", "    \n", "    thinkplot.preplot(cols=2)\n", "    thinkplot.plot(gaussian)\n", "    thinkplot.config(xlabel='Index', ylabel='Window', \n", "                     xlim=[0, len(gaussian)-1], ylim=[0, 1.1*high])\n", "\n", "    ys = np.convolve(wave.ys, gaussian, mode='same')\n", "    smooth = thinkdsp.Wave(ys, framerate=wave.framerate)\n", "    spectrum2 = smooth.make_spectrum()\n", "\n", "    # plot the ratio of the original and smoothed spectrum\n", "    amps = spectrum.amps\n", "    amps2 = spectrum2.amps\n", "    ratio = amps2 / amps    \n", "    ratio[amps<560] = 0\n", "\n", "    # plot the same ratio along with the FFT of the window\n", "    padded = thinkdsp.zero_pad(gaussian, len(wave))\n", "    dft_gaussian = np.fft.rfft(padded)\n", "\n", "    thinkplot.subplot(2)\n", "    thinkplot.plot(abs(dft_gaussian), color=GRAY, label='Gaussian filter')\n", "    thinkplot.plot(ratio, label='amplitude ratio')\n", "\n", "    thinkplot.show(xlabel='Frequency (Hz)',\n", "                     ylabel='Amplitude ratio',\n", "                     xlim=[0, 22050],\n", "                     ylim=[0, 1.05])"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 195, "lines": ["Try out different values of `M` and `std`."]}, {"block": 54, "type": "code", "linesLength": 6, "startIndex": 196, "lines": ["from ipywidgets import interact, interactive, fixed\n", "import ipywidgets as widgets\n", "\n", "slider = widgets.IntSlider(min=2, max=100, value=11)\n", "slider2 = widgets.FloatSlider(min=0, max=20, value=2)\n", "interact(plot_filter, M=slider, std=slider2);"]}, {"block": 55, "type": "markdown", "linesLength": 5, "startIndex": 202, "lines": ["## Convolution theorem\n", "\n", "Let's use the Convolution theorem to compute convolutions using FFT.  Read the Facebook data again, and smooth it using `np.convolve` and a 30-day Gaussian window.\n", "\n", "I'll ignore the dates and treat the values as if they are equally spaced in time."]}, {"block": 56, "type": "code", "linesLength": 9, "startIndex": 207, "lines": ["names = ['date', 'open', 'high', 'low', 'close', 'volume']\n", "df = pd.read_csv('fb.csv', header=0, names=names, parse_dates=[0])\n", "close = df.close.values[::-1]\n", "\n", "window = scipy.signal.gaussian(M=30, std=6)\n", "window /= window.sum()\n", "smoothed = np.convolve(close, window, mode='valid')\n", "\n", "len(close), len(smoothed)"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 216, "lines": ["Plot the original and smoothed data."]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 217, "lines": ["thinkplot.plot(close, color=GRAY)\n", "thinkplot.plot(smoothed)"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 219, "lines": ["Pad the window and compute its FFT."]}, {"block": 60, "type": "code", "linesLength": 4, "startIndex": 220, "lines": ["N = len(close)\n", "padded = thinkdsp.zero_pad(window, N)\n", "fft_window = np.fft.fft(padded)\n", "thinkplot.plot(np.absolute(fft_window))"]}, {"block": 61, "type": "markdown", "linesLength": 1, "startIndex": 224, "lines": ["Apply the convolution theorem."]}, {"block": 62, "type": "code", "linesLength": 4, "startIndex": 225, "lines": ["fft_signal = np.fft.fft(close)\n", "smoothed2 = np.fft.ifft(fft_signal * fft_window)\n", "M = len(window)\n", "smoothed2 = smoothed2[M-1:]"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 229, "lines": ["Plot the two signals (smoothed with numpy and FFT)."]}, {"block": 64, "type": "code", "linesLength": 2, "startIndex": 230, "lines": ["thinkplot.plot(smoothed)\n", "thinkplot.plot(smoothed2.real)"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 232, "lines": ["Confirm that the difference is small."]}, {"block": 66, "type": "code", "linesLength": 2, "startIndex": 233, "lines": ["diff = smoothed - smoothed2\n", "max(abs(diff))"]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 235, "lines": ["`scipy.signal` provides `fftconvolve`, which computes convolutions using FFT."]}, {"block": 68, "type": "code", "linesLength": 1, "startIndex": 236, "lines": ["smoothed3 = scipy.signal.fftconvolve(close, window, mode='valid')"]}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 237, "lines": ["Confirm that it gives the same answer, at least approximately."]}, {"block": 70, "type": "code", "linesLength": 2, "startIndex": 238, "lines": ["diff = smoothed - smoothed3\n", "max(abs(diff))"]}, {"block": 71, "type": "markdown", "linesLength": 1, "startIndex": 240, "lines": ["We can encapsulate the process in a function:"]}, {"block": 72, "type": "code", "linesLength": 4, "startIndex": 241, "lines": ["def fft_convolve(signal, window):\n", "    fft_signal = np.fft.fft(signal)\n", "    fft_window = np.fft.fft(window)\n", "    return np.fft.ifft(fft_signal * fft_window)"]}, {"block": 73, "type": "markdown", "linesLength": 1, "startIndex": 245, "lines": ["And confirm that it gives the same answer."]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 246, "lines": ["smoothed4 = fft_convolve(close, padded)[M-1:]\n", "len(smoothed4)"]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 248, "lines": ["diff = smoothed - smoothed4\n", "max(abs(diff))"]}, {"block": 76, "type": "markdown", "linesLength": 5, "startIndex": 250, "lines": ["### Autocorrelation\n", "\n", "We can also use the convolution theorem to compute autocorrelation functions.\n", "\n", "Compute autocorrelation using `numpy.correlate`:\n"]}, {"block": 77, "type": "code", "linesLength": 2, "startIndex": 255, "lines": ["corrs = np.correlate(close, close, mode='same')\n", "corrs[:7]"]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 257, "lines": ["Compute autocorrelation using my `fft_convolve`.  The window is a reversed copy of the signal.  We have to pad the window and signal with zeros and then select the middle half from the result."]}, {"block": 79, "type": "code", "linesLength": 8, "startIndex": 258, "lines": ["def fft_autocorr(signal):\n", "    N = len(signal)\n", "    signal = thinkdsp.zero_pad(signal, 2*N)\n", "    window = np.flipud(signal)\n", "\n", "    corrs = fft_convolve(signal, window)\n", "    corrs = np.roll(corrs, N//2+1)[:N]\n", "    return corrs"]}, {"block": 80, "type": "markdown", "linesLength": 1, "startIndex": 266, "lines": ["Test the function."]}, {"block": 81, "type": "code", "linesLength": 2, "startIndex": 267, "lines": ["corrs2 = fft_autocorr(close)\n", "corrs2[:7]"]}, {"block": 82, "type": "markdown", "linesLength": 1, "startIndex": 269, "lines": ["Plot the results."]}, {"block": 83, "type": "code", "linesLength": 5, "startIndex": 270, "lines": ["lags = np.arange(N) - N//2\n", "thinkplot.plot(lags, corrs, color=GRAY, linewidth=7, label='np.convolve')\n", "thinkplot.plot(lags, corrs2.real, linewidth=2, label='fft_convolve')\n", "thinkplot.config(xlabel='Lag', ylabel='Correlation')\n", "len(corrs), len(corrs2)"]}, {"block": 84, "type": "markdown", "linesLength": 1, "startIndex": 275, "lines": ["Confirm that the difference is small."]}, {"block": 85, "type": "code", "linesLength": 2, "startIndex": 276, "lines": ["diff = corrs - corrs2.real\n", "max(abs(diff))"]}, {"block": 86, "type": "code", "linesLength": 0, "startIndex": 278, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 31, "startIndex": 0, "lines": ["# RBM Deep Dive with Tensorflow \n", "\n", "In this notebook we provide a complete walkthough of the Restricted Boltzmann Machine (RBM) algorithm with applications to recommender systems. In particular, we use as a case study the [movielens dataset](https://movielens.org), comprising the ranking of movies (from 1 to 5) given by viewers. A quickstart version of this notebook can be found [here](notebooks/00_quick_start/rbm_movielens.ipynb).  \n", "\n", "### Overview \n", "\n", "The RBM is a generative neural network model used to perform unsupervised learning. The main task of an RBM is to learn the joint probability distribution $P(v,h)$, where $v$ are the visible units and $h$ the hidden ones. The hidden units represent latent variables while the visible units are clamped on the input data. Once the joint distribution is learnt, new examples are generated by sampling from it.  \n", "\n", "The implementation presented here is based on the article by Ruslan Salakhutdinov, Andriy Mnih and Geoffrey Hinton [Restricted Boltzmann Machines for Collaborative Filtering](https://www.cs.toronto.edu/~rsalakhu/papers/rbmcf.pdf) with the exception that here we use multinomial units instead of one-hot encoded. \n", "\n", "### Advantages of RBM: \n", "\n", "The model generates ratings for a user/movie pair using a collaborative filtering based approach. While matrix factorization methods learn how to reproduce an instance of the user/item affinity matrix, the RBM learns its underlying probability distribution. This has several advantages: \n", "\n", "- Generalizability : the model generalize well to new examples as long as they do not differ much in probability\n", "- Stability in time: if the recommendation task is time-stationary, the model does not need to be trained often to accomodate new ratings/users. \n", "- Scales well with the size of the dataset and the sparsity of the user/affinity matrix. \n", "- The tensorflow implementation presented here allows fast, scalable  training on GPU \n", "\n", "### Outline \n", "\n", "This notebook is organizaed as follows:\n", "\n", "1. RBM Theory \n", "2. Tensorflow implementation and model parameters  \n", "3. Data preparation and inspection\n", "4. Model application, performance and analysis of the results  \n", "\n", "Sections 1 and 2 requires basic knowledge of linear algebra, probability theory and tensorflow while  \n", "sections 3 and 4 only requires some basic data science understanding. **Feel free to jumpo to the section you are most interested in!**\n", "\n"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["## 0 Global Settings and Import"]}, {"block": 2, "type": "code", "linesLength": 37, "startIndex": 32, "lines": ["from __future__ import print_function\n", "from __future__ import absolute_import\n", "from __future__ import division\n", "\n", "# set the environment path to find Recommenders\n", "import sys\n", "sys.path.append(\"../../\")\n", "\n", "import os\n", "import numpy as np\n", "import pandas as pd\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "\n", "import papermill as pm\n", "\n", "#RBM \n", "from reco_utils.recommender.rbm.Mrbm_tensorflow import RBM\n", "from reco_utils.dataset.rbm_splitters import splitter\n", "\n", "#Evaluation libraries\n", "from reco_utils.dataset import movielens \n", "\n", "from reco_utils.evaluation.python_evaluation import (\n", "    map_at_k,\n", "    ndcg_at_k,\n", "    precision_at_k,\n", "    recall_at_k,\n", ")\n", "\n", "from reco_utils.evaluation.parameter_sweep import generate_param_grid\n", "#For interactive mode only\n", "%load_ext autoreload\n", "%autoreload 2\n", "\n", "print(\"System version: {}\".format(sys.version))\n", "print(\"Pandas version: {}\".format(pd.__version__))"]}, {"block": 3, "type": "markdown", "linesLength": 20, "startIndex": 69, "lines": ["## 1. RBM Theory \n", "\n", "## 1.1 Overview and main differences with other recommender algorithms\n", "\n", "A Restricted Boltzmann Machine (RBM) is an undirected graphical model with origin in the statistical mechanics (or physics) of magnetic systems. Statistical mechanics (SM) provides a probabilistic description of complex systems made of a huge number of constituents (typically $\\sim 10^{23}$); instead of looking at a particular instance of the system, the aim of SM is to describe their **typical** behaviour. This approach has been succesfull for the description of gases, liquids, complex materials (e.g. semiconductors) and even the famous [Higgs boson](https://en.wikipedia.org/wiki/Higgs_boson)!\n", "\n", "Being designed to handle and organize a large amount of data, SM finds ideal applications in modern learnign algorithms. In the context of **recommender systems**, the idea is to learn typical user behaviour instead of particular instances. To understand this better, consider the most general setup of a recmmendation problem: there are $m$ users rating $n$ items according to some scale (e.g. 1 to 5). In a typical scenario of online shopping, streaming services or decision processes, the user only rates a subset $l \\ll m$ of the products. If we now create a matrix representation of this problem, we obtain the user/item affinity matrix $X$. In a more readable table form, $X$ will look like this:\n", "\n", "\n", "|  $X$   |$i_1$  |$i_2$  |$i_3$  |  ... |$i_m$  | \n", "|-----|-------|-------|-------|------|-------|\n", "|$u_1$|5      |0      |2      |0 ... |1      |\n", "|$u_2$|0      |0      |3      |4 ... |0      |\n", "|...  |...    |...    |...    |...   |...    |\n", "|$u_m$|3      |3      |0      |5...  |2      |\n", "\n", "\n", "where zeroes denote unrated items. In a nutshell, the recommender task is to \"fill in\" the missing ratings (later we will see that in practice this is not the only criteria to recommend a product). The classical approach to this problem is called matrix factorization: the basic idea is to decompose $X$ into a user ($P$) and item ($Q$) matrix, such that $X = Q^T P$. The dimensions of the two matrices are $dim(Q) = (f, n)$ and $dim(P)= (f,m)$ where $f \\le m,n$ is the number of latent factors, e.g. the genre of a movie, the type of food etc... and it is an hyperparameter of the model, for more details see the [ALS notebook](notebooks/02_modeling/als_deep_dive.ipynb). By learning $Q$ and $P$ we try to reproduce a particular instance of $X$ (provided by the available data) and use this information to fill up the missing matrix elements. \n", "\n", "The RBM approach is to look at $X$ as a particular realization (sample) of a more general process; instead of learning a specific $X$, we try to learn the matrix distrbution from which $X$ has been sampled form. Efectively, we learn the typical distirbution of *tastes* (i.e. latent factors) and use this information to *generate* new ratings. For this reaoson, this class of neural network models is also called **generative**. Consider the following example: imagine you are given the  income distribution per age window of a particular country (this is easy to find from goverments data), then we could fix the age window and *generate* virtual citizens with various incomes by sampling from this distibution.   "]}, {"block": 4, "type": "markdown", "linesLength": 19, "startIndex": 89, "lines": ["## 1.2 Model \n", "\n", "The central quantity of every SM model is the [Boltzmann distribution ](https://en.wikipedia.org/wiki/Boltzmann_distribution); this can be seen as the least biased probability distribution on a given probability space $\\Sigma$ and can be obtained using a maximum entropy principle on the space of distributions over $\\Sigma$. Its typical form is: \n", "\n", "$P = \\frac{1}{Z} \\, e^{- \\beta \\, H}$, \n", "\n", "where $Z$ is a normalization constant known as the partition function, $\\beta$ is a noise parameter with units of inverse energy and $H$ is the Hamiltonian, or energy function of the system. For this reason, this class of models is also known as *energy based* in computer science. In physics, $\\beta$ is the inverse temperature of the system in units of Boltzmann's constant, but here we will effectively rescale inside $H$, so that this is now a pure number. $H$ describes the behaviour of two sets of stochastic vectors, typically called $v_i$ (visibles) and $h_j$ (hidden). The former constitutes both the input *and* the ouput of the algo (this will be clear later), while the hidden units are the latent factors we want to learn. This structure results in the following Neural Network topology\n", "\n", "![rbm1](https://393229b54263dsvm.file.core.windows.net/images/RBM1.png?sp=rl&st=2018-12-03T13:06:28Z&se=2020-12-04T13:06:00Z&sv=2017-11-09&sig=XP5y%2BXuU4r3Snmb%2FIgksMR%2B26XZfgrV2ZVs183Nwn3k%3D&sr=f)\n", "\n", "The input of the movielens databse consists of ratings from 1 to 5; we shall thus consider a discrete configuration space of $m$ visible variables, each taking values in a finite set $\\chi_v = \\{ 1, 2, 3,4,5 \\}$. A global configuration of the system is determined by $\\mathbf{v} = (v_1, v_2, ..., v_m) \\in \\chi_v^m$ and we reserve $0$ for an unrated movie. We also need to specify the hidden units, that we take as random binary variables $\\chi_h = \\{0,1 \\}$ denoting if the particular unit is active or not and $\\mathbf{h} = (h_1, h_2, ...,h_n) \\in \\chi_h^n$. As we said before, the hidden units may describe attributes such as the genre of a movie; so given for example an sci-fi/horror movie, only the hidden units describing such attribute should be active. The minimal model for such a system is defined by the following Hamiltonian: \n", "\n", "$H = - \\sum_{i,j \\in G} v_i \\, w_{ij} \\, h_j - \\sum_{i=1}^m v_i \\, a_i - \\sum_{j=1}^n h_i \\, b_i$\n", "\n", "The first term is an \"interaction term\", capturing the correlations between the visible and hidden units, while the other two terms are \"potential terms\", taking into account the bias of the units. The correlation matrix $w_{ij}$ and the two biases $a_i$ and $b_i$ are learning parameters to be fixed by the minimization of a properly defined cost function. Remember that this is an unsupervised problem, i.e. there is no real output and therefore we cannot directly minimize the error function between the prediction and the labeled data. As in every SM problem, the right quantity to minimize is the Free energy (remember that $\\beta =1$ and there is a minus sign difference for convention)\n", "\n", "$F = \\log Z = \\log \\sum_{ v_i, h_i } P(v, h)$.\n", "\n", "In the langiage of probaility theory, the above quantity is the cumulant generating function. One way of evaluating the free energy is to use a [Markov-chain Montecarlo sampling](https://en.wikipedia.org/wiki/Monte_Carlo_method#Computer_graphics) algorithm such as the Metropolis-Hasting; here we will use instead an approximate method called Contrastive divergence, based on [Gibbs sampling](https://en.wikipedia.org/wiki/Gibbs_sampling) (see below). The latter algorithm has the advantage of being faster than the Montecarlo ones. Once the candidate $F$ has been found, we fix the learning parameters by extremizing $F$. Let us see how this works in practive in the next section. "]}, {"block": 5, "type": "markdown", "linesLength": 47, "startIndex": 108, "lines": ["## 1.3 Learning Algorithm \n", "\n", "Instead of sampling directly from the joint probability distirbution, one can evaluate the conditional distributions instead   \n", "\n", "$P(v, h) = P(v|h) P(h) = P(h|v) P(v)$ \n", "\n", "where the second equality follows from the fact that the model is undirected or, in physical terms, is at equilibrium. Gibbs sampling eesentially consists of two steps called positive and negative phases:\n", "\n", "### Positive \n", "\n", "**Fix the visible units on the data and evaluate $P(h_j =1| \\mathbf{v})$**, i.e. the probability that the jth hidden unit is active given the entire input vector. In practice, it is convenient to evaluate the generating function: \n", "\n", "$ Z[v,b] = \\prod_j \\sum_{h_j = 0,1}  e^{(\\sum_i w_{ij} v_i + b_j) h_j} = \\prod_j \\left( 1+  e^{\\sum_i w_{ij} v_i + b_j} \\right)$.\n", "\n", "Taking the gradients with respect to the bias we easily obtain \n", "\n", "$\\frac{\\partial}{\\partial b_j}\\log Z[v,b] =  \\frac{1}{1+ e^{-(\\sum_i w_{ij} v_i + b_j)}} = \\sigma( \\phi_j(v, b) )$\n", "\n", "where $\\phi_j(v,b) = \\sum_i w_{ij} v_i + b_j $ and we have identified the logistic function $\\sigma(.) \\equiv P(h_j=1|v,b)$. \n", "\n", "**Use $\\sigma$ to sample the value of $h_j$** \n", "\n", "### Negative \n", "\n", "**Use the sampled value of the hidden units to evaluete P(v_i = q |h)**, where $q=1,...,5$. This is given by the multinomial expression\n", "\n", "$P(v_i = q |h,a) =  \\prod_{v_i=1}^q e^{v_i (\\sum_j w_{ij} \\, h_j + a_i ) }/Z_q $,\n", "\n", "where $Z_q$ is partition function (aka normalization constant) evaluated over the $q$ outcomes (note that $0$ shoul not be included here). Finally, sample the values of $v_i$ from the above distribution. Clearly, these new $v_i$ are not necessarily those we have used as an input, at least not at the beginning of training. The above steps are repeated $k$ times, where $k$ is usually increased during training according to a specified protocol. \n", "\n", "At the end of each k-step Gibbs sampling, we evaluate the difference between the initial free energy ($k=0$) (given v) and the one after k-steps \n", "\n", "$\\Delta F = F_0 - F_k$, \n", "\n", "and update the learning parameters $w_{ij}$, $b_i$ and $a_i$: \n", "\n", "$\\frac{\\partial}{\\partial b_j} \\Delta F = \\frac{\\partial}{\\partial b_j} (\\log Z_0[v,b] - \\log Z_k[v,b]) = P_0(h_j=1|v,b) - P_k(h_j=1|v,b)$\n", "\n", "$\\frac{\\partial}{\\partial w_{ij} } \\Delta F = v_i \\, P_0(v_i = q|h, a) - v_i P_k(v_i| h,a) \\equiv \\langle v_i\\rangle_0 - \\langle v_i \\rangle_k$. \n", "\n", "This process is repeated for each training epoch, eventually until $\\Delta F =0$, i.e. the learned distribution faithfully reproduces the empirical one. In this sense, the $v_i$ serve both as input and output of the model. As $w_{ij}$ contains informations on how users' votes are correlated, we can use this information to generate ratings for the unseen movies by sampling from the learned, marginal distribution:\n", "\n", "$\\langle v_i \\rangle = \\sum_{v_i} v_i \\, P(v)$ \n", "\n", "The entire workflow is summarised below \n", "\n", "![gibbs](https://393229b54263dsvm.file.core.windows.net/images/Gsampling.001.png?sp=rl&st=2018-12-04T08:34:33Z&se=2020-12-05T08:34:00Z&sv=2017-11-09&sig=N0GXdj0UqLsXM2cwIZsWdMgqUTlYvu1pmGhnNmuAOWI%3D&sr=f)\n"]}, {"block": 6, "type": "markdown", "linesLength": 37, "startIndex": 155, "lines": ["## 2. TensorFlow implemetation and model parameters \n", "\n", "In this section we briefly describe how the algorithm in implemented in Tensorflow and which paramters can be customized by the user during training. We also discuss some best practice to be used when training the RBM model on a recommendation task. Further technical details are explained directly in the [code](reco_utils/recommender/rbm/Mrbm_tensorflow.py). \n", "\n", "Tensorflow (TF) is an opensource framework to develope deep learning (DL) models in a fast and efficient way. One of the shared characteristics of DL frameworks is autodifferentiation, i.e. the symbolic evaluation of gradients, that will be particulary useful here. The other advantage of TF is the geration and optimization of the symbolic operations defined on a computational graph, for fast and scalable deployment on CPU and GPU. For more informations on TF see [here](www.tensorflow.com). Unfortunately, TF is tailor made for supervised learning tasks, so its application to unsupervised model needs some more work. Note: although TF has recently started developing a [set of libraries to perform probabilistic inference](www.tensorflow_probability.com), we found their performance still not optimal and therefore we will not use them here. \n", "\n", "\n", "\n", "The model is instantiated as a class with several methods to build the graph, perform sampling, training and inference. The skeleton of the graph is built at the moment the class is instantiated; mandatory fields are \n", "\n", "- `hidden_units`: number of hidden units\n", "- `training_epoch`: number of training epochs \n", "- `minibatch_size`: size of the batch to be chosen at random at each training epoch \n", "\n", "The optional parameters are: \n", "\n", "- `keep_prob` : float (Default = 0.7) we use dropout regularization on the hidden units, so this parameters specifies the probability of keeping the connection to a hidden unit active. Dropout will affect specific matrix elements of $w_{ij}$, decreasing in this way the model's complexity and generally improving generalization. \n", "\n", "- `momentum` : float (Default= 0.5 - 0.9) We use TF's native momentum optimizer.  \n", "\n", "- `CD_protocol` : Array (Default = $[50, 70, 80,90,100]$) perfecentage of the entire training epochs when the \"annealing\" parameter should be increased. We use this protocol to increase the k-sampling step. In the default case, the first 50% of the training epochs are sampled with a single k-step. As training converges, the number of k-steps is increased by $1$ at each percentage.\n", "\n", "- `save_model`: Boolean (Default - False) if True save the model to a TF .ckpt file to be restored later on during inference. \n", "\n", "- `save_path`: String (Default = 'reco_utils/recommender/rbm/saver'), spefies the path where the RF model is goinf to be saved\n", "\n", "- `debug`: Boolean (Default = False) if True print the output of some of the intermediate steps to inspect their output \n", "\n", "- `with_metrics`: Boolean (Default= False) if True it evaluates, print and finally plot the mean squared root error per training epoch on the training set. At the end, it also evaluates and print the total model accuracy both on the training and test set. We suggest to switch it off only for benchmarking execution time.  \n", "\n", "- `init_stdv`: float (Default = 0.05) standard deviation used to inititialize the correlation matrix. \n", "\n", "- `learning_rate`: float (Default = 0.04) init learning rate used in the optimization algorithm. Note that the optimizer uses a different rate scaled to the batch size $\\alpha$ = `learning_rate/minibatch_size`. \n", "\n", "- `display_epoch `: integer (Default = 10) the number of epochs after which the rmse error is printed during the learning phase. \n", "\n", "Although optional, it is likely that the \"annealing protocol\" needs to be modified for different recommenders, we suggest the user to keep this in mind when training the recommender on a new dataset. \n"]}, {"block": 7, "type": "markdown", "linesLength": 7, "startIndex": 192, "lines": ["# 3 Data preparation and inspection \n", "\n", "The Movielens dataset comes in different sizes, denoting the number of available ratings. The number of users and rated movies also changes across the different dataset. The data are imported in a pandas dataframe including the **user ID**, the **item ID**, the **ratings** and a **timestamp** denoting when a particular user rated a particular item. Although this last feature could be explicitely included, it will not be considered here. The underlying assumption of this choice is that user's tastes are weakly time dependent, i.e. a user's taste typically chage on time scales (usually years) much longer than the typical recommendation time scale (e.g. hours/days). As a consequence, the joint probability distribution we want to learn can be safely considered as time dependent. Nevertheless, timestamps could be used as *contextual variables*, e.g. recommend a certain movie during the weekend and another during weekdays.  \n", "\n", "Below, we first load the different movielens data in pandas dataframes, explain how the user/affinity matrix is built and how the train/test set is generated. As this procedure is common to all the datasets we will consider, we explain it in details only for the 1 milion dataset.  \n", "\n", "We start with downloading the different dataset"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 199, "lines": ["MOVIELENS_DATA_SIZE = '100k'\n", "\n", "mldf_100k = movielens.load_pandas_df(\n", "    size=MOVIELENS_DATA_SIZE,\n", "    header=['userID','movieID','rating','timestamp']\n", ")\n", "\n", "mldf_100k.head()"]}, {"block": 9, "type": "code", "linesLength": 8, "startIndex": 207, "lines": ["MOVIELENS_DATA_SIZE = '1m'\n", "\n", "mldf_1m = movielens.load_pandas_df(\n", "    size=MOVIELENS_DATA_SIZE,\n", "    header=['userID','movieID','rating','timestamp']\n", ")\n", "\n", "mldf_1m.head()"]}, {"block": 10, "type": "markdown", "linesLength": 29, "startIndex": 215, "lines": ["### 3.1 Split the data using the stratified splitter  \n", "\n", "As a second step we split the data into train and test set. If you are familiar with training supervised learning model, here you will notice the first difference. In the former case, we cut off a certain proportion of training examples from the dataset (e.g. images), here corresponding to users (or items), ending up with two matrices (train and test) having different row dimensions. To make the RBM works corerctly, we need to mantain the same matrix size for the train and test set, but the two will contain different amounts of ratings. To see this in practice, let us describe what the `rbm_splitters` class does in details: \n", "\n", "- First, the class creates the $(m,n)$ user/affinity matrix $X$ defined in section **1.1**, together with the sparsness percentage. For example, for the 1m dataset, $95$% of the matrix entries are zeros. This represent a challenge for the learning task: fixing $95% of entries with only $5$% of data points. \n", "\n", "- Second, the matrix is split into train and test set. By default, we choose a $75$% to $25$% ratio. The `stratified_split()` method selects, for every user, $25$% of rated movies and it moves them in the new test matrix. Following the example $X$ above, we have\n", "\n", "### Train\n", "\n", "|  $X_{tr}$   |$i_1$  |$i_2$  |$i_3$  |  $...$ |$i_n$  |    \n", "|-----|-------|-------|-------|--------|-------|\n", "|$u_1$|$0$    |$0$    |$2$    |$0...$  |$0$    |\n", "|$u_2$|$0$    |$0$    |$3$    |$0...$  |$0$    |\n", "|$...$|$...$  |$...$  |$...$  |$...$   |$...$  |\n", "|$u_m$|$3$    |$0$    |$0$    |$0...$  |$2$    |\n", "\n", "\n", "### Test \n", "\n", "| $X_{tst}$    |$i_1$  |$i_2$  |$i_3$  |  ... |$i_n$  | \n", "|-----|-------|-------|-------|------|-------|\n", "|$u_1$|5      |0      |0      |0 ... |1      |\n", "|$u_2$|0      |0      |0      |4 ... |0      |\n", "|...  |...    |...    |...    |...   |...    |\n", "|$u_m$|0      |3      |0      |5...  |0      |\n", "\n", "The Train and Test matrices have exactly the same dimensions (i.e. same numbers of users and movies) but contain different ratings. Once the model is trained, at inference time, we use the test set user vectors to obtain the inferred values for the ratings.\n", "\n"]}, {"block": 11, "type": "code", "linesLength": 6, "startIndex": 244, "lines": ["#to use standard names across the analysis \n", "header = {\n", "        \"col_user\": \"userID\",\n", "        \"col_item\": \"movieID\",\n", "        \"col_rating\": \"rating\",\n", "    }"]}, {"block": 12, "type": "code", "linesLength": 7, "startIndex": 250, "lines": ["#instantiate the splitter \n", "split1m = splitter(DF = mldf_1m, **header)\n", "\n", "#Returns the train/test matrices (Xtr, Xtst) together with their dataframe versions (train_df, test_df) needed later for validation. \n", "#Finally, maps contains the mapping between matrix elements and the original user/movied IDs. \n", "\n", "Xtr_1m, Xtst_1m, train_df_1m, test_df_1m, maps_1m = split1m.stratified_split()"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 257, "lines": ["It is useful to inspect the distribution of ratings in the test/train matrix to make sure that the splitter keeps the same one across the train and test set. We can inspect this by plotting the normalized histogram"]}, {"block": 14, "type": "code", "linesLength": 5, "startIndex": 258, "lines": ["_, (ax1m, ax2m) = plt.subplots(1, 2, sharey=True, figsize=(10,5))\n", "ax1m.hist(Xtr_1m[Xtr_1m !=0], 5, density= True)\n", "ax1m.set_title('Train')\n", "ax2m.hist(Xtst_1m[Xtst_1m !=0], 5, density= True)\n", "ax2m.set_title('Test')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 263, "lines": ["We now repeat the same operations for the other datasets"]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 264, "lines": ["#100k\n", "split100k = splitter(DF = mldf_100k, **header)\n", "Xtr_100k, Xtst_100k, train_df_100k, test_df_100k, maps_100k = split100k.stratified_split()"]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 267, "lines": ["_, (ax1k, ax2k) = plt.subplots(1, 2, sharey=True, figsize=(10,5))\n", "ax1k.hist(Xtr_100k[Xtr_100k !=0], 5, density= True)\n", "ax1k.set_title('Train')\n", "ax2k.hist(Xtst_100k[Xtst_100k !=0], 5, density= True)\n", "ax2k.set_title('Train')"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 272, "lines": ["From the plots above we can see that the two datasets have very similar rating distributions. The main difference is in the degree of sparsness of the user/item affinity matrix; this is an important factor as it states the ratio between datapoints and unrated movies to infere. Note that the split function returns the total (or per dataset) sparsness, not the user-wise one. "]}, {"block": 19, "type": "code", "linesLength": 40, "startIndex": 273, "lines": ["def ranking_metrics(\n", "    data_size,\n", "    data_true,\n", "    data_pred,\n", "    time_train,\n", "    time_test,\n", "    K\n", "):\n", "\n", "    eval_map = map_at_k(data_true, data_pred, col_user=\"userID\", col_item=\"movieID\", \n", "                    col_rating=\"rating\", col_prediction=\"prediction\", \n", "                    relevancy_method=\"top_k\", k= K)\n", "\n", "    eval_ndcg = ndcg_at_k(data_true, data_pred, col_user=\"userID\", col_item=\"movieID\", \n", "                      col_rating=\"rating\", col_prediction=\"prediction\", \n", "                      relevancy_method=\"top_k\", k= K)\n", "\n", "    eval_precision = precision_at_k(data_true, data_pred, col_user=\"userID\", col_item=\"movieID\", \n", "                               col_rating=\"rating\", col_prediction=\"prediction\", \n", "                               relevancy_method=\"top_k\", k= K)\n", "\n", "    eval_recall = recall_at_k(data_true, data_pred, col_user=\"userID\", col_item=\"movieID\", \n", "                          col_rating=\"rating\", col_prediction=\"prediction\", \n", "                          relevancy_method=\"top_k\", k= K)\n", "\n", "    \n", "    df_result = pd.DataFrame(\n", "        {   \"Dataset\": data_size,\n", "            \"K\": K,\n", "            \"MAP\": eval_map,\n", "            \"nDCG@k\": eval_ndcg,\n", "            \"Precision@k\": eval_precision,\n", "            \"Recall@k\": eval_recall,\n", "            \"Train time\": time_train,\n", "            \"Test time\": time_test\n", "        }, \n", "        index=[0]\n", "    )\n", "    \n", "    return df_result"]}, {"block": 20, "type": "markdown", "linesLength": 10, "startIndex": 313, "lines": ["# 4. Model application, performance and analysis of the results  \n", "\n", "The model has been implemented as a Tensorflow (TF) class with the TF session hidden inside the `fit()` method so that no explicit, external call is needed. The algorithm operated in three different steps: \n", "\n", "- Model initialization: This is where we tell TF how to build the computational graph. The main parameters to specify are the number of hidden units, the number of training epochs and the minibatch size. \n", "\n", "- Model fit: This is where we train the model on the data. The method takes two arguments: the training and test set matrices. Note that the model is trained **only** on the training set, the set is used to display the generalization accuracy of the trained model, useful to have a first idea on the quality of training. \n", "\n", "- Model prediction: This is where we generate ratings for the unseen items. Once the model has been trained and we are satisfied with its overall accuracy, we sample new ratings from the learned distribution. In particular, we extract the top_k (e.g. 10) most relevant recommendation according to some predefined score. The prediction is then returned in dataframe format ready to be analysed and deployed.  \n", "\n"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 323, "lines": ["## 4.1 1m Dataset"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 324, "lines": ["#First we initialize the model class\n", "model_1m = RBM(hidden_units= 1000, training_epoch = 10, minibatch_size= 350, with_metrics=True, **header)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 326, "lines": ["Note that the first time the fit method is called it may take longer to return the result. This is due to the fact that TF needs to initialized the GPU session. You will notice that this is not the case when training the algorithm the second or more times. As for the `minibatch_size`, you would like to choose a value that gives you a good generalization error while mantaining a reasonable running time. The lower the size, the closer you get to stochastic gradient descent, but training takes longer. A big size value (say 1/2 of batch size) will speed up training but will increase the generalization error.     "]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 327, "lines": ["#Model Fit\n", "train_time =model_1m.fit(Xtr_1m, Xtst_1m)"]}, {"block": 25, "type": "markdown", "linesLength": 8, "startIndex": 329, "lines": ["During training, we evauate the Root mean squared error to have an idea of how learning is proceeding. Remember that in the RBM this is not the quantity being minimized, but plotting the rmse per epoch give us a rough understanding of how learning is proceeding and how we should adjust the hyper parameters. Generally, we would like to see the rmse decrease as a function of the learning epochs. Even though you may be using an automated hyper parameter optimization method, I strongly suggest to spend some time first to manually inspect the learning process; this will give you an idea of the value range to expect for the hyperparameters. Finally, note that most automated hyperparameters search methods are optimized for supervised learning, so they may not work as well for unsupervised tasks. \n", "\n", "The two final scores are the train/test mean average accuracies across the all set together with their difference. This has been defined as: \n", "\n", "$$ AC = \\frac{1}{m} \\sum_{\\mu=1}^{m} \\sum_{i=1}^{N_v} \\frac{1}{s_i} \\, I(v-vp = 0)_{\\mu,i} $$,\n", "\n", "where $m$ = total number of users, $N_v$ = Total number of items $\\equiv$ number of visible units and $s_i$= the number of non-zero elements per row, i.e. the per user total number of ratings. \n", "Remeber that for a model to generalize well the difference between train and test metrics should not be too big. In order to visualize these online metrics, choose `with_metrics =True` in the `RBM()` model function. When evaluating metrics, the model takes a bit longer to run, but you need to do so only in the exploratory phase of your work"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 337, "lines": ["### 4.1.2 Model Evaluation\n", "\n", "To evaluate the model performance and compare it against the other algorithms in this repository, we use the `recommend_k_items()` method. Note that we pass 'maps' as a second argument in order to return the correct user/item IDs in a pandas dataframe format.  "]}, {"block": 27, "type": "code", "linesLength": 11, "startIndex": 340, "lines": ["#number of top score elements to be recommended  \n", "K = 10\n", "\n", "#Model prediction on the test set Xtst. \n", "top_k_1m, test_time =  model_1m.recommend_k_items(Xtst_1m, maps_1m)\n", "\n", "#show the first 10 elements of the dataframe for inspection \n", "top_k_1m['userID'] = pd.to_numeric(top_k_1m['userID'])\n", "top_k_1m['movieID'] = pd.to_numeric(top_k_1m['movieID'])\n", "\n", "top_k_1m.head(10)  "]}, {"block": 28, "type": "code", "linesLength": 9, "startIndex": 351, "lines": ["rating_1m= ranking_metrics(\n", "    data_size = \"mv 1m\",\n", "    data_true =test_df_1m,\n", "    data_pred =top_k_1m,\n", "    time_train=train_time,\n", "    time_test =test_time,\n", "    K =10)\n", "\n", "rating_1m"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 360, "lines": ["## 4.2 100k Dataset"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 361, "lines": ["#100k\n", "model_100k = RBM(hidden_units= 500, training_epoch = 10, minibatch_size= 60,keep_prob= 0.9, with_metrics = True, **header)"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 363, "lines": ["train_time = model_100k.fit(Xtr_100k, Xtst_100k)"]}, {"block": 32, "type": "code", "linesLength": 8, "startIndex": 364, "lines": ["#Model prediction on the test set Xtst. \n", "top_k_100k, test_time =  model_100k.recommend_k_items(Xtst_100k, maps_100k)\n", "\n", "#show the first 10 elements of the dataframe for inspection \n", "top_k_100k['userID'] = pd.to_numeric(top_k_100k['userID'])\n", "top_k_100k['movieID'] = pd.to_numeric(top_k_100k['movieID'])\n", "\n", "top_k_100k.head(10)  "]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 372, "lines": ["### 4.2.1 Model evaluation "]}, {"block": 34, "type": "code", "linesLength": 9, "startIndex": 373, "lines": ["eval_100k= ranking_metrics(\n", "    data_size = \"mv 100k\",\n", "    data_true =test_df_100k,\n", "    data_pred =top_k_100k,\n", "    time_train=train_time,\n", "    time_test =test_time,\n", "    K =10)\n", "\n", "eval_100k"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 382, "lines": ["Note that the metrics for the 100k dataset are considerably better than those obtained for the 1m dataset, for the same number of training epochs. As we hae anticipated above, the sparsness of the user/affinity matrix is more important than the absolute number of ratings.  "]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Fichiers"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Exercice - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["### Calcul du nombre de lignes, de mots et de caract\u00e8res"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 4, "lines": ["# chargement de l'exercice\n", "from corrections.w4s1_files import exo_comptage"]}, {"block": 5, "type": "markdown", "linesLength": 8, "startIndex": 6, "lines": ["On se propose d'\u00e9crire une * moulinette* qui annote un fichier avec des nombres de lignes, de mots et de caract\u00e8res.\n", "\n", "Le but de l'exercice est d'\u00e9crire une fonction `comptage`:\n", " * qui prenne en argument un nom de fichier d'entr\u00e9e (on suppose qu'il existe) et un nom de fichier de sortie (on suppose qu'on a le droit de l'\u00e9crire);\n", " * le fichier d'entr\u00e9e est suppos\u00e9 encod\u00e9 en Unicode/UTF-8;\n", " * le fichier d'entr\u00e9e est laiss\u00e9 intact;\n", " *  pour chaque ligne en entr\u00e9e, le fichier de sortie comporte une ligne qui donne le num\u00e9ro de ligne, le nombre de mots (**s\u00e9par\u00e9s par des espaces**), le nombre de caract\u00e8res (y compris la fin de ligne), et la ligne d'origine;\n", " * et enfin le fichier de sortie comporte une derni\u00e8re ligne avec les nombres totaux de lignes, de mots et de caract\u00e8res, **suivieF d'une derni\u00e8re fin de ligne**."]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 14, "lines": ["# un exemple de ce qui est attendu\n", "exo_comptage.example()"]}, {"block": 7, "type": "code", "linesLength": 5, "startIndex": 16, "lines": ["# votre code\n", "def comptage(in_filename, out_filename):\n", "    print('in',in_filename)\n", "    print('out',out_filename)\n", "    \"<votre_code>\""]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["**N'oubliez pas de v\u00e9rifier** que vous ajoutez bien la **derni\u00e8re fin de ligne**, car la v\u00e9rification automatique est pointilleuse (elle utilise l'op\u00e9rateur `==`), et rejettera votre code si vous ne produisez pas une sortie rigoureusement similaire \u00e0 ce qui est attendu."]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 22, "lines": ["# pour v\u00e9rifier votre code\n", "# voyez aussi un peu plus bas, une cellule d'aide au debugging\n", "\n", "exo_comptage.correction(comptage)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["La m\u00e9thode `debug` applique votre fonction au premier fichier d'entr\u00e9e, et affiche le r\u00e9sultat comme dans l'exemple ci-dessus. "]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["# debugging\n", "exo_comptage.debug(comptage)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["### Acc\u00e8s aux fichiers d'exemples"]}, {"block": 13, "type": "markdown", "linesLength": 10, "startIndex": 30, "lines": ["Vous pouvez t\u00e9l\u00e9charger les fichiers d'exemples&nbsp;:\n", " * [Romeo and Juliet](data/romeo_and_juliet.txt)\n", " * [Lorem Ipsum](data/lorem_ipsum.txt)\n", " * [\"Une charogne\" en utf-8](data/une_charogne_unicode.txt)\n", "\n", "***\n", "\n", "Pour les courageux, je vous donne \u00e9galement [\"Une charogne\" en Iso-latin-15](data/une_charogne_iso15.txt), qui contient le m\u00eame texte que \"Une charogne\", mais encod\u00e9 en iso-latin-15.\n", "\n", "Ce dernier fichier n'est pas \u00e0 prendre en compte dans la version basique de l'exercice, mais vous pourrez vous rendre compte par vous m\u00eame, au cas o\u00f9 cela ne serait pas clair encore pour vous, qu'il n'est pas facile d'\u00e9crire une fonction `comptage` qui devine l'encodage, c'est-\u00e0-dire qui fonctionne correctement avec des entr\u00e9es indiff\u00e9remment en unicode ou isolatin, sans que cet encodage soit pass\u00e9 en param\u00e8tre \u00e0 `comptage`."]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Manipuler des ensembles d'instances"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Souvenez-vous de ce qu'on avait dit en semaine 3 s\u00e9quence 4, concernant les cl\u00e9s dans un dictionnaire ou les \u00e9l\u00e9ments dans un ensemble. Nous avions vu alors que, pour les types *built-in*, les cl\u00e9s devaient \u00eatre des objets immuables et m\u00eame globalement immuables."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Nous allons voir dans ce compl\u00e9ment quelles sont les r\u00e8gles qui s'appliquent aux instances de classe."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### Instance mutable dans un ensemble"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Une instance de classe est par d\u00e9faut un objet mutable. Malgr\u00e9 cela, le langage vous permet d'ins\u00e9rer une instance dans un ensemble - ou de l'utiliser comme cl\u00e9 dans un dictionnaire. Nous allons voir ce m\u00e9canisme en action."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["### Hachage par d\u00e9faut\u00a0: bas\u00e9 sur `id()`"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 12, "lines": ["# une classe Point\n", "class Point1:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "        \n", "    def __repr__(self):\n", "        return f\"Pt[{self.x}, {self.y}]\""]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Avec ce code, les instances de `Point` sont mutables\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 21, "lines": ["# deux instances \n", "p1 = Point1(2, 2)\n", "p2 = Point1(2, 3)"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["# objets mutables\n", "p1.y = 3"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 26, "lines": ["Mais par contre soyez attentifs, car il faut savoir que pour la classe `Point1`, o\u00f9 nous n'avons rien red\u00e9fini, la fonction de hachage sur une instance de `Point1` ne d\u00e9pend que de la valeur de `id()` sur cet objet.\n", "\n", "Ce qui, dit autrement, signifie que deux objets qui sont distincts au sens de `id()` sont consid\u00e9r\u00e9s comme diff\u00e9rents, et donc peuvent coexister dans un ensemble (ou dans un dictionnaire)\u00a0:"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 29, "lines": ["# nos deux objets se ressemblent\n", "p1, p2"]}, {"block": 14, "type": "code", "linesLength": 5, "startIndex": 31, "lines": ["# mais peuvent coexister \n", "# dans un ensemble\n", "# qui a alors 2 \u00e9l\u00e9ments\n", "s = { p1, p2 }\n", "len(s)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Si on recherche un de ces deux objets on le trouve\u00a0:"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["p1 in s"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 38, "lines": ["# mais pas un troisi\u00e8me\n", "p3 = Point1(2, 4)\n", "p3 in s"]}, {"block": 18, "type": "markdown", "linesLength": 3, "startIndex": 41, "lines": ["Cette possibilit\u00e9 de g\u00e9rer des ensembles d'objets selon cette strat\u00e9gie est tr\u00e8s commode et peut apporter de gros gains de performance, notamment lorsqu'on a souvent besoin de faire des tests d'appartenance.\n", "\n", "En pratique, lorsqu'un mod\u00e8le de donn\u00e9es d\u00e9finit une relation de type \"1-n\", je vous recommande d'envisager d'utiliser un ensemble plut\u00f4t qu'une liste."]}, {"block": 19, "type": "markdown", "linesLength": 8, "startIndex": 44, "lines": ["Par exemple envisagez :\n", "\n", "    class Animal:\n", "        # blabla\n", "       \n", "    class Zoo:\n", "        def __init__(self):\n", "            self.animals = set()"]}, {"block": 20, "type": "markdown", "linesLength": 8, "startIndex": 52, "lines": ["Plut\u00f4t que :\n", "\n", "    class Animal:\n", "        # blabla\n", "       \n", "    class Zoo:\n", "        def __init__(self):\n", "            self.animals = []"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["### Ce n'est pas ce que vous voulez ?"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Le comportement qu'on vient de voir pour les instances de `Point1` dans les tables de hachage est raisonnable, si on admet que deux points ne sont \u00e9gaux que s'ils sont **le m\u00eame objet** au sens de `is`."]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 63, "lines": ["Mais imaginons que vous voulez au contraire consid\u00e9rer que deux points son \u00e9gaux lorsqu'ils coincident sur le plan. Avec ce mod\u00e8le de donn\u00e9es, vous voudriez que\u00a0:\n", "* un ensemble dans lequel on ins\u00e8re `p1` et `p2` ne contienne qu'un \u00e9l\u00e9ment,\n", "* et qu'on trouve `p3` quand on le cherche dans cet ensemble.\n"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["### Le protocole *hashable*: `__hash__` et `__eq__` "]}, {"block": 26, "type": "markdown", "linesLength": 6, "startIndex": 67, "lines": ["Le langage nous permet de faire cela, gr\u00e2ce au protocole *hashable*; pour cela il nous faut d\u00e9finir deux m\u00e9thodes\u00a0:\n", "\n", "* `__eq__` qui, sans grande surprise, va servir \u00e0 \u00e9valuer `p == q`\u00a0;\n", "* `__hash__` qui va retourner la cl\u00e9 de hachage sur un objet.\n", "\n", "La subtilit\u00e9 \u00e9tant bien entendu que ces deux m\u00e9thodes doivent \u00eatre coh\u00e9rentes, si deux objets sont \u00e9gaux, il faut que leurs hashs soient \u00e9gaux\u00a0; de bon sens, si l'\u00e9galit\u00e9 se base sur nos deux attributs `x` et `y`, il faudra bien entendu que la fonction de hachage utilise elle aussi ces deux attributs. Voir la documentation de [`__hash__`](https://docs.python.org/3/reference/datamodel.html?highlight=__hash__#object.__hash__)."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Voyons cela sur une sous-classe de `Point1`, dans laquelle nous d\u00e9finissons ces deux m\u00e9thodes\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 10, "startIndex": 74, "lines": ["class Point2(Point1):\n", "\n", "    # l'\u00e9galit\u00e9 va se baser naturellement sur x et y\n", "    def __eq__(self, other):\n", "        return self.x == other.x and self.y == other.y\n", "\n", "    # du coup la fonction de hachage \n", "    # d\u00e9pend aussi de x et de y\n", "    def __hash__(self):\n", "        return (11 * self.x + self.y) // 16"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["On peut v\u00e9rifier que cette fois les choses fonctionnent correctement\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 85, "lines": ["q1 = Point2(2, 3)\n", "q2 = Point2(2, 3)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Nos deux objets sont distincts pour `id()`/`is`, mais \u00e9gaux pour `==`\u00a0:"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["print(f\"is \u2192 {q1 is q2} \\n== \u2192 {q1 == q2}\")"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Et un ensemble contenant les deux points n'en contient qu'un\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["s = {q1, q2}\n", "len(s)"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["q3 = Point2(2, 3)\n", "q3 in s"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["Comme les ensembles et les dictionnaires reposent sur le m\u00eame m\u00e9canisme de table de hachage, on peut aussi indiff\u00e9remment utiliser n'importe lequel de nos 3 points pour indexer un dictionnaire\u00a0:"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 95, "lines": ["d = {}\n", "d[q1] = 1\n", "d[q2]"]}, {"block": 38, "type": "code", "linesLength": 4, "startIndex": 98, "lines": ["# les cl\u00e9s q1, q2 et q3 sont\n", "# les m\u00eames pour le dictionnaire\n", "d[q3] = 10000\n", "d"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["### Attention ! "]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Tout ceci semble tr\u00e8s bien fonctionner; sauf qu'en fait, il y a une **grosse faille**, c'est que nos objets `Point2` sont **mutables**. Du coup on peut maintenant imaginer un sc\u00e9nario comme celui-ci\u00a0:"]}, {"block": 41, "type": "code", "linesLength": 3, "startIndex": 104, "lines": ["t1, t2 = Point2(10, 10), Point2(10, 10)\n", "s = {t1, t2}\n", "s"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 107, "lines": ["t1 in s, t2 in s"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["Mais si maintenant je change un des deux objets:"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 109, "lines": ["t1.x = 100"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 110, "lines": ["s"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 111, "lines": ["t1 in s"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["t2 in s"]}, {"block": 48, "type": "markdown", "linesLength": 8, "startIndex": 113, "lines": ["\u00c9videmment cela n'est pas correct. Ce qui se passe ici c'est qu'on a\n", "* d'abord ins\u00e9r\u00e9 `t1` dans `s`, avec un indice de hachage calcul\u00e9 \u00e0 partir de `10, 10`\n", "* pas ins\u00e9r\u00e9 `t2` dans `s` parce qu'on a d\u00e9termin\u00e9 qu'il existait d\u00e9j\u00e0.\n", "\n", "Apr\u00e8s avoir modifi\u00e9 `t1` qui est le seul \u00e9l\u00e9ment de `s`:\n", "\u00c0 ce stade: \n", "* lorsqu'on cherche `t1` dans `s`, on le fait avec un indice de hachage calcul\u00e9 \u00e0 partir de `100, 10` et du coup on ne le trouve pas,\n", "* lorsqu'on cherche `t2` dans `s`, on utilise le bon indice de hachage, mais ensuite le seul \u00e9l\u00e9ment qui pourrait faire l'affaire n'est pas \u00e9gal \u00e0 `t2`."]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 121, "lines": ["### Conclusion"]}, {"block": 50, "type": "markdown", "linesLength": 3, "startIndex": 122, "lines": ["La [documentation de Python sur ce sujet](https://docs.python.org/3/reference/datamodel.html#object.__hash__) indique ceci\u00a0:\n", "\n", "> If a class defines mutable objects and implements an `__eq__`() method, it should not implement `__hash__`(), since the implementation of hashable collections requires that a key\u2019s hash value is immutable (if the object\u2019s hash value changes, it will be in the wrong hash bucket)."]}, {"block": 51, "type": "markdown", "linesLength": 4, "startIndex": 125, "lines": ["Notre classe `Point2` illustre bien cette limitation. Pour qu'elle soit utilisable en pratique, il faut **rendre ses instances immutables**. Cela peut se faire de plusieurs fa\u00e7ons, dont deux que nous aborderons dans la prochaine s\u00e9quence et qui sont - entre autres\u00a0:\n", "\n", "* le `namedtuple`\n", "* et la `dataclass` (nouveau en 3.7)."]}]
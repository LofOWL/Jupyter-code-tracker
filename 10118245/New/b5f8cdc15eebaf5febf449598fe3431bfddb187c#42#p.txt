[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Fichiers et utilitaires"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Outre les objets fichiers cr\u00e9\u00e9s avec la fonction `open`, comme on l'a vu dans la vid\u00e9o, et qui servent \u00e0 lire et \u00e9crire \u00e0 un endroit pr\u00e9cis, une application a besoin d'un minimum d'utilitaires pour **parcourir l'arborescence de r\u00e9pertoires et fichiers**, c'est notre propos dans ce compl\u00e9ment."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Le module `os.path` (obsol\u00e8te)"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 5, "lines": ["Avant la version python-3.4, la librairie standard offrait une conjonction d'outils pour ce type de fonctionnalit\u00e9s:\n", "\n", "* le module `os.path`, pour faire des calculs sur les les chemins et noms de fichiers [doc](https://docs.python.org/3/library/os.html),\n", "* le module `os` pour certaines fonctions compl\u00e9mentaires comme renommer ou d\u00e9truire un fichier [doc](https://docs.python.org/3/library/os.path.html),\n", "* et enfin le module `glob` pour la recherche de fichiers, par exemple pour trouver tous les fichiers en `*.txt` [doc](https://docs.python.org/3/library/glob.html)."]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 10, "lines": ["Cet ensemble un peu disparate a \u00e9t\u00e9 remplac\u00e9 par une librairie unique `pathlib`, qui fournit toutes ces fonctionnalit\u00e9s sous un interface unique et moderne, que nous recommandons \u00e9videmment d'utiliser pour du nouveau code.\n", "\n", "Avant d'aborder `pathlib`, voici un tr\u00e8s bref aper\u00e7u de ces trois anciens modules, pour le cas - assez probable - o\u00f9 vous les rencontreriez dans du code existant; tous les noms qui suivent correspondent \u00e0 des **fonctions** - par opposition \u00e0 `pathlib` qui comme nous allons le voir offre une interface orient\u00e9e objet:"]}, {"block": 7, "type": "markdown", "linesLength": 4, "startIndex": 13, "lines": ["* `os.path.join` ajoute '/' ou '\\' entre deux morceaux de chemin, selon l'OS\n", "* `os.path.basename` trouve le nom de fichier dans un chemin\n", "* `os.path.dirname` trouve le nom du directory dans un chemin\n", "* `os.path.abspath` calcule un chemin absolu, c'est-\u00e0-dire \u00e0 partir de la racine du filesystem "]}, {"block": 8, "type": "markdown", "linesLength": 4, "startIndex": 17, "lines": ["* `os.path.exists` pour savoir si un chemin existe ou pas (fichier ou r\u00e9pertoire)\n", "* `os.path.isfile` (et `isdir`) pour savoir si un chemin est un fichier  (et un r\u00e9pertoire)\n", "* `os.path.getsize` pour obtenir la taille du fichier \n", "* `os.path.getatime` et aussi `getmtime` et `getctime`  pour obtenir les dates de cr\u00e9ation/modification d'un fichier"]}, {"block": 9, "type": "markdown", "linesLength": 4, "startIndex": 21, "lines": ["* `os.remove` (ou son ancien nom `os.unlink`), qui permet de supprimer un fichier\n", "* `os.rmdir` pour supprimer un r\u00e9pertoire (mais qui doit \u00eatre vide)\n", "* `os.removedirs` pour supprimer tout un r\u00e9pertoire avec son contenu, r\u00e9cursivement si n\u00e9cessaire\n", "* `os.rename` pour renommer un fichier"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["* `glob.glob` comme dans par exemple `glob.glob(\"*.txt\")`"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["### Le module `pathlib`"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["##### Orient\u00e9 Objet"]}, {"block": 13, "type": "markdown", "linesLength": 3, "startIndex": 28, "lines": ["Comme on l'a mentionn\u00e9 `pathlib` offre une interface orient\u00e9e objet; mais qu'est-ce que \u00e7a veut dire au juste ? \n", "\n", "Ceci nous donne un pr\u00e9texte pour une premi\u00e8re application pratique des notions de module (que nous avons introduits en fin de semaine 2) et de classe (que nous allons voir en fin de semaine)."]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["De m\u00eame que le langage nous propose les types *builtin* `int` et `str`, le module `pathlib` nous expose **un type** (on dira plut\u00f4t **une classe**) qui s'appelle `Path`, que nous allons importer comme ceci:"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 32, "lines": ["from pathlib import Path"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Nous allons faire tourner un petit sc\u00e9nario qui va cr\u00e9er un fichier:"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["# le nom de notre fichier jouet \n", "nom = 'fichier-temoin'"]}, {"block": 18, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["Pour commencer, nous allons v\u00e9rifier si le fichier en question existe. \n", "\n", "Pour \u00e7a nous cr\u00e9ons un **objet** qui est une **instance** de la classe `Path`, comme ceci:"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 39, "lines": ["# on cr\u00e9e un objet de la classe Path, associ\u00e9 au nom de fichier\n", "path = Path(nom)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Vous remarquez que c'est consistent avec par exemple:"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 42, "lines": ["# transformer un float en int\n", "i = int(3.5)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["en ce sens que le type (`int` ou `Path`) se comporte comme une usine pour cr\u00e9er des objets du type en question."]}, {"block": 23, "type": "markdown", "linesLength": 7, "startIndex": 45, "lines": ["Quoi qu'il en soit, cet objet `path` offre un certain nombre de m\u00e9thodes; pour les voir puisque nous sommes dans un notebook, je vous invite dans la cellule suivante \u00e0 utilise l'aide en ligne en appuyant sur la touche 'Tabulation' apr\u00e8s avoir ajout\u00e9 un `.` comme si vous alliez envoyer une m\u00e9thode \u00e0 cet objet\n", "\n", "```\n", "path.[taper la touche TAB]\n", "```\n", "\n", "et le notebook vous montrera la liste des m\u00e9thodes disponibles."]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 52, "lines": ["# ajouter un . et utilisez la touche <Tabulation>\n", "path"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Ainsi par exemple on peut savoir si le fichier existe avec la m\u00e9thode `exists`:"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 55, "lines": ["# au d\u00e9part le fichier n'existe pas\n", "path.exists()"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 57, "lines": ["# si j'\u00e9cris dedans je le cr\u00e9e\n", "with open(nom, 'w') as output:\n", "    output.write('0123456789\\n')"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["# et maintenant il existe\n", "path.exists()"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["##### m\u00e9tadonn\u00e9es"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Voici quelques exemples qui montrent comment acc\u00e9der aux m\u00e9tadonn\u00e9es de ce fichier:"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 64, "lines": ["# cette m\u00e9thode retourne (en un seul appel syst\u00e8me) les m\u00e9tadonn\u00e9es agr\u00e9g\u00e9es\n", "path.stat()"]}, {"block": 32, "type": "markdown", "linesLength": 3, "startIndex": 66, "lines": ["Pour ceux que \u00e7a int\u00e9resse, l'objet retourn\u00e9 par cette m\u00e9thode `stat` est un `namedtuple`, que l'on va voir tr\u00e8s bient\u00f4t.\n", "\n", "On acc\u00e8de aux diff\u00e9rentes informations comme ceci:"]}, {"block": 33, "type": "code", "linesLength": 3, "startIndex": 69, "lines": ["# la taille du fichier en octets est de 11\n", "# car il faut compter le caract\u00e8re \"newline\" en fin de ligne \n", "path.stat().st_size"]}, {"block": 34, "type": "code", "linesLength": 4, "startIndex": 72, "lines": ["# la date de derni\u00e8re modification, sous forme d'un entier\n", "# c'est le nombre de secondes depuis le 1er Janvier 1970\n", "mtime = path.stat().st_mtime\n", "mtime"]}, {"block": 35, "type": "code", "linesLength": 5, "startIndex": 76, "lines": ["# que je peux rendre lisible comme ceci\n", "# en anticipant sur le module datetime\n", "from datetime import datetime\n", "mtime_datetime = datetime.fromtimestamp(mtime)\n", "mtime_datetime"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 81, "lines": ["# ou encore, si je formatte pour n'obtenir que\n", "# l'heure et la minute\n", "f\"{mtime_datetime:%H--%M}\""]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["##### D\u00e9truire un fichier"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 85, "lines": ["# je peux maintenant d\u00e9truire le fichier\n", "path.unlink()"]}, {"block": 39, "type": "code", "linesLength": 6, "startIndex": 87, "lines": ["# ou encore mieux, si je veux d\u00e9truire \n", "# seulement dans le cas o\u00f9 il existe je peux aussi faire\n", "try: \n", "    path.unlink()\n", "except FileNotFoundError:\n", "    print(\"no need to remove\")"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 93, "lines": ["# et maintenant il n'existe plus\n", "path.exists()"]}, {"block": 41, "type": "code", "linesLength": 4, "startIndex": 95, "lines": ["# je peux aussi retrouver le nom du fichier comme ceci\n", "# attention ce n'est pas une m\u00e9thode mais un attribut \n", "# c'est pourquoi il n'y a pas de parenth\u00e8ses\n", "path.name"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["##### Recherche de fichiers"]}, {"block": 43, "type": "markdown", "linesLength": 3, "startIndex": 100, "lines": ["Maintenant je voudrais conna\u00eetre la liste des fichiers de nom `*.json` dans le directory `data`. \n", "\n", "La m\u00e9thode la plus naturelle consiste \u00e0 cr\u00e9er une instance de `Path` associ\u00e9e au directory lui-m\u00eame:"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 103, "lines": ["dirpath = Path('./data/')"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["Sur cet objet la m\u00e9thode `glob` nous retourne un it\u00e9rable qui contient ce qu'on veut:"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 105, "lines": ["# tous les fichiers *.json dans le r\u00e9pertoire data/\n", "for json in dirpath.glob(\"*.json\"):\n", "    print(json)"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["##### Documentation compl\u00e8te"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["Voyez [la documentation compl\u00e8te ici](https://docs.python.org/3/library/pathlib.html)"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 111, "lines": ["Pour ceux qui sont d\u00e9j\u00e0 familiers avec les classes, j'en profite pour vous faire remarquer le type de notre objet path"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 112, "lines": ["type(path)"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["qui n'est pas `Path`, mais en fait une sous-classe de `Path` qui est - sur la plateforme du MOOC au moins, qui fonctionne sous linux - un objet de type `PosixPath`, qui est une sous-classe de `Path`, comme vous pouvez le voir:"]}, {"block": 53, "type": "code", "linesLength": 2, "startIndex": 114, "lines": ["from pathlib import PosixPath\n", "issubclass(PosixPath, Path)"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["Ce qui fait que m\u00e9caniquement, path est bien une instance de `Path`"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["isinstance(path, Path)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 118, "lines": ["ce qui est heureux puisqu'on avait utilis\u00e9 `Path()` pour construire l'objet `path` au d\u00e9part :)"]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Expressions r\u00e9guli\u00e8res"]}, {"block": 2, "type": "markdown", "linesLength": 4, "startIndex": 6, "lines": ["Nous vous proposons dans ce notebook quelques exercices sur les expressions r\u00e9guli\u00e8res. Faisons quelques remarques avant de commencer\u00a0:\n", "\n", "* nous nous concentrons sur l'\u00e9criture de l'expression r\u00e9guli\u00e8re en elle-m\u00eame, et pas sur l'utilisation de la biblioth\u00e8que\u00a0;\n", "* en particulier, tous les exercices font appel \u00e0 `re.match` entre votre *regexp* et une liste de cha\u00eenes d'entr\u00e9e qui servent de jeux de test."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["##### Liens utiles"]}, {"block": 4, "type": "markdown", "linesLength": 4, "startIndex": 11, "lines": ["Pour travailler sur ces exercices, il pourra \u00eatre profitable d'avoir sous la main\u00a0:\n", "\n", "* la [documentation officielle](https://docs.python.org/3/library/re.html#regular-expression-syntax)\u00a0;\n", "* et [cet outil interactif sur https://pythex.org/](https://pythex.org/) qui permet d'avoir un retour presque imm\u00e9diat, et donc d'acc\u00e9l\u00e9rer la mise au point."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["## Exercice - niveau interm\u00e9diaire (1)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["##### Identificateurs Python"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["# \u00e9valuez cette cellule pour charger l'exercice\n", "from corrections.regexp_pythonid import exo_pythonid"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["On vous demande d'\u00e9crire une expression r\u00e9guli\u00e8re qui d\u00e9crit les noms de variable en Python. Pour cet exercice on se concentre sur les caract\u00e8res ASCII. On exclut donc les noms de variables qui pourraient contenir des caract\u00e8res exotiques comme les caract\u00e8res accentu\u00e9s ou autres lettres grecques.\n", "\n", "Il s'agit donc de reconna\u00eetre toutes les cha\u00eenes qui commencent par une lettre ou un `_`, suivi de lettres, chiffres ou `_`."]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["# quelques exemples de r\u00e9sultat attendus\n", "exo_pythonid.example()"]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 24, "lines": ["# \u00e0 vous de jouer: \u00e9crivez ici\n", "# sous forme de cha\u00eene votre expression r\u00e9guli\u00e8re\n", "\n", "regexp_pythonid = r\"<votre_regexp>\""]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["# \u00e9valuez cette cellule pour valider votre code\n", "exo_pythonid.correction(regexp_pythonid)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["## Exercice - niveau interm\u00e9diaire (2)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["##### Lignes avec nom et pr\u00e9nom"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# pour charger l'exercice\n", "from corrections.regexp_agenda import exo_agenda"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["On veut reconna\u00eetre dans un fichier toutes les lignes qui contiennent un nom et un pr\u00e9nom."]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["exo_agenda.example()"]}, {"block": 17, "type": "markdown", "linesLength": 6, "startIndex": 36, "lines": ["Plus pr\u00e9cis\u00e9ment, on cherche les cha\u00eenes qui\u00a0:\n", "\n", "* commencent par une suite - possiblement vide - de caract\u00e8res alphanum\u00e9riques (vous pouvez utiliser `\\w`) ou tiret haut (`-`) qui constitue le pr\u00e9nom\u00a0;\n", "* contiennent ensuite comme s\u00e9parateur le caract\u00e8re 'deux-points' `:`\u00a0;\n", "* contiennent ensuite une suite - cette fois jamais vide - de caract\u00e8res alphanum\u00e9riques, qui constitue le nom\u00a0;\n", "* et enfin contiennent un deuxi\u00e8me caract\u00e8re `:` mais optionnellement seulement."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["On vous demande de construire une expression r\u00e9guli\u00e8re qui d\u00e9finit les deux groupes `nom` et `prenom`, et qui rejette les lignes qui ne satisfont pas ces crit\u00e8res."]}, {"block": 19, "type": "code", "linesLength": 5, "startIndex": 43, "lines": ["# entrez votre regexp ici\n", "# il faudra la faire terminer par \\Z\n", "# regardez ce qui se passe si vous ne le faites pas\n", "\n", "regexp_agenda = r\"<votre regexp>\\Z\""]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 48, "lines": ["# \u00e9valuez cette cellule pour valider votre code\n", "exo_agenda.correction(regexp_agenda)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["## Exercice - niveau interm\u00e9diaire (3)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["##### Num\u00e9ros de t\u00e9l\u00e9phone"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 52, "lines": ["# pour charger l'exercice\n", "from corrections.regexp_phone import exo_phone"]}, {"block": 24, "type": "markdown", "linesLength": 6, "startIndex": 54, "lines": ["Cette fois on veut reconna\u00eetre des num\u00e9ros de t\u00e9l\u00e9phone fran\u00e7ais, qui peuvent \u00eatre\u00a0:\n", "\n", "* soit au format contenant 10 chiffres dont le premier est un `0`\u00a0;\n", "* soit un format international commen\u00e7ant par `+33` suivie de 9 chiffres.\n", "\n", "Dans tous les cas on veut trouver dans le groupe 'number' les 9 chiffres vraiment significatifs, comme ceci\u00a0:"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["exo_phone.example()"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 61, "lines": ["# votre regexp\n", "# \u00e0 nouveau il faut terminer la regexp par \\Z\n", "regexp_phone = r\"<votre regexp>\\Z\""]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 64, "lines": ["# \u00e9valuez cette cellule pour valider votre code\n", "exo_phone.correction(regexp_phone)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["## Exercice - niveau avanc\u00e9"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Vu comment sont con\u00e7us les exercices, vous ne pouvez pas passer \u00e0 `re.compile` un drapeau comme `re.IGNORECASE` ou autre\u00a0; sachez cependant que vous pouvez ***embarquer* ces drapeaux dans la *regexp*** elle-m\u00eame\u00a0; par exemple pour rendre la regexp insensible \u00e0 la casse de caract\u00e8res, au lieu d'appeler `re.compile` avec le flag `re.I`, vous pouvez utiliser `(?i)` comme ceci\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["import re"]}, {"block": 31, "type": "code", "linesLength": 6, "startIndex": 69, "lines": ["# on peut embarquer les flags comme IGNORECASE\n", "# directement dans la regexp\n", "# c'est \u00e9quivalent de faire ceci\n", "\n", "re_obj = re.compile(\"abc\", flags=re.IGNORECASE)\n", "re_obj.match(\"ABC\").group(0)"]}, {"block": 32, "type": "code", "linesLength": 3, "startIndex": 75, "lines": ["# ou cela\n", "\n", "re.match(\"(?i)abc\",\"ABC\").group(0)"]}, {"block": 33, "type": "code", "linesLength": 3, "startIndex": 78, "lines": ["# les flags comme (?i) doivent appara\u00eetre\n", "# en premier dans la regexp\n", "re.match(\"abc(?i)\",\"ABC\").group(0)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Pour plus de pr\u00e9cisions sur ce trait, que nous avons laiss\u00e9 de c\u00f4t\u00e9 dans le compl\u00e9ment pour ne pas trop l'alourdir, voyez [la documentation sur les expressions r\u00e9guli\u00e8res](https://docs.python.org/3/library/re.html#regular-expression-syntax) et cherchez la premi\u00e8re occurrence de `iLmsux`."]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["### D\u00e9cortiquer une URL"]}, {"block": 36, "type": "markdown", "linesLength": 24, "startIndex": 83, "lines": ["On vous demande d'\u00e9crire une expression r\u00e9guli\u00e8re qui permette d'analyser des URLs.\n", "\n", "Voici les conventions que nous avons adopt\u00e9es pour l'exercice\u00a0:\n", "\n", "* la cha\u00eene contient les parties suivantes\u00a0:\n", "  * `<protocol>://<location>/<path>`\u00a0;\n", "* l'URL commence par le nom d'un protocole qui doit \u00eatre parmi `http`, `https`, `ftp`, `ssh`\u00a0;\n", "* le nom du protocole peut contenir de mani\u00e8re indiff\u00e9rente des minuscules ou des majuscules\u00a0;\n", "* ensuite doit venir la s\u00e9quence `://`\u00a0;\n", "* ensuite on va trouver une cha\u00eene `<location>` qui contient\u00a0:\n", "  * potentiellement un nom d'utilisateur, et s'il est pr\u00e9sent, potentiellement un mot de passe\u00a0;\n", "  * obligatoirement un nom de `hostname`\u00a0;\n", "  * potentiellement un num\u00e9ro de port\u00a0;\n", "* lorsque les 4 parties sont pr\u00e9sentes dans `<location>`, cela se pr\u00e9sente comme ceci\u00a0:\n", "  * `<location> = <user>:<password>@<hostname>:<port>`\u00a0;\n", "* si l'on note entre crochets les parties optionnelles, cela donne\u00a0:\n", "  * `<location> = [<user>[:<password>]@]<hostname>[:<port>]`\u00a0;\n", "* le champ `<user>` ne peut contenir que des caract\u00e8res alphanum\u00e9riques\u00a0; si le `@` est pr\u00e9sent le champ `<user>` ne peut pas \u00eatre vide\u00a0;\n", "* le champ `<password>` peut contenir tout sauf un `:` et de m\u00eame, si le `:` est pr\u00e9sent le champ `<password>` ne peut pas \u00eatre vide\u00a0;\n", "* le champ `<hostname>` peut contenir un suite non-vide de caract\u00e8res alphanum\u00e9riques, underscores, ou `.`\u00a0;\n", "* le champ `<port>` ne contient que des chiffres, et il est non vide si le `:` est sp\u00e9cifi\u00e9\u00a0;\n", "* le champ `<path>` peut \u00eatre vide.\n", "\n", "Enfin, vous devez d\u00e9finir les groupes `proto`, `user`, `password`, `hostname`, `port` et `path` qui sont utilis\u00e9s pour v\u00e9rifier votre r\u00e9sultat. Dans la case `R\u00e9sultat attendu`, vous trouverez soit `None` si la regexp ne filtre pas l'int\u00e9gralit\u00e9 de l'entr\u00e9e, ou bien une liste ordonn\u00e9e de tuples qui donnent la valeur de ces groupes\u00a0; vous n'avez rien \u00e0 faire pour construire ces tuples, c'est l'exercice qui s'en occupe."]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 107, "lines": ["# pour charger l'exercice\n", "from corrections.regexp_url import exo_url"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 109, "lines": ["# exemples du r\u00e9sultat attendu\n", "exo_url.example()"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 111, "lines": ["# n'h\u00e9sitez pas \u00e0 construire votre regexp petit \u00e0 petit\n", "\n", "regexp_url = \"<votre_regexp>\""]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 114, "lines": ["exo_url.correction(regexp_url)"]}]
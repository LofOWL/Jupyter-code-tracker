[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Type d'un tableau `numpy`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Nous allons voir dans ce compl\u00e9ment ce qu'il faut savoir sur le type d'un tableau `numpy`."]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 8, "lines": ["import numpy as np"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Dans ce compl\u00e9ment nous allons rester en dimension 1\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 10, "lines": ["a = np.array([1, 2, 4, 8])"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["### Toutes les cellules ont le m\u00eame type"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["Comme on l'a vu dans la vid\u00e9o, les tr\u00e8s bonnes performances que l'on peut obtenir en utilisant un tableau `numpy` sont li\u00e9es au fait que le tableau est **homog\u00e8ne**\u00a0: toutes les cellules du tableau **poss\u00e8dent le m\u00eame type**\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 13, "lines": ["# pour acc\u00e9der au type d'un tableau\n", "a.dtype"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Vous voyez que dans notre cas, le syst\u00e8me a choisi pour nous un type entier\u00a0; selon les entr\u00e9es on peut obtenir\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 16, "lines": ["# si je mets au moins un flottant\n", "f = np.array([1, 2, 4, 8.])\n", "f.dtype"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 19, "lines": ["# et avec un complexe\n", "c = np.array([1, 2, 4, 8j])\n", "c.dtype"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Et on peut pr\u00e9ciser le type que l'on veut si cette heuristique ne nous convient pas\u00a0:"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["# je choisis explicitement mon dtype\n", "c2 = np.array([1, 2, 4, 8], dtype=np.complex64)\n", "c2.dtype"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["##### Pertes de pr\u00e9cision"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Une fois que le type est d\u00e9termin\u00e9, on s'expose \u00e0 de possibles pertes de pr\u00e9cision, comme d'habitude\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["a, a.dtype"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 29, "lines": ["# a est de type entier\n", "# je vais perdre le 0.14\n", "a[0] = 3.14\n", "a"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["##### Types disponibles"]}, {"block": 20, "type": "markdown", "linesLength": 7, "startIndex": 34, "lines": ["[Voyez la liste compl\u00e8te https://docs.scipy.org/doc/numpy/user/basics.types.html](https://docs.scipy.org/doc/numpy/user/basics.types.html).\n", "\n", "Ce qu'il faut en retenir\u00a0:\n", "\n", "* vous pouvez choisir entre `bool`, `int`, `uint` (entier non sign\u00e9), `float` et `complex`\u00a0;\n", "* ces types ont diverses tailles pour vous permettre d'optimiser la m\u00e9moire r\u00e9ellement utilis\u00e9e\u00a0;\n", "* ces types existent en tant que tels (hors de tableaux)."]}, {"block": 21, "type": "code", "linesLength": 4, "startIndex": 41, "lines": ["# un entier sur 1 seul octet, c'est possible !\n", "np_1 = np.int8(1)\n", "# l'\u00e9quivalent en Python natif\n", "py_1 = 1"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 45, "lines": ["# il y a bien \u00e9galit\u00e9\n", "np_1 == py_1"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 47, "lines": ["# mais bien entendu ce ne sont pas les m\u00eames objets\n", "np_1 is py_1"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Du coup, on peut commencer \u00e0 faire de tr\u00e8s substantielles \u00e9conomies de place\u00a0; imaginez que vous souhaitez manipuler une image d'un million de pixels en noir et blanc sur 256 niveaux de gris\u00a0; j'en profite pour vous montrer `np.zeros` (qui fait ce que vous pensez)\u00a0:"]}, {"block": 25, "type": "code", "linesLength": 4, "startIndex": 50, "lines": ["# pur Python\n", "from sys import getsizeof\n", "pure_py = [0 for i in range(10**6)]\n", "getsizeof(pure_py)"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 54, "lines": ["# numpy\n", "num_py = np.zeros(10**6, dtype=np.int8)\n", "getsizeof(num_py)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Je vous signale enfin l'attribut `itemsize` qui vous permet d'obtenir la taille en octets occup\u00e9e par chacune des cellules, et qui correspond donc en gros au nombre qui appara\u00eet dans `dtype`, mais divis\u00e9 par huit\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["a.dtype"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["a.itemsize"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["c.dtype"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["c.itemsize"]}]
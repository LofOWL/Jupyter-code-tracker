[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Animations interactives avec `matplotlib`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 7, "lines": ["Nous allons voir dans ce notebook comment cr\u00e9er une animation avec matplotlib et tirer parti des *widgets* dans un notebook pour rendre ces animations interactives.\n", "\n", "Ce sera l'occasion de d\u00e9cortiquer un exemple un peu sophistiqu\u00e9, o\u00f9 l'utilisation d'un g\u00e9n\u00e9rateur permet de rendre l'impl\u00e9mentation plus propre et plus \u00e9l\u00e9gante."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["### Le sujet"]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 11, "lines": ["En guise d'illustration, nous allons cr\u00e9er\u00a0:\n", "* une animation matplotlib\u00a0: disons que l'on veut faire d\u00e9filer horizontalement une sinuso\u00efde ;\n", "* un widget interactif\u00a0: disons que l'on veut pouvoir changer la vitesse de d\u00e9filement."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Les outils"]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 15, "lines": ["Pour fabriquer cela nous aurons besoin principalement\u00a0:\n", "* de la librairie d'animation de matplotlib, et sp\u00e9cifiquement le sous-package `animation`,\n", "* et des widgets du module `ipywidgets`."]}, {"block": 8, "type": "code", "linesLength": 3, "startIndex": 18, "lines": ["import numpy as np\n", "from matplotlib import pyplot as plt\n", "from matplotlib import animation"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["from IPython.display import display as display_widget\n", "from ipywidgets import IntSlider"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### La logique"]}, {"block": 11, "type": "markdown", "linesLength": 10, "startIndex": 24, "lines": ["Dans un notebook pr\u00e9c\u00e9dent nous avions abord\u00e9 la fonction `interact`, de la librairie `ipywidgets`, qui nous permettait d'appeler interactivement une fonction avec des arguments choisis interactivement via une s\u00e9rie de widgets.\n", "\n", "Si on essaie d'utiliser `interact` pour faire des animations, l'effet visuel, qui revient \u00e0 effacer/recalculer une visualisation \u00e0 chaque changement de valeur des entr\u00e9es, donne un rendu peu agr\u00e9able \u00e0 l'oeil.\n", "\n", "C'est pourquoi ici la logique va \u00eatre un petit peu diff\u00e9rente\u00a0:\n", "* c'est une fonction native de `matplotlib` qui impl\u00e9mente la boucle principale, en travaillant sur un objet `Figure`,\n", "* et le widget est utilis\u00e9 uniquement pour modifier une variable python ;\n", "* pour simplifier notre code, l'\u00e9change d'informations entre ces deux morceaux se fait le plus simplement possible, via une variable globale. \n", "\n", "Bien entendu cette derni\u00e8re pratique n'est pas recommand\u00e9e dans du code de production, et le lecteur int\u00e9ress\u00e9 est invit\u00e9 \u00e0 am\u00e9liorer ce point."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["### Version non interactive et basique"]}, {"block": 13, "type": "markdown", "linesLength": 3, "startIndex": 35, "lines": ["Pour commencer nous allons voir comment utiliser `matplotlib.animation` sans interactivit\u00e9. \n", "\n", "Cette version est inspir\u00e9e du [tutorial matplotlib sur les animations](https://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/), qui montre d'ailleurs d'autres animations plus complexes et convaincantes, comme le double pendule par exemple."]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Mais avant tout choisissons ce mode de rendu\u00a0:"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["%matplotlib notebook"]}, {"block": 16, "type": "markdown", "linesLength": 7, "startIndex": 40, "lines": ["Nous allons utiliser la fonction `animation.FuncAnimation`; celle-ci s'attend \u00e0 recevoir en argument, principalement\u00a0:\n", "* une figure,\n", "* et une fonction d'affichage.\n", "\n", "La logique est que la fonction d'affichage est appel\u00e9e \u00e0 intervalles r\u00e9guliers par `FuncAnimation`, elle doit retourner un it\u00e9rable d'objets affichable dans la figure. \n", "\n", "Dans notre cas, nous allons cr\u00e9er une instance unique d'un objet `plot`; cette instance sera modifi\u00e9e \u00e0 chaque frame par la fonction d'affichage, qui le renverra dans un tuple \u00e0 un \u00e9l\u00e9ment (ceci parce qu'un it\u00e9rable est attendu)."]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["##### Version basique dite *tout-en-un*"]}, {"block": 18, "type": "code", "linesLength": 40, "startIndex": 48, "lines": ["import numpy as np\n", "from matplotlib import pyplot as plt\n", "from matplotlib import animation\n", "\n", "# on commence par cr\u00e9er une figure; \n", "figure1 = plt.figure(figsize=(4, 2))\n", "\n", "# en g\u00e9n\u00e9ral pour une animation \n", "# il est important de fixer les bornes en x et en y \n", "# pour ne pas avoir d'artefacts de changement d'\u00e9chelle\n", "# pendant l'animation\n", "ax1 = plt.axes(xlim=(0, 2), ylim=(-1.5, 1.5))\n", "\n", "# on cr\u00e9e aussi un plot vide qui va \u00eatre modifi\u00e9 \u00e0 chaque frame\n", "line1, = ax1.plot([], [], linewidth=2)\n", "\n", "# la vitesse de d\u00e9filement\n", "speed = 1\n", "\n", "# une globale; c'est vilain !\n", "offset = 0.\n", "\n", "# la fonction qui calcule et affiche chaque frame\n", "def compute_and_display(n):\n", "    global offset\n", "    offset += speed / 100\n", "    x = np.linspace(0, 2, 1000)\n", "    y = np.sin(2 * np.pi * (x - offset))\n", "    line1.set_data(x, y)\n", "    return line1,\n", "\n", "\n", "# la fonction magique pour animer une figure\n", "# blit=True est une optimisation graphique \n", "# pour ne rafficher que le n\u00e9cessaire\n", "anim = animation.FuncAnimation(figure1, \n", "                               func=compute_and_display, \n", "                               frames=50, repeat=False,\n", "                               interval=40, blit=True)\n", "plt.show()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["### S\u00e9paration calcul et affichage"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 89, "lines": ["plt.ion()"]}, {"block": 21, "type": "markdown", "linesLength": 6, "startIndex": 90, "lines": ["On voit qu'on a appel\u00e9 `FuncAnimation` avec `frames=50` et `interval=40` (ms); ce qui correspond donc \u00e0 25 images par seconde, soit une dur\u00e9e de deux secondes.\n", "\n", "Profitons-en pour voir tout de suite une am\u00e9lioration possible. \n", "Il serait souhaitable de s\u00e9parer\u00a0:\n", "* d'une part la logique du calcul - ou de l'acquisition, si on voulait par exemple faire du postprocessing temps r\u00e9el d'images vid\u00e9o,\n", "* et d'autre part l'affichage \u00e0 proprement parler."]}, {"block": 22, "type": "markdown", "linesLength": 5, "startIndex": 96, "lines": ["Pour cela, remarquez que le param\u00e8tre `frames` est document\u00e9 comme pouvant \u00eatre **un it\u00e9rateur**. La logique en fait \u00e0 l'oeuvre dans `FuncAnimation` est que \n", "* `frames` est un it\u00e9rateur qui va \u00e9num\u00e9rer des donn\u00e9es,\n", "* \u00e0 chaque frame cet it\u00e9rateur est avanc\u00e9 avec `next()`, et son retour est pass\u00e9 \u00e0 la fonction d'affichage.\n", "\n", "En guise de commodit\u00e9, lorsqu'on passe comme ci-dessus `frames=200`, la fonction transforme cela en `frames=range(200)`. C'est pourquoi d'ailleurs il est important que `compute_and_display` accepte un param\u00e8tre unique, m\u00eame si nous n'en avons pas eu besoin."]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["Cette constatation nous am\u00e8ne \u00e0 une deuxi\u00e8me version, en concevant un **g\u00e9n\u00e9rateur** pour le calcul, qui est pass\u00e9 \u00e0 `FuncAnimation` comme param\u00e8tre `frames`."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["##### Version non interactive, mais avec s\u00e9paration calcul / affichage"]}, {"block": 25, "type": "code", "linesLength": 41, "startIndex": 103, "lines": ["import numpy as np\n", "from matplotlib import pyplot as plt\n", "from matplotlib import animation\n", "\n", "figure2 = plt.figure(figsize=(4, 2))\n", "ax2 = plt.axes(xlim=(0, 2), ylim=(-1.5, 1.5))\n", "line2, = ax2.plot([], [], linewidth=2)\n", "\n", "# la vitesse de d\u00e9filement\n", "speed = 1\n", "\n", "# remarquez qu'on n'a plus besoin de globale ici\n", "# une locale dans le g\u00e9n\u00e9rateur est bien plus propre\n", "\n", "# la logique du calcul est con\u00e7ue comme un g\u00e9n\u00e9rateur\n", "def compute():\n", "    offset = 0.\n", "    # nous sommes dans un g\u00e9n\u00e9rateur, il n'y a pas \n", "    # de contrindication \u00e0 tourner ind\u00e9finiment\n", "    while True:\n", "        offset += speed / 100\n", "        x = np.linspace(0, 2, 1000)\n", "        y = np.sin(2 * np.pi * (x - offset))\n", "        # on d\u00e9cide de retourner un tuple X, Y\n", "        # qui est pass\u00e9 tel-quel \u00e0 l'affichage\n", "        yield x, y \n", "\n", "# la fonction qui affiche\n", "def display(frame):\n", "    # on retrouve nos deux \u00e9l\u00e9ments x et y\n", "    x, y = frame\n", "    # il n'y a plus qu'\u00e0 les afficher\n", "    line2.set_data(x, y)\n", "    return line2,\n", "\n", "\n", "anim = animation.FuncAnimation(figure2,\n", "                               func=display,\n", "                               frames=compute(),\n", "                               interval=40, blit=True)\n", "plt.show()"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["Cette fois l'animation ne se termine jamais, mais dans le notebook vous pouvez cliquer le bouton bleu en haut \u00e0 droite de la figure pour la faire cesser."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 145, "lines": ["### Avec interactivit\u00e9"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 146, "lines": ["Pour rendre ceci interactif, nous allons simplement ajouter un widget qui nous permettra de r\u00e9gler la vitesse de d\u00e9filement. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["##### Version interactive avec widget pour choisir la vitesse"]}, {"block": 30, "type": "code", "linesLength": 44, "startIndex": 148, "lines": ["import numpy as np\n", "from matplotlib import pyplot as plt\n", "from matplotlib import animation\n", "\n", "from IPython.display import display as display_widget\n", "from ipywidgets import IntSlider\n", "\n", "figure3 = plt.figure(figsize=(4, 2))\n", "ax3 = plt.axes(xlim=(0, 2), ylim=(-1.5, 1.5))\n", "line3, = ax3.plot([], [], linewidth=2)\n", "\n", "# un widget pour choisir la vitesse de d\u00e9filement\n", "speed_slider = IntSlider(min=1, max=10, value=3,\n", "                         description=\"Vitesse:\")\n", "\n", "def compute():\n", "    offset = 0.\n", "    # nous sommes dans un g\u00e9n\u00e9rateur, il n'y a pas \n", "    # de contrindication \u00e0 tourner ind\u00e9finiment\n", "    while True:\n", "        # on acc\u00e8de \u00e0 la vitesse via le widget\n", "        offset += speed_slider.value / 100\n", "        x = np.linspace(0, 2, 1000)\n", "        y = np.sin(2 * np.pi * (x - offset))\n", "        # on d\u00e9cide de retourner un tuple X, Y\n", "        # qui est pass\u00e9 tel-quel \u00e0 l'affichage\n", "        yield x, y \n", "\n", "# la fonction qui affiche\n", "def display(frame):\n", "    # on retrouve nos deux \u00e9l\u00e9ments x et y\n", "    x, y = frame\n", "    # il n'y a plus qu'\u00e0 les afficher\n", "    line3.set_data(x, y)\n", "    return line3,\n", "\n", "\n", "anim = animation.FuncAnimation(figure3,\n", "                               func=display,\n", "                               frames=compute(),\n", "                               interval=40, blit=True)\n", "\n", "display_widget(speed_slider)\n", "plt.show()"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 192, "lines": ["### Conclusion"]}, {"block": 32, "type": "markdown", "linesLength": 10, "startIndex": 193, "lines": ["Avec une approche de programmation plus traditionnelle, on pourrait penser avoir besoin de recourir \u00e0 plusieurs *threads* pour impl\u00e9menter ce genre de visualisation interactive.\n", "\n", "En effet, vous remarquerez que dans cette derni\u00e8re version, en termes de parall\u00e8lisme, on peut avoir l'impression que 3 choses ont lieu principalement en m\u00eame temps\u00a0:\n", "* la logique de calcul, qui en substance est d\u00e9crite comme un unique `while True:`,\n", "* la logique d'affichage, qui est cadenc\u00e9e par `FuncAnimation`,\n", "* et la logique interactive, qui g\u00e8re le widget sur interaction de l'utilisateur.\n", "\n", "Le point \u00e0 retenir ici est que, gr\u00e2ce \u00e0 la fois au g\u00e9n\u00e9rateur et au notebook, on n'a pas du tout besoin de g\u00e9rer soi-m\u00eame cet aspect de programmation parall\u00e8le.\n", "\n", "Nous verrons d'ailleurs dans la semaine suivante comment le paradigme de programmation asynchrone de Python a \u00e9t\u00e9 b\u00e2ti, au dessus de cette capacit\u00e9 qu'offre le g\u00e9n\u00e9rateur, pour utiliser ce type d'approche de mani\u00e8re syst\u00e9matique, afin de faire tourner dans un seul *thread* et de mani\u00e8re transparente, un grand nombre de logiques."]}, {"block": 33, "type": "markdown", "linesLength": 5, "startIndex": 203, "lines": ["### Pour en savoir plus\n", "\n", "Voyez\u00a0: \n", "* [la documentation du module `animation`](https://matplotlib.org/api/animation_api.html),\n", "* ainsi que [le tutoriel dont on s'est inspir\u00e9 pour ce notebook](https://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/), surtout pour voir d'autres animations plus \u00e9labor\u00e9es."]}]
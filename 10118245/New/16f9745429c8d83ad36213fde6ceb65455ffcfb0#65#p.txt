[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout,<img src=\"media/inria-25.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# It\u00e9rable et it\u00e9rateur"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Nous r\u00e9sumons dans ce compl\u00e9ment les notions d'it\u00e9rable et d'it\u00e9rateur."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### It\u00e9rable"]}, {"block": 5, "type": "markdown", "linesLength": 7, "startIndex": 5, "lines": ["On appelle **it\u00e9rable** un objet qui peut \u00eatre **l'objet d'une boucle `for`**\n", "\n", "Pour qu'un objet soit it\u00e9rable il faut  \n", " * qu'il dispose d'une m\u00e9thode `__iter__()` qui renvoie un **it\u00e9rateur**\n", " * ou qu'il dispose d'une m\u00e9thode `__getitem__()` qui permette un acc\u00e8s s\u00e9quentiel par des indices commen\u00e7ant \u00e0 0. \n", "    \n", "Le second point s'applique \u00e0 quelques types builtin comme `str` (qui donc n'a pas de m\u00e9thode `__iter__()`), mais en r\u00e8gle g\u00e9n\u00e9rale on est dans le premier cas, et nous y reviendrons en semaine 6 lorsque nous verrons comment rendre nos objets it\u00e9rables."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["### It\u00e9rateur"]}, {"block": 7, "type": "markdown", "linesLength": 5, "startIndex": 13, "lines": ["Un it\u00e9rateur est donc **attach\u00e9 \u00e0 un it\u00e9rable**, et sa fonction est de **m\u00e9moriser l'\u00e9tat d'une it\u00e9ration** sur cet it\u00e9rable.\n", "\n", "La fa\u00e7on usuelle d'impl\u00e9menter un it\u00e9rable consiste \u00e0 exposer une m\u00e9thode `next()` qui renvoie l'item suivant \u00e0 balayer lors de l'it\u00e9ration, et qui l\u00e8ve l'exception `StopIteration` si on se trouve en fin de boucle.\n", "\n", "Notez qu'en python3 on a renomm\u00e9 `next` en `__next__`, ce qui est plus en accord avec la convention de nommage des m\u00e9thodes qui permettent de red\u00e9finir le comportement du langage sur des types utilisateur."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["### R\u00e9sum\u00e9"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": [" * Pour pouvoir faire une boucle `for` sur un objet `spam`, il faut que `spam` soit **it\u00e9rable**, c'est-\u00e0-dire que `spam` a une m\u00e9thode`__iter__()` qui renvoie un it\u00e9rateur; l'**it\u00e9rateur** doit impl\u00e9menter une m\u00e9thode `next()` qui renvoie l'\u00e9l\u00e9ment suivant dans la boucle ou l\u00e8ve l'exception `StopIteration` s'il n'y a plus d'\u00e9l\u00e9ments \u00e0 renvoyer. "]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": [" * L'**it\u00e9rateur** est l'objet en charge de conserver l'\u00e9tat de la boucle sur l'it\u00e9rable, mais rien n'emp\u00eache un objet d'\u00eatre son propre it\u00e9rateur. Cependant, lorsqu'on fait ce choix, il n'est pas possible - comme on le verra plus tard - d'\u00e9crire deux boucles imbriqu\u00e9es sur le m\u00eame objet, puisqu'on ne dispose que d'un seul it\u00e9rateur pour m\u00e9moriser l'\u00e9tat de deux boucles.  C'est pourquoi les types *builtin* it\u00e9rables ont tous leurs it\u00e9rateurs impl\u00e9ment\u00e9s sous la forme d'un objet distinct (sauf, comme on le verra bient\u00f4t, dans le cas des fichiers)."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 22, "lines": ["Pour terminer, signalons que pour rendre tout le mod\u00e8le clos, on d\u00e9cide par convention qu'un **it\u00e9rateur** doit toujours pouvoir **\u00eatre utilis\u00e9 comme un it\u00e9rable** - dit plus simplement, on peut faire une boucle sur un it\u00e9rable ou sur son it\u00e9rateur.\n", "\n", "Pour la coh\u00e9rence de l'ensemble on d\u00e9cide donc qu'un it\u00e9rateur, dans le cas o\u00f9 il est un objet distinct de l'it\u00e9rable, doit \u00e9galement impl\u00e9menter la m\u00e9thode `__iter__()` qui retourne l'it\u00e9rateur lui-m\u00eame. "]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Voyons tout ceci sur un exemple simple"]}, {"block": 14, "type": "code", "linesLength": 7, "startIndex": 26, "lines": ["iterable = range(2)\n", "\n", "# on calcule un it\u00e9rateur pour la liste\n", "iterator = iterable.__iter__()\n", "\n", "# ce n'est pas l'objet liste lui m\u00eame\n", "print iterator is iterable"]}, {"block": 15, "type": "code", "linesLength": 4, "startIndex": 33, "lines": ["# v\u00e9rifions si cet it\u00e9rateur est it\u00e9rable:\n", "# il a une m\u00e9thode __iter__() \n", "# et il se trouve qu'elle renvoie bien l'iterateur lui-m\u00eame\n", "print iterator.__iter__() is iterator"]}, {"block": 16, "type": "code", "linesLength": 8, "startIndex": 37, "lines": ["# l'it\u00e9rateur est bien it\u00e9rable;\n", "# ce qui fait qu'on peut aussi bien faire une boucle sur l'iterable lui-m\u00eame\n", "for i in iterable:\n", "    print 'iterable', i\n", "\n", "# que sur l'iterateur\n", "for i in iterator:\n", "    print 'iterator', i"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Il y a une diff\u00e9rence de taille toutefois, c'est qu'\u00e0 chaque fois qu'on fait une boucle sur l'it\u00e9rable on rappelle `__iter__()`, ce qui a pour r\u00e9sultat de cr\u00e9er un nouvel it\u00e9rateur:"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 46, "lines": ["# on peut imbriquer deux boucles sur la liste - l'it\u00e9rable \n", "for i in iterable:\n", "    for j in iterable:\n", "        print 'iterable', i, 'x', j"]}, {"block": 19, "type": "code", "linesLength": 6, "startIndex": 50, "lines": ["# si on fait la m\u00eame chose avec un iterateur\n", "# que l'on cr\u00e9e \u00e0 la main, on a une mauvaise surprise\n", "iterator = iterable.__iter__()\n", "for i in iterator:\n", "    for j in iterator:\n", "        print 'iterator', i, 'x', j        "]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["En fait, l'iterateur a \u00e9t\u00e9 mis \u00e0 contribution deux fois et a signal\u00e9 la fin de la boucle."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["##### \u00c9pilogue"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Tous ces exemples visent uniquement \u00e0 d\u00e9cortiquer en profondeur le fonctionnement de la boucle `for` et des it\u00e9rateurs."]}, {"block": 23, "type": "markdown", "linesLength": 9, "startIndex": 59, "lines": ["En pratique, **on n'appelle pas soi-m\u00eame** `__iter__()`, c'est la boucle `for`, par exemple, qui cr\u00e9e l'it\u00e9rateur. \n", "\n", "Dans l'exemple \n", "\n", "    for i in iterable:\n", "        for j in iterable:\n", "            print 'iterable', i, 'x', j\n", "\n", "les deux boucles `for` cr\u00e9ent chacune leur it\u00e9rateur, un pour `i` et un pour `j`, on n'a besoin de s'occuper de rien et tout fonctionne comme souhait\u00e9."]}]
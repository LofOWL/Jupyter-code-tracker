[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Les fichiers"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Voici quelques utilisations habituelles du type `file` en python"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Avec un *context manager*"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["Nous avons vu dans la vid\u00e9o les m\u00e9canismes de base sur les fichiers. Nous avons vu notamment qu'il est important de bien fermer un fichier apr\u00e8s usage. Dans la pratique, il est recommand\u00e9 de **toujours** utiliser l'instruction `with`, que nous approfondirons en semaine 6. Il est donc recommand\u00e9 de faire:"]}, {"block": 6, "type": "code", "linesLength": 4, "startIndex": 6, "lines": ["# avec un `with' on garantit la fermeture du fichier\n", "with open(\"s1.txt\", \"w\") as sortie:\n", "    for i in range(2):\n", "        sortie.write(\"{}\\n\".format(i))"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Cette premi\u00e8re forme avec `with` pr\u00e9sente le gros avantage de **garantir** que le fichier sera **bien ferm\u00e9**, et cela m\u00eame si une exception devait \u00eatre lev\u00e9e \u00e0 l'int\u00e9rieur du bloc `with`. "]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["La clause `with` est donc pr\u00e9f\u00e9rable \u00e0 l'utilisation des fonctions de bas niveau sur les fichiers, comme par exemple:"]}, {"block": 9, "type": "code", "linesLength": 5, "startIndex": 12, "lines": ["# la m\u00e9thode \"de bas niveau\" n'est pas recommand\u00e9e \n", "sortie = open(\"s1.txt\", \"w\")\n", "for i in range(2):\n", "    sortie.write(\"{}\\n\".format(i))\n", "sortie.close()"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["qui est moins lisible, et plus fragile, car ici le fichier ne sera pas ferm\u00e9 si une exception se produit dans l'appel \u00e0 `write`."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["### Les modes d'ouverture"]}, {"block": 12, "type": "markdown", "linesLength": 4, "startIndex": 19, "lines": ["Les modes d'ouverture les plus utilis\u00e9s sont\n", " * `'r'` (la cha\u00eene contenant l'unique caract\u00e8re `r`) pour ouvrir un fichier en lecture seulement;\n", " * `'w'` en \u00e9criture seulement; le contenu pr\u00e9c\u00e9dent du fichier, s'il existait, est perdu;\n", " * `'a'` en \u00e9criture seulement, mais pour ajouter du contenu en fin de fichier.\n"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Voici par exemple comment on pourrait ajouter deux lignes de texte dans le fichier `s1.txt` qui contient, \u00e0 ce stade du notebook, 2 entiers:"]}, {"block": 14, "type": "code", "linesLength": 4, "startIndex": 24, "lines": ["# on ouvre le fichier en mode 'a' comme append (= ajouter)\n", "with open(\"s1.txt\", \"a\") as sortie:\n", "    for i in range(100, 102):\n", "        sortie.write(\"{}\\n\".format(i))"]}, {"block": 15, "type": "code", "linesLength": 5, "startIndex": 28, "lines": ["# maintenant on regarde ce que contient le fichier\n", "with open(\"s1.txt\") as entree: # remarquez que sans 'mode', on ouvre en lecture seule\n", "    for line in entree:\n", "        # line contient d\u00e9j\u00e0 un newline\n", "        print(line, end='')"]}, {"block": 16, "type": "markdown", "linesLength": 5, "startIndex": 33, "lines": ["Il existe de nombreuses variantes au mode d'ouverture, pour par exemple:\n", " * ouvrir le fichier en lecture *et* en \u00e9criture (mode `+`),\n", " * ouvrir le fichier en mode binaire (mode `b`), nous y revenons un peu plus bas.\n", "\n", "Ces variantes sont d\u00e9crites dans [la section sur la fonction built-in `open`](https://docs.python.org/3/library/functions.html#open) dans la documentation python."]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["### Comment lire un contenu (haut niveau)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Les fichiers textuels classiques se lisent en g\u00e9n\u00e9ral, comme on vient d'ailleurs de le faire, avec une **simple boucle `for` sur l'objet fichier**, qui it\u00e8re sur les lignes du fichier. Cette m\u00e9thode est **recommand\u00e9e** car elle est **efficace**, et n'implique pas notamment de charger l'int\u00e9gralit\u00e9 du fichier en m\u00e9moire."]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["On trouve aussi, dans du code plus ancien, l'appel \u00e0 la m\u00e9thode `readlines` qui renvoie une liste de lignes:"]}, {"block": 20, "type": "code", "linesLength": 4, "startIndex": 41, "lines": ["# il faut \u00e9viter cette forme qu'on peut trouver dans du code ancien\n", "with open(\"s1.txt\") as entree:\n", "    for line in entree.readlines():\n", "        print(line, end='')"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Vous remarquerez cependant que cette m\u00e9thode implique de **charger l'int\u00e9gralit\u00e9** du fichier en m\u00e9moire. Similairement \u00e0 la discussion que nous avons eue en fin de semaine 3 sur les it\u00e9rateurs et la performance xxx pas s\u00fbr qu'on va la conserver xxx, ici aussi l'utilisation du fichier comme un it\u00e9rateur est de loin pr\u00e9f\u00e9rable."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["### Un fichier est un it\u00e9rateur"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Pendant que l'on parle d'it\u00e9rateur, remarquons qu'un fichier - qui donc **est it\u00e9rable** puisqu'on peut le lire par une boucle `for` - est aussi **son propre it\u00e9rateur**:"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["# un fichier est son propre it\u00e9rateur"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 50, "lines": ["with open(\"s1.txt\") as entree:\n", "    print(entree.__iter__() is entree)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["Dans le prolongement de la discussion sur les it\u00e9rateurs et les it\u00e9rables en fin de semaine 3, nous vous rappelons que tous les autres types de base que nous avons vus jusqu'ici ont leur it\u00e9rateurs impl\u00e9ment\u00e9s comme des objets s\u00e9par\u00e9s. Nous avions \u00e0 l'\u00e9poque soulign\u00e9 que ce choix permettait notamment de r\u00e9aliser deux boucles imbriqu\u00e9es sur la m\u00eame liste."]}, {"block": 28, "type": "code", "linesLength": 5, "startIndex": 53, "lines": ["# deux boucles imbriqu\u00e9es sur la m\u00eame liste fonctionnent comme attendu\n", "liste = [1, 2]\n", "for i in liste:\n", "    for j in liste:\n", "        print(i, \"x\", j)"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Par contre, \u00e9crire deux boucles `for` imbriqu\u00e9es sur **le m\u00eame objet fichier** ne **fonctionnerait pas** comme on pourrait s'y attendre :"]}, {"block": 30, "type": "code", "linesLength": 10, "startIndex": 59, "lines": ["# Si on essaie d'\u00e9crire deux boucles imbriqu\u00e9es\n", "# sur le m\u00eame objet fichier, le r\u00e9sultat est inattendu\n", "with open(\"s1.txt\") as entree:\n", "    for l1 in entree:\n", "        # on enleve les fins de ligne\n", "        l1 = l1.strip()\n", "        for l2 in entree:\n", "            # on enleve les fins de ligne\n", "            l2 = l2.strip()\n", "            print(l1, \"x\", l2)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["### Autres m\u00e9thodes"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Vous pouvez \u00e9galement acc\u00e9der \u00e0 des fonctions de beaucoup plus bas niveau, notamment celle fournies directement par le syst\u00e8me d'exploitation; nous allons en d\u00e9crire deux parmi les plus utiles."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["##### Digression - `repr()`"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Comme nous allons utiliser maintenant des outils d'assez bas niveau pour lire du texte, aussi pour examiner ce texte nous allons utiliser la fonction `repr()`, et voici pourquoi:"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 74, "lines": ["# construisons \u00e0 la main une chaine qui contient deux lignes\n", "lines = \"abc\"+ \"\\n\" + \"def\"  + \"\\n\""]}, {"block": 37, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["# si on l'imprime on voit bien les newline\n", "# d'ailleurs on sait qu'il n'est pas utile \n", "# d'ajouter un newline \u00e0 la fin\n", "print(lines, end=\"\")"]}, {"block": 38, "type": "code", "linesLength": 3, "startIndex": 80, "lines": ["# v\u00e9rifions que repr() nous permet de bien\n", "# voir le contenu de cette chaine\n", "print(repr(lines))"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["##### Lire un contenu - bas niveau"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["Revenons aux fichiers; la m\u00e9thode `read()` permet de lire dans le fichier un buffer d'une certaine taille:"]}, {"block": 41, "type": "code", "linesLength": 4, "startIndex": 85, "lines": ["# lire dans le fichier deux blocs de 4 caract\u00e8res\n", "with open(\"s1.txt\") as entree:\n", "    for bloc in range(2):\n", "        print(\"Bloc {} >>{}<<\".format(bloc, repr(entree.read(4))))"]}, {"block": 42, "type": "markdown", "linesLength": 6, "startIndex": 89, "lines": ["On voit donc que chaque bloc contient bien 4 caract\u00e8res en comptant les sauts de ligne\n", "\n", "| bloc # | contenu |\n", "|--------|---------|\n", "| 0 | un `0`, un `1`, deux *newline* |\n", "| 1 | un `1`, deux `0`, un *newline* |\n"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["Toujours avec la m\u00e9thode `read`, mais cette fois sans argument, on peut lire tout le fichier d'un coup. L\u00e0 encore prenez garde \u00e0 l'utilisation de la m\u00e9moire, c'est une technique utilisable pour des petits fichiers, mais si vous utilisez ceci avec un fichier de plusieurs giga-octets votre OS risque de commencer \u00e0 ne pas \u00eatre content:"]}, {"block": 44, "type": "code", "linesLength": 4, "startIndex": 96, "lines": ["# avec read() sans argument on lit tout le contenu d'un seul coup\n", "with open(\"s1.txt\") as entree:\n", "    contenu = entree.read()\n", "    print(repr(contenu))"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["##### La m\u00e9thode `flush`"]}, {"block": 46, "type": "markdown", "linesLength": 3, "startIndex": 101, "lines": ["Les entr\u00e9es-sortie sur fichier sont bien souvent *bufferis\u00e9es* par le syst\u00e8me d'exploitation. Cela signifie qu'un appel \u00e0 `write` ne provoque pas forc\u00e9ment une \u00e9criture imm\u00e9diate, car pour des raisons de performance on attend d'avoir suffisamment de mati\u00e8re avant d'\u00e9crire sur le disque.\n", "\n", "Il y a des cas o\u00f9 ce comportement peut s'av\u00e9rer g\u00eanant, et o\u00f9 on a besoin d'\u00e9crire imm\u00e9diatement (et donc de vider le *buffer*), et c'est le propos de la m\u00e9thode `flush`()."]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["### Fichiers textuels et fichiers binaires"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["De la m\u00eame fa\u00e7on que le langage propose les deux types `str` et `bytes`, il est possible d'ouvrir un fichier en mode *textuel* ou en mode *binaire*. "]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["Les fichiers que nous avons vus jusqu'ici \u00e9taient ouverts en mode *textuel* (c'est le d\u00e9faut), et c'est pourquoi quand nous avons interagi avec eux avec des objets de type `str`:"]}, {"block": 50, "type": "code", "linesLength": 4, "startIndex": 107, "lines": ["# un fichier ouvert en mode textuel nous donne des str\n", "with open('s1.txt') as input:\n", "    for line in input:\n", "        print(\"on a lu un objet de type\", type(line))"]}, {"block": 51, "type": "markdown", "linesLength": 3, "startIndex": 111, "lines": ["Lorsque ce n'est pas le comportement souhait\u00e9, on peut \n", "* ouvrir le fichier en mode *binaire* - pour cela on ajoute le caract\u00e8re `b` au mode d'ouverture\n", "* et on peut alors interagir avec le fichier avec des objets de type `bytes`"]}, {"block": 52, "type": "markdown", "linesLength": 3, "startIndex": 114, "lines": ["Pour illustrer ce trait, nous allons:\n", "1. cr\u00e9er un fichier en mode texte, et y ins\u00e9rer du texte en UTF-8\n", "1. relire le fichier en mode binaire, et retrouver le codage des diff\u00e9rents caract\u00e8res."]}, {"block": 53, "type": "code", "linesLength": 7, "startIndex": 117, "lines": ["# phase 1 : on \u00e9crit un fichier avec du texte en UTF-8\n", "# on ouvre le donc le fichier en mode texte\n", "# en toute rigueur il faut pr\u00e9ciser l'encodage, \n", "# si on ne le fait pas il sera d\u00e9termin\u00e9 \n", "# \u00e0 partir de vos r\u00e9glages syst\u00e8me\n", "with open('strbytes', 'w', encoding='utf-8') as output:\n", "    output.write(\"d\u00e9j\u00e0 l'\u00e9t\u00e9\\n\")"]}, {"block": 54, "type": "code", "linesLength": 9, "startIndex": 124, "lines": ["# phase 2: on rouvre le fichier en mode binaire\n", "with open('strbytes', 'rb') as rawinput:\n", "    # on relit tout le contenu\n", "    octets = rawinput.read()\n", "    # qui est de type bytes\n", "    print(\"on a lu un objet de type\", type(octets))\n", "    # si on regarde chaque octet un par un\n", "    for i, octet in enumerate(octets):\n", "        print(\"{} \u2192 {} [{}]\".format(i, repr(chr(octet)), hex(octet)))"]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 133, "lines": ["Vous retrouvez ainsi le fait que l'unique caract\u00e8re unicode \"\u00e9\", a \u00e9t\u00e9 encod\u00e9 par UTF-8 sous la forme de deux octets de code hexad\u00e9cimal `0xc3` et `0xa9`."]}, {"block": 56, "type": "markdown", "linesLength": 3, "startIndex": 134, "lines": ["Vous pouvez \u00e9galement consulter ce site qui visualise l'encodage UTF-8, avec notre s\u00e9quence d'entr\u00e9e\n", "\n", "https://mothereff.in/utf-8#d%C3%A9j%C3%A0%20l%27%C3%A9t%C3%A9%0A"]}, {"block": 57, "type": "code", "linesLength": 5, "startIndex": 137, "lines": ["# on peut comperer le nombre d'octets et le nombre de caract\u00e8res\n", "with open('strbytes') as textfile:\n", "    print(\"en mode texte, {} caract\u00e8res\".format(len(textfile.read())))\n", "with open('strbytes', 'rb') as binfile:\n", "    print(\"en mode binaire, {} octets\".format(len(binfile.read())))"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 142, "lines": ["Ce qui correpond au fait que nos 4 caract\u00e8res non-ASCII (3 `\u00e9` et 1 `\u00e0`) sont tous encod\u00e9s par UTF-8 comme 2 octets, comme vous pouvez vous en assurer [ici pour `\u00e9`](https://mothereff.in/utf-8#%C3%A9) et [l\u00e0 pour `\u00e0`](https://mothereff.in/utf-8#%C3%A0)."]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["### Pour en savoir plus"]}, {"block": 60, "type": "markdown", "linesLength": 3, "startIndex": 144, "lines": ["Pour une description plus exhaustive vous pouvez vous reporter \u00e0\n", "* au [glossaire sur la notion de `object file`](https://docs.python.org/3/glossary.html#term-file-object),\n", "* et aussi et surtout [au module `io`](https://docs.python.org/3/library/io.html#module-io) qui d\u00e9crit plus en d\u00e9tails les fonctionnalit\u00e9s disponibles."]}]
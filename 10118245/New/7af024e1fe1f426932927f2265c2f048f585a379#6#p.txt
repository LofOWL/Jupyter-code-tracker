[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Divers"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 2, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Pour finir notre introduction \u00e0 `numpy`, nous allons survoler \u00e0 tr\u00e8s grande vitesse quelques traits plus annexes mais qui peuvent \u00eatre utiles. Je vous laisse approfondir de votre cot\u00e9 les parties qui vous int\u00e9ressent."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### R\u00e9f\u00e9rences crois\u00e9es, shallow et deep copies"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 8, "lines": ["Pour r\u00e9sumer ce qu'on a vu jusqu'ici\u00a0:\n", "* un tableau numpy est un objet mutable,\n", "* une slice sur un tableau retourne une vue, on est donc dans le cas d'une r\u00e9f\u00e9rence partag\u00e9e,\n", "* dans tous les cas qu'on a vus jusqu'ici, comme les cases des tableaux sont des objets atomiques, il n'y a pas de diff\u00e9rence entre *shallow* et *deep* copie,\n", "* pour cr\u00e9er une copie, utilisez `np.copy()`."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Et de plus\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 14, "lines": ["# un tableau de base\n", "a = np.arange(3)"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 16, "lines": ["# une vue\n", "v = a.view()"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["# une slice\n", "s = a[:]"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Les deux objets ne sont pas diff\u00e9rentiables\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["v.base is a"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 22, "lines": ["s.base is a"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### L'option `out=`"]}, {"block": 14, "type": "code", "linesLength": 4, "startIndex": 24, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Lorsqu'on fait du calcul vectoriel, on peut avoir tendance \u00e0 cr\u00e9er de nombreux tableaux interm\u00e9diaires qui co\u00fbtent cher en m\u00e9moire. Pour cette raison, presque tous les op\u00e9rateurs `numpy` proposent un param\u00e8tre optionnel `out=` qui permet de sp\u00e9cifier un tableau d\u00e9j\u00e0 allou\u00e9, dans lequel ranger le r\u00e9sultat."]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Prenons l'exemple un peu factice suivant, ou on calcule $e^{sin(cos(x))}$ sur l'intervalle $[0, 2\\pi]$"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["# le domaine\n", "X = np.linspace(0, 2*np.pi)"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["Y = np.exp(np.sin(np.cos(X)))\n", "plt.plot(X, Y);"]}, {"block": 19, "type": "code", "linesLength": 7, "startIndex": 34, "lines": ["# chaque fonction alloue un tableau pour ranger ses r\u00e9sultats,\n", "# et si je d\u00e9compose, ce qui se passe en fait c'est ceci\n", "# en tout en comptant X et Y j'aurai cr\u00e9\u00e9 4 tableaux \n", "Y1 = np.cos(X)\n", "Y2 = np.sin(Y1)\n", "Y3 = np.exp(Y2)\n", "plt.plot(X, Y3);"]}, {"block": 20, "type": "code", "linesLength": 10, "startIndex": 41, "lines": ["# Mais moi je sais qu'en fait je n'ai besoin que de X et de Y\n", "# ce qui fait que je peux optimiser comme ceci\n", "\n", "# je ne peux pas r\u00e9crire sur X parce que j'en aurai besoin pour le plot\n", "X1 = np.cos(X)\n", "# par contre ici je peux recycler X1 sans souci\n", "np.sin(X1, out=X1)\n", "# etc ...\n", "np.exp(X1, out=X1)\n", "plt.plot(X, X1);"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Et avec cette approche je n'ai cr\u00e9\u00e9 que 2 tableaux en tout."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["**Notez-bien** je ne vous recommande pas d'utiliser ceci syst\u00e9matiquement, car \u00e7a d\u00e9figure nettement le code. Mais il faut savoir que \u00e7a existe, et savoir y penser lorsque la cr\u00e9ation de tableaux interm\u00e9diaires a un co\u00fbt important dans l'algorithme."]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["### `np.add` et similaires"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Si vous vous mettez \u00e0 optimiser de cette fa\u00e7ons, vous utiliserez par exemple `np.add` plut\u00f4t que `+`, qui ne vous permet pas de choisir la destination du r\u00e9sultat."]}]
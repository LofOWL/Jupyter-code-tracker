[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `Series` en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Cr\u00e9ation d'une Series"]}, {"block": 4, "type": "markdown", "linesLength": 6, "startIndex": 9, "lines": ["Une Series est un tableau numpy \u00e0 une dimension avec un index, par\n", "cons\u00e9quent, une Series a une certaine similarit\u00e9 avec un dictionnaire\n", "et peut d'ailleurs \u00eatre directement construite \u00e0 partir de ce\n", "dictionnaire. Notons que comme pour un dictionnaire, l'acc\u00e8s ou la\n", "modification est en O(1), c'est-\u00e0-dire \u00e0 temps constant ind\u00e9pendamment\n", "du nombre d'\u00e9l\u00e9ments dans la Series. "]}, {"block": 5, "type": "code", "linesLength": 21, "startIndex": 15, "lines": ["# Regardons la construction d'une Series\n", "import numpy as np\n", "import pandas as pd\n", "\n", "# \u00e0 partir d'un it\u00e9rable\n", "s = pd.Series([x**2 for x in range(10)])\n", "print(s)\n", "\n", "# en contr\u00f4lant maitenant le type\n", "s = pd.Series([x**2 for x in range(10)], dtype='int8')\n", "print(s)\n", "\n", "# en d\u00e9finissant un index, par d\u00e9faut l'index est un rang d\u00e9marrant \u00e0 0\n", "s = pd.Series([x**2 for x in range(10)], dtype='int8', index=[x for x in 'abcdefghij'])\n", "print(s)\n", "\n", "# et directement \u00e0 partir d'un dictionnaire, les clefs forment l'index\n", "d = {k:v**2 for k, v in zip('abcdefghij', range(10))}\n", "print(d)\n", "s = pd.Series(d, dtype='int8')\n", "print(s)"]}, {"block": 6, "type": "markdown", "linesLength": 2, "startIndex": 36, "lines": ["\u00c9videmment, l'int\u00e9r\u00eat d'un index est de pouvoir acc\u00e9der \u00e0 un \u00e9l\u00e9ment\n", "par son index, mais nous allons bient\u00f4t largement revenir dessus."]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 38, "lines": ["print(s['c'])"]}, {"block": 8, "type": "markdown", "linesLength": 5, "startIndex": 39, "lines": ["L'index d'une Series est un objet impl\u00e9ment\u00e9 sous la forme d'un\n", "ndarray numpy, mais qui ne peut contenir que des objets hashable (pour\n", "garantir la performance de l'acc\u00e8s). L'index va \u00e9galement supporter un\n", "certain nombre de m\u00e9thodes qui vont faciliter son utilisation. Regardez la documentation de l'objet\n", "[Index](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.html#pandas.Index) et de ses sous classes pour plus de d\u00e9tails. \n"]}, {"block": 9, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["# regardons les valeurs de ma Series\n", "print(s.values) # values est un attribut, pas une fonction\n", "\n", "# et l'index\n", "print(s.index) # index est un attribut, pas une fonction"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Mais une Series \u00e0 \u00e9galement une interface de dictionnaire \u00e0 laquelle on acc\u00e8de de la mani\u00e8re suivante"]}, {"block": 11, "type": "code", "linesLength": 14, "startIndex": 50, "lines": ["# les clefs correspondent \u00e0 l'index\n", "print(f\"Les clefs: {s.keys()}\") # attention ici c'est un appel de fonction !\n", "\n", "# et les couples (clefs, valeurs) sous forme d'un objet zip\n", "z = s.items() # attention ici aussi c'est un appel de fonction !\n", "\n", "print(f\"Les items: {z}\")\n", "\n", "for k, v in z:\n", "    print(k, v)\n", "    \n", "# pour finir remarquons que le test d'appartenance est possible sur les index\n", "print(f\"est-ce que a est dans s ? {'a' in s}\")\n", "print(f\"est-ce que z est dans s ? {'z' in s}\")"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 64, "lines": ["Vous remarquez ici qu'alors que `values` et `index` sont des attributs de la Series, `keys()` et `items()` sont des fonctions. Voici un exemple des nombreuses petites inconsistances de pandas avec lesquelles il faut vivre. Notez que lorsque l'on pratique Python, on devient vite exigeant. Pandas le fait pas plus mal que d'autres langages, il fait juste moins bien que Python.\n", "\n", "Il y a cependant, des pi\u00e8ges \u00e0 conna\u00eetre."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["### Pi\u00e8ges \u00e0 \u00e9viter"]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 68, "lines": ["Avant d'aller plus loin, il faut faire attention \u00e0 la gestion du type\n", "des objets contenus dans notre Series (on aura la m\u00eame probl\u00e8me avec\n", "les DataFrame). Alors qu'un ndarray numpy a un type qui ne change pas,\n", "une Series peut implicitement changer le type de ses valeurs lors\n", "d'op\u00e9rations d'affectations. "]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 73, "lines": ["# cr\u00e9ons une series et regardons le type de ses valeurs\n", "s = pd.Series({k:v**2 for k, v in zip('abcdefghij', range(10))})\n", "print(s.values.dtype)"]}, {"block": 16, "type": "code", "linesLength": 7, "startIndex": 76, "lines": ["# On a d\u00e9j\u00e0 vu que l'on ne pouvait pas modifier lors d'une affectation le\n", "# type d'un ndarray numpy\n", "\n", "try:\n", "    s.values[2] = 'spam'\n", "except ValueError as e:\n", "    print(f\"On ne peut pas affecter une str \u00e0 un ndarray de int64:\\n{e}\")"]}, {"block": 17, "type": "code", "linesLength": 5, "startIndex": 83, "lines": ["# Par contre, on peut le faire sur une Series\n", "s['c'] = 'spam'\n", "\n", "# et maintenant le type des valeurs de la series a chang\u00e9\n", "print(s.values.dtype)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["C'est un point extr\u00eament important puisque toutes les op\u00e9rations vectoris\u00e9es vont avoir leur performance impact\u00e9e et le r\u00e9sultat obtenu peut m\u00eame \u00eatre faux. Regardons cela"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 89, "lines": ["s = pd.Series(range(10_000))\n", "print(s.values.dtype)"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 91, "lines": ["# combien de temps prend le calcul du carr\u00e9 des valeurs\n", "%timeit s**2"]}, {"block": 21, "type": "code", "linesLength": 8, "startIndex": 93, "lines": ["# ajoutons 'spam' \u00e0 la fin de la Series\n", "s[10_000] = 'spam'\n", "\n", "# oups, je me suis tromp\u00e9, enlevons cet \u00e9l\u00e9ment\n", "del s[10_000]\n", "\n", "# calculons de nouveau le temps de calcul pour obtenir le carr\u00e9 des valeurs\n", "%timeit s**2"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 101, "lines": ["# que se passe-t-il, pourquoi le calcul est maintenant plus long\n", "s.values.dtype"]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 103, "lines": ["Maintenant, les op\u00e9rations vectoris\u00e9es le sont sur des objets Python et non plus sur des int64, il y a donc un impact sur la performance. \n", "\n", "Mais on peut obtenir un r\u00e9sultat carr\u00e9ment faux. Regardons cela"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 106, "lines": ["# cr\u00e9ons une series de trois entiers\n", "s = pd.Series([1, 2, 3])\n", "print(s)"]}, {"block": 25, "type": "code", "linesLength": 7, "startIndex": 109, "lines": ["# puis ajoutons un nouvel \u00e9l\u00e9ment, mais ici je me trompe, c'est une str\n", "# au lieu d'un entier\n", "s[3] = '4'\n", "\n", "# \u00e0 part le type qui pourrait attirer mon attention, rien dans l'affichage\n", "# ne distingue les entiers de la str\n", "print(s)"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 116, "lines": ["# seulement si j'additionne, les entiers sont additionn\u00e9s, \n", "# mais les cha\u00eenes de caract\u00e8res concat\u00e9n\u00e9es. \n", "print(s+s)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["### Acc\u00e9s aux \u00e9l\u00e9ments d'une Series"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Comme les Series sont bas\u00e9es sur des ndarray numpy, elles supportent les op\u00e9rations d'acc\u00e8s aux \u00e9l\u00e9ments des ndarray, notamment la notion de masque. "]}, {"block": 29, "type": "code", "linesLength": 4, "startIndex": 121, "lines": ["s = pd.Series([30, 35, 20], index=['alice', 'bob', 'julie'])\n", "\n", "# qui a plus de 25 ans\n", "print(s[s>25])"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 125, "lines": ["# regardons uniquement 'alice' et 'julie'\n", "print(s[['alice', 'julie']])"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 127, "lines": ["# et affectons sur un masque\n", "s[s<=25] = np.NaN\n", "print(s)"]}, {"block": 32, "type": "code", "linesLength": 4, "startIndex": 130, "lines": ["# notons \u00e9galement, que naturellement les op\u00e9rations de broacast \n", "# sont support\u00e9es\n", "s = s + 10\n", "print(s)"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["#### Slicing on Series"]}, {"block": 34, "type": "markdown", "linesLength": 9, "startIndex": 135, "lines": ["L'op\u00e9ration de slicing sur les Series est une source fr\u00e9quente d'erreur qui peut passer inaper\u00e7ue pour les raisons suivantes.\n", "\n", " - On peut slicer sur les indexes, mais aussi sur la position d'un \u00e9l\u00e9ment dans la Serie.\n", " - Les op\u00e9rations de slices sur les positions et les indexes se comportent diff\u00e9remment, [un slice sur les positions exclut la borne de droite (comme tous les slices en Python), mais un slice sur l'index inclus la borne de droite](http://pandas.pydata.org/pandas-docs/stable/gotchas.html#endpoints-are-inclusive).\n", " - il peut y avoir ambiguit\u00e9 entre un index et la position d'un \u00e9l\u00e9ment.\n", " \n", "Nous allons d\u00e9tailler chacun de ces cas, mais sachez qu'il existe une solution qui \u00e9vite toute ambig\u00fcit\u00e9, c'est l'interface `loc` et `iloc` que nous allons discuter un peu plus loin.\n", "\n", "Regardons maintenant ces diff\u00e9rents probl\u00e8mes"]}, {"block": 35, "type": "code", "linesLength": 7, "startIndex": 144, "lines": ["s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'julie', 'sonia'])\n", "\n", "# peut acc\u00e9der directement \u00e0 la valeur correspondant \u00e0 alice\n", "print(s['alice'])\n", "\n", "# mais aussi par la position d'alice \n", "print(s[0])"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 151, "lines": ["# On peut faire un slice sur l'index, dans ce cas la borne\n", "# de droite est inclus\n", "s['alice': 'julie']"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 154, "lines": ["# et on peut faire un slice sur les positions, mais dans ce cas \n", "# la borne de droite est exclue, comme un slice normal en Python\n", "s[0:2]"]}, {"block": 38, "type": "markdown", "linesLength": 7, "startIndex": 157, "lines": ["Ce comportement m\u00e9rite quelques explications. On voit bien que dire que la borne de droite est exclue est bien d\u00e9fini pour des positions, mais beaucoup moins intuitif pour un index. \n", "\n", "En effet, l'ordre d'un index est d\u00e9fini au moment de la cr\u00e9ation et la valeur venant juste avant une position dans cet index particulier n'est pas une information qui peut \u00eatre directement d\u00e9duite sans conna\u00eetre le d\u00e9tail de l'index. \n", "\n", "C'est pour cette raison que les concepteurs de pandas ont pr\u00e9f\u00e9r\u00e9 inclure la borne de droite. \n", "\n", "Regardons maintenant plus en d\u00e9tail cette notion d'ordre sur les indexes."]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 164, "lines": ["# Regardons le slice sur un index avec un ordre particulier\n", "s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'julie', 'sonia'])\n", "print(s['alice':'julie'])"]}, {"block": 40, "type": "code", "linesLength": 3, "startIndex": 167, "lines": ["# Si on change l'ordre de l'index, \u00e7a change la signification du slice\n", "s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'sonia', 'julie'])\n", "print(s['alice':'julie'])"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 170, "lines": ["Vous devez peut-\u00eatre vous demander si un slice sur l'index est toujours d\u00e9fini. La r\u00e9ponse est non ! Pour qu'un slice soit d\u00e9fini sur un index, il faut que l'index ait une croissance monotonique ou qu'il n'y ait pas de label dans l'index qui soit dupliqu\u00e9. \n", "\n", "Donc la croissance monotonique n'est pas n\u00e9cessaire tant qu'il n'y a pas de duplication de labels. Regardons cela."]}, {"block": 42, "type": "code", "linesLength": 4, "startIndex": 173, "lines": ["# mon index a des labels dupliqu\u00e9s, mais a une croissance monotonique\n", "s = pd.Series([30, 35, 20, 12], index=['a', 'a', 'b', 'c'])\n", "# le slice est d\u00e9fini\n", "s['a': 'b']"]}, {"block": 43, "type": "code", "linesLength": 7, "startIndex": 177, "lines": ["# mon index a des labels dupliqu\u00e9s et n'a pas de croissance monotonique\n", "s = pd.Series([30, 35, 20, 12], index=['a', 'b', 'c', 'a'])\n", "# le slice n'est d\u00e9fini\n", "try:\n", "    s['a': 'b']\n", "except KeyError as e:\n", "    print(f\"Je n'arrive pas \u00e0 extraire un slice :\\n{e}\")"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Pour finir sur les probl\u00e8mes que l'on peut rencontrer avec les slices, que se passe-t-il si on a un index qui a pour label des entiers ? Lorsque l'on va faire un slice, il va y avoir ambig\u00fcit\u00e9 entre la position du label et le label lui m\u00eame. Dans ce cas, pandas donne la priorit\u00e9 \u00e0 la position, mais ce qui est troublant, c'est que lorsqu'on acc\u00e8de \u00e0 un seul \u00e9l\u00e9ment en dehors d'un slice, pandas donne la priorit\u00e9 \u00e0 l'index. Encore une petite inconsistance. "]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 185, "lines": ["s = pd.Series(['a', 'b', 'c'], index=[2, 0, 1])\n", "print(f\"si on acc\u00e8de diretement \u00e0 un \u00e9l\u00e9ment, priorit\u00e9 au label : {s[0]}\")\n", "print(f\"si on calcul un slice, priorit\u00e9 \u00e0 la position : {s[2:0]}\")"]}, {"block": 46, "type": "markdown", "linesLength": 3, "startIndex": 188, "lines": ["La solution \u00e0 tous ces probl\u00e8mes est de dire explicitement ce que l'on veut faire \u00e0 pandas. On peut en effet dire explicitement si l'on veut utiliser les labels ou les positions, c'est ce qu'on vous recommande de faire pour \u00e9viter les comportements implicites.\n", "\n", "Pour utiliser les labels il faut utiliser `s.loc[]` et pour utiliser les positions if faut utiliser `s.iloc[]` (le `i` est pour localisation implicite, c'est-\u00e0-dire la position). Regardons cela. "]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 191, "lines": ["# acc\u00e8s au label\n", "print(s.loc[0])"]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 193, "lines": ["# acc\u00e8s \u00e0 la position\n", "print(s.iloc[0])"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 195, "lines": ["# slice sur le label, ATTENTION, inclus la borne de droite\n", "print(s.loc[2:0])"]}, {"block": 50, "type": "code", "linesLength": 2, "startIndex": 197, "lines": ["# slice sur les positions, ATTENTION, exclus la borne de droite\n", "print(s.iloc[0:2])"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 199, "lines": ["### Conclusion"]}, {"block": 52, "type": "markdown", "linesLength": 3, "startIndex": 200, "lines": ["Nous avons vu que les Series forment une extension des ndarray de dimension 1 en leur ajoutant un index qui permet une plus grande expressivit\u00e9 pour acc\u00e9der aux \u00e9l\u00e9ments. Seulement cette expressivit\u00e9 vient au prix de quelques subtilit\u00e9s (conversion implicite de type, acc\u00e8s aux labels ou aux positions) qu'il faut maitriser. \n", "\n", "Nous verrons dans le prochain compl\u00e9ment la notion de DataFrame qui est sans doute la plus utile et puissante structure de donn\u00e9es en pandas. Tous les pi\u00e8ges que nous avons vu pour les Series sont valables pour les DataFrames."]}]
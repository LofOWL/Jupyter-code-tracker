[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# H\u00e9ritage, typage"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 2, "lines": ["xxx c'est le fameux morceau de bravoure de la fois pass\u00e9e; est-ce qu'on peut le sauver ou pas ?\n", "\n", "xxx dans l'\u00e9tat il y a de gros probl\u00e8mes de consistence ..."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Dans ce compl\u00e9ment, nous allons revenir sur la notion de *duck typing*, et attirer votre attention sur cette diff\u00e9rence assez essentielle entre python et les langages statiquement typ\u00e9s."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Type concret et type abstrait"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 8, "lines": ["Revenons sur la notion de type et remarquons que les types peuvent jouer plusieurs r\u00f4les, comme on l'a \u00e9voqu\u00e9 rapidement en premi\u00e8re semaine&nbsp;; et pour reprendre des notions standard en langages de programmation nous allons distinguer deux types.\n", " 1. **type concret&nbsp;:** d'une part, la notion de type a bien entendu \u00e0 voir avec l'impl\u00e9mentation&nbsp;; par exemple, un compilateur C a besoin de savoir tr\u00e8s pr\u00e9cis\u00e9ment quel espace allouer \u00e0 une variable, et l'interpr\u00e9teur python sous-traite \u00e0 la classe le soin d'initialiser un objet&nbsp;;\n", " 1. **type abstrait&nbsp;:** d'autre part, les types sont cruciaux dans les syst\u00e8mes de v\u00e9rification statique, au sens large, dont le but est de trouver un maximum de d\u00e9fauts \u00e0 la seule lecture du code (par opposition aux techniques qui n\u00e9cessitent de le faire tourner)."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["### *Duck typing*"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["En python, ces deux aspects du typage sont relativement d\u00e9corr\u00e9l\u00e9s."]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 13, "lines": ["Pour la deuxi\u00e8me dimension du typage, le syst\u00e8me de types abstraits de python est connu sous le nom de [*duck typing*](http://en.wikipedia.org/wiki/Duck_typing), une appellation qui fait r\u00e9f\u00e9rence \u00e0 cette phrase:\n", "\n", "    When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["### L'exemple des it\u00e9rables"]}, {"block": 11, "type": "markdown", "linesLength": 6, "startIndex": 17, "lines": ["Pour prendre l'exemple sans doute le plus repr\u00e9sentatif, la notion d'*it\u00e9rable* est un type abstrait, en ce sens que pour que le fragment:\n", "    \n", "    for item in container:\n", "        do_something(item)\n", "        \n", "ait un sens, il faut et il suffit que `container` soit un it\u00e9rable. Et vous connaissez maintenant plein d'exemples tr\u00e8s diff\u00e9rents d'objets it\u00e9rables, a minima les *builtin* `str`, `list`, `tuple`, et d'autres..."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Dans un langage typ\u00e9 statiquement, pour pouvoir donner un type \u00e0 cette construction, on serait **oblig\u00e9** de d\u00e9finir un type - qu'on appellerait logiquement une classe abstraite - dont ces trois types seraient des descendants."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["En python, et c'est le point que nous voulons souligner dans ce compl\u00e9ment, il n'existe pas dans le syst\u00e8me python d'objet de type `type` qui mat\u00e9rialise ce type `iterable`. Si on regarde les superclasses de nos trois types concrets, on voit que leur seul anc\u00eatre commun est la classe  `object`&nbsp;:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["str.__bases__"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 26, "lines": ["list.__bases__"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["tuple.__bases__"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Un autre exemple"]}, {"block": 18, "type": "markdown", "linesLength": 9, "startIndex": 29, "lines": ["Pour prendre un exemple plus simple, si je consid\u00e8re:\n", "\n", "```\n", "def foo(graphic):\n", "    ...\n", "    graphic.draw()\n", "```\n", "\n", "pour que dans ce fragment l'expression `graphic.draw()` ait un sens, il faut et il suffit que l'objet `graphic` ait une m\u00e9thode `draw`."]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["\u00c0 nouveau, dans un langage typ\u00e9 statiquement, on serait amen\u00e9 \u00e0 d\u00e9finir une classe abstraite `Graphic`. En python ce n'est **pas requis**; vous pouvez utiliser ce code tel quel avec deux classes `Rectangle` et `Texte` qui n'ont pas de rapport entre elles - autres que, \u00e0 nouveau, d'avoir `object` comme anc\u00eatre commun - pourvu qu'elles aient toutes les deux une m\u00e9thode `draw`."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["### H\u00e9ritage et type abstrait"]}, {"block": 21, "type": "markdown", "linesLength": 3, "startIndex": 40, "lines": ["Pour r\u00e9sumer, en python comme dans les langages typ\u00e9s statiquement, on n'a bien entendu la bonne propri\u00e9t\u00e9 que si, par exemple, la classe `Spam` est it\u00e9rable, alors la classe `Eggs` qui h\u00e9rite de `Spam` est it\u00e9rable. \n", "\n", "Mais dans l'autre sens, si `Foo` et `Bar` sont it\u00e9rables, il n'y a pas forc\u00e9ment une superclasse commune qui repr\u00e9sente l'ensemble des objets it\u00e9rables. "]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["### `isinstance` sur st\u00e9ro\u00efdes"]}, {"block": 23, "type": "markdown", "linesLength": 5, "startIndex": 44, "lines": ["D'un autre c\u00f4t\u00e9, c'est tr\u00e8s utile d'exposer au programmeur un moyen de v\u00e9rifier si un objet a un *type* donn\u00e9 - dans un sens volontairement vague ici.\n", "\n", "On a d\u00e9j\u00e0 parl\u00e9 - en Semaine 4, s\u00e9quence \"les fonctions\" - de l'int\u00e9r\u00eat qu'il peut y avoir \u00e0 tester le type d'un argument avec `isinstance` dans une fonction, pour parvenir \u00e0 faire l'\u00e9quivalent de la surcharge en C++ (la surcharge en C++, c'est quand vous d\u00e9finissez plusieurs fonctions qui ont le m\u00eame nom mais des types d'arguments diff\u00e9rents). \n", "\n", "C'est pourquoi, quand on a cherch\u00e9 \u00e0 exposer au programmeur des propri\u00e9t\u00e9s comme \"cet objet est-il iterable ?\", on a choisi d'\u00e9tendre *isinstance* au travers de [cette initiative](http://legacy.python.org/dev/peps/pep-3119/). C'est ainsi qu'on peut faire par exemple&nbsp;:"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["from collections import Iterable"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["isinstance('ab', Iterable)"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 51, "lines": ["isinstance([1, 2], Iterable)"]}, {"block": 27, "type": "code", "linesLength": 12, "startIndex": 52, "lines": ["# comme on l'a vu, un objet qui a des m\u00e9thodes\n", "# __iter__() et __next__() \n", "# est consid\u00e9r\u00e9 comme un it\u00e9rable\n", "class Foo():\n", "    def __iter__(self):\n", "        return self\n", "    def __next__(self):\n", "        # ceci naturellement est bidon\n", "        return \n", "        \n", "foo = Foo()\n", "isinstance(foo, Iterable)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["L'impl\u00e9mentation du module `abc` donne l'**illusion** que `Iterable` est un objet dans la hi\u00e9rarchie de classes, et que tous ces *classes* `str`, `list`, et `Foo` lui sont asujetties, mais ce n'est pas le cas en r\u00e9alit\u00e9; comme on l'a vu plus t\u00f4t, ces trois types ne sont pas comparables dans la hi\u00e9rarchie de classes, ils n'ont pas de plus petit (ou plus grand) \u00e9l\u00e9ment \u00e0 part `object`. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Je signale pour finir, \u00e0 propos de `isinstance` et du module `collections`, que la d\u00e9finition du symbole `Hashable` est \u00e0 mon avis beaucoup moins convaincante que `Iterable`&nbsp;; si vous vous souvenez qu'en Semaine 3, S\u00e9quence \"les dictionnaires\", on avait vu que les cl\u00e9s doivent \u00eatre globalement immuables. C'est une caract\u00e9ristique qui est assez difficile \u00e0 \u00e9crire, et en tous cas ceci de mon point de vue ne remplit pas la fonction&nbsp;:"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["from collections import Hashable"]}, {"block": 31, "type": "code", "linesLength": 4, "startIndex": 67, "lines": ["# un tuple qui contient une liste ne convient \n", "# pas comme cl\u00e9 dans un dictionnaire\n", "# et pourtant\n", "isinstance (([1], [2]), Hashable)"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["### python et les classes abstraites"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["Les points \u00e0 retenir de ce compl\u00e9ment un peu digressif sont&nbsp;:\n", " * en python, on h\u00e9rite des **impl\u00e9mentations** et pas des **sp\u00e9cifications**&nbsp;; \n", " * et le langage n'est pas taill\u00e9 pour tirer profit de **classes abstraites** - m\u00eame si rien ne vous interdit d'\u00e9crire, pour des raisons documentaires, une classe qui r\u00e9sume l'interface qui est attendue par tel ou tel syst\u00e8me de plugin."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Venant de C++ ou de Java, cela peut prendre du temps d'arriver \u00e0 se d\u00e9barrasser de l'esp\u00e8ce de r\u00e9flexe qui fait qu'on pense d'abord classe abstraite, puis impl\u00e9mentations. "]}]
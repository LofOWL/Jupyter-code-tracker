[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Conditions & Expressions Bool\u00e9ennes"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment : niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Nous pr\u00e9sentons rapidement dans ce notebook comment construire la condition qui contr\u00f4le l'ex\u00e9cution d'un `if`"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Tests consid\u00e9r\u00e9s comme vrai"]}, {"block": 5, "type": "markdown", "linesLength": 8, "startIndex": 5, "lines": ["Lorsqu'on \u00e9crit une instuction comme\n", "\n", "    if <expression>:\n", "       <do_something>\n", "    \n", "le r\u00e9sultat de l'expression peut **ne pas \u00eatre un bool\u00e9en**. Pour la plupart des types, il existe des valeurs particuli\u00e8res qui sont consid\u00e9r\u00e9es**comme fausses**. \n", "\n", "Par exemple, pour n'importe quel type num\u00e9rique, la valeur 0 est consid\u00e9r\u00e9e comme fausse. Cela signifie que"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 13, "lines": ["# ici la condition s'\u00e9value \u00e0 0, donc on ne fait rien\n", "if 3 - 3:\n", "    print(\"ne passera pas par l\u00e0\")"]}, {"block": 7, "type": "code", "linesLength": 4, "startIndex": 16, "lines": ["# par contre si vous vous souvenez notre cours sur les flottants\n", "# ici la condition donne un tout petit r\u00e9el mais pas 0.\n", "if 0.1 + 0.2 - 0.3:\n", "    print(\"par contre on passe ici\")"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["De m\u00eame, une cha\u00eene vide, une liste vide, un tuple vide, sont consid\u00e9r\u00e9s comme faux. Bref, vous voyez l'id\u00e9e g\u00e9n\u00e9rale."]}, {"block": 9, "type": "code", "linesLength": 6, "startIndex": 21, "lines": ["if \"\": \n", "    print(\"ne passera pas par l\u00e0\")\n", "if []: \n", "    print(\"ne passera pas par l\u00e0\")\n", "if ():\n", "    print(\"ne passera pas par l\u00e0\")"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Enfin le singleton `None`, que nous verrons bient\u00f4t, est lui aussi consid\u00e9r\u00e9 comme faux. "]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["if None:\n", "    print(\"ne passe toujours pas par ici\")"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["### \u00c9galit\u00e9"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Les tests les plus simples se font \u00e0 l'aide des op\u00e9rateurs d'\u00e9galit\u00e9, qui fonctionnent sur presque tous les objets (nous verrons un contre-exemple dans la section sur les r\u00e9f\u00e9rences partag\u00e9es). Comme nous l'avons d\u00e9j\u00e0 vu, l'op\u00e9rateur `==` v\u00e9rifie si deux objets ont la m\u00eame valeur:"]}, {"block": 14, "type": "code", "linesLength": 8, "startIndex": 32, "lines": ["bas = 12\n", "haut = 25.82\n", "# \u00e9galit\u00e9 \n", "if bas == haut:\n", "    print('==')\n", "# non \u00e9galit\u00e9\n", "if bas != haut:\n", "    print('!=')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["En gen\u00e9ral, deux objets de types diff\u00e9rents ne peuvent pas \u00eatre \u00e9gaux."]}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 41, "lines": ["# ces deux objets se ressemblent \n", "# mais ils ne sont pas du m\u00eame type !\n", "if [1, 2] != (1, 2):\n", "    print('!=')"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Par contre, des `float`, des `int` et des `complex` peuvent \u00eatre \u00e9gaux entre eux:"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 46, "lines": ["# on rappelle que bas vaut l'entier 12\n", "bas_reel = 12.\n", "# le r\u00e9el 12 et l'entier 12 sont \u00e9gaux\n", "if bas == bas_reel:\n", "    print('int == float')\n", "if (12 + 0j) == 12:\n", "    print('int == complex')"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Signalons \u00e0 titre un peu anecdotique une syntaxe ancienne: historiquement et **seulement en python2** on pouvait aussi noter `<>` le test de non \u00e9galit\u00e9. On trouve ceci dans du code ancien mais il faut \u00e9viter de l'utiliser:"]}, {"block": 20, "type": "code", "linesLength": 5, "startIndex": 54, "lines": ["%%python2\n", "\n", "# l'ancienne forme de !=\n", "if 12 <> 25:\n", "    print(\"<> est obsolete et ne fonctionne qu'en python2\")"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["### Les op\u00e9rateurs de comparaison "]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["Sans grande surprise on peut aussi \u00e9crire"]}, {"block": 23, "type": "code", "linesLength": 8, "startIndex": 61, "lines": ["if bas <= haut:\n", "    print('<=')\n", "if bas < haut:\n", "    print('<')\n", "if bas >= haut:\n", "    print('>=')\n", "if bas > haut:\n", "    print('>')"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["On peut l\u00e0 aussi les utiliser sur une palette assez large de types, comme par exemple avec les listes"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["# on peut comparer deux listes, mais ATTENTION\n", "[1, 2] <= [2, 3]"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["Il est parfois utile de v\u00e9rifier le sens qui est donn\u00e9 \u00e0 ces op\u00e9rateurs selon le type; ainsi par exemple sur les ensembles - que nous verrons bient\u00f4t - ils se r\u00e9f\u00e8rent \u00e0 l'**inclusion** sur les ensembles. \n", "\n", "Il faut aussi se m\u00e9fier avec les types num\u00e9riques, si un complexe est impliqu\u00e9, comme dans l'exemple suivant. J'en profite pour anticiper un peu sur les exceptions, que nous verrons \u00e9galement plus tard:"]}, {"block": 27, "type": "code", "linesLength": 8, "startIndex": 75, "lines": ["# on ne peut pas par contre comparer deux nombres complexes\n", "\n", "# l'instuction 'try .. except' permet d'attraper\n", "# les erreurs \u00e0 l'ex\u00e9cution\n", "try:\n", "    2j <= 3j\n", "except Exception as e:\n", "    print(\"OOPS\", e)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["### Connecteurs logiques et / ou / non"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["On peut bien s\u00fbr combiner facilement plusieurs expressions entre elles, gr\u00e2ce aux op\u00e9rateurs `and`, `or` et `not`"]}, {"block": 30, "type": "code", "linesLength": 3, "startIndex": 85, "lines": ["# il ne faut pas faire ceci, mettez des parenth\u00e8ses\n", "if 12 <= 25. or [1, 2] <= [2, 3] and not 12 <= 32 :\n", "    print(\"OK mais pourrait \u00eatre mieux\")"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["En termes de priorit\u00e9s: le plus simple si vous avez une expression compliqu\u00e9e reste de mettre les parenth\u00e8ses qui rendent son \u00e9valuation claire et lisible pour tous. Aussi on pr\u00e9f\u00e8rera de beaucoup la formulation \u00e9quivalente:"]}, {"block": 32, "type": "code", "linesLength": 7, "startIndex": 89, "lines": ["# c'est mieux\n", "if 12 <= 25. or ([1, 2] <= [2, 3] and not 12 <= 32) :\n", "    print(\"OK, c'est \u00e9quivalent et plus clair\")\n", "\n", "# c'est bien le parenth\u00e9sage ci-dessus, puisque:\n", "if (12 <= 25. or [1, 2] <= [2, 3]) and not 12 <= 32 :\n", "    print(\"ce n'est pas \u00e9quivalent, ne passera pas par l\u00e0\")"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["### Pour en savoir plus"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["Reportez-vous \u00e0 la section sur les [op\u00e9rateurs bool\u00e9ens](https://docs.python.org/3/library/stdtypes.html#truth-value-testing) dans la documentation python."]}]
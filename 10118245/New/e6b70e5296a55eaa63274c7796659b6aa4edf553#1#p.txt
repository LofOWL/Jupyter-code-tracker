[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# It\u00e9rateur et performances"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["*XXXXXX Ce notebook est \u00e0 reprendre lorsque la structure du cours python3 sera plus clairement connue. Voir aussi ONGOING-py3.md XXXXXX*"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["Dans ce compl\u00e9ment, nous allons voir pourquoi il est bien souvent pref\u00e9rable d'utiliser un it\u00e9rateur comme sujet d'une boucle `for`, plut\u00f4t que d'it\u00e9rer sur une \u00e9num\u00e9ration explicite comme une liste."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["### Digression sur le module `time`"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 6, "lines": ["Dans ce compl\u00e9ment, nous allons faire un peu de mesures de temps d'ex\u00e9cutution et pour cela nous allons utiliser [le module `time`](https://docs.python.org/3/library/time.html).\n", "\n", "En fait nous n'aurons besoin que d'une seule des fonctions du module, qui retourne l'heure de l'horloge interne, en secondes&nbsp;:"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["import time\n", "print(time.time())"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 11, "lines": ["Pour les curieux ce nombre correspond au nombre de secondes \u00e9coul\u00e9es depuis le 1$^{er}$ Janvier 1970.\n", "\n", "Ce qui nous importe est que, pour savoir combien de temps prend une op\u00e9ration, on peut faire quelque chose comme:"]}, {"block": 9, "type": "code", "linesLength": 12, "startIndex": 14, "lines": ["from time import time\n", "# on enregistre l'heure au d\u00e9but \n", "debut = time()\n", "# uniquement pour illustrer notre m\u00e9thode de mesure, \n", "# nous utilisons time.sleep, qui attend \u00e0 ne rien faire pendant la dur\u00e9e indiqu\u00e9e\n", "from time import sleep\n", "sleep(0.8)\n", "# on enregistre l'heure \u00e0 la fin\n", "fin = time()\n", "# si tout se passe bien, la dur\u00e9e observ\u00e9e: fin-debut\n", "# doit nous donner environ 0.8 seconde\n", "print(\"Dur\u00e9e observ\u00e9e pour sleep {}s\".format(fin-debut))"]}, {"block": 10, "type": "markdown", "linesLength": 5, "startIndex": 26, "lines": ["### Calculs non-instantan\u00e9s dans un notebook\n", "\n", "Vous remarquerez d'ailleurs que pendant le temps du `sleep`, le nombre en face du label `In[]` est remplac\u00e9 par une \u00e9toile, qui indique que votre interpr\u00e9teur python est occup\u00e9.\n", "\n", "Si en manipulant les exemples vous lancez par erreur un calcul trop long, l'interpr\u00e9teur reste occup\u00e9 jusqu'\u00e0 en avoir fini avec ce calcul, et ne pourra pas \u00e9valuer d'autres cellules tant qu'il n'aura pas fini. Pensez dans ce cas \u00e0 faire dans votre notebook *Kernel* \u2192 *Restart* pour red\u00e9marrer votre interpr\u00e9teur."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["### `range` *vs* `xrange`"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Reprenons notre comparaison entre boucles `for` sur liste et sur it\u00e9rateur. Pour cela, commen\u00e7ons par un cas tr\u00e8s simple. Nous avons vu d\u00e9j\u00e0 \u00e0 de nombreuses reprises la fonction `range`. Il existe \u00e9galement une fonction `xrange` qui renvoie un **it\u00e9rateur** \u00e9quivalent, et non pas une liste&nbsp;:"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 33, "lines": ["for i in range(3):\n", "    print('range', i)\n", "\n", "for i in range(3):\n", "    print('xrange', i)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["### Quelle diff\u00e9rence alors ?"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Imaginez maintenant qu'au lieu de 3 \u00e9l\u00e9ments on en ait beaucoup plus; nous allons exp\u00e9rimenter avec plusieurs tailles"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 40, "lines": ["# de 100.000 \u00e0 50 millions\n", "tailles = [10**5, 10**6, 10**7, 5*10**7]"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Voyons le temps que prend uniquement la **construction** d'une grosse liste."]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 43, "lines": ["import time\n", "\n", "for taille in tailles:\n", "    beg = time.time()\n", "    liste = list(range(taille))\n", "    end = time.time()\n", "    print(\"Cr\u00e9ation de la liste de taille {}: {}s\".format(taille,end-beg))"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Si maintenant on construit un it\u00e9rateur \u00e9quivalent on mesure un temps beaucoup plus court&nbsp;:"]}, {"block": 20, "type": "code", "linesLength": 7, "startIndex": 51, "lines": ["import time\n", "\n", "for taille in tailles:\n", "    beg = time.time()\n", "    iterateur = range(taille)\n", "    end = time.time()\n", "    print(\"Cr\u00e9ation de l'it\u00e9rateur de taille {}: {}s\".format(taille,end-beg))"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["On peut voir que, en tendance, la **cr\u00e9ation d'un it\u00e9rateur** de type `xrange` est quasiment **instantan\u00e9e** quelle que soit la taille, alors que la cr\u00e9ation d'une liste \u00e9quivalente prend **un temps beaucoup plus important** et d'autant plus long que la liste est grande."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["### Ce qu'il faut retenir"]}, {"block": 23, "type": "markdown", "linesLength": 5, "startIndex": 60, "lines": ["Pour r\u00e9sumer ce compl\u00e9ment, retenez que&nbsp;: \n", "\n", " * la **construction d'une liste**, surtout si elle est tr\u00e8s longue, peut avoir un **co\u00fbt non n\u00e9gligeable** en temps et en m\u00e9moire;\n", " * c'est pourquoi il convient de s'efforcer de **ne cr\u00e9er une liste** que lorsque c'est **r\u00e9ellement n\u00e9cessaire**;\n", " * et dans tous les autres cas - c'est \u00e0 dire \u00e0 chaque fois que la liste n'est qu'un **accessoire de calcul**, et ne repr\u00e9sente pas une fin en soi - il faut **pr\u00e9f\u00e9rer** l'utilisation d'**it\u00e9rateurs**."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["### Allouer et initialiser de la m\u00e9moire prend du temps"]}, {"block": 26, "type": "markdown", "linesLength": 7, "startIndex": 67, "lines": ["Ce ph\u00e9nom\u00e8ne peut vous para\u00eetre surprenant si vous n'\u00eates pas familier avec l'informatique. \u00c0 premi\u00e8re vue, si on juge superficiellement, on peut se demander ce qui se passe. \n", "\n", "En fait, pour cr\u00e9er la liste des `taille` premiers entiers, il faut\n", " * d'abord allouer suffisamment de m\u00e9moire pour tous les ranger\n", " * et ensuite remplir les `taille` cases de la liste avec les valeurs\n", "\n", "Ces deux op\u00e9rations semblent banales, mais elles prennent n\u00e9anmoins un peu de temps, qui \u00e0 grande \u00e9chelle devient sensible, comme nous venons de l'exp\u00e9rimenter."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["### Un it\u00e9rateur est un objet minuscule"]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 75, "lines": ["A contrario, un it\u00e9rateur du type `xrange` ne **contient presque rien**. Cela sera approfondi en semaine 6, mais pour anticiper un peu la fonction d'un iterateur `xrange` consiste uniquement \u00e0 m\u00e9moriser les param\u00e8tres de la boucle, et \u00e0 quelle \u00e9tape on en est rendu \u00e0 un moment donn\u00e9. \n", "\n", "Ce qui explique le temps tr\u00e8s faible, et constant en fonction de `taille`, que l'on a observ\u00e9 pour la cr\u00e9ation de nos it\u00e9rateurs."]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["### Des it\u00e9rateurs pour tout"]}, {"block": 30, "type": "markdown", "linesLength": 9, "startIndex": 79, "lines": ["Au fur et \u00e0 mesure de l'\u00e9volution de python-2, on a petit \u00e0 petit ajout\u00e9 des utilitaires pour calculer des it\u00e9rateurs plut\u00f4t que des listes. C'est le cas par exemple avec les fonctions et m\u00e9thodes suivantes&nbsp;:\n", "\n", "<table>\n", "<tr> <th>Original</th>  <th>Am\u00e9lior\u00e9</th>  </tr>\n", "<tr> <td>`range`</td>  <td>`xrange`</td>  </tr>\n", "<tr> <td>`dict.keys`</td>  <td>`dict.iterkeys`</td>  </tr>\n", "<tr> <td>`dict.values`</td>  <td>`dict.itervalues`</td>  </tr>\n", "<tr> <td>`dict.items`</td>  <td>`dict.iteritems`</td>  </tr>\n", "</table>"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["### python-3"]}, {"block": 32, "type": "markdown", "linesLength": 3, "startIndex": 89, "lines": ["Parmi les grandes diff\u00e9rences entre python-2 et python-3, il y a ceci&nbsp;: pour toutes les m\u00e9thodes ci-dessus, la s\u00e9mantique est syt\u00e9matiquement de retourner un it\u00e9rateur. \n", "\n", "Ainsi en python-3, `range(10)` retourne un objet it\u00e9rateur. Et il n'y a pas de fonction `xrange`, sachant qu'on peut toujours construire une liste liste en appelant explicitement la fonction `list` comme ceci&nbsp;:"]}, {"block": 33, "type": "markdown", "linesLength": 16, "startIndex": 92, "lines": ["    ~ $ python3\n", "    Python 3.4.1 (default, Sep 20 2014, 19:44:17)\n", "    [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.40)] on darwin\n", "    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n", "    >>>\n", "    >>> range(10)\n", "    range(0, 10)\n", "    >>>\n", "    >>> xrange(10)\n", "    Traceback (most recent call last):\n", "      File \"<stdin>\", line 1, in <module>\n", "    NameError: name 'xrange' is not defined\n", "    >>>\n", "    >>> list(range(10))\n", "    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "    >>>"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["Pour finir, et pour revenir sur les mesures de performances, voici une astuce qui permet de lancer  de petits benchmarkes dans un terminal&nbsp;:"]}, {"block": 36, "type": "markdown", "linesLength": 2, "startIndex": 110, "lines": ["    $ python -m timeit 'liste=range(10**6)' 'for x in liste: x+1'\n", "    10 loops, best of 3: 50.5 msec per loop"]}, {"block": 37, "type": "markdown", "linesLength": 8, "startIndex": 112, "lines": ["Ceci met en jeu un certain nombre de choses nouvelles:\n", " * python avec l'option -m permet d'importer un module, en l'occurrence ici [le module `timeit`](https://docs.python.org/3/library/timeit.html);\n", " * avec cette forme on peut passer \u00e0 `timeit` plusieurs instructions; ici nous avons deux instructions, une pour initialiser `liste`, la seconde pour lancer la boucle `for`;\n", " * il est possible d'\u00e9crire des instructions sur une seule ligne. Ici le dernier argument pass\u00e9 \u00e0 python est \n", " \n", "    for x in liste: x+1\n", "    \n", "   qui est interpr\u00e9t\u00e9 comme une seule ligne. Cette pratique doit absolument rester limit\u00e9e \u00e0 de tels usages sp\u00e9cifiques.\n"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Cette forme est pratique notamment parce que `timeit` fait, comme on le voit, plusieurs essais successifs qui donnent un r\u00e9sultat plus repr\u00e9sentatif. C'est pourquoi vous la trouverez fr\u00e9quemment utilis\u00e9e dans les forums de discussion autour de python."]}]
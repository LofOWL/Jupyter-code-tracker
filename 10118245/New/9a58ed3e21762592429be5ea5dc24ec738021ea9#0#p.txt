[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["# Indexes et slices"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 2, "type": "code", "linesLength": 4, "startIndex": 2, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 6, "lines": ["J'esp\u00e8re que vous \u00eates \u00e0 pr\u00e9sent convaincus qu'il est possible de faire \u00e9norm\u00e9ment de choses avec numpy en faisant des op\u00e9rations entre tableaux, et sans aller r\u00e9f\u00e9rencer un par un les \u00e9l\u00e9ments des tableaux.\n", "\n", "Il est temps maintenant de voir que l'on peut *aussi* manipuler les tableaux numpy avec des indexes."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### Indexation par des entiers et tuples"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["La fa\u00e7on la plus naturelle d'utiliser un tableau, habituellement c'est \u00e0 travers des indices. On peut aussi bien s\u00fbr acc\u00e9der aux \u00e9l\u00e9ments d'un tableau numpy par des indices\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 11, "lines": ["n = 5\n", "a = np.arange(n*n).reshape( (n, n)); print(a)"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Avec un seul index on obtient naturellement une ligne"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["a[0]"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["# qu'on peut a nouveau indexer\n", "a[0][2]"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["# ou plus simplement indexer par un tuple\n", "a[0, 2]"]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 19, "lines": ["# Naturellement on peut affecter une case\n", "# individuellement\n", "a[0][1] = 101\n", "a[0, 2] = 102\n", "print(a)"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["# Ou toute une ligne\n", "a[2] = np.arange(200, 205); print(a)"]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 26, "lines": ["# et on on peut aussi changer \n", "# toute une ligne par broadcasting\n", "a[4] = 400; a"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["# Slicing"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Gr\u00e2ce au slicing on peut aussi r\u00e9f\u00e9rencer toute une colonne\u00a0:"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["n = 5\n", "a = np.arange(n*n).reshape( (n, n)); print(a)"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["a[:, 3]"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["C'est un tableau \u00e0 une dimension, mais vous pouvez tout de m\u00eame modifier la colonne par une affectation\u00a0:"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["a[:, 3] = range(300, 305); print(a)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["ou, ici \u00e9galement bien s\u00fbr, par broadcasting\u00a0:"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 37, "lines": ["# on affecte un scalaire \u00e0 une colonne\n", "a[:, 2] = 200; print(a)"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 39, "lines": ["# ou on ajoute un scalaire \u00e0 une colonne \n", "a[:, 4] += 400; print(a)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Les slices peuvent prendre une forme g\u00e9n\u00e9rale\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["b = np.arange(100).reshape(10, 10); print(b)"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["# toutes les lignes de rang 1, 4, 7\n", "b[1::3]"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 45, "lines": ["# toutes les colonnes de rang 1, 5, 9\n", "b[:, 1::4]"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["b[:, 1::4] = 0; print(b)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Le slicing peut servir \u00e0 extraire des blocs compacts:"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 49, "lines": ["# un bloc au hasard dans b\n", "print(b[2:5, 6:9])"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["### `newaxis`"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["On peut utiliser \u00e9galement le symbole sp\u00e9cial `np.newaxis` en conjonstion avec un slice pour d\u00e9caler les dimensions\u00a0:"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["X = np.arange(1, 7); print(X)"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["X.shape"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["Y = X[:, np.newaxis]; print(Y)"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 56, "lines": ["Y.shape"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Et ainsi de suite\u00a0:"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["Z = Y[:, np.newaxis]; Z"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["Z.shape"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["De cett fa\u00e7on par exemple, en combinant le slicing pour cr\u00e9er X et Y, et le broadcasting pour cr\u00e9er leur somme,  je peux cr\u00e9er facilement la table de tous les tirages de 2 d\u00e9s \u00e0 6 faces\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["dice = X + Y; dice"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["### Conclusion"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Avec l'indexation et le slicing, on peut cr\u00e9er des tableaux qui sont des vues sur des fragments d'un tableau; on peut \u00e9galement d\u00e9former leur dimension gr\u00e2ce \u00e0 `newaxis`; on peut modifier ces fragments, en utilisant un scalaire, un tableau, ou ne slice sur un autre tableau; les possibilit\u00e9s sont infinies."]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["b"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["dice"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 66, "lines": ["# les lignes de rangs 1, 3, 5\n", "b[1:6:2]"]}, {"block": 46, "type": "code", "linesLength": 2, "startIndex": 68, "lines": ["# parmi ces lignes, les colonnes de rangs 1, 4, 7\n", "b[1:6:2, 1::4]"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["# je peux affecter ce tableau (en fait cette vue) \u00e0 par exemple un scalaire\n", "b[1:6:2, 1::4] = 333"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 72, "lines": ["b"]}]
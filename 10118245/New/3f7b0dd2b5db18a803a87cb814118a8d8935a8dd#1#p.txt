[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Les attributs"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ments - niveau basique"]}, {"block": 2, "type": "heading", "linesLength": 1, "startIndex": 2, "lines": ["La notation `.` et les attributs"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["La notation `module.variable` que nous avons vue dans la vid\u00e9o est un cas particulier de la notion d'attribut, qui permet d'\u00e9tendre un objet, ou si on pr\u00e9f\u00e8re de lui accrocher des annotations.\n", "\n", "Nous avons d\u00e9j\u00e0 rencontr\u00e9 ceci plusieurs fois, c'est exactement le m\u00eame m\u00e9canisme d'attribut qui est utilis\u00e9 \u00e9galement pour les m\u00e9thodes; pour le syst\u00e8me d'attribut il n'y a pas de diff\u00e9rence entre `module.variable`, `module.fonction`, `objet.classe`, etc.. \n", "\n", "Nous verrons tr\u00e8s bient\u00f4t que ce m\u00e9canisme est masivement utilis\u00e9 \u00e9galement dans les instances de classe."]}, {"block": 4, "type": "heading", "linesLength": 1, "startIndex": 8, "lines": ["Les fonctions de gestion des attributs"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Pour acc\u00e9der programmativement aux attributs d'un objet, on dispose des 3 fonctions *builtin* `getattr`, `setattr`, et `hasattr`, que nous allons illustrer tout de suite"]}, {"block": 6, "type": "heading", "linesLength": 1, "startIndex": 10, "lines": ["Lire un attribut"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["La [fonction *builtin* `getattr`](https://docs.python.org/2/library/functions.html#getattr) permet de lire un attribut programmativement"]}, {"block": 8, "type": "heading", "linesLength": 1, "startIndex": 12, "lines": ["\u00c9crire un attribut"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Comme pour la lecture on peut \u00e9crire un attribut programativement avec la [fonction *builtin* `setattr`](https://docs.python.org/2/library/functions.html#setattr)"]}, {"block": 10, "type": "heading", "linesLength": 1, "startIndex": 14, "lines": ["Liste des attributs"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["La [fonction *builtin* `hasattr`](https://docs.python.org/2/library/functions.html#hasattr) permet de savoir si un objet poss\u00e8de ou pas un attribut:"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Ce qui peut aussi \u00eatre retrouv\u00e9 autrement, avec la [fonction *builtin* `vars`](https://docs.python.org/2/library/functions.html#vars)"]}, {"block": 13, "type": "heading", "linesLength": 1, "startIndex": 17, "lines": ["Sur quels objets"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Il n'est pas disponible d'ajouter des attributs sur les types de base"]}, {"block": 15, "type": "markdown", "linesLength": 6, "startIndex": 19, "lines": ["Il est par contre disponible sur virtuellement tout le reste, et notamment l\u00e0 o\u00f9 il est tr\u00e8s utile, c'est-\u00e0-dire pour ce qui nous concerne:\n", " * modules\n", " * packages\n", " * fonctions\n", " * classes\n", " * instances"]}, {"block": 16, "type": "heading", "linesLength": 1, "startIndex": 25, "lines": ["Compl\u00e9ments - niveau avanc\u00e9"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Vous pouvez vous demander pourquoi il n'est pas possible d'ajouter des attributs \u00e0 un objet *builtin*. Le probl\u00e8me n'est pas tant d'ajouter des attributs que de modifier des attributs existants. On comprend ais\u00e9ment que modifier un objet *builtin* risque de corrompre le fonctionnement non seulement de votre programme d'une mani\u00e8re difficile \u00e0 pr\u00e9voir, mais aussi de tous les modules que vous utilisez. Dit autrement, les objets *builtin* sont la base de python et si vous les modifiez, vous modifiez le fonctionnement de python. "]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Pour rendre impossible la modification d'un objet *builtin*, python utilise, au lieu d'un dictionnaire classique pour son espace de nommage, un proxy \u00e0 ce dictionnaire, appel\u00e9 *dictproxy* qui interdit les modifications. On rappelle que l'espace de nommage d'un objet est presque toujours r\u00e9f\u00e9renc\u00e9 par l'attribut `__dict__`. Regardons alors le type de l'espace de nommage pour la fonction `foo`"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["mais le type de l'espace de nommage pour l'objet *builtin* `int` est"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Op\u00e9rations *bitwise*"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ments - niveau avanc\u00e9 "]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Les compl\u00e9ments ci-dessous expliquent des fonctions \u00e9volu\u00e9es sur les entiers; les d\u00e9butants en programmation peuvent sans souci sauter cette partie en cas de difficult\u00e9s."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Op\u00e9rations logiques : ET `&`, OU `|` et OU exclusif `^`"]}, {"block": 5, "type": "markdown", "linesLength": 4, "startIndex": 5, "lines": ["Il est possible aussi de faire des op\u00e9rations *bit-\u00e0-bit* sur les nombres entiers. \n", "Le plus simple est de penser \u00e0 l'\u00e9criture du nombre en base 2.\n", "\n", "Consid\u00e9rons par exemple deux entiers constants dans cet exercice:"]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["x49 = 49\n", "y81 = 81"]}, {"block": 7, "type": "markdown", "linesLength": 7, "startIndex": 11, "lines": ["Ce qui nous donne comme d\u00e9composition binaire \n", "\n", "$\\begin{array}{rcccccc}\n", "x49&=&49&=&32 + 16 + 1 &\\rightarrow&(0,1,1,0,0,0,1) \\\\\n", "y81&=&81&=&64 + 16 + 1 &\\rightarrow&(1,0,1,0,0,0,1)\n", "\\end{array}\n", "$"]}, {"block": 8, "type": "markdown", "linesLength": 5, "startIndex": 18, "lines": ["Pour comprendre comment passer de $32 + 16 + 1$ \u00e0 $(0,1,1,0,0,0,1)$ il suffit d'observer que \n", "\n", "$32 + 16 + 1 = \\textbf{0}*2^6 + \n", "\\textbf{1}*2^5 + \\textbf{1}*2^4 + \\textbf{0}*2^3 \n", "+ \\textbf{0}*2^2 + \\textbf{0}*2^1 + \\textbf{1}* 2^0$"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["#### Et logique : op\u00e9rateur `&`"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["L'op\u00e9ration logique `&` va faire un *et* logique bit \u00e0 bit entre les op\u00e9randes, ainsi"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["x49 & y81"]}, {"block": 12, "type": "markdown", "linesLength": 6, "startIndex": 26, "lines": ["Et en effet\n", "$\\begin{array}{rcl}\n", "x49 & \\rightarrow & (0,1,1,0,0,0,1) \\\\\n", "y81 & \\rightarrow & (1,0,1,0,0,0,1) \\\\\n", "x49\\ \\&\\ y81 & \\rightarrow & (0,0,1,0,0,0,1) \\rightarrow 16 + 1 \\rightarrow 17\n", "\\end{array}$"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["#### Ou logique : op\u00e9rateur `|`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["De m\u00eame, l'op\u00e9rateur logique `|` fait simplement un *ou* logique, comme ceci:"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 34, "lines": ["x49 | y81"]}, {"block": 16, "type": "markdown", "linesLength": 7, "startIndex": 35, "lines": ["On s'y retrouve parce que\n", "\n", "$\\begin{array}{rcl}\n", "x49 & \\rightarrow & (0,1,1,0,0,0,1) \\\\\n", "y81 & \\rightarrow & (1,0,1,0,0,0,1) \\\\\n", "x49\\ |\\ y81 & \\rightarrow & (1,1,1,0,0,0,1) \\rightarrow 64+32+16+1 \\rightarrow 113\n", "\\end{array}$\n"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["##### Ou exclusif : op\u00e9rateur ^"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["Enfin on peut \u00e9galement faire la m\u00eame op\u00e9ration \u00e0 base de *ou exclusif* avec l'op\u00e9rateur '\u02c6'"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["x49 ^ y81"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Je vous laisse le soin de d\u00e9cortiquer le calcul \u00e0 titre d'exercice (le ou exclusif de deux bits est vrai si et seulement exactement une des deux entr\u00e9es est vraie)."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["### D\u00e9calages"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Un d\u00e9calage *\u00e0 gauche* de, par exemple, 4 positions, revient \u00e0 d\u00e9caler tout le champ de bits de 4 cases \u00e0 gauche (les 4 nouveaux bits ins\u00e9r\u00e9s sont toujours des 0); c'est donc \u00e9quivalent \u00e0 une multiplication par $2^4=16$:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["x49 << 4"]}, {"block": 24, "type": "markdown", "linesLength": 4, "startIndex": 49, "lines": ["$\\begin{array}{rcl}\n", "x49 & \\rightarrow & (0,1,1,0,0,0,1) \\\\\n", "x49 << 4 & \\rightarrow & (0,1,1,0,0,0,1,0,0,0,0) \\rightarrow 512+256+16 \\rightarrow 784 \n", "\\end{array}$\n"]}, {"block": 25, "type": "markdown", "linesLength": 2, "startIndex": 53, "lines": ["De la m\u00eame fa\u00e7on le d\u00e9calage \u00e0 droite de $n$ revient \u00e0 une\n", "division par $2^n$ (plus pr\u00e9cis\u00e9ment, le quotient de la division):"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["x49 >> 4"]}, {"block": 27, "type": "markdown", "linesLength": 4, "startIndex": 56, "lines": ["$\\begin{array}{rcl}\n", "x49 & \\rightarrow & (0,1,1,0,0,0,1) \\\\\n", "x49 >> 4 & \\rightarrow & (0,0,0,0,0,1,1) \\rightarrow 2+1 \\rightarrow 3\n", "\\end{array}$"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["### Une astuce"]}, {"block": 29, "type": "markdown", "linesLength": 2, "startIndex": 61, "lines": ["On peut utiliser la fonction *built-in* `bin` \n", "pour calculer la repr\u00e9sentation binaire d'un entier; attention la valeur de retour est une cha\u00eene de caract\u00e8res de type `str`"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["bin(x49)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["Dans l'autre sens, on peut aussi entrer un entier directement en base 2 comme ceci; ici comme on le voit `x49bis` est bien un entier"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 65, "lines": ["x49bis = 0b110001\n", "x49bis == x49"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["### Pour en savoir plus"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["[Section de la documentation python](https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types)"]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Op\u00e9rations logiques"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["M\u00eame si les tableaux contiennent habituellement des nombres, on peut \u00eatre amen\u00e9s \u00e0 faire des op\u00e9rations logiques et du coup \u00e0 manipuler des tableaux de bool\u00e9ens. Nous allons voir quelques \u00e9l\u00e9ments \u00e0 ce sujet."]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 8, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["### Op\u00e9rations logiques"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["On peut faire des op\u00e9rations logiques entre tableaux exactement comme on fait des op\u00e9rations arithm\u00e9tiques\u00a0:"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["On va partir de deux tableaux presque identiques. J'en profite pour vous signaler qu'on peut copier un tableau avec tout simplement `np.copy`\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["a = np.arange(25).reshape(5, 5)\n", "print(a)"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 17, "lines": ["b = np.copy(a)\n", "b[2, 2] = 1000\n", "print(b)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Une op\u00e9ration logique va bien s\u00fbr nous retourner un tableau de la m\u00eame taille\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 21, "lines": ["print(a == b)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["### `all` et `any`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Si votre intention est de v\u00e9rifier que les deux tableaux sont enti\u00e8rement identiques, utilisez `np.all` - et non pas le *built-in* natif `all` de python\u00a0- qui va v\u00e9rifier que tous les \u00e9l\u00e9ments du tableau sont vrais\u00a0:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["np.all(a == a)"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["np.all(a == b)"]}, {"block": 16, "type": "code", "linesLength": 5, "startIndex": 26, "lines": ["# le builtin all ne s'applique qu'\u00e0 des tableaux de dimension 1\n", "try:\n", "    all(a == a)\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["C'est bien s\u00fbr la m\u00eame chose pour `any` qui va v\u00e9rifier qu'il y a au moins un \u00e9l\u00e9ment vrai. Comme en python natif, u nombre qui est nul est consid\u00e9r\u00e9 comme faux\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 6, "startIndex": 32, "lines": ["# on peut faire aussi bien\n", "# np.any(x)\n", "# ou \n", "# x.any()\n", "\n", "np.zeros(10).any()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["### Masques"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Mais en g\u00e9n\u00e9ral, c'est rare qu'on ait besoin de consolider de la sorte un bool\u00e9en sur tout un tableau, on utilise plut\u00f4t les tableaux logiques comme des masques pour faire des op\u00e9rations ou non sur un autre tableau."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["J'en profite pour introduire une fonction de `matplotlib` qui s'appelle `imshow` et qui permet d'afficher une image\u00a0:"]}, {"block": 22, "type": "code", "linesLength": 9, "startIndex": 41, "lines": ["# construisons un disque centr\u00e9 au milieu de l'image\n", "\n", "width = 128\n", "center = width/2\n", "\n", "ix, iy = np.indices((width, width))\n", "# je rajoute une constante arbitrairement \n", "image = (ix-center)**2 + (iy-center)**2 + 100\n", "plt.imshow(image);"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Maintenant je peux cr\u00e9er un masque qui produise des rayures en diagonale, donc selon la valeur de `(i+j)`. Par exemple\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 51, "lines": ["# pour faire des rayures de 6 pixels de large \n", "rayures = (ix + iy) % 8 <= 5\n", "plt.imshow(rayures);"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 54, "lines": ["# en fait c'est bien s\u00fbr un tableau de bool\u00e9ens\n", "print(rayures)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["je vous montre aussi comment inverser un masque parce que c'est un peu abscons\u00a0:"]}, {"block": 27, "type": "code", "linesLength": 9, "startIndex": 57, "lines": ["# on pourrait penser faire `not rayures` mais non,\n", "#   c'est un peu comme pour all() et any()\n", "# on ne peut pas non plus d'ailleurs faire \n", "#   anti_rayures.not() parce not est un mot cl\u00e9\n", "# et on ne peut pas non plus faire\n", "#   anti_rayures.logical_not() - et \u00e7a c'est plut\u00f4t un d\u00e9faut\n", "\n", "anti_rayures = np.logical_not(rayures)\n", "plt.imshow(anti_rayures);"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Ne soyez pas perturb\u00e9s par les couleurs, on s'attendrait \u00e0 du noir et blanc, mais en fait on n'a pas pr\u00e9cis\u00e9 quelles couleurs on voulait utiliser; on en reparlera d'ailleurs. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Maintenant je peux utiliser le masque `rayures` pour faire des choses sur l'image. Par exemple simplement\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 68, "lines": ["# si je veux effacer les rayures\n", "plt.imshow(image*rayures)"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["# ou garder l'autre moiti\u00e9\n", "plt.imshow(image*anti_rayures)"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 72, "lines": ["image"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 73, "lines": ["np.logical_not(image)"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 74, "lines": ["xxx ici"]}]
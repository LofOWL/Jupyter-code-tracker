[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Op\u00e9rations logiques"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["M\u00eame si les tableaux contiennent habituellement des nombres, on peut \u00eatre amen\u00e9s \u00e0 faire des op\u00e9rations logiques et du coup \u00e0 manipuler des tableaux de bool\u00e9ens. Nous allons voir quelques \u00e9l\u00e9ments \u00e0 ce sujet."]}, {"block": 4, "type": "code", "linesLength": 7, "startIndex": 8, "lines": ["###### import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()\n", "\n", "%pylab inline\n", "pylab.rcParams['figure.figsize'] = (6, 6)"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["### Op\u00e9rations logiques"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["On peut faire des op\u00e9rations logiques entre tableaux exactement comme on fait des op\u00e9rations arithm\u00e9tiques\u00a0:"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["On va partir de deux tableaux presque identiques. J'en profite pour vous signaler qu'on peut copier un tableau avec tout simplement `np.copy`\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["a = np.arange(25).reshape(5, 5)\n", "print(a)"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 20, "lines": ["b = np.copy(a)\n", "b[2, 2] = 1000\n", "print(b)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Une op\u00e9ration logique va donc nous retourner un tableau de la m\u00eame taille\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["print(a == b)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### `all` et `any`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Si votre intention est de v\u00e9rifier que les deux tableaux sont enti\u00e8rement identiques, utilisez `np.all` - et non pas le *built-in* natif `all` de python\u00a0- qui va v\u00e9rifier que tous les \u00e9l\u00e9ments du tableau sont vrais\u00a0:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["np.all(a == a)"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["np.all(a == b)"]}, {"block": 16, "type": "code", "linesLength": 5, "startIndex": 29, "lines": ["# le builtin all ne s'applique qu'\u00e0 des tableaux de dimension 1\n", "try:\n", "    all(a == a)\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["C'est bien s\u00fbr la m\u00eame chose pour `any` qui va v\u00e9rifier qu'il y a au moins un \u00e9l\u00e9ment vrai. Comme en python natif, u nombre qui est nul est consid\u00e9r\u00e9 comme faux\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 6, "startIndex": 35, "lines": ["# on peut faire aussi bien\n", "# np.any(x)\n", "# ou \n", "# x.any()\n", "\n", "np.zeros(10).any()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["### Masques"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Mais en g\u00e9n\u00e9ral, c'est rare qu'on ait besoin de consolider de la sorte un bool\u00e9en sur tout un tableau, on utilise plut\u00f4t les tableaux logiques comme des masques pour faire des op\u00e9rations ou non sur un autre tableau."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["J'en profite pour introduire une fonction de `matplotlib` qui s'appelle `imshow` et qui permet d'afficher une image\u00a0:"]}, {"block": 22, "type": "code", "linesLength": 8, "startIndex": 44, "lines": ["# construisons un disque centr\u00e9 au milieu de l'image\n", "\n", "width = 128\n", "center = width/2\n", "\n", "ix, iy = np.indices((width, width))\n", "image = (ix-center)**2 + (iy-center)**2\n", "plt.imshow(image);"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["Maintenant je peux cr\u00e9er un masque qui produise des rayures en diagonale, donc selon la valeur de `(i+j)`. Par exemple\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 53, "lines": ["# pour faire des rayures \n", "# de 6 pixels de large \n", "rayures = (ix + iy) % 8 <= 5\n", "plt.imshow(rayures);"]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 57, "lines": ["# en fait c'est bien s\u00fbr \n", "# un tableau de bool\u00e9ens\n", "print(rayures)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["je vous montre aussi comment inverser un masque parce que c'est un peu abscons\u00a0:"]}, {"block": 27, "type": "code", "linesLength": 9, "startIndex": 61, "lines": ["# on pourrait penser faire `not rayures` mais non,\n", "#   c'est un peu comme pour all() et any()\n", "# on ne peut pas non plus d'ailleurs faire \n", "#   anti_rayures.not() parce not est un mot cl\u00e9\n", "# et on ne peut pas non plus faire\n", "#   anti_rayures.logical_not() - et \u00e7a c'est plut\u00f4t un d\u00e9faut\n", "\n", "anti_rayures = np.logical_not(rayures)\n", "plt.imshow(anti_rayures);"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Ne soyez pas perturb\u00e9s par les couleurs, on s'attendrait \u00e0 du noir et blanc, mais en fait on n'a pas pr\u00e9cis\u00e9 quelles couleurs on voulait utiliser; on en reparlera d'ailleurs. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Maintenant je peux utiliser le masque `rayures` pour faire des choses sur l'image. Par exemple simplement\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 72, "lines": ["# pour effacer les rayures\n", "plt.imshow(image*rayures);"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 74, "lines": ["# ou garder l'autre moiti\u00e9\n", "plt.imshow(image*anti_rayures);"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["image"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["np.logical_not(image)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["### Expression conditionnelle et `np.where`"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Noous avons vu en python natif l'expression conditionnelle\u00a0:"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 80, "lines": ["3 if True else 2"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Pour reproduire cette construction en `numpy` vous avez \u00e0 votre disposition `np.where`. Pour l'illustrer nous allons construire deux images facilement discernables. Et pour \u00e7a on va utiliser `np.isclose`, qui est tr\u00e8s utile pour comparer que deux nombres sont suffisamment proches, surtout pour les calculs flottants en fait, mais \u00e7a nous convient tr\u00e8s bien ici aussi\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["np.isclose?"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Pour \u00e9laborer une image qui contient un grand cercle, je vais dire que la distance au centre (je rappelle que c'est le contenu de `image`) est suffisamment proche de $64^2$, ce que vaut `image` au milieu de chaque bord\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["big_circle = np.isclose(image, 64 **2, 10/100)\n", "plt.imshow(big_circle);"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["small_circle = np.isclose(image, 32 **2, 10/100)\n", "plt.imshow(small_circle);"]}, {"block": 42, "type": "markdown", "linesLength": 3, "startIndex": 88, "lines": ["En utilisant `np.where`, je peux simuler quelque chose comme ceci\u00a0:\n", "\n", "    mixed = big_circle if rayures else small_circle"]}, {"block": 43, "type": "code", "linesLength": 3, "startIndex": 91, "lines": ["# sauf que \u00e7a se pr\u00e9sente en fait comme ceci\u00a0:\n", "mixed = np.where(rayures, big_circle, small_circle)\n", "plt.imshow(mixed);"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["Remarquez enfin qu'on peut aussi faire la m\u00eame chose en tirant profit que `True` == 1 et `False` == 0\u00a0:"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 95, "lines": ["mixed2 = rayures * big_circle + (1-rayures) * small_circle\n", "plt.imshow(mixed2);"]}]
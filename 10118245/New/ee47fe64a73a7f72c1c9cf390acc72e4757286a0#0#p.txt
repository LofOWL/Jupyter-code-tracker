[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Les instructions += et autres revisit\u00e9es"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["Nous avons vu en deuxi\u00e8me semaine (S\u00e9quence \"Les types num\u00e9riques\") une premi\u00e8re introduction aux instructions `+=` et ses d\u00e9riv\u00e9es comme `*=`, `**=`, etc."]}, {"block": 3, "type": "heading", "linesLength": 1, "startIndex": 3, "lines": ["Ces constructions ont une d\u00e9finition \u00e0 g\u00e9om\u00e9trie variable"]}, {"block": 4, "type": "markdown", "linesLength": 5, "startIndex": 4, "lines": ["Historiquement, en C quand on utilise `+=` (ou encore `++`) on modifie la m\u00e9moire en place - en utilisant lorsque c'est possible l'instruction qui va bien du CPU.\n", "\n", "Ces constructions en python s'inspirent clairement de C, aussi dans l'esprit ces constructions devraient fonctionner en **modifiant** l'objet r\u00e9f\u00e9renc\u00e9 par la variable. \n", "\n", "Mais les types num\u00e9riques en python ne sont **pas mutables**, alors que les listes le sont. Du coup le comportement de `+=` est diff\u00e9rent selon qu'on l'utilise sur un nombre ou sur une liste. Voyons cela sur des exemples tr\u00e8s simples."]}, {"block": 5, "type": "code", "linesLength": 5, "startIndex": 9, "lines": ["# Premier exemple avec un entier\n", "\n", "# on commence avec une r\u00e9f\u00e9rence partag\u00e9e\n", "a = b = 3\n", "a is b "]}, {"block": 6, "type": "code", "linesLength": 9, "startIndex": 14, "lines": ["# on utilise += sur une des deux variables\n", "a += 1\n", "\n", "# ceci n'a pas modifi\u00e9 b\n", "# c'est normal, l'entier n'est pas mutable\n", "\n", "print a\n", "print b\n", "print a is b"]}, {"block": 7, "type": "code", "linesLength": 5, "startIndex": 23, "lines": ["# Deuxi\u00e8me exemple, cette fois avec une liste\n", "\n", "# la m\u00eame r\u00e9f\u00e9rence partag\u00e9e\n", "a = b = []\n", "a is b"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 28, "lines": ["# pareil, on fait += sur une des variables\n", "a += [1]\n", "\n", "# cette fois on a modifi\u00e9 a et b\n", "# car += a pu modifier la liste en place\n", "print a\n", "print b\n", "print a is b"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Vous voyez donc que la s\u00e9mantique de `+=` (c'est bien entendu le cas pour toutes les autres formes d'instructions qui combinent l'affectation avec un op\u00e9rateur) **est diff\u00e9rente** suivant que l'objet r\u00e9f\u00e9renc\u00e9 par le terme de gauche est **mutable ou immuable**."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["Pour cette raison, c'est l\u00e0 une opinion personnelle, cette famille d'instructions n'est pas le trait le plus r\u00e9ussi dans le langage, et je ne recommande pas de l'utiliser."]}]
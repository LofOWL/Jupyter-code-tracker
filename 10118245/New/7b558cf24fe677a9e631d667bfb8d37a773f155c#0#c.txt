[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# `yield from` pour cascader deux g\u00e9n\u00e9rateurs "]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Dans ce notebook nous allons voir comment fabriquer une fonction g\u00e9n\u00e9ratrice qui appelle elle-m\u00eame une autre fonction g\u00e9n\u00e9ratrice."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Une fonction g\u00e9n\u00e9ratrice "]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Commen\u00e7ons \u00e0 nous d\u00e9finir une fonction g\u00e9n\u00e9ratrice; par exemple ici nous listons les diviseurs d'un entier, en excluant 1 et l'entier lui-m\u00eame\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 10, "lines": ["def dividers(n, verbose=False):\n", "    for i in range(2, n):\n", "        if n % i == 0:\n", "            if verbose: \n", "                print(f'trouv\u00e9 diviseur {i} de {n}')\n", "            yield i"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Comme attendu, l'appel direct \u00e0 cette fonction ne donne rien d'utile:"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["dividers(28)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Mais lorsqu'on l'utilise dans une boucle `for`:"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 19, "lines": ["for d in dividers(28):\n", "    print(d)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["### Une g\u00e9n\u00e9ratrice qui appelle une autre g\u00e9n\u00e9ratrice"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Bien, jusqu'ici c'est clair. Maintenant supposons que je veuille \u00e9crire une fonction g\u00e9n\u00e9ratrice qui \u00e9num\u00e8re tous les diviseurs de tous les diviseurs d'un entier. Il s'agit donc, en sorte, d'\u00e9crire une fonction g\u00e9n\u00e9ratrice qui en appelle une autre - ici elle m\u00eame."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["##### Premi\u00e8re id\u00e9e"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Premi\u00e8re id\u00e9e, qui ne marche pas\u00a0:"]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 25, "lines": ["def dividers_square(n):\n", "    for i in dividers(n):\n", "        dividers(i)"]}, {"block": 16, "type": "code", "linesLength": 5, "startIndex": 28, "lines": ["try:\n", "    for i in dividers_square(28):\n", "        print(i)\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Ce qui se passe ici, c'est que `dividers_square` est per\u00e7ue comme une fonction normale, lorsqu'on l'appelle elle ne retourne rien, donc `None`; et c'est sur ce `None` qu'on essaie de faire la boucle `for`, qui \u00e9choue."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["##### Deuxi\u00e8me id\u00e9e"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Si on utilise juste `yield`, \u00e7a ne fait pas du tout ce qu'on veut\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 3, "startIndex": 36, "lines": ["def dividers_square(n):\n", "    for i in dividers(n):\n", "        yield dividers(i)"]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 39, "lines": ["try:\n", "    for i in dividers_square(28):\n", "        print(i)\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["En effet, c'est logique, chaque `yield` dans `dividers_square()` correspond \u00e0 une it\u00e9ration de la boucle. Bref il nous manque quelque chose dans le langage pour arriver \u00e0 faire ce qu'on veut."]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["##### `yield from`"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["La construction du langage qui permet de faire ceci s'appelle `yield from`; "]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 47, "lines": ["def dividers_square(n):\n", "    for i in dividers(n):\n", "        yield from dividers(i, verbose=True)"]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 50, "lines": ["try:\n", "    for i in dividers_square(28):\n", "        print(i)\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Avec `yield from`, on elle peut indiquer que `dividers_square` est une fonction g\u00e9n\u00e9ratrice, et qu'il faut \u00e9valuer `dividers(..)` comme un g\u00e9n\u00e9rateur; ici l'interpr\u00e9teur va empiler un second appel \u00e0 `dividers` et \u00e9num\u00e9rer tous les r\u00e9sultats que cette fonction va \u00e9num\u00e9rer avec `yield`."]}]
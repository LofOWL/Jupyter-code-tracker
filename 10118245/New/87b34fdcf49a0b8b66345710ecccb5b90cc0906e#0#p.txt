[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Surcharge op\u00e9rateurs (2)"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 2, "type": "heading", "linesLength": 1, "startIndex": 2, "lines": ["`__contains__`, `__len__`, `__getitem__` et apparent\u00e9s"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["La m\u00e9thode `__contains__` permet de donner un sens \u00e0&nbsp;:\n", "\n", "    item in objet\n", "    \n", "Sans grande surprise, elle prend en argument un objet et un item, et doit renvoyer un bool\u00e9en. Nous l'illustrons ci-dessous avec la classe `DualQueue`."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["La m\u00e9thode `__len__` est utilis\u00e9e par la fonction *builtin* `len` pour retourner la longueur d'un objet. "]}, {"block": 5, "type": "heading", "linesLength": 1, "startIndex": 9, "lines": ["La classe `DualQueue`"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 10, "lines": ["Nous allons illustrer ceci avec un exemple de classe, un peu artificiel, qui impl\u00e9mente une queue de type FIFO. Les objets sont d'abord admis dans la file d'entr\u00e9e (`add_input`), puis d\u00e9plac\u00e9s dans la file de sortie (`move_input_to_output`), et enfin sortis (`emit_output`).\n", "\n", "Clairement, cet exemple est \u00e0 but uniquement p\u00e9dagogique; on veut montrer comment une impl\u00e9mentation qui repose sur deux listes s\u00e9par\u00e9es peut donner l'illusion d'une continuit\u00e9, et se pr\u00e9senter comme un container unique. De plus cette impl\u00e9mentation ne fait aucun contr\u00f4le pour ne pas obscurcir le code. "]}, {"block": 7, "type": "heading", "linesLength": 1, "startIndex": 13, "lines": ["Longueur et appartenance"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Avec cette premi\u00e8re version de la classe `DualQueue` on peut utiliser `len` et le test d'appartenance&nbsp;:"]}, {"block": 9, "type": "heading", "linesLength": 1, "startIndex": 15, "lines": ["Acc\u00e8s s\u00e9quentiel"]}, {"block": 10, "type": "markdown", "linesLength": 5, "startIndex": 16, "lines": ["Lorsqu'on a la notion de longueur de l'objet avec  `__len__`, il peut \u00eatre opportun -  quoique cela n'est pas impos\u00e9 par le langage, comme on vient de le voir - de proposer \u00e9galement un acc\u00e8s index\u00e9 par un entier pour pouvoir faire&nbsp;:\n", "\n", "    queue[1]\n", "    \n", "**Pour ne pas r\u00e9p\u00e9ter tout le code de la classe**, nous allons \u00e9tendre `DualQueue` avec la m\u00e9thode `__getitem__`, comme nous avons d\u00e9j\u00e0 eu l'occasion de le faire&nbsp;:"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["\u00c0 pr\u00e9sent, on peut **acc\u00e9der** aux objets de la queue **s\u00e9quentiellement**&nbsp;:"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["ce qui l\u00e8ve la m\u00eame exception qu'avec une vraie liste si on utilise un mauvais index&nbsp;:"]}, {"block": 13, "type": "heading", "linesLength": 1, "startIndex": 23, "lines": ["Am\u00e9lioration : acc\u00e8s par slice"]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 24, "lines": ["Si on veut aussi supporter l'acc\u00e8s par slice comme ceci&nbsp;:\n", "\n", "    queue[1:3]\n", "    \n", "il nous faut modifier la m\u00e9thode `__getitem__`. "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Le second argument de `__getitem__` correspond naturellement au contenu des crochets `[]`, on utilise donc `isinstance` pour \u00e9crire un code qui s'adapte au type d'indexation, comme ceci&nbsp;:"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Maintenant on peut acc\u00e9der par slice"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Et on re\u00e7oit bien une exception si on essaie d'acc\u00e9der par cl\u00e9&nbsp;:"]}, {"block": 18, "type": "heading", "linesLength": 1, "startIndex": 32, "lines": ["L'objet est it\u00e9rable (m\u00eame sans avoir `__iter__`)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Avec seulement `__len__` et `__getitem__`, on peut **faire une boucle** sur l'objet queue. On l'a mentionn\u00e9 rapidement dans la s\u00e9quence sur les it\u00e9rateurs, mais la **m\u00e9thode `__iter__` n'est pas la seule fa\u00e7on** de rendre un objet it\u00e9rable&nbsp;:"]}, {"block": 20, "type": "heading", "linesLength": 1, "startIndex": 34, "lines": ["On peut faire un test sur l'objet"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["De mani\u00e8re similaire, m\u00eame sans la m\u00e9thode `__nonzero__`, cette classe sait **faire des tests de mani\u00e8re correcte** gr\u00e2ce uniquement \u00e0 la m\u00e9thode `__len__`&nbsp;:"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["***"]}, {"block": 23, "type": "heading", "linesLength": 1, "startIndex": 37, "lines": ["`__call__` et les *callables*"]}, {"block": 24, "type": "markdown", "linesLength": 2, "startIndex": 38, "lines": ["Le langage introduit de mani\u00e8re similaire la notion de ***callable*** - litt\u00e9ralement, qui peut \u00eatre appel\u00e9.\n", "L'id\u00e9e est tr\u00e8s simple, on cherche \u00e0 donner un sens \u00e0 un fragment de code du genre de&nbsp;:"]}, {"block": 25, "type": "raw", "linesLength": 5, "startIndex": 40, "lines": ["# on cr\u00e9e une instance\n", "objet = Classe(arguments)\n", "\n", "# et c'est l'objet (et pas la classe) qu'on utilise comme une fonction\n", "objet(arg1, arg2)"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 45, "lines": ["Le protocole ici est tr\u00e8s simple; cette derni\u00e8re ligne a un sens en python d\u00e8s lors que&nbsp;:\n", " * `objet` poss\u00e8de une m\u00e9thode `__call__`,\n", " * et que celle-ci peut \u00eatre envoy\u00e9e \u00e0 `objet` avec les arguments `arg1, arg2`, pour nous donner le r\u00e9sultat qui sera retourn\u00e9 par `objet(arg1, arg2)`."]}, {"block": 27, "type": "raw", "linesLength": 1, "startIndex": 48, "lines": ["objet(arg1, arg2)   ===>   objet.__call__(arg1, arg2)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Voyons cela sur un exemple&nbsp;:"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Pour ceux qui connaissent, nous avons choisi \u00e0 dessein un exemple qui s'apparente \u00e0 [une cl\u00f4ture](http://en.wikipedia.org/wiki/Closure_%28computer_programming%29). Nous reviendrons sur cette notion de *callable* lorsque nous verrons les d\u00e9corateurs en semaine 7. "]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["***"]}, {"block": 31, "type": "heading", "linesLength": 1, "startIndex": 52, "lines": ["`__getattr__` et apparent\u00e9s"]}, {"block": 32, "type": "markdown", "linesLength": 3, "startIndex": 53, "lines": ["Dans cette derni\u00e8re partie nous allons voir comment avec la m\u00e9thode `__getattr__`, on peut red\u00e9finir la fa\u00e7on que le langage a d'\u00e9valuer\n", "\n", "    objet.attribut"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["**Avertissement:** on a vu dans la s\u00e9quence consacr\u00e9e \u00e0 l'h\u00e9ritage que, pour l'essentiel, le m\u00e9canisme d'h\u00e9ritage repose **pr\u00e9cis\u00e9ment** sur la fa\u00e7on d'\u00e9valuer les attributs d'un objet, aussi nous vous recommandons d'utiliser ce trait avec parcimonie."]}]
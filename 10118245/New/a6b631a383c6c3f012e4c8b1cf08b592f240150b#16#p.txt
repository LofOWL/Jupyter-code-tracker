[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Compr\u00e9hensions imbriqu\u00e9es"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ments - niveau interm\u00e9diaire "]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Imbrications"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["On peut \u00e9galement imbriquer plusieurs niveaux pour ne construire qu'une seule liste, comme par exemple\u00a0:"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 9, "lines": ["[n + p for n in [2, 4] for p in [10, 20, 30]]"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Bien s\u00fbr on peut aussi restreindre ces compr\u00e9hensions, comme par exemple\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 11, "lines": ["[n + p for n in [2, 4] for p in [10, 20, 30] if n*p >= 40]"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["Observez surtout que le r\u00e9sultat ci-dessus est une liste simple (de profondeur 1), \u00e0 comparer avec\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["[[n + p for n in [2, 4]] for p in [10, 20, 30]]"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["qui est de profondeur 2, et o\u00f9 les r\u00e9sultats atomiques apparaissent dans un ordre diff\u00e9rent."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Un moyen mn\u00e9motechnique pour se souvenir dans quel ordre les compr\u00e9hensions imbriqu\u00e9es produisent leur r\u00e9sultat, est de penser \u00e0 la version \"na\u00efve\" du code qui produirait le m\u00eame r\u00e9sultat\u00a0; dans ce code les clause `for` et `if` apparaissent **dans le m\u00eame ordre** que dans la compr\u00e9hension\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 10, "startIndex": 16, "lines": ["# notre exemple\u00a0:\n", "# [n + p for n in [2, 4] for p in [10, 20, 30] if n*p >= 40]\n", "\n", "# est \u00e9quivalent \u00e0 ceci\u00a0:\n", "resultat = []\n", "for n in [2, 4]:\n", "    for p in [10, 20, 30]:\n", "        if n*p >= 40:\n", "            resultat.append(n + p)\n", "resultat"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["### Ordre d'\u00e9valuation de `[[ .. for .. ] .. for .. ]`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Pour rappel, on peut imbriquer des compr\u00e9hensions de compr\u00e9hensions. Commen\u00e7ons par poser"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["n = 4"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["On peut alors cr\u00e9er une liste de listes comme ceci\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["[[(i, j) for i in range(1, j + 1)] for j in range(1, n + 1)]"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Et dans ce cas, tr\u00e8s logiquement, l'\u00e9valuation se fait **en commen\u00e7ant par la fin**, ou si on pr\u00e9f\u00e8re **\"par l'ext\u00e9rieur\"**, c'est-\u00e0-dire que le code ci-dessus est \u00e9quivalent \u00e0\u00a0:"]}, {"block": 19, "type": "code", "linesLength": 8, "startIndex": 32, "lines": ["# en version bavarde, pour illustrer l'ordre des \"for\"\n", "resultat_exterieur = []\n", "for j in range(1, n + 1):\n", "    resultat_interieur = []\n", "    for i in range(1, j + 1):\n", "        resultat_interieur.append((i, j))\n", "    resultat_exterieur.append(resultat_interieur)\n", "resultat_exterieur"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["### Avec `if`"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Lorsqu'on assortit les compr\u00e9hensions imbriqu\u00e9es de cette mani\u00e8re de clauses `if`, l'ordre d'\u00e9valuation est tout aussi logique. Par exemple, si on voulait se limiter - arbitrairement - aux lignes correspondant \u00e0 `j` pair, et aux diagonales o\u00f9 `i+j` est pair, on \u00e9crirait\u00a0:"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 42, "lines": ["[[(i, j) for i in range(1, j + 1) if (i + j)%2 == 0]\n", "         for j in range(1, n + 1) if j % 2 == 0]"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["ce qui est \u00e9quivalent \u00e0\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 10, "startIndex": 45, "lines": ["# en version bavarde \u00e0 nouveau\n", "resultat_exterieur = []\n", "for j in range(1, n + 1):\n", "    if j % 2 == 0:\n", "        resultat_interieur = []\n", "        for i in range(1, j + 1):\n", "            if (i + j) % 2 == 0:\n", "                resultat_interieur.append((i, j))\n", "        resultat_exterieur.append(resultat_interieur)\n", "resultat_exterieur"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Le point important ici est que l'**ordre** dans lequel il faut lire le code est **naturel**, et dict\u00e9 par l'imbrication des `[ .. ]`."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["## Compl\u00e9ments - niveau avanc\u00e9"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["### Les variables de boucle *fuitent*"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Nous avons d\u00e9j\u00e0 signal\u00e9 que les variables de boucle **restent d\u00e9finies** apr\u00e8s la sortie de la boucle, ainsi nous pouvons examiner\u00a0:"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 59, "lines": ["i, j"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["C'est pourquoi, afin de comparer les deux formes de compr\u00e9hension imbriqu\u00e9es nous allons explicitement retirer les variables `i` et `j` de l'environnement"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["del i, j"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["### Ordre d'\u00e9valuation de `[ .. for .. for .. ]`"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Toujours pour rappel, on peut \u00e9galement construire une compr\u00e9hension imbriqu\u00e9e mais **\u00e0 un seul niveau**. Dans une forme simple cela donne\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["[(x, y) for x in [1, 2] for y in [1, 2]]"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["**Avertissement** m\u00e9fiez-vous toutefois, car il est facile de ne pas voir du premier coup d'oeil qu'ici on \u00e9value les deux clauses `for` **dans un ordre diff\u00e9rent**."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Pour mieux le voir, essayons de reprendre la logique de notre tout premier exemple, mais avec une forme de double compr\u00e9hension *\u00e0 plat*\u00a0:"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["[ (i, j) for i in range(1, j + 1) for j in range(1, n + 1) ]"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["On obtient une erreur, l'interpr\u00e9teur se plaint \u00e0 propos de la variable `j` (c'est pourquoi nous l'avons effac\u00e9e de l'environnement au pr\u00e9alable)."]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Ce qui se passe ici, c'est que, comme nous l'avons d\u00e9j\u00e0 mentionn\u00e9 en semaine 3, le code que nous avons \u00e9crit est en fait \u00e9quivalent \u00e0\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 7, "startIndex": 70, "lines": ["# la version bavarde de cette imbrication \u00e0 plat, \u00e0 nouveau\u00a0:\n", "# [ (i, j) for i in range(1, j + 1) for j in range(1, n + 1) ]\n", "# serait\n", "resultat = []\n", "for i in range(1, j + 1):\n", "    for j in range(1, n + 1):\n", "        resultat.append((i, j))"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["Et dans cette version * d\u00e9pli\u00e9e* on voit bien qu'en effet on utilise `j` avant qu'elle ne soit d\u00e9finie."]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["### Conclusion"]}, {"block": 43, "type": "markdown", "linesLength": 3, "startIndex": 79, "lines": ["La possibilit\u00e9 d'imbriquer des compr\u00e9hensions avec plusieurs niveaux de `for` dans la m\u00eame compr\u00e9hension est un trait qui peut rendre service, car c'est une mani\u00e8re de simplifier la structure des entr\u00e9es (on passe essentiellement d'une liste de profondeur 2 \u00e0 une liste de profondeur 1).\n", "\n", "Mais il faut savoir ne pas en abuser, et rester conscient de la confusion qui peut en r\u00e9sulter, et en particulier \u00eatre prudent et prendre le temps de bien se relire. N'oublions pas non plus ces deux phrases du Zen de Python\u00a0: \"*Flat is better than nested*\" et surtout \"*Readability counts*\"."]}]
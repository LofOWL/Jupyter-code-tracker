[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Attributs de classe et attributs d'instance"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["Nous avons vu jusqu'\u00e0 pr\u00e9sent que l'on peut ajouter des attributs \u00e0 toutes sortes d'objets en python, et notamment \u00e0\n", " * un module,\n", " * une fonction,\n", " * une classe,\n", " * une instance de classe."]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 8, "lines": ["Et si on s'int\u00e9resse de plus pr\u00e8s aux deux derni\u00e8res cat\u00e9gories, nous avons vu \u00e9galement, si vous vous souvenez de la classe `Matrix2`, qu'**en r\u00e8gle g\u00e9n\u00e9rale** : \n", " * une **m\u00e9thode** est un attribut de la **classe**,\n", " * et que les **donn\u00e9es** qui d\u00e9crivent l'objet sont rang\u00e9es dans des attributs de l'**instance**."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["### Propos de ce compl\u00e9ment"]}, {"block": 6, "type": "markdown", "linesLength": 5, "startIndex": 12, "lines": ["Dans ce compl\u00e9ment, nous allons approfondir les notions d'attributs de classe et d'attributs d'instance. \n", "\n", "Le **premier point** que nous voulons illustrer ici est que le langage **ne fait pas la diff\u00e9rence** entre un attribut dont la valeur est du code (une fonction ou une m\u00e9thode), et un attribut contenant des donn\u00e9es.\n", "\n", "Le **second point** est qu'un attribut est cherch\u00e9 **en premier dans l'instance puis dans la classe**. "]}, {"block": 7, "type": "markdown", "linesLength": 5, "startIndex": 17, "lines": ["Pour illustrer tout ceci, nous allons voir que le langage permet \u00e9galement :\n", " * d'attacher des *donn\u00e9es \u00e0 une classe* - pour d\u00e9finir par exemple une valeur par d\u00e9faut valable pour toutes les instances de la classe, ou de\n", " * de *d\u00e9finir une m\u00e9thode sur une instance* - pour sp\u00e9cialiser un comportement pour un seul objet, et ainsi \u00e9viter de d\u00e9finir une nouvelle classe pour un seul objet. \n", " \n", "Nous d\u00e9montrons ce second usage, rare en pratique, dans la deuxi\u00e8me partie de ce compl\u00e9ment, qui est de niveau avanc\u00e9."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["### Un attribut de donn\u00e9e d\u00e9fini sur la classe"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Voyons, pour commencer, un exemple de classe avec un attribut de donn\u00e9es qui est en fait un attribut qui r\u00e9f\u00e9rence un objet *builtin* contenant des donn\u00e9es, typiquement `int`, `list` ou `str`."]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["class Spam:\n", "    attribut = \"attribut de classe\""]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Naturellement, on aurait pu aussi d\u00e9finir des m\u00e9thodes dans cette classe, mais nous avons choisi de montrer un exemple tr\u00e8s simple."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["La classe `Spam` poss\u00e8de donc maintenant l'attribut `attribut` qui vaut"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["Spam.attribut"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Cr\u00e9ons \u00e0 pr\u00e9sent deux instances de cette classe:"]}, {"block": 15, "type": "code", "linesLength": 4, "startIndex": 30, "lines": ["# une instance normale de Spam\n", "normal = Spam()\n", "# une instance sp\u00e9ciale de Spam - on va lui attacher un attribut\n", "special = Spam()"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["\u00c0 ce stade naturellement on peut acc\u00e9der \u00e0 l'attribut:"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["# depuis chacune des instances, ou depuis la classe\n", "print(f\"normal\u2192{normal.attribut},\\nspecial\u2192{special.attribut},\\nclasse\u2192{Spam.attribut}\")"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["On peut alors attacher \u00e0 une des instances un attribut `attribut`, comme on l'a d\u00e9j\u00e0 vu :"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["# on affecte l'attribut de l'instance\n", "special.attribut = \"attribut de l'instance\""]}, {"block": 20, "type": "code", "linesLength": 4, "startIndex": 40, "lines": ["# naturellement on retrouve cette valeur quand\n", "# on cherche l'attribut \u00e0 partir de l'instance\n", "# mais pour les deux autres acc\u00e8s rien ne change\n", "print(f\"normal\u2192{normal.attribut},\\nspecial\u2192{special.attribut},\\nclasse\u2192{Spam.attribut}\")"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["Le point important de ce compl\u00e9ment, c'est qu'une **instance** \u00e0 laquelle on n'a pourtant pas attach\u00e9 d'attribut `attribut` peut tout de m\u00eame **r\u00e9f\u00e9rencer** cet attribut et **trouver celui de la classe** comme si c'\u00e9tait le sien. "]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Voici \u00e0 toutes fins utiles le m\u00eame sc\u00e9nario sous ipythontutor:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["%load_ext ipythontutor"]}, {"block": 24, "type": "code", "linesLength": 9, "startIndex": 47, "lines": ["%%ipythontutor curInstr=4\n", "class Spam:\n", "    attribut = 'classatt'\n", "    \n", "normal = Spam()\n", "special = Spam()\n", "special.attribut = 'instatt'\n", "\n", "print(f\"normal\u2192{normal.attribut},\\nspecial\u2192{special.attribut},\\nclasse\u2192{Spam.attribut}\")"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["### Discussion"]}, {"block": 26, "type": "markdown", "linesLength": 5, "startIndex": 57, "lines": ["En fait, on a d\u00e9j\u00e0 vu ce m\u00e9canisme en action; c'est exactement la m\u00eame chose qui se passe lorsqu'on a :\n", " * une classe qui d\u00e9finit la m\u00e9thode `foo`\n", " * et une instance `obj` de la classe sur laquelle on appelle la m\u00e9thode en faisant\n", " \n", "```obj.foo()```"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Le m\u00e9canisme de **recherche d'un attribut sur une instance est le m\u00eame**, que cet attribut repr\u00e9sente une m\u00e9thode ou une donn\u00e9e. En effet, en python tout est un objet et un attribut peut r\u00e9f\u00e9rencer n'importer quel objet. \u00c7a n'est que lorsque l'interpr\u00e9teur python acc\u00e8de \u00e0 l'objet qu'il peut finalement conna\u00eetre son type. "]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["### Conclusion"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 64, "lines": ["Le m\u00e9canisme de recherche d'attributs, bien qu'extr\u00eamement simple, est tr\u00e8s souple et tr\u00e8s puissant. On peut attacher, au choix, **\u00e0 une instance ou \u00e0 une classe**, des attributs repr\u00e9sentant **n'importe quel objet**, et la recherche de ces attributs se fait dans l'ordre **instance** puis **classe**.\n", "\n", "Et nous verrons dans la prochaine vid\u00e9o que les m\u00e9canismes d'h\u00e9ritage ne font en fait que prolonger ce m\u00e9canisme de recherche d'attributs."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["### Un attribut de m\u00e9thode (re)d\u00e9fini sur une instance"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["D\u00e9finir un attribut de donn\u00e9es dans une classe, comme on vient de le voir, pr\u00e9sente un int\u00e9r\u00eat pratique; il est parfois commode de d\u00e9finir une constante, ou une valeur par d\u00e9faut, au niveau de la classe, qui s'applique alors \u00e0 tous les objets."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Nous allons \u00e0 pr\u00e9sent illustrer la possibilit\u00e9 de d\u00e9finir, \u00e0 l'inverse, une **m\u00e9thode au niveau d'une instance**. Comme ceci est rare en pratique, il s'agit ici de bien comprendre les m\u00e9canismes du langage plut\u00f4t que de d\u00e9couvrir une technique de programmation."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Pour cela nous prenons \u00e0 nouveau une classe jouet, avec une m\u00e9thode `the_name` qui est utilis\u00e9e pour l'impression, et que nous allons red\u00e9finir sur certaines instances:"]}, {"block": 35, "type": "code", "linesLength": 9, "startIndex": 72, "lines": ["class Eggs:\n", "    def __init__(self, name):\n", "        self.name = name\n", "    # la m\u00e9thode qu'on va red\u00e9finir\n", "    def the_name(self):\n", "        return f\"class({self.name})\"\n", "    # pour que \u00e7a se voie\n", "    def __repr__(self):\n", "        return f\"[[Eggs:{self.the_name()}]]\""]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Voici comment s'affiche une instance normale de cette classe:"]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 82, "lines": ["normal = Eggs('normal')\n", "print(normal)"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["##### \u00c0 partir d'une fonction sans argument"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["La fa\u00e7on la plus simple pour red\u00e9finir une m\u00e9thode sur une instance consiste \u00e0 attacher \u00e0 l'instance une **fonction**; toutefois, il faut noter que dans cette configuration le langage **ne passe pas l'instance en param\u00e8tre** \u00e0 la fonction."]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["Ceci est illustr\u00e9 ici:"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 87, "lines": ["Arr\u00eatons-nous un instant; souvenez-vous qu'avant de parler de classes on a parl\u00e9 de fonctions; on pourrait tr\u00e8s bien avoir envie de ranger dans un attribut une vraie fonction, et de l'appeler comme une fonction, mais pas comme une m\u00e9thode, c'est-\u00e0-dire sans mettre en \u0153uvre la *magie* qui consiste \u00e0 mettre l'instance elle-m\u00eame comme premier argument.\n", "\n", "C'est pour cette raison que lorsqu'une m\u00e9thode est attach\u00e9e \u00e0 une instance, l'instance elle m\u00eame n'est pas pass\u00e9e \u00e0 l'appel. Voyons cela de plus pr\u00e8s"]}, {"block": 42, "type": "code", "linesLength": 9, "startIndex": 90, "lines": ["# une instance sur laquelle on veut red\u00e9finir the_name()\n", "special0 = Eggs('special0')\n", "\n", "# pour cela on affecte l'attribut de l'instance\n", "# de sorte qu'il r\u00e9f\u00e9rence une fonction *SANS ARGUMENT*\n", "special0.the_name = lambda: \"SPECIAL-no-arg\"\n", "\n", "# et le r\u00e9sultat\n", "print(special0)"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["##### \u00c0 partir d'une fonction avec argument"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["Voyons \u00e0 pr\u00e9sent comment on pourrait obtenir le m\u00eame r\u00e9sultat, mais \u00e0 partir d'une fonction qui prend en argument une instance:"]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 101, "lines": ["# si maintenant on a une fonction avec un argument\n", "def redefined(self):\n", "    return f'SPECIAL+redefined+{self.name}'    "]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["Ce qu'il nous suffit de faire, c'est de produire une fonction sans argument \u00e0 partir de la fonction `redefined` et de l'instance qui nous int\u00e9resse; on appelle cela **une cl\u00f4ture**, en ce sens que l'instance est *captur\u00e9e* dans la fonction sans argument."]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["Une premi\u00e8re m\u00e9thode, un peu *ad hoc* pour y arriver, consisterait \u00e0 faire:"]}, {"block": 48, "type": "code", "linesLength": 8, "startIndex": 106, "lines": ["# red\u00e9finir une m\u00e9thode sur une instance (1/4)\n", "special1 = Eggs('special1')\n", "\n", "# on fabrique une cloture - une lambda sans argument -\n", "# dans laquelle on a \"captur\u00e9\" special1\n", "special1.the_name = lambda: redefined(special1)\n", "\n", "print(special1)"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Voyons une seconde m\u00e9thode, un peu plus propre, pour faire ceci; "]}, {"block": 50, "type": "code", "linesLength": 11, "startIndex": 115, "lines": ["# red\u00e9finir une m\u00e9thode sur une instance (2/4)\n", "\n", "# essentiellement la m\u00eame chose, \n", "# mais on fabrique la cl\u00f4ture avec l'utilitaire 'partial'\n", "from functools import partial\n", "\n", "special2 = Eggs('special2')\n", "\n", "special2.the_name = partial(redefined, special2)\n", "\n", "print(special2)"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["La diff\u00e9rence principale entre les approches pour `special1` et `special2` est que la seconde approche fonctionnerait avec un nombre quelconque d'arguments. Je veux dire: remarquez que dans notre cas concret, on veut red\u00e9finir une m\u00e9thode qui ne prend pas d'autre argument que l'instance; si cela n'\u00e9tait pas le cas, il faudrait modifier la cellule qui cr\u00e9e `special1`, mais on pourrait garder telle quelle la cellule qui cr\u00e9e `special2`."]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["Enfin, et uniquement pour d\u00e9mystifier compl\u00e8tement cette fonction `partial`, en voici deux impl\u00e9mentations possibles; \u00e0 nouveau notre unique objectif ici est de bien d\u00e9cortiquer les m\u00e9canismes du langage: "]}, {"block": 53, "type": "code", "linesLength": 6, "startIndex": 128, "lines": ["# une impl\u00e9mentation possible pour functools.partial\n", "\n", "def mypartial1(function, instance, *args):\n", "    def projection(*args):\n", "        return function(instance, *args)\n", "    return projection"]}, {"block": 54, "type": "code", "linesLength": 6, "startIndex": 134, "lines": ["# red\u00e9finir une m\u00e9thode sur une instance (3/4)\n", "special3 = Eggs('special3')\n", "\n", "special3.the_name = mypartial1(redefined, special3)\n", "\n", "print(special3)"]}, {"block": 55, "type": "code", "linesLength": 4, "startIndex": 140, "lines": ["# ou encore, totalement \u00e9quivalent mais\n", "# \u00e0 base de lambda plut\u00f4t que de def:\n", "def mypartial2(function, instance, *args):\n", "    return lambda *args: function(instance, *args)"]}, {"block": 56, "type": "code", "linesLength": 6, "startIndex": 144, "lines": ["# red\u00e9finir une m\u00e9thode sur une instance (4/4)\n", "special4 = Eggs('special4')\n", "\n", "special4.the_name = mypartial2(redefined, special4)\n", "\n", "print(special4)"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 150, "lines": ["##### Note par rapport \u00e0 python2"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["Le sujet des m\u00e9thodes attach\u00e9es \u00e0 une instance a \u00e9t\u00e9 assez profond\u00e9ment modifi\u00e9 entre python2 et python3; notamment la notion de *unbound method* a \u00e9t\u00e9 rendue obsol\u00e8te en python3."]}]
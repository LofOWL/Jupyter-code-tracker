[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# Op\u00e9ration avanc\u00e9es en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Introduction"]}, {"block": 4, "type": "markdown", "linesLength": 5, "startIndex": 9, "lines": ["Pandas supporte des op\u00e9rations de manipulation des Series et DataFrame qui sont similaires dans l'esprit \u00e0 ce que l'on peut faire avec une base de donn\u00e9es et le langage SQL, mais de mani\u00e8re plus intuitive et expressive et beaucoup plus efficacement puisque les op\u00e9rations se d\u00e9roulent toutes en m\u00e9moire. \n", "\n", "Vous pouvez concat\u00e9ner (`concat`) des DataFrame, faire des jointures (`merge`), faire des regroupements (`groupby`) ou r\u00e9organiser les indexes (`pivot`).\n", "\n", "Nous allons dans la suite d\u00e9velopper ces diff\u00e9rentes techniques. "]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Concat\u00e9nations avec `concat`"]}, {"block": 6, "type": "code", "linesLength": 0, "startIndex": 15, "lines": []}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["`concat` est utilis\u00e9 pour concat\u00e9ner des Series ou des DataFrames. Regardons un exemple."]}, {"block": 8, "type": "code", "linesLength": 6, "startIndex": 16, "lines": ["import numpy as np\n", "import pandas as pd\n", "\n", "s1 = pd.Series([30, 35], index=['alice', 'bob'])\n", "s2 = pd.Series([32, 22, 29], index=['bill', 'alice', 'jo'])\n", "pd.concat([s1, s2])"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["On remarque, cependant, que par d\u00e9faut il n'y a pas de contr\u00f4le sur les labels d'indexe dupliqu\u00e9s. On peut corriger cela avec l'argument `verify_integrity` qui va produire une exception s'il y a des labels d'indexes qui ont un recouvrement. \u00c9videmment, cela a un co\u00fbt de calcul suppl\u00e9mentaire, \u00e7a n'est donc \u00e0 utiliser que si c'est n\u00e9cessaire."]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["try:\n", "    pd.concat([s1, s2], verify_integrity=True)\n", "except ValueError as e:\n", "    print(f\"erreur de concat\u00e9nation:\\n{e}\")"]}, {"block": 11, "type": "code", "linesLength": 8, "startIndex": 27, "lines": ["# cr\u00e9ons deux series avec les index sans recouvrement\n", "s1 = pd.Series(range(1000), index=[chr(x) for x in range(1000)])\n", "s2 = pd.Series(range(1000), index=[chr(x+2000) for x in range(1000)])\n", "\n", "# temps de concat\u00e9nation avec v\u00e9rification des recouvrements\n", "%timeit pd.concat([s1, s2], verify_integrity=True)\n", "# temps de concat\u00e9nation sans v\u00e9rification des recouvrements\n", "%timeit pd.concat([s1, s2])"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Par d\u00e9faut, `concat` concat\u00e8ne les lignes, c'est-\u00e0-dire que `s2` sera sous `s1`, mais on peut changer ce comportement un utilisant l'argument `axis`."]}, {"block": 13, "type": "code", "linesLength": 6, "startIndex": 36, "lines": ["p1 = pd.DataFrame(np.random.randint(1, 10, size=(2,2)), columns=list('ab'), index=list('xy'))\n", "p2 = pd.DataFrame(np.random.randint(1, 10, size=(2,2)), columns=list('ab'), index=list('zt'))\n", "\n", "# \u00e9quivalent \u00e0 pd.concat([p1, p2], axis=0)\n", "# concat\u00e9nation des lignes\n", "pd.concat([p1, p2])"]}, {"block": 14, "type": "code", "linesLength": 5, "startIndex": 42, "lines": ["p1 = pd.DataFrame(np.random.randint(1, 10, size=(2,2)), columns=list('ab'), index=list('xy'))\n", "p2 = pd.DataFrame(np.random.randint(1, 10, size=(2,2)), columns=list('cd'), index=list('xy'))\n", "\n", "# concat\u00e9nation des colonnes\n", "pd.concat([p1, p2], axis=1)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Regardons maintenant ce cas."]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["pd.concat([p1, p2])\n"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Vous remarquez que lors de la concat\u00e9nation, on prend l'union des tous les labels des indexes de `p1` et `p2`, il y a donc des valeurs mises \u00e0 `NaN`. On peut contr\u00f4ler ce comportement de plusieurs mani\u00e8res que vous allons voir ci-dessous."]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 50, "lines": ["# on concat\u00e8ne les lignes, l'argument join d\u00e9cide quels labels sur l'autre \n", "# axe on garde (ici sur les colonnes). \n", "\n", "#Par d\u00e9faut, join utilise la strat\u00e9gie 'outer', c'est-\u00e0-dire \n", "# qu'on prend la concat\u00e9nation des labels, si on sp\u00e9cifie 'inner' on prend \n", "# l'intersection des labels\n", "pd.concat([p1, p2], join='inner')"]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 57, "lines": ["# avec join_axes, on peut sp\u00e9cifier les labels qu'on veut garder sous forme \n", "# d'un objet Index\n", "pd.concat([p1, p2], join_axes=[p1.columns])"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["pd.concat([p1, p2], join_axes=[pd.Index(['a', 'c'])])"]}, {"block": 21, "type": "markdown", "linesLength": 5, "startIndex": 61, "lines": ["Notons que les Series et DataFrame ont une m\u00e9thode `append` qui est un raccourci vers `concat`, mais avec moins d'options. \n", "\n", "Pour aller plus loin, voici la documentation officielle : \n", "\n", "http://pandas.pydata.org/pandas-docs/stable/merging.html#concatenating-objects"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["### Jointures avec `merge`"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["`merge` est dans l'esprit similaire au `join` en SQL. L'id\u00e9e est de combiner deux DataFrame en fonction d'un crit\u00e8re d'\u00e9galit\u00e9 sur des colonnes. Regardons un exemple."]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 68, "lines": ["df1 = pd.DataFrame({'employee': ['Bob', 'Lisa', 'Sue'],\n", "                    'group': ['Accounting', 'Engineering', 'HR']})\n", "df2 = pd.DataFrame({'employee': ['Lisa', 'Bob', 'Sue'],\n", "                    'hire_date': [2004, 2008, 2014]})"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 72, "lines": ["print(df1)\n", "print(df2)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["On souhaite ici combiner `df1` et `df2` de mani\u00e8re \u00e0 ce que les lignes contenant le m\u00eame _employee_ soit align\u00e9es. Notre crit\u00e8re de merge est donc l'\u00e9galit\u00e9 des labels sur la colonne _employee_."]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 75, "lines": ["pd.merge(df1, df2)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Par d\u00e9faut, `merge` fait un inner join (ou jointure interne) en utilisant comme crit\u00e8re de jointure les colonnes de m\u00eame nom (ici _employee_). _inner join_ veut dire que pour joindre deux lignes il faut que le m\u00eame _employee_ apparaisse dans les deux DataFrame. "]}, {"block": 29, "type": "markdown", "linesLength": 12, "startIndex": 77, "lines": ["Il existe trois type de merges.\n", "\n", " - one-to-one, c'est celui que l'on vient de voir. C'est le merge lorqu'il n'y a pas de labels dupliqu\u00e9s dans les colonnes utilis\u00e9es comme crit\u00e8re de merge.\n", " \n", " - many-to-one, c'est le merge lorsque l'une des deux colonnes contient des labels dupliqu\u00e9s, dans ce cas, on applique la strat\u00e9gie one-to-one pour chaque lable dupliqu\u00e9, donc les entr\u00e9es dupliqu\u00e9es sont pr\u00e9serv\u00e9es.\n", " \n", " - many-to-many, c'est la strat\u00e9gie lorsqu'il y a des entr\u00e9es dupliqu\u00e9es dans les deux colonnes. Dans ce cas on fait un produit cart\u00e9sien des lignes. \n", " \n", "D'une mani\u00e8re g\u00e9n\u00e9rale, gardez en t\u00eate que pandas fait essentiellement ce \u00e0 quoi on s'attend. Regardons cela sur des exemples.\n", " \n", " \n", " "]}, {"block": 30, "type": "code", "linesLength": 6, "startIndex": 89, "lines": ["df1 = pd.DataFrame({'patient': ['Bob', 'Lisa', 'Sue'],\n", "                    'repas': ['SS', 'SS', 'SSR']})\n", "df2 = pd.DataFrame({'repas': ['SS', 'SSR'],\n", "                    'explication': ['sans sel', 'sans sucre']})\n", "print(df1)\n", "print(df2)"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 95, "lines": ["# la colonne commune pour le merge est 'repas' et dans une des colonnes \n", "# (sur df1), il y a des labels dupliqu\u00e9s, on applique la strat\u00e9gie many-to-one\n", "pd.merge(df1, df2)"]}, {"block": 32, "type": "code", "linesLength": 6, "startIndex": 98, "lines": ["df1 = pd.DataFrame({'patient': ['Bob', 'Lisa', 'Sue'],\n", "                    'repas': ['SS', 'SS', 'SSR']})\n", "df2 = pd.DataFrame({'repas': ['SS', 'SS', 'SSR'],\n", "                    'explication': ['sans sel', 'l\u00e9gumes', 'sans sucre']})\n", "print(df1)\n", "print(df2)"]}, {"block": 33, "type": "code", "linesLength": 3, "startIndex": 104, "lines": ["# la colonne commune pour le merge est 'repas' et dans les des colonnes \n", "# il y a des labels dupliqu\u00e9s, on applique la strat\u00e9gie many-to-many\n", "pd.merge(df1,df2)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["Dans un merge, on peut contr\u00f4ler les colonnes \u00e0 utiliser comme crit\u00e8re de merge. Regardons ces diff\u00e9rents cas sur des exemples."]}, {"block": 35, "type": "code", "linesLength": 6, "startIndex": 108, "lines": ["df1 = pd.DataFrame({'employee': ['Bob', 'Lisa', 'Sue'],\n", "                    'group': ['Accounting', 'Engineering', 'HR']})\n", "df2 = pd.DataFrame({'employee': ['Lisa', 'Bob', 'Sue'],\n", "                    'hire_date': [2004, 2008, 2014]})\n", "print(df1)\n", "print(df2)"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 114, "lines": ["# on d\u00e9cide d'utiliser la colonne 'employee' comme crit\u00e8re de merge\n", "pd.merge(df1, df2, on='employee')"]}, {"block": 37, "type": "code", "linesLength": 6, "startIndex": 116, "lines": ["df1 = pd.DataFrame({'employee': ['Bob', 'Lisa', 'Sue'],\n", "                    'group': ['Accounting', 'Engineering', 'HR']})\n", "df2 = pd.DataFrame({'name': ['Lisa', 'Bob', 'Sue'],\n", "                    'hire_date': [2004, 2008, 2014]})\n", "print(df1)\n", "print(df2)"]}, {"block": 38, "type": "code", "linesLength": 4, "startIndex": 122, "lines": ["# mais on peut \u00e9galement d\u00e9finir un nom de colonne diff\u00e9rent \n", "# \u00e0 gauche et \u00e0 droite\n", "m = pd.merge(df1,df2, left_on='employee', right_on='name')\n", "print(m)"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 126, "lines": ["# dans ce cas, comme on garde les colonnes utilis\u00e9es comme crit\u00e8re dans \n", "# le r\u00e9sultat du merge, on peut effacer la colonne inutile ainsi\n", "m.drop('name', axis=1)\n"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["`merge` permet \u00e9galement de contr\u00f4ler la strat\u00e9gie \u00e0 appliquer lorsqu'il y a des valeurs dans une colonne utilis\u00e9e comme crit\u00e8re merge absente dans l'autre colonne. C'est ce que l'on appelle jointure \u00e0 gauche, jointure \u00e0 droite, jointure interne (comportement par d\u00e9faut) et jointure externe. Pour ceux qui ne sont pas famili\u00e9 avec ces notions, regardons des exemples. "]}, {"block": 41, "type": "code", "linesLength": 6, "startIndex": 130, "lines": ["df1 = pd.DataFrame({'name': ['Bob', 'Lisa', 'Sue'],\n", "                    'pulse': [70, 63, 81]})\n", "df2 = pd.DataFrame({'name': ['Eric', 'Bob', 'Marc'],\n", "                    'weight': [60, 100, 70]})\n", "print(df1)\n", "print(df2)"]}, {"block": 42, "type": "code", "linesLength": 5, "startIndex": 136, "lines": ["# la colonne 'name' est crit\u00e8re de merge dans les deux DataFrame.\n", "# Seul Bob existe dans les deux colonnes. Dans un inner join \n", "# (le cas par d\u00e9faut) on ne garde que les lignes pour lesquels il y a une \n", "# m\u00eame valeur pr\u00e9sente \u00e0 gauche et \u00e0 droite\n", "pd.merge(df1, df2) # \u00e9quivalent \u00e0 pd.merge(df1, df2, how='inner')"]}, {"block": 43, "type": "code", "linesLength": 3, "startIndex": 141, "lines": ["# le outer join va au contraire faire une union des lignes et compl\u00e9ter ce \n", "# qui manque avec NaN\n", "pd.merge(df1, df2, how='outer')"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 144, "lines": ["# le left join ne garde que les valeurs de la colonne de gauche \n", "pd.merge(df1, df2, how='left')"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 146, "lines": ["# et le right join ne garde que les valeurs de la colonne de droite \n", "pd.merge(df1, df2, how='right')"]}, {"block": 46, "type": "markdown", "linesLength": 3, "startIndex": 148, "lines": ["Pour aller plus loin, vous pouvez lire la documentation. Vous verrez notamment que vous pouvez merger sur les indexes (au lieu des colonnes) ou le cas ou vous avez des colonnes de m\u00eame noms qui ne font pas partie du crit\u00e8re de merge&nbsp;:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/merging.html#database-style-dataframe-joining-merging"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["### Regroupement avec `groupby`"]}, {"block": 48, "type": "markdown", "linesLength": 8, "startIndex": 152, "lines": ["Regardons maintenant cette notion de groupement. Il s'agit d'une notion tr\u00e8s puissante avec de nombreuses options que nous ne couvrirons que partiellement. \n", "La logique derri\u00e8re `groupby` est de cr\u00e9er des groupes dans une DataFrame en fonction des valeurs d'une (ou plusieurs) colonne(s), toutes les lignes contenant la m\u00eame valeur sont dans le m\u00eame groupe. On peut ensuite appliquer \u00e0 chaque groupe des op\u00e9rations qui sont :\n", "\n", " - soit des calculs sur chaque groupe ;\n", " - soit un filtre sur chaque groupe qui peut garder ou supprimer un groupe ;\n", " - soit une transformation qui va modifier tout le groupe (par exemple, pour centrer les valeurs sur la moyenne du groupe).\n", " \n", "Regardons quelques exemples."]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 160, "lines": ["d = pd.DataFrame({'key': list('ABCABC'), 'val': range(6)})\n", "print(d)"]}, {"block": 50, "type": "code", "linesLength": 3, "startIndex": 162, "lines": ["# utilisons comme colonne de groupement 'key'\n", "g = d.groupby('key')\n", "print(g)\n"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 165, "lines": ["`groupby` produit un nouvel objet, mais ne fait aucun calcul. Les calculs seront affectu\u00e9s lors de l'appel de fonction sur ce nouvel objet. Par exemple, calculons la somme pour chaque groupe."]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 166, "lines": ["g.sum()"]}, {"block": 53, "type": "markdown", "linesLength": 3, "startIndex": 167, "lines": ["`groupby` peut utiliser comme crit\u00e8re de groupement une colonne, une liste de colonne, ou un index (c'est notamment utile pour les Series). \n", "\n", "On particularit\u00e9 de `groupby` est que le crit\u00e8re de groupement devient un index dans le nouvel objet g\u00e9n\u00e9r\u00e9. L'avantage est que l'on a maintenant un acc\u00e8s optimis\u00e9 sur ce crit\u00e8re, mais l'inconv\u00e9nient est que sur certaines op\u00e9rations qui d\u00e9truise l'index on peut perdre ce crit\u00e8re. On peut contr\u00f4ler ce comportement avec `as_index`."]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 170, "lines": ["g = d.groupby('key', as_index=False)\n", "g.sum()"]}, {"block": 55, "type": "markdown", "linesLength": 0, "startIndex": 172, "lines": []}]
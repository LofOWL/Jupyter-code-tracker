[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["It\u00e9rable et it\u00e9rateur"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau basique"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["Nous r\u00e9sumons dans ce compl\u00e9ment les notions d'iterable et d'it\u00e9rat"]}, {"block": 3, "type": "heading", "linesLength": 1, "startIndex": 3, "lines": ["It\u00e9rable"]}, {"block": 4, "type": "markdown", "linesLength": 7, "startIndex": 4, "lines": ["On appelle **it\u00e9rable** un objet qui peut \u00eatre **l'objet d'une boucle `for`**\n", "\n", "Pour qu'un objet soit it\u00e9rable il faut  \n", " * qu'il dispose d'une m\u00e9thode `__iter__()` qui renvoie un **it\u00e9rateur**\n", " * ou qu'il dispose d'une m\u00e9thode `__getitem__()` qui permette un acc\u00e8s s\u00e9quentiel par des indices commen\u00e7ant \u00e0 0. \n", "    \n", "Le second point s'applique \u00e0 quelques types builtin comme `str` (qui donc n'a pas de m\u00e9thode `__iter__()`), mais en r\u00e8gle g\u00e9n\u00e9rale on est dans le premier cas, et nous y reviendrons en semaine 6 lorsque nous verrons comment rendre nos objets it\u00e9rables."]}, {"block": 5, "type": "heading", "linesLength": 1, "startIndex": 11, "lines": ["It\u00e9rateur"]}, {"block": 6, "type": "markdown", "linesLength": 5, "startIndex": 12, "lines": ["Un it\u00e9rateur est donc **attach\u00e9 \u00e0 un it\u00e9rable**, et sa fonction est de **m\u00e9moriser l'\u00e9tat d'une it\u00e9ration** sur cet it\u00e9rable.\n", "\n", "La fa\u00e7on usuelle d'impl\u00e9menter un it\u00e9rable consiste \u00e0 exposer une m\u00e9thode `next()` qui renvoie l'item suivant \u00e0 balayer lors de l'it\u00e9ration, ou de lever l'exception `StopIteration` en fin de boucle.\n", "\n", "Notez qu'en python3 on a renomm\u00e9 `next` en `__next__`, ce qui est plus en accord avec la convention de nommage des m\u00e9thodes qui permettent de red\u00e9finir le comportement du langage sur des types utilisateur."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["De mani\u00e8re \u00e0 rendre un it\u00e9rateur it\u00e9rable, on adopte la convention qu'un it\u00e9rateur doit \u00e9galement impl\u00e9menter la m\u00e9thode `__iter__()` et dans ce cas-l\u00e0 naturellement l'it\u00e9rateur est son propre it\u00e9rateur. "]}, {"block": 8, "type": "heading", "linesLength": 1, "startIndex": 18, "lines": ["Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Voyons tout ceci sur un exemple simple"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Il y a une diff\u00e9rence de taille toutefois, c'est qu`\u00e0 chaque fois qu'on fait une boucle sur l'it\u00e9rable on rapelle `__iter__()`, ce qui a pour r\u00e9sultat de cr\u00e9er un nouvel it\u00e9rateur:"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["En fait l'iterateur a \u00e9t\u00e9 mis \u00e0 contribution deux fois et a signal\u00e9 la fin de la boucle."]}]
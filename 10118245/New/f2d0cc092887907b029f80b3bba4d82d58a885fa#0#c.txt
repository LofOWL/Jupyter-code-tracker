[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Ensembles"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau basique"]}, {"block": 2, "type": "markdown", "linesLength": 2, "startIndex": 2, "lines": ["Ce document r\u00e9sume les op\u00e9rations courantes disponibles sur le type `set`.\n", "On rappelle que le type `set` est un type **mutable**."]}, {"block": 3, "type": "heading", "linesLength": 1, "startIndex": 4, "lines": ["Cr\u00e9ation en extension"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["On cr\u00e9e un ensemble avec les accolades, comme les dictionnaires (mais sans utiliser le caract\u00e8re `:`) et cela donne par exemple"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 6, "lines": ["heteroclite = { 'marc', 12, 'pierre', (1,2,3), 'pierre'}\n", "print heteroclite"]}, {"block": 6, "type": "heading", "linesLength": 1, "startIndex": 8, "lines": ["Cr\u00e9ation - la fonction `set`"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Il devrait \u00eatre clair \u00e0 ce stade que, le nom du type \u00e9tant `set`, la fonction `set` est un constructeur d'ensembles. On aurait donc aussi bien pu faire"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 10, "lines": ["heteroclite2 = set ( ['marc', 12, 'pierre', (1,2,3), 'pierre' ])\n", "print heteroclite2"]}, {"block": 9, "type": "heading", "linesLength": 1, "startIndex": 12, "lines": ["Un \u00e9l\u00e9ment dans un ensemble doit \u00eatre globalement immutable"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["On a vu pr\u00e9c\u00e9demment que les cl\u00e9s dans un dictionnaire doivent \u00eatre globalement immutables. Pour exactement les m\u00eames raisons, les \u00e9l\u00e9ments d'un ensemble doivent aussi \u00eatre globalement immutables."]}, {"block": 11, "type": "raw", "linesLength": 5, "startIndex": 14, "lines": ["# on ne peut pas ins\u00e9rer un tuple qui contient une liste\n", ">>> ensemble = { ( 1, 2, [ 3,4] ) }\n", "Traceback (most recent call last):\n", "  File \"<stdin>\", line 1, in <module>\n", "TypeError: unhashable type: 'list'"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Le type `set` \u00e9tant lui-m\u00eame mutable, on ne peut pas cr\u00e9er un ensemble d'ensembles"]}, {"block": 13, "type": "raw", "linesLength": 4, "startIndex": 20, "lines": [">>> ensemble = { { 1,2} }\n", "Traceback (most recent call last):\n", "  File \"<stdin>\", line 1, in <module>\n", "TypeError: unhashable type: 'set'"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Et c'est une des raisons d'\u00eatre du type `frozenset`."]}, {"block": 15, "type": "heading", "linesLength": 1, "startIndex": 25, "lines": ["Cr\u00e9ation - la fonction `frozenset`"]}, {"block": 16, "type": "markdown", "linesLength": 3, "startIndex": 26, "lines": ["Il n'existe pas de raccourci syntaxique comme les `{}` pour cr\u00e9er un ensemble immutable, qui doit \u00eatre cr\u00e9\u00e9 avec la fonction `frozenset`. Toutes les op\u00e9rations document\u00e9es dans ce notebook, et qui n'ont pas besoin de modifier l'ensemble, sont disponibles sur un `frozenset`. \n", "\n", "Parmi les fonctions exclues sur un `frozenset`, on peut citer, sans doute non exhaustivement :  `update`, `pop`, `clear`, `remove`, `discard` ..."]}, {"block": 17, "type": "heading", "linesLength": 1, "startIndex": 29, "lines": ["Op\u00e9rations simples"]}, {"block": 18, "type": "heading", "linesLength": 1, "startIndex": 30, "lines": ["Test d'appartenance"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["(1,2,3) in heteroclite"]}, {"block": 20, "type": "heading", "linesLength": 1, "startIndex": 32, "lines": ["Cardinal"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["len(heteroclite)"]}, {"block": 22, "type": "heading", "linesLength": 1, "startIndex": 34, "lines": ["Manipulations"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["ensemble = { 1, 2, 1}\n", "ensemble"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 37, "lines": ["# pour nettoyer\n", "ensemble.clear()\n", "ensemble"]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 40, "lines": ["# ajouter un element\n", "ensemble.add ( 1 )\n", "ensemble"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 43, "lines": ["# ajouter tous les elements d'un autre *ensemble*\n", "ensemble.update ( { 2, (1,2,3), (1,3,5)})\n", "ensemble"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 46, "lines": ["# enlever un element avec discard\n", "ensemble.discard ((1,3,5,))\n", "ensemble"]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 49, "lines": ["# discard fonctionne m\u00eame si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent\n", "ensemble.discard( 'foo' )\n", "ensemble"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 52, "lines": ["# enlever un \u00e9l\u00e9ment avec remove\n", "ensemble.discard ((1,2,3,))\n", "ensemble"]}, {"block": 30, "type": "code", "linesLength": 5, "startIndex": 55, "lines": ["# contrairement \u00e0 discard, l'\u00e9l\u00e9ment qui doit \u00eatre pr\u00e9sent\n", "try:\n", "    ensemble.remove ('foo')\n", "except KeyError as e:\n", "    print \"remove a lev\u00e9 l'exception\",e"]}, {"block": 31, "type": "code", "linesLength": 6, "startIndex": 60, "lines": ["# pop() ressemble \u00e0 la m\u00e9thode \u00e9ponyme sur les listes\n", "# sauf qu'il n'y a pas d'ordre dans un ensemble\n", "while ensemble:\n", "    element = ensemble.pop()\n", "    print \"element\",element\n", "print \"et bien s\u00fbr maintenant l'ensemble est vide\", ensemble"]}, {"block": 32, "type": "heading", "linesLength": 1, "startIndex": 66, "lines": ["Op\u00e9rations classiques sur les ensembles"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Donnons nous deux ensembles simples"]}, {"block": 34, "type": "code", "linesLength": 4, "startIndex": 68, "lines": ["A2 = { 2 * x for x in range(4) }\n", "print 'A2',A2\n", "A3 = { 3 * x for x in range (3)}\n", "print 'A3',A3"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["N'oubliez pas que les ensembles, comme les dictionnaires, ne sont **pas ordonn\u00e9s**."]}, {"block": 36, "type": "markdown", "linesLength": 3, "startIndex": 73, "lines": ["**Remarques** \n", " * Les notations des op\u00e9rateurs sur les ensembles rappellent les op\u00e9rateurs \"bit-\u00e0-bit\" sur les entiers.\n", " * Ces op\u00e9rateurs sont \u00e9galement disponibles sous la forme de m\u00e9thodes"]}, {"block": 37, "type": "heading", "linesLength": 1, "startIndex": 76, "lines": ["Union"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["A2 | A3"]}, {"block": 39, "type": "heading", "linesLength": 1, "startIndex": 78, "lines": ["Intersection"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 79, "lines": ["A2 & A3"]}, {"block": 41, "type": "heading", "linesLength": 1, "startIndex": 80, "lines": ["Diff\u00e9rence"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 81, "lines": ["A2 - A3"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["A3 - A2"]}, {"block": 44, "type": "heading", "linesLength": 1, "startIndex": 83, "lines": ["Diff\u00e9rence sym\u00e9trique"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["On rappelle que $ A \\Delta B = (A - B) \\cup (B - A) $ "]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 85, "lines": ["A2 ^ A3"]}, {"block": 47, "type": "heading", "linesLength": 1, "startIndex": 86, "lines": ["Comparaisons"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Ici encore on se donne deux ensembles"]}, {"block": 49, "type": "code", "linesLength": 4, "startIndex": 88, "lines": ["superset = { 0, 1, 2, 3 }\n", "print 'superset', superset\n", "subset =  { 1, 3 }\n", "print 'subset', subset"]}, {"block": 50, "type": "heading", "linesLength": 1, "startIndex": 92, "lines": ["\u00c9galit\u00e9"]}, {"block": 51, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["heteroclite == heteroclite2"]}, {"block": 52, "type": "heading", "linesLength": 1, "startIndex": 94, "lines": ["Inclusion"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 95, "lines": ["subset <= superset"]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 96, "lines": ["subset < superset"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 97, "lines": ["heteroclite < heteroclite2"]}, {"block": 56, "type": "heading", "linesLength": 1, "startIndex": 98, "lines": ["Ensembles disjoints"]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 99, "lines": ["heteroclite.isdisjoint(A3)"]}, {"block": 58, "type": "heading", "linesLength": 1, "startIndex": 100, "lines": ["Pour en savoir plus"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["Reportez vous \u00e0 [la section sur les ensembles](https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset) dans la documentation python"]}]
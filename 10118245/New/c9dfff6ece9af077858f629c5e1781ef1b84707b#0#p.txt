[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `DataFrame` en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Cr\u00e9ation d'une `DataFrame`"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Une `DataFrame` est un tableau numpy \u00e0 deux dimensions avec un index pour les lignes et un index pour les colonnes. Il y a de nombreuses mani\u00e8res de construire une `DataFrame`."]}, {"block": 5, "type": "code", "linesLength": 16, "startIndex": 10, "lines": ["# Regardons la construction d'une DataFrame\n", "import numpy as np\n", "import pandas as pd\n", "\n", "# Cr\u00e9ons une Serie pour d\u00e9finir des ages\n", "age = pd.Series([30, 20, 50], index=['alice', 'bob', 'julie'])\n", "\n", "# et une Serie pour d\u00e9finir des tailles\n", "height = pd.Series([150, 170, 168], index=['alice', 'marc', 'julie'])\n", "\n", "# On peut maintenant combiner ces deux Series en DataFrame,\n", "# chaque Series d\u00e9finissant une colonne, une mani\u00e8re de le faire est\n", "# de d\u00e9finir un dictionnaire qui contient pour clef le nom de la colonne\n", "# et pour valeur la Series correspondante\n", "stat = pd.DataFrame({'age': age, 'height': height})\n", "print(stat)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["On remarque que pandas fait automatiquement l'alignement des index, lorsqu'une valeur n'est pas pr\u00e9sente, elle est automatiquement remplac\u00e9e par `NaN`. Pandas va \u00e9galement broadcaster une valeur unique d\u00e9finissant un colonne sur toutes les lignes. Regardons cela\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["stat = pd.DataFrame({'age': age, 'height': height, 'city': 'Nice'})\n", "print(stat)"]}, {"block": 8, "type": "code", "linesLength": 4, "startIndex": 29, "lines": ["# On peut maintenant acc\u00e9der aux index des lignes et des colonnes\n", "\n", "# l'index des lignes\n", "print(stat.index)"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 33, "lines": ["# l'index des colonnes\n", "print(stat.columns)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Il y a de nombreuses mani\u00e8res d'acc\u00e9der aux \u00e9l\u00e9ments de la `DataFrame`, certaines sont bonnes et d'autres \u00e0 proscrire, commen\u00e7ons par prendre de bonnes habitudes. Comme il s'agit d'une structure \u00e0 deux dimensions, il faut donner un indice de ligne et de colonne."]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 36, "lines": ["# Quel est l'\u00e2ge de alice\n", "a = stat.loc['alice', 'age']"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["# a est un flottant\n", "type(a), a"]}, {"block": 13, "type": "code", "linesLength": 4, "startIndex": 40, "lines": ["# Quel est la moyenne de tous les ages\n", "c = stat.loc[:, 'age']\n", "m = c.mean()\n", "print(f\"L'\u00e2ge moyen est de {m:.1f} ans.\")"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 44, "lines": ["# c est une Series\n", "type(c)"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 46, "lines": ["# et m est un flottant\n", "type(m)"]}, {"block": 16, "type": "markdown", "linesLength": 5, "startIndex": 48, "lines": ["On peut d\u00e9j\u00e0 noter plusieurs choses int\u00e9ressantes\u00a0:\n", "\n", "- On peut utiliser `.loc[]` et `.iloc` comme pour les `Series`. Pour les `DataFrame` c'est encore plus important parce qu'il y a plus de risques d'ambigu\u00eft\u00e9s (notamment entre les lignes et les colonnes, on y reviendra)\u00a0;\n", "\n", "- la m\u00e9thode `mean` calcule la moyenne, \u00e7a n'est pas surprenant, mais ignore les `NaN`. C'est en g\u00e9n\u00e9ral ce que l'on veut. Si vous vous demandez comment savoir si la m\u00e9thode que vous utilisez ignore ou pas les `NaN`, le mieux est de regarder l'aide de cette m\u00e9thode. Il existe pour un certain nombre de m\u00e9thodes avec deux versions\u00a0: une qui ignore les `NaN` et une autre qui les prend en compte\u00a0; on en reparlera."]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Une autre mani\u00e8re de construire une `DataFrame` est de partir d'un `array` numpy, et de sp\u00e9cifier les index pour les lignes et les colonnes avec les arguments `index` et `columns`\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 54, "lines": ["a = np.random.randint(1, 20, 9).reshape(3, 3)\n", "p = pd.DataFrame(a, index=['a', 'b', 'c'], columns=['x', 'y', 'z'])\n", "print(p)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["### Importation et exportation de donn\u00e9es"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["En pratique, il est tr\u00e8s fr\u00e9quent que les donn\u00e9es qu'on manipule soient stock\u00e9es dans un fichier ou une base de donn\u00e9es. Il existe en pandas de nombreux utilitaires pour importer et exporter des donn\u00e9es et les convertir automatiquement en `DataFrame`. Vous pouvez importer ou exporter du CSV, JSON, HTML, Excel, HDF5, SQL, python pickle, etc."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["\u00c0 titre d'illustration \u00e9crivons la `DataFrame` `p` dans diff\u00e9rents formats."]}, {"block": 22, "type": "code", "linesLength": 3, "startIndex": 60, "lines": ["# \u00e9crivons notre DataFrame dans un fichier CSV\n", "p.to_csv('my_data.csv')\n", "!cat my_data.csv"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 63, "lines": ["# et dans un fichier JSON\n", "p.to_json('my_data.json')\n", "!cat my_data.json"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 66, "lines": ["# on peut maintenant recharger notre fichier, la conversion en DataFrame est automatique\n", "new_p = pd.read_json('my_data.json')\n", "print(new_p)"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 69, "lines": ["Pour la gestion des autres formats, comme il s'agit de quelque chose de tr\u00e8s sp\u00e9cifique et sans difficult\u00e9 particuli\u00e8re, je vous renvoie simplement \u00e0 la documentation\u00a0:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/io.html"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["### Manipulation d'une `DataFrame`"]}, {"block": 27, "type": "code", "linesLength": 13, "startIndex": 73, "lines": ["# contruisons maintenant une DataFrame jouet\n", "\n", "# voici une liste de pr\u00e9noms\n", "names = ['alice', 'bob', 'marc', 'bill', 'sonia']\n", "\n", "# cr\u00e9ons trois Series qui formeront les trois colonnes\n", "age = pd.Series([12, 13, 16, 11, 16], index=names)\n", "height = pd.Series([130, 140, 176, 120, 165], index=names)\n", "sex = pd.Series(list('fmmmf'), index=names)\n", "\n", "# cr\u00e9ons maintenant la DataFrame\n", "p = pd.DataFrame({'age': age, 'height': height, 'sex': sex})\n", "print(p)"]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 86, "lines": ["# et chargeons le jeux de donn\u00e9es sur les pourboires de seaborn\n", "import seaborn as sns\n", "tips = sns.load_dataset('tips')"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Pandas offre de nombreuses possibilit\u00e9s d'explorer les donn\u00e9es. Attention, dans mes exemples je vais alterner entre le `DataFrame` `p` et le `DataFrame` `tips` suivant les besoins de l'explication."]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["# afficher les premi\u00e8res lignes\n", "tips.head()"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["# et les derni\u00e8re lignes\n", "tips.tail()"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["# l'index des lignes\n", "p.index"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 96, "lines": ["# et l'index des colonnes\n", "p.columns"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 98, "lines": ["# et afficher uniquement les valeurs\n", "p.values"]}, {"block": 35, "type": "code", "linesLength": 3, "startIndex": 100, "lines": ["# \u00e9changer lignes et colonnes\n", "# cf. la transposition de matrices\n", "p.T"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Pour finir, il y a la m\u00e9thodes `describe` qui permet d'obtenir des premi\u00e8res statistiques sur un `DataFrame`. `describe` permet de calculer des statistiques sur des type num\u00e9riques, mais aussi sur des types cha\u00eenes de caract\u00e8res."]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 104, "lines": ["# par d\u00e9faut describe ne prend en compte que les colonnes num\u00e9riques\n", "p.describe()"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 106, "lines": ["# mais on peut le forcer \u00e0 prendre en compte toutes les colonnes\n", "p.describe(include='all')"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["### Requ\u00eates sur une `DataFrame`"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["On peut maintenant commencer \u00e0 faire des requ\u00eates sur les `DataFrames`. Les `DataFrame` supportent la notion de masque que l'on a vue pour les `ndarray` numpy et pour les `Series`."]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 110, "lines": ["# p.loc prend soit un label de ligne\n", "print(p.loc['sonia'])"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 112, "lines": ["# ou alors un label de ligne ET de colonne\n", "print(p.loc['sonia', 'age'])"]}, {"block": 43, "type": "markdown", "linesLength": 12, "startIndex": 114, "lines": ["On peut mettre \u00e0 la place d'une label\u00a0:\n", "\n", "- une liste de labels\u00a0;\n", "- un slice sur les labels\u00a0;\n", "- un masque (c'est-\u00e0-dire un tableau de bool\u00e9ens)\u00a0;\n", "- un callable qui retourne une des trois premi\u00e8res possibilit\u00e9s.\n", "\n", "Noter que l'on peut \u00e9galement utiliser la notation `.iloc[]` avec les m\u00eames r\u00e8gles, mais elle est moins utile.\n", "\n", "Je recommande de toujours utiliser la notation `.loc[lignes, colonnes]` pour \u00e9viter toute ambigu\u00eft\u00e9. Nous verrons que les notations `.loc[lignes]` ou pire seulement `[label]` sont sources d'erreurs.\n", "\n", "Regardons maintenant d'autres exemples plus sophistiqu\u00e9s\u00a0:"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 126, "lines": ["# un masque sur les femmes\n", "p.loc[:, 'sex'] == 'f'"]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 128, "lines": ["# si bien que pour construire un tableau\n", "# avec uniquement les femmes\n", "p.loc[p.loc[:, 'sex'] == 'f', :]"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 131, "lines": ["# si on veut ne garder uniquement\n", "# que les femmes de plus de 14 ans\n", "p.loc[(p.loc[:, 'sex'] == 'f') & (p.loc[:, 'age'] > 14), :]"]}, {"block": 47, "type": "code", "linesLength": 3, "startIndex": 134, "lines": ["# quelle est la moyenne de 'total_bill' pour les femmes\n", "addition_f = tips.loc[tips.loc[:, 'sex'] == 'Female', 'total_bill'].mean()\n", "print(f\"addition moyenne des femmes : {addition_f:.2f}\")"]}, {"block": 48, "type": "code", "linesLength": 3, "startIndex": 137, "lines": ["# quelle est la note moyenne des hommes\n", "addition_h = tips.loc[tips.loc[:, 'sex'] == 'Male', 'total_bill'].mean()\n", "print(f\"addition moyenne des hommes : {addition_h:.2f}\")"]}, {"block": 49, "type": "code", "linesLength": 8, "startIndex": 140, "lines": ["# qui laisse le plus grand pourcentage de pourboire :\n", "# les hommes ou les femmes ?\n", "\n", "pourboire_f = tips.loc[tips.loc[:, 'sex'] == 'Female', 'tip'].mean()\n", "pourboire_h = tips.loc[tips.loc[:, 'sex'] == 'Male', 'tip'].mean()\n", "\n", "print(f\"Les femmes laissent {pourboire_f/addition_f:.2%} de pourboire\")\n", "print(f\"Les hommes laissent {pourboire_h/addition_h:.2%} de pourboire\")"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 148, "lines": ["### Erreurs fr\u00e9quentes et ambigu\u00eft\u00e9s sur les requ\u00eates"]}, {"block": 51, "type": "markdown", "linesLength": 3, "startIndex": 149, "lines": ["Nous avons vu une mani\u00e8re simple et non ambigu\u00eb de faire des requ\u00eates sur les `DataFrame`. Nous allons voir qu'il existe d'autres mani\u00e8res qui ont pour seul avantage d'\u00eatre plus concises, mais sources de nombreuses erreurs.\n", "\n", "**Souvenez-vous, utilisez toujours la notation `.loc[lignes, colonnes]` sinon, soyez s\u00fbr de savoir ce qui est r\u00e9ellement calcul\u00e9**."]}, {"block": 52, "type": "code", "linesLength": 2, "startIndex": 152, "lines": ["# commen\u00e7ons par la notation la plus classique\n", "p['sex']  # prend forc\u00e9ment un label de colonne"]}, {"block": 53, "type": "code", "linesLength": 3, "startIndex": 154, "lines": ["# mais par contre, si on passe un slice, c'est forc\u00e9ment des lignes,\n", "# assez perturbant et source de confusion.\n", "p['alice': 'marc']"]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 157, "lines": ["# on peut m\u00eame directement acc\u00e9der \u00e0 une colonne par son nom\n", "p.age"]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 159, "lines": ["Mais c'est **fortement d\u00e9conseill\u00e9** parce que si un attribut de m\u00eame nom existe sur une `DataFrame`, alors la priorit\u00e9 est donn\u00e9e \u00e0 l'attribut, et non \u00e0 la colonne\u00a0:"]}, {"block": 56, "type": "code", "linesLength": 4, "startIndex": 160, "lines": ["# ajoutons une colonne qui a pour nom une m\u00e9thode qui existe sur\n", "# les DataFrame\n", "p['mean'] = 1\n", "print(p)"]}, {"block": 57, "type": "code", "linesLength": 3, "startIndex": 164, "lines": ["# je peux bien acc\u00e9der\n", "# \u00e0 la colonne sex\n", "p.sex"]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 167, "lines": ["# mais pas \u00e0 la colonne mean\n", "p.mean"]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 169, "lines": ["# \u00e0 nouveau, la seule m\u00e9thode non ambigu\u00eb est d'utiliser .loc\n", "p.loc[:, 'mean']"]}, {"block": 60, "type": "code", "linesLength": 4, "startIndex": 171, "lines": ["# supprimons maintenant la colonne mean *en place* (par d\u00e9faut,\n", "# drop retourne une nouvelle DataFrame)\n", "p.drop(columns='mean', inplace=True)\n", "print(p)"]}, {"block": 61, "type": "markdown", "linesLength": 3, "startIndex": 175, "lines": ["Pour allez plus loin, vous pouvez lire la documentation officielle\u00a0:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/indexing.html"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 178, "lines": ["### *Universal functions* et pandas"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 179, "lines": ["\u00c7a n'est pas une surprise, les `Series` et `DataFrame` pandas supportent les `ufunc` numpy. Mais il y a une subtilit\u00e9. Il est parfaitement l\u00e9gitime et correct d'appliquer une `ufunc` numpy sur les \u00e9l\u00e9ments d'une `DataFrame`\u00a0:"]}, {"block": 64, "type": "code", "linesLength": 3, "startIndex": 180, "lines": ["d = pd.DataFrame(np.random.randint(\n", "    1, 10, 9).reshape(3, 3), columns=list('abc'))\n", "print(d)"]}, {"block": 65, "type": "code", "linesLength": 1, "startIndex": 183, "lines": ["np.log(d)"]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Nous remarquons que comme on s'y attend, la `ufunc` a \u00e9t\u00e9 appliqu\u00e9e \u00e0 chaque \u00e9l\u00e9ment de la `DataFrame` et que les labels des lignes et colonnes ont \u00e9t\u00e9 pr\u00e9serv\u00e9s."]}, {"block": 67, "type": "markdown", "linesLength": 3, "startIndex": 185, "lines": ["Par contre, si l'on a besoin d'alignement de labels, c'est le cas avec toutes les op\u00e9rations qui s'appliquent sur 2 objets comme une addition, alors les `ufunc` numpy ne **vont pas faire** ce \u00e0 quoi on s'attend. Elles vont faire les op\u00e9rations sur les tableaux numpy sans prendre en compte les labels.\n", "\n", "Pour avoir un alignement des labels, il faut utiliser les `ufunc` pandas."]}, {"block": 68, "type": "code", "linesLength": 4, "startIndex": 188, "lines": ["# prenons deux series\n", "s1 = pd.Series([10, 20, 30],\n", "               index=list('abc'))\n", "print(s1)"]}, {"block": 69, "type": "code", "linesLength": 4, "startIndex": 192, "lines": ["#\n", "s2 = pd.Series([12, 22, 32],\n", "               index=list('acd'))\n", "print(s2)"]}, {"block": 70, "type": "code", "linesLength": 4, "startIndex": 196, "lines": ["# la ufunc numpy fait la somme\n", "# des arrays sans prendre en compte\n", "# les labels, donc sans alignement\n", "np.add(s1, s2)"]}, {"block": 71, "type": "code", "linesLength": 4, "startIndex": 200, "lines": ["# la ufunc pandas va faire\n", "# un alignement des labels\n", "# cet appel est \u00e9quivalent \u00e0 s1 + s2\n", "s1.add(s2)"]}, {"block": 72, "type": "code", "linesLength": 4, "startIndex": 204, "lines": ["# comme on l'a vu sur le compl\u00e9ment pr\u00e9c\u00e9dent, les valeurs absentes sont\n", "# remplac\u00e9es par NaN, mais on peut changer ce comportement lors de\n", "# l'appel de .add\n", "s1.add(s2, fill_value=0)"]}, {"block": 73, "type": "code", "linesLength": 11, "startIndex": 208, "lines": ["# regardons un autre exemple sur des DataFrame\n", "# on affiche tout \u00e7a dans les cellules suivantes\n", "names = ['alice', 'bob', 'charle']\n", "\n", "bananas = pd.Series([10, 3, 9], index=names)\n", "oranges = pd.Series([3, 11, 6], index=names)\n", "fruits_jan = pd.DataFrame({'bananas': bananas, 'orange': oranges})\n", "\n", "bananas = pd.Series([6, 1], index=names[:-1])\n", "apples = pd.Series([8, 5], index=names[1:])\n", "fruits_feb = pd.DataFrame({'bananas': bananas, 'apples': apples})"]}, {"block": 74, "type": "code", "linesLength": 2, "startIndex": 219, "lines": ["# ce qui donne\n", "fruits_jan"]}, {"block": 75, "type": "code", "linesLength": 2, "startIndex": 221, "lines": ["# et\n", "fruits_feb"]}, {"block": 76, "type": "code", "linesLength": 3, "startIndex": 223, "lines": ["# regardons maintenant la somme des fruits mang\u00e9s\n", "eaten_fruits = fruits_jan + fruits_feb\n", "print(eaten_fruits)"]}, {"block": 77, "type": "code", "linesLength": 4, "startIndex": 226, "lines": ["# On a bien un alignement des labels, mais il y a beaucoup de valeurs\n", "# manquantes. Corrigeons cela on rempla\u00e7ant les valeurs manquantes par 0\n", "eaten_fruits = fruits_jan.add(fruits_feb, fill_value=0)\n", "print(eaten_fruits)"]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 230, "lines": ["Notons que lorsqu'une valeur est absente dans toutes les `DataFrame`, `NaN` est conserv\u00e9."]}, {"block": 79, "type": "markdown", "linesLength": 1, "startIndex": 231, "lines": ["Un derni\u00e8re subtilit\u00e9 \u00e0 conna\u00eetre lors de l'alignement des labels intervient lorsque vous faites une op\u00e9ration sur une `DataFrame` et une `Series`. Pandas va consid\u00e9rer la `Series` comme une ligne et va la broadcaster sur les autres lignes. Par cons\u00e9quent, l'index de la `Series` va \u00eatre consid\u00e9r\u00e9 comme des colonnes et align\u00e9 avec les colonnes de la `DataFrame`."]}, {"block": 80, "type": "code", "linesLength": 4, "startIndex": 232, "lines": ["dataframe = pd.DataFrame(\n", "    np.random.randint(1, 10, size=(3, 3)),\n", "    columns=list('abc'), index=list('xyz'))\n", "dataframe"]}, {"block": 81, "type": "code", "linesLength": 4, "startIndex": 236, "lines": ["series_row = pd.Series(\n", "    [100, 100, 100],\n", "    index=list('abc'))\n", "series_row"]}, {"block": 82, "type": "code", "linesLength": 4, "startIndex": 240, "lines": ["series_col = pd.Series(\n", "    [200, 200, 200],\n", "    index=list('xyz'))\n", "series_col"]}, {"block": 83, "type": "code", "linesLength": 6, "startIndex": 244, "lines": ["# la Series est consid\u00e9r\u00e9e comme une ligne et son index\n", "# s'aligne sur les colonnes de la DataFrame\n", "# la Series va \u00eatre broadcast\u00e9e\n", "# sur les autres lignes de la DataFrame\n", "\n", "dataframe + series_row"]}, {"block": 84, "type": "code", "linesLength": 4, "startIndex": 250, "lines": ["# du coup si les labels ne correspondent pas,\n", "# le r\u00e9sultat sera le suivant\n", "\n", "dataframe + series_col"]}, {"block": 85, "type": "code", "linesLength": 4, "startIndex": 254, "lines": ["# on peut dans ce cas, changer le comportement par d\u00e9faut et for\u00e7ant\n", "# l'alignement de la Series suivant un autre axe avec l'argument axis\n", "\n", "dataframe.add(series_col, axis=0)"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 258, "lines": ["Ici, `axis=0` signifie que la `Series` est consid\u00e9r\u00e9e comme une colonne est qu'elle va \u00eatre broadcast\u00e9e sur les autres colonnes (le long de l'axe de ligne)."]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 259, "lines": ["### Op\u00e9rations sur les cha\u00eenes de caract\u00e8res"]}, {"block": 88, "type": "markdown", "linesLength": 11, "startIndex": 260, "lines": ["Nous allons maintenant parler de la vectorisation des op\u00e9rations sur les cha\u00eenes de caract\u00e8res. Il y a plusieurs choses importantes \u00e0 savoir\u00a0:\n", "\n", "* les m\u00e9thodes sur les cha\u00eenes de caract\u00e8res ne sont disponibles que pour les `Series` et les `Index`, mais pas pour les `DataFrame`\u00a0;\n", "* ces m\u00e9thodes ignorent les `NaN` et remplacent les valeurs qui ne sont pas des cha\u00eenes de caract\u00e8res par `NaN`\u00a0;\n", "* ces m\u00e9thodes retournent une copie de l'objet (`Series` ou `Index`), il n'y a pas de modification en place\u00a0;\n", "* la plupart des m\u00e9thodes Python sur le type `str` existe sous forme vectoris\u00e9e\u00a0;\n", "* on acc\u00e8de \u00e0 ces m\u00e9thodes avec la syntaxe\u00a0:\n", "  * `Series.str.<vectorized method name>`\n", "  * `Index.str.<vectorized method name>`\n", "\n", "Regardons quelques exemples\u00a0:"]}, {"block": 89, "type": "code", "linesLength": 4, "startIndex": 271, "lines": ["# Cr\u00e9ons une Series avec des noms ayant une capitalisation inconsistante\n", "# et une mauvaise gestion des espaces\n", "names = ['alice ', '  bOB', 'Marc', 'bill', 3, ' JULIE ', np.NaN]\n", "age = pd.Series(names)"]}, {"block": 90, "type": "code", "linesLength": 8, "startIndex": 275, "lines": ["# nettoyons maintenant ces donn\u00e9es\n", "\n", "# on met en minuscule\n", "a = age.str.lower()\n", "\n", "# on enl\u00e8ve les espaces\n", "a = a.str.strip()\n", "a"]}, {"block": 91, "type": "code", "linesLength": 4, "startIndex": 283, "lines": ["# comme les m\u00e9thodes vectoris\u00e9es retournent un objet de m\u00eame type, on\n", "# peut les cha\u00eener comme ceci\n", "\n", "[x for x in age.str.lower().str.strip()]"]}, {"block": 92, "type": "markdown", "linesLength": 1, "startIndex": 287, "lines": ["On peut \u00e9galement utiliser l'indexation des `str` de mani\u00e8re vectoris\u00e9e\u00a0:"]}, {"block": 93, "type": "code", "linesLength": 1, "startIndex": 288, "lines": ["print(a)"]}, {"block": 94, "type": "code", "linesLength": 1, "startIndex": 289, "lines": ["print(a.str[-1])"]}, {"block": 95, "type": "markdown", "linesLength": 3, "startIndex": 290, "lines": ["Pour allez plus loin vous pouvez lire la documentation officielle\u00a0:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/text.html"]}, {"block": 96, "type": "markdown", "linesLength": 1, "startIndex": 293, "lines": ["### Gestion des valeurs manquantes"]}, {"block": 97, "type": "markdown", "linesLength": 1, "startIndex": 294, "lines": ["Nous avons vu que des op\u00e9rations sur les `DataFrame` pouvaient g\u00e9n\u00e9rer des valeurs `NaN` lors de l'alignement. Il est \u00e9galement possible d'avoir de telles valeurs _manquantes_ dans votre jeu de donn\u00e9es original. Pandas offre plusieurs possibilit\u00e9s pour g\u00e9rer correctement ces valeurs manquantes."]}, {"block": 98, "type": "markdown", "linesLength": 11, "startIndex": 295, "lines": ["Avant de voir ces diff\u00e9rentes possibilit\u00e9s, d\u00e9finissons cette notion de valeur manquante.\n", "\n", "Une valeur manquante peut-\u00eatre repr\u00e9sent\u00e9e en pandas soit par `np.NaN` ou par l'objet Python `None`.\n", "\n", "- `np.NaN` est un objet de type `float`, par cons\u00e9quent il ne peut appara\u00eetre que dans un array de `float` ou un array d'`object`. Notons que `np.NaN` appara\u00eet en pandas comme simplement `NaN` et que dans la suite on utilise de mani\u00e8re indiff\u00e9rente les deux notations, par contre, dans du code, il faut obligatoirement utiliser `np.NaN`\u00a0;\n", "  - si on ajoute un `NaN` dans un array d'entier, ils seront convertis en `float64`\u00a0;\n", "  - si on ajoute un `NaN` dans un array de bool\u00e9ens, ils seront convertis en `object`\u00a0;\n", "- `NaN` est contaminant, toute op\u00e9ration avec un `NaN` a pour r\u00e9sultat `NaN`\u00a0;\n", "- lorsque l'on utilise `None`, il est automatiquement convertit en `NaN` lorsque le type de l'array est num\u00e9rique.\n", "\n", "Illustrons ces propri\u00e9t\u00e9s\u00a0:"]}, {"block": 99, "type": "code", "linesLength": 3, "startIndex": 306, "lines": ["# une Series d'entier\n", "s = pd.Series([1, 2])\n", "s"]}, {"block": 100, "type": "code", "linesLength": 3, "startIndex": 309, "lines": ["# on ins\u00e8re un NaN, la Series est alors convertie en float64\n", "s[0] = np.NaN\n", "s"]}, {"block": 101, "type": "code", "linesLength": 3, "startIndex": 312, "lines": ["# on r\u00e9initialise\n", "s = pd.Series([1, 2])\n", "s"]}, {"block": 102, "type": "code", "linesLength": 6, "startIndex": 315, "lines": ["# et on ins\u00e8re None\n", "s[0] = None\n", "\n", "# Le r\u00e9sultat est le m\u00eame\n", "# None est converti en NaN\n", "s"]}, {"block": 103, "type": "markdown", "linesLength": 10, "startIndex": 321, "lines": ["Regardons maintenant, les m\u00e9thodes pandas pour g\u00e9rer les valeurs manquantes (donc `NaN` ou `None`)\u00a0:\n", "\n", "- `isna()` retourne un masque mettant \u00e0 `True` les valeurs manquantes (il y a un alias `isnull()`)\u00a0;\n", "- `notna()` retourne un masque mettant \u00e0 `False` les valeurs manquantes (il y a un alias `notnull()`)\u00a0;\n", "- `dropna()` retourne un nouvel objet sans les valeurs manquantes\u00a0;\n", "- `fillna()` retourne un nouvel objet avec les valeurs manquantes remplac\u00e9es.\n", "\n", "On remarque que l'ajout d'alias pour les m\u00e9thodes est de nouveau une source de confusion avec laquelle il faut vivre.\n", "\n", "On remarque \u00e9galement qu'alors que `isnull()` et `notnull()` sont des m\u00e9thodes simples, `dropna()` et `fillna()` impliquent l'utilisation de strat\u00e9gies. Regardons cela\u00a0:"]}, {"block": 104, "type": "code", "linesLength": 6, "startIndex": 331, "lines": ["# cr\u00e9ons une DataFrame avec quelques valeurs manquantes\n", "names = ['alice', 'bob', 'charles']\n", "bananas = pd.Series([6, 1], index=names[:-1])\n", "apples = pd.Series([8, 5], index=names[1:])\n", "fruits_feb = pd.DataFrame({'bananas': bananas, 'apples': apples})\n", "print(fruits_feb)"]}, {"block": 105, "type": "code", "linesLength": 1, "startIndex": 337, "lines": ["fruits_feb.isna()"]}, {"block": 106, "type": "code", "linesLength": 1, "startIndex": 338, "lines": ["fruits_feb.notna()"]}, {"block": 107, "type": "markdown", "linesLength": 1, "startIndex": 339, "lines": ["Par d\u00e9faut, `dropna()` va enlever toutes les lignes qui contiennent au moins une valeur manquante. Mais on peut changer ce comportement avec des arguments\u00a0:"]}, {"block": 108, "type": "code", "linesLength": 2, "startIndex": 340, "lines": ["p = pd.DataFrame([[1, 2, np.NaN], [3, np.NaN, np.NaN], [7, 5, np.NaN]])\n", "print(p)"]}, {"block": 109, "type": "code", "linesLength": 3, "startIndex": 342, "lines": ["# comportement par d\u00e9faut, j'enl\u00e8ve toutes les lignes avec au moins\n", "# une valeur manquante; il ne reste rien !\n", "p.dropna()"]}, {"block": 110, "type": "code", "linesLength": 2, "startIndex": 345, "lines": ["# maintenant, je fais l'op\u00e9ration par colonne\n", "p.dropna(axis=1)"]}, {"block": 111, "type": "code", "linesLength": 2, "startIndex": 347, "lines": ["# je fais l'op\u00e9ration par colonne qui si toute la colonne est manquante\n", "p.dropna(axis=1, how='all')"]}, {"block": 112, "type": "code", "linesLength": 2, "startIndex": 349, "lines": ["# je fais l'op\u00e9ration par ligne si au moins 2 valeurs sont manquantes\n", "p.dropna(thresh=2)"]}, {"block": 113, "type": "markdown", "linesLength": 1, "startIndex": 351, "lines": ["Par d\u00e9faut, `fillna()` remplace les valeurs manquantes avec un argument pas d\u00e9faut. Mais on peut ici aussi changer ce comportement. Regardons cela\u00a0:"]}, {"block": 114, "type": "code", "linesLength": 1, "startIndex": 352, "lines": ["print(p)"]}, {"block": 115, "type": "code", "linesLength": 2, "startIndex": 353, "lines": ["# je remplace les valeurs manquantes par -1\n", "p.fillna(-1)"]}, {"block": 116, "type": "code", "linesLength": 4, "startIndex": 355, "lines": ["# je remplace les valeurs manquantes avec la valeur suivante sur la colonne\n", "# bfill est pour back fill, c'est-\u00e0-dire remplace en arri\u00e8re \u00e0 partir des\n", "# valeurs existantes\n", "p.fillna(method='bfill')"]}, {"block": 117, "type": "code", "linesLength": 4, "startIndex": 359, "lines": ["# je remplace les valeurs manquantes avec la valeur pr\u00e9c\u00e9dente sur la ligne\n", "# ffill est pour forward fill, remplace en avant \u00e0 partir des valeurs\n", "# existantes\n", "p.fillna(method='ffill', axis=1)"]}, {"block": 118, "type": "markdown", "linesLength": 1, "startIndex": 363, "lines": ["Regardez l'aide de ces m\u00e9thodes pour aller plus loin."]}, {"block": 119, "type": "code", "linesLength": 1, "startIndex": 364, "lines": ["p.dropna?"]}, {"block": 120, "type": "code", "linesLength": 1, "startIndex": 365, "lines": ["p.fillna?"]}, {"block": 121, "type": "markdown", "linesLength": 1, "startIndex": 366, "lines": ["### Analyse statistique des donn\u00e9es"]}, {"block": 122, "type": "markdown", "linesLength": 12, "startIndex": 367, "lines": ["Nous n'avons pas le temps de couvrir les possibilit\u00e9s d'analyse statistique de la suite data science de Python. Pandas offre quelques possibilit\u00e9s basique avec des calculs de moyennes, d'\u00e9quarts types ou de covariances que l'on peut \u00e9ventuellement appliquer par fen\u00eatres \u00e0 un jeux de donn\u00e9es. Pour avoir plus de d\u00e9tails dessus vous pouvez consulter cette documentation\u00a0:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/computation.html\n", "\n", "Dans la suite data science de Python, il a aussi des modules sp\u00e9cialis\u00e9s dans l'analyse statistique comme\u00a0:\n", "\n", "- [StatsModels](http://www.statsmodels.org/stable/index.html)\n", "- [ScikitLearn](http://scikit-learn.org/stable/)\n", "\n", "ou des outils de calculs scientifiques plus g\u00e9n\u00e9riques comme [SciPy](https://www.scipy.org/).\n", "\n", "De nouveau, il s'agit d'outils appliqu\u00e9s \u00e0 des domaines sp\u00e9cifiques et ils se basent tous sur le couple numpy/pandas."]}, {"block": 123, "type": "markdown", "linesLength": 1, "startIndex": 379, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 124, "type": "markdown", "linesLength": 1, "startIndex": 380, "lines": ["### Les MultiIndex"]}, {"block": 125, "type": "markdown", "linesLength": 7, "startIndex": 381, "lines": ["Pandas avait historiquement d'autres structures de donn\u00e9es en plus des `Series` et des `DataFrame` permettant d'exprimer des dimensionalit\u00e9s sup\u00e9rieures \u00e0 2, comme par exemple les `Panel`. Mais pour des raisons de maintenance du code et d'optimisations, les d\u00e9veloppeurs ont d\u00e9cid\u00e9 de ne garder que les `Series` et les `DataFrame`. Alors, comment exprimer des donn\u00e9es avec plus de deux dimensions\u00a0?\n", "\n", "On utilise pour cela des `MultiIndex`. Un `MultiIndex` est un index qui peut \u00eatre utilis\u00e9 partout o\u00f9 l'on utilise un index (dans une `Series`, ou comme ligne ou colonne d'une `DataFrame`) et qui a pour caract\u00e9ristique d'avoir plusieurs niveaux.\n", "\n", "Comme tous types d'index, et parce qu'un `MultiIndex` est une sous classe d'`Index`, pandas va correctement aligner les `Series` et les `DataFrame` avec des `MultiIndex`.\n", "\n", "Regardons tout de suite un exemple\u00a0:"]}, {"block": 126, "type": "code", "linesLength": 13, "startIndex": 388, "lines": ["# contruisons une DataFrame jouet\n", "\n", "# voici une liste de pr\u00e9noms\n", "names = ['alice', 'bob', 'sonia']\n", "\n", "# cr\u00e9ons trois Series qui formeront trois colonnes\n", "age = pd.Series([12, 13, 16], index=names)\n", "height = pd.Series([130, 140, 165], index=names)\n", "sex = pd.Series(list('fmf'), index=names)\n", "\n", "# cr\u00e9ons maintenant la DataFrame\n", "p = pd.DataFrame({'age': age, 'height': height, 'sex': sex})\n", "print(p)"]}, {"block": 127, "type": "code", "linesLength": 4, "startIndex": 401, "lines": ["# unstack, en premi\u00e8re approximation, permet de passer d'une DataFrame \u00e0\n", "# une Series avec un MultiIndex\n", "s = p.unstack()\n", "print(s)"]}, {"block": 128, "type": "code", "linesLength": 2, "startIndex": 405, "lines": ["# et voici donc l'index de cette Series\n", "s.index"]}, {"block": 129, "type": "markdown", "linesLength": 1, "startIndex": 407, "lines": ["Il existe \u00e9videmment des moyens de cr\u00e9er directement un `MultiIndex` et ensuite de le d\u00e9finir comme index d'une `Series` ou comme index de ligne ou colonne d'une `DataFrame`\u00a0:"]}, {"block": 130, "type": "code", "linesLength": 5, "startIndex": 408, "lines": ["# on peut cr\u00e9er un MultiIndex \u00e0 partir d'une liste de liste\n", "names = ['alice', 'alice', 'alice', 'bob', 'bob', 'bob']\n", "age = [2014, 2015, 2016, 2014, 2015, 2016]\n", "s_list = pd.Series([40, 42, 45, 38, 40, 40], index=[names, age])\n", "print(s_list)"]}, {"block": 131, "type": "code", "linesLength": 9, "startIndex": 413, "lines": ["# ou \u00e0 partir d'un dictionnaire de tuples\n", "s_tuple = pd.Series({('alice', 2014): 40,\n", "                     ('alice', 2015): 42,\n", "                     ('alice', 2016): 45,\n", "                     ('bob', 2014): 38,\n", "                     ('bob', 2015): 40,\n", "                     ('bob', 2016): 40})\n", "\n", "print(s_tuple)"]}, {"block": 132, "type": "code", "linesLength": 6, "startIndex": 422, "lines": ["# ou avec la m\u00e9thode from_product()\n", "name = ['alice', 'bob']\n", "year = [2014, 2015, 2016]\n", "i = pd.MultiIndex.from_product([name, year])\n", "s = pd.Series([40, 42, 45, 38, 40, 40], index=i)\n", "print(s)"]}, {"block": 133, "type": "markdown", "linesLength": 1, "startIndex": 428, "lines": ["On peut m\u00eame nommer les niveaux d'un `MultiIndex`."]}, {"block": 134, "type": "code", "linesLength": 5, "startIndex": 429, "lines": ["name = ['alice', 'bob']\n", "year = [2014, 2015, 2016]\n", "i = pd.MultiIndex.from_product([name, year], names=['name', 'year'])\n", "s = pd.Series([40, 42, 45, 38, 40, 40], index=i)\n", "print(s)"]}, {"block": 135, "type": "code", "linesLength": 3, "startIndex": 434, "lines": ["# on peut changer le nom des niveaux du MultiIndex\n", "s.index.names = ['NAMES', 'YEARS']\n", "print(s)"]}, {"block": 136, "type": "markdown", "linesLength": 1, "startIndex": 437, "lines": ["Cr\u00e9ons maintenant une `DataFrame` jouet avec des `MultiIndex` pour \u00e9tudier comment acc\u00e9der aux \u00e9l\u00e9ments de la `DataFrame`."]}, {"block": 137, "type": "code", "linesLength": 16, "startIndex": 438, "lines": ["index = pd.MultiIndex.from_product([[2013, 2014],\n", "                                    [1, 2, 3]],\n", "                                   names=['year',\n", "                                          'visit'])\n", "\n", "columns = pd.MultiIndex.from_product([['Bob', 'Sue'],\n", "                                      ['avant', 'arri\u00e8re']],\n", "                                     names=['client',\n", "                                            'pression'])\n", "\n", "# on cr\u00e9e des pressions de pneus factices\n", "data = 2 + np.random.rand(6, 4)\n", "\n", "# on cr\u00e9e la DataFrame\n", "mecanics_data = pd.DataFrame(data, index=index, columns=columns)\n", "print(mecanics_data)"]}, {"block": 138, "type": "markdown", "linesLength": 3, "startIndex": 454, "lines": ["Il y a plusieurs mani\u00e8res d'acc\u00e9der aux \u00e9l\u00e9ments, mais une seule que l'on recommande\u00a0:\n", "\n", "**utilisez la notation `.loc[ligne, colonne], .iloc[ligne, colonne]`**."]}, {"block": 139, "type": "code", "linesLength": 2, "startIndex": 457, "lines": ["# pression en 2013 pour Bob\n", "mecanics_data.loc[2013, 'Bob']"]}, {"block": 140, "type": "code", "linesLength": 2, "startIndex": 459, "lines": ["# pour acc\u00e9der aux sous niveaux du MultiIndex, on utilise des tuples\n", "mecanics_data.loc[(2013, 2), ('Bob', 'avant')]"]}, {"block": 141, "type": "markdown", "linesLength": 1, "startIndex": 461, "lines": ["Le slice sur le `MultiIndex` est un peu d\u00e9licat. On peut utiliser la notation `:` si on veut slicer sur tous les \u00e9l\u00e9ments d'un `MultiIndex`, sans prendre en compte un niveau. Si on sp\u00e9cifie les niveaux, il faut utiliser un objet `slice` ou `pd.IndexSlice`\u00a0:"]}, {"block": 142, "type": "code", "linesLength": 2, "startIndex": 462, "lines": ["# slice(None) signifie tous les \u00e9l\u00e9ments du niveau\n", "print(mecanics_data.loc[slice((2013, 2), (2014, 1)), ('Sue', slice(None))])"]}, {"block": 143, "type": "code", "linesLength": 2, "startIndex": 464, "lines": ["# on peut utiliser la notation : si on ne distingue par les niveaux\n", "print(mecanics_data.loc[(slice(None), slice(1, 2)), :])"]}, {"block": 144, "type": "code", "linesLength": 4, "startIndex": 466, "lines": ["# on peut aussi utiliser pd.IndexSlice pour slicer avec un notation\n", "# un peu plus concise\n", "idx = pd.IndexSlice\n", "print(mecanics_data.loc[idx[:, 1:2], idx['Sue', :]])"]}, {"block": 145, "type": "markdown", "linesLength": 3, "startIndex": 470, "lines": ["Pour aller plus loin, regardez la documentation des `MultiIndex`\u00a0:\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/advanced.html"]}, {"block": 146, "type": "markdown", "linesLength": 1, "startIndex": 473, "lines": ["## Conclusion"]}, {"block": 147, "type": "markdown", "linesLength": 1, "startIndex": 474, "lines": ["La `DataFrame` est la structure de donn\u00e9es la plus souple et la plus puissante de pandas. Nous avons vu comment cr\u00e9er des `DataFrame` et comment acc\u00e9der aux \u00e9l\u00e9ments. Nous verrons dans le prochain compl\u00e9ment les techniques permettant de faire des op\u00e9rations complexes (et proches dans l'esprit de ce que l'on peut faire avec une base de donn\u00e9e) comme les op\u00e9rations de `merge` ou de `groupby`."]}]
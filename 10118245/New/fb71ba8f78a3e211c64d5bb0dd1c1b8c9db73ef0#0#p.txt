[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["### Impl\u00e9menter un it\u00e9rateur de permutations"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Dans ce compl\u00e9ment nous allons nous amuser \u00e0 impl\u00e9menter une fonctionnalit\u00e9 qui est d\u00e9j\u00e0 disponible dans le module `itertools`. "]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["##### C'est quoi d\u00e9j\u00e0 les permutations\u00a0?"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["En guise de rappel, l'ensemble des permutations d'un ensemble fini correspond \u00e0 toutes les fa\u00e7ons d'ordonner ses \u00e9l\u00e9ments\u00a0; si l'ensemble est de cardinal $n$, il poss\u00e8de $n!$ permutations\u00a0: on a $n$ fa\u00e7ons de choisir le premier \u00e9l\u00e9ment, $n-1$ fa\u00e7ons de choisir le second, etc."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Un it\u00e9rateur sur les permutations est disponible au travers du module standard `itertools`. Cependant il nous a sembl\u00e9 int\u00e9ressant de vous montrer comment nous pourrions \u00e9crire nous-m\u00eames cette fonctionnalit\u00e9, de mani\u00e8re relativement simple."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Pour illustrer le concept, voici \u00e0 quoi ressemblent les 6 permutations d'un ensemble \u00e0 trois \u00e9l\u00e9ments\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["from itertools import permutations"]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 13, "lines": ["set = {1, 2, 3}\n", "\n", "for p in permutations(set):\n", "    print(p)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["##### Une impl\u00e9mentation "]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Voici une impl\u00e9mentation possible pour un it\u00e9rateur de permutations\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 70, "startIndex": 19, "lines": ["class Permutations:\n", "    \"\"\"\n", "    Un it\u00e9rateur qui \u00e9num\u00e8re les permutations de n\n", "    sous la forme d'une liste d'indices commen\u00e7ant \u00e0 0\n", "    \"\"\"\n", "    def __init__(self, n):\n", "        # le constructeur bien s\u00fbr ne fait (presque) rien\n", "        self.n = n\n", "        # au fur et \u00e0 mesure des it\u00e9rations\n", "        # le compteur va aller de 0 \u00e0 n-1\n", "        # puis retour \u00e0 0 et comme \u00e7a en boucle sans fin\n", "        self.counter = 0\n", "        # on se contente d'allouer un iterateur de rang n-1\n", "        # si bien qu'une fois qu'on a fini de construire\n", "        # l'objet d'ordre n on a n objets Permutations en tout\n", "        if n >= 2:\n", "            self.subiterator = Permutations(n-1)\n", "\n", "    # pour satisfaire le protocole d'it\u00e9ration\n", "    def __iter__(self):\n", "        return self\n", "\n", "    # c'est ici bien s\u00fbr que se fait tout le travail\n", "    def __next__(self):\n", "        # pour n == 1\n", "        # le travail est tr\u00e8s simple\n", "        if self.n == 1:\n", "            # on doit renvoyer une fois la liste [0]\n", "            # car les indices commencent \u00e0 0\n", "            if self.counter == 0: \n", "                self.counter += 1\n", "                return [0]\n", "            # et ensuite c'est termin\u00e9\n", "            else:\n", "                raise StopIteration\n", "\n", "        # pour n >= 2\n", "        # lorsque counter est nul,\n", "        # on traite la permutation d'ordre n-1 suivante\n", "        # si next() l\u00e8ve StopIteration on n'a qu'\u00e0 laisser passer\n", "        # car en effet c'est qu'on a termin\u00e9\n", "        if self.counter == 0:\n", "            self.subsequence = next(self.subiterator)\n", "        #\n", "        # on ins\u00e8re alors n-1 (car les indices commencent \u00e0 0)\n", "        # successivement dans la sous-sequence\n", "        #\n", "        # naivement on \u00e9crirait\n", "        # result = self.subsequence[0:self.counter] \\\n", "        #    + [self.n - 1] \\\n", "        #    + self.subsequence[self.counter:self.n-1]\n", "        # mais c'est mettre le nombre le plus \u00e9lev\u00e9 en premier\n", "        # et donc \u00e0 it\u00e9rer les permutations dans le mauvais ordre,\n", "        # en commen\u00e7ant par la fin\n", "        #\n", "        # donc on fait plut\u00f4t une sym\u00e9trie\n", "        # pour ins\u00e9rer en commen\u00e7ant par la fin\n", "        cutter = self.n-1 - self.counter\n", "        result = self.subsequence[0:cutter] + [self.n - 1] \\\n", "                 + self.subsequence[cutter:self.n-1]\n", "        # \n", "        # on n'oublie pas de maintenir le compteur et de\n", "        # le remettre \u00e0 z\u00e9ro tous les n tours\n", "        self.counter = (self.counter+1) % self.n\n", "        return result\n", "\n", "    # la longeur de cet it\u00e9rateur est connue\n", "    def __len__(self):\n", "        import math\n", "        return math.factorial(self.n)"]}, {"block": 13, "type": "markdown", "linesLength": 26, "startIndex": 89, "lines": ["Ce qu'on a essay\u00e9 d'expliquer dans les commentaires, c'est qu'on proc\u00e8de en fin de compte par r\u00e9currence. Un objet `Permutations` de rang `n` poss\u00e8de un sous-it\u00e9rateur de rang `n-1` qu'on cr\u00e9e dans le constructeur. Ensuite l'objet de rang `n` va faire successivement (c'est-\u00e0-dire \u00e0 chaque appel de `next()`)\u00a0:\n", "\n", "* appel *0*\u00a0:\n", "  * demander \u00e0 son sous-it\u00e9rateur une permutation de rang `n-1` (en lui envoyant `next`),\n", "  * la stocker dans l'objet de rang `n`, ce sera utilis\u00e9 par les *n* premier appels,\n", "  * et construire une liste de taille `n` en ins\u00e9rant `n-1` \u00e0 la fin de la s\u00e9quence de taille `n-1`,  \n", "\n", "\n", "* appel *1*\u00a0:\n", "  * ins\u00e9rer `n-1` dans la m\u00eame s\u00e9quence de rang `n-1` mais cette fois 1 cran avant la fin,\n", "\n", "\n", "* ...\n", "\n", "\n", "* appel *n-1*\u00a0:\n", "  * ins\u00e9rer `n-1` au d\u00e9but de la s\u00e9quence de rang `n-1`,\n", "\n", "\n", "* appel *n*\u00a0:\n", "  * refaire `next()` sur le sous-it\u00e9rateur pour traiter une nouvelle sous-s\u00e9quence,\n", "  * la stocker dans l'objet de rang `n`, comme \u00e0 l'appel *0*, pour ce bloc de n appels,\n", "  * et construire la permutation en ins\u00e9rant *n-1* \u00e0 la fin, comme \u00e0 l'appel 0,\n", "\n", "\n", "* ..."]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 115, "lines": ["On voit donc le caract\u00e8re cyclique d'ordre *n* qui est mat\u00e9rialis\u00e9 par `counter`, que l'on incr\u00e9mente \u00e0 chaque boucle mais modulo *n* - notez d'ailleurs que pour ce genre de comportement on dispose aussi de `itertools.cycle` comme on le verra dans une deuxi\u00e8me version, mais pour l'instant j'ai pr\u00e9f\u00e9r\u00e9 ne pas l'utiliser pour ne pas tout embrouiller ;) \n", "\n", "La terminaison se g\u00e8re tr\u00e8s simplement, car une fois que l'on a trait\u00e9 toutes les s\u00e9quences d'ordre *n-1* eh bien on a fini, on n'a m\u00eame pas besoin de lever StopIteration explicitement, sauf bien s\u00fbr dans le cas *n=1*.\n", "\n", "Le seul point un peu d\u00e9licat, si on veut avoir les permutations dans le \"bon\" ordre, consiste \u00e0 commencer \u00e0 ins\u00e9rer `n-1` par la droite (la fin de la sous-s\u00e9quence)."]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["##### Discussion"]}, {"block": 16, "type": "markdown", "linesLength": 5, "startIndex": 121, "lines": ["Il existe certainement des tas d'autres fa\u00e7ons de faire bien entendu. Le point important ici, et qui donne toute sa puissance \u00e0 la notion d'it\u00e9rateur, c'est **qu'\u00e0 aucun moment on ne construit** une liste ou une s\u00e9quence quelconque de** $n!$ termes**. \n", "\n", "C'est une erreur fr\u00e9quente chez les d\u00e9butants que de calculer une telle liste dans le constructeur, mais proc\u00e9der de cette fa\u00e7on c'est aller exactement \u00e0 l'oppos\u00e9 de ce pourquoi les it\u00e9rateurs ont \u00e9t\u00e9 con\u00e7us\u00a0; au contraire, on veut \u00e9viter \u00e0 tout prix le co\u00fbt d'une telle construction.\n", "\n", "On peut le voir sur un code qui n'utiliserait que les 20 premi\u00e8res valeurs de l'it\u00e9rateur, vous constatez que ce code est imm\u00e9diat\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 10, "startIndex": 126, "lines": ["def show_first_items(iterable, nb_items):\n", "    \"\"\"\n", "    montre les <nb_items> premiers items de iterable\n", "    \"\"\"\n", "    print(f\"Il y a {len(iterable)} items dans l'it\u00e9rable\")\n", "    for i, item in enumerate(iterable):\n", "        print(item)\n", "        if i >= nb_items:\n", "            print('....')\n", "            break"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 136, "lines": ["show_first_items(Permutations(12), 20)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 137, "lines": ["Ce tableau vous montre par ailleurs sous un autre angle comment fonctionne l'algorithme, si vous observez le `11` qui balaie en diagonale les 12 premi\u00e8res lignes, puis les 12 suivantes, etc.."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["##### Ultimes am\u00e9liorations"]}, {"block": 21, "type": "markdown", "linesLength": 4, "startIndex": 139, "lines": ["Derni\u00e8res remarques, sur des am\u00e9liorations possibles - mais tout \u00e0 fait optionnelles\u00a0:\n", "\n", "* le lecteur attentif aura remarqu\u00e9 qu'au lieu d'un entier `counter` on aurait pu profitablement utiliser une instance de `itertools.cycle`, ce qui aurait eu l'avantage d'\u00eatre plus clair sur le propos de ce compteur\u00a0;\n", "* aussi dans le m\u00eame mouvement, au lieu de se livrer \u00e0 la gymnastique qui calcule `cutter` \u00e0 partir de `counter`, on pourrait d\u00e8s le d\u00e9part cr\u00e9er dans le cycle les bonnes valeurs en commen\u00e7ant \u00e0 `n-1`."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["C'est ce qu'on a fait dans cette deuxi\u00e8me version\u00a0; apr\u00e8s avoir enlev\u00e9 la loghorr\u00e9e de commentaires \u00e7a redevient presque lisible ;)"]}, {"block": 23, "type": "code", "linesLength": 43, "startIndex": 144, "lines": ["import itertools\n", "\n", "class Permutations2:\n", "    \"\"\"\n", "    Un it\u00e9rateur qui \u00e9num\u00e8re les permutations de n\n", "    sous la forme d'une liste d'indices commen\u00e7ant \u00e0 0\n", "    \"\"\"\n", "    def __init__(self, n):\n", "        self.n = n\n", "        # on commence \u00e0 ins\u00e9rer \u00e0 la fin \n", "        self.cycle = itertools.cycle(list(range(n))[::-1])\n", "        if n >= 2:\n", "            self.subiterator = Permutations2(n-1)\n", "        # pour savoir quand terminer le cas n==1\n", "        if n == 1:\n", "            self.done = False\n", "\n", "    def __iter__(self):\n", "        return self\n", "\n", "    def __next__(self):\n", "        cutter = next(self.cycle)\n", "\n", "        # quand n==1 on a toujours la m\u00eame valeur 0\n", "        if self.n == 1:\n", "            if not self.done:\n", "                self.done = True\n", "                return [0]\n", "            else:\n", "                raise StopIteration\n", "\n", "        # au d\u00e9but de chaque s\u00e9quence de n appels\n", "        # il faut appeler une nouvelle sous-s\u00e9quence\n", "        if cutter == self.n-1:\n", "            self.subsequence = next(self.subiterator)\n", "        # dans laquelle on ins\u00e9re n-1\n", "        return self.subsequence[0:cutter] + [self.n-1] \\\n", "                 + self.subsequence[cutter:self.n-1]\n", "\n", "    # la longeur de cet it\u00e9rateur est connue\n", "    def __len__(self):\n", "        import math\n", "        return math.factorial(self.n)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 187, "lines": ["show_first_items(Permutations2(5), 20)"]}, {"block": 25, "type": "markdown", "linesLength": 2, "startIndex": 188, "lines": ["***\n", "***"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 190, "lines": ["Il me semble int\u00e9ressant de montrer une autre fa\u00e7on, plus simple, d'\u00e9crire un it\u00e9rateur de permutations, \u00e0 base cette fois de g\u00e9n\u00e9rateurs; c'est un tout petit peu une digression par rapport au cours qui est sur la conception d'it\u00e9rateurs et d'it\u00e9rables. \u00c7a va nous permettre surtout de r\u00e9viser la notion de `yield from`."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 191, "lines": ["On commence par une version tr\u00e8s rustique qui fait des impressions\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 13, "startIndex": 192, "lines": ["# pour simplifier ici on suppose que l'entr\u00e9e est une vraie liste\n", "# que l'on va ainsi pouvoir modifier par effets de bord\n", "def gen_perm1(subject, k=0):\n", "    if k == len(subject):\n", "        # cette version hyper rustique se contente de faire une impression\n", "        print(subject)\n", "    else:\n", "        for i in range(k, len(subject)):\n", "            # on \u00e9change \n", "            subject[k], subject[i] = subject[i], subject[k]\n", "            gen_perm1(subject, k+1)\n", "            # on remet comme c'\u00e9tait pour le prochain \u00e9change\n", "            subject[k], subject[i] = subject[i], subject[k]"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 205, "lines": ["gen_perm1(['a', 'b', 'c', 'd'])"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 206, "lines": ["Tr\u00e8s bien, mais on ne veut pas imprimer, on veut it\u00e9rer. On pourrait se dire, il me suffit de remplacer `print` par `yield`. Essayons cela\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 13, "startIndex": 207, "lines": ["# pour simplifier ici on suppose que l'entr\u00e9e est une vraie liste\n", "# que l'on va ainsi pouvoir modifier par effets de bord\n", "def gen_perm2(subject, k=0):\n", "    if k == len(subject):\n", "        # cette version hyper rustique se contente de faire une impression\n", "        yield subject\n", "    else:\n", "        for i in range(k, len(subject)):\n", "            # on \u00e9change \n", "            subject[k], subject[i] = subject[i], subject[k]\n", "            gen_perm2(subject, k+1)\n", "            # on remet comme c'\u00e9tait pour le prochain \u00e9change\n", "            subject[k], subject[i] = subject[i], subject[k]"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 220, "lines": ["for perm in gen_perm2(['a', 'b', 'c', 'd']):\n", "    print(perm)"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 222, "lines": ["On est exactement dans le cas o\u00f9 il nous faut utiliser `yield from`. En effet lorsqu'on appelle `gen_perm(subject, k+1)` ici, ce qu'on obtient en retour c'est maintenant un objet g\u00e9n\u00e9rateur. Pour faire ce qu'on cherche \u00e0 faire il nous faut bien utiliser cet objet g\u00e9n\u00e9rateur, et pour cela on utilise `yield from`."]}, {"block": 34, "type": "code", "linesLength": 13, "startIndex": 223, "lines": ["# pour simplifier ici on suppose que l'entr\u00e9e est une vraie liste\n", "# que l'on va ainsi pouvoir modifier par effets de bord\n", "def gen_perm3(subject, k=0):\n", "    if k == len(subject):\n", "        # cette version hyper rustique se contente de faire une impression\n", "        yield subject\n", "    else:\n", "        for i in range(k, len(subject)):\n", "            # on \u00e9change \n", "            subject[k], subject[i] = subject[i], subject[k]\n", "            yield from gen_perm3(subject, k+1)\n", "            # on remet comme c'\u00e9tait pour le prochain \u00e9change\n", "            subject[k], subject[i] = subject[i], subject[k]"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 236, "lines": ["for perm in gen_perm3(['a', 'b', 'c', 'd']):\n", "    print(perm)"]}]
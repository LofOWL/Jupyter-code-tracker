[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Indexation \u00e9volu\u00e9e"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 7, "lines": ["Nous allons maintenant voir qu'il est possible d'indexer un tableau numpy avec, non pas des entiers ou des tuples comme on l'a vu dans un compl\u00e9ment pr\u00e9c\u00e9dent, mais aussi avec\u00a0d'autres types d'objets, qui permettent des manipulations tr\u00e8s puissantes\u00a0:\n", "* indexation par une liste\n", "* indexation par un tableau\n", "* indexation multiple (par un tuple)\n", "* indexation par un tableau de bool\u00e9ens"]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 12, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Pour illustrer ceci, on va r\u00e9utiliser la fonction `background` qu'on avait vue pour les indexations simples\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 17, "lines": ["# une fonction qui cr\u00e9e un tableau\n", "# tab[i, j] = i + 10 * j\n", "def background(n):\n", "    i = np.arange(n)\n", "    j = i.reshape((n, 1))\n", "    return i + 10 * j"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### Indexation par une liste"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["On peut indexer par une liste d'entiers, \u00e7a constitue une g\u00e9n\u00e9ralisation des slices."]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["b = background(6); print(b)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Si je veux r\u00e9f\u00e9rencer les lignes 1, 3 et 4, je ne peux pas utiliser un slice; mais je peux utiliser une liste \u00e0 la place\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["# il faut lire ceci comme \n", "# j'indexe b, avec comme indice la liste [1, 3, 4]\n", "b[ [1, 3, 4] ]"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["# pareil pour les colonnes, en combinant avec un slice\n", "b [:, [1, 3, 4]]"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# et comme toujours on peut faire du broadcasting\n", "b [:, [1, 3, 4]] = np.arange(1000, 1006).reshape((6, 1)); print(b)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["### Indexation par un tableau"]}, {"block": 15, "type": "markdown", "linesLength": 3, "startIndex": 35, "lines": ["On peut aussi indexer un tableau A \u2026 par un tableau ! Pour que cela ait un sens\u00a0:\n", "* le tableau d'index doit contenir des entiers,\n", "* tous plus petits que la premi\u00e8re dimension de A."]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["#### Le cas simple: l'entr\u00e9e et l'index sont de dimension 1."]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 39, "lines": ["# le tableau qu'on va indexer \n", "cubes = np.arange(10) ** 3; print(cubes)"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 41, "lines": ["# et un index qui est un tableau numpy\n", "# doit contenir des entiers entre 0 et 9\n", "tab = np.array([1, 7, 2])\n", "print(cubes[tab])"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 45, "lines": ["# donne - logiquement - le m\u00eame r\u00e9sultat que\n", "# si l'index \u00e9tait une liste python\n", "lis = [ 1, 7, 2]\n", "print(cubes[lis])"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["#### De mani\u00e8re g\u00e9n\u00e9rale"]}, {"block": 21, "type": "markdown", "linesLength": 4, "startIndex": 50, "lines": ["Dans le cas g\u00e9n\u00e9ral, le r\u00e9sultat de `A[index]`\n", "* a la m\u00eame forme \"externe\" que `index`\n", "* o\u00f9 on a remplac\u00e9 `i` par `A[i]`\n", "* qui peut donc \u00eatre un tableau si `A` est de dimension > 1"]}, {"block": 22, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["A = np.array([ [0, 'zero'], [1, 'un'], [2, 'deux'], [3, 'trois']]); print(A)"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["index = np.array([[1, 0, 2], [3, 2, 3]]); print(index)"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["![parts](media/index-parts.png)"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 57, "lines": ["B = A[index]\n", "print(B)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["![result](media/index-result.png)"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["B[1, 2, 1]"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["![result](media/index-detail.png)"]}, {"block": 29, "type": "markdown", "linesLength": 5, "startIndex": 62, "lines": ["Et donc si \n", "* `index` est de dimension `(i, j, k)` \n", "* et `A` est  de dimension `(a, b)`\n", "* `A[index]` est de dimension `(i, j, k, b)`\n", "* et il faut que les \u00e9l\u00e9ments dans `index` soient dans `[0 .. a[`"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": [" Ce qu'on v\u00e9rifie ici\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 68, "lines": ["# l'entr\u00e9e\n", "print(A.shape)"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["# l'index\n", "print(index.shape)"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 72, "lines": ["# le r\u00e9sultat\n", "print(A[index].shape)"]}, {"block": 34, "type": "markdown", "linesLength": 5, "startIndex": 74, "lines": ["#### Cas particulier : entr\u00e9e de dimension 1, index de dim. > 1\n", "* Lorsque l'entr\u00e9e `A` est de dimension 1\n", "* Alors la sortie a **exactement** la m\u00eame forme que l'index\n", "* C'est comme si `A` \u00e9tait une fonction \n", "* Qu'on applique aux indices dans index"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 79, "lines": ["print(cubes)"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 80, "lines": ["i2 = np.array( [ [2, 4], [8, 9]])\n", "print(i2)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["print(cubes[i2])"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["#### Application au codage des couleurs dans une image"]}, {"block": 39, "type": "code", "linesLength": 8, "startIndex": 84, "lines": ["# je cr\u00e9e une image avec 6 valeurs dispos\u00e9es en diagonale\n", "N = 32\n", "colors = 6\n", "\n", "image = np.empty((N, N), dtype = np.int32)\n", "for i in range(N):\n", "    for j in range(N):\n", "       image[i, j] = (i+j) % colors"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 92, "lines": ["plt.imshow(image, cmap='gray');"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["Les couleurs ne sont pas significatives, ce sont des valeurs enti\u00e8res dans `range(colors)`. On voudrait pouvoir choisir la vraie couleur correspondant \u00e0 chaque valeur. Pour cela on peut utiliser une simple indexation par tableau."]}, {"block": 42, "type": "code", "linesLength": 9, "startIndex": 94, "lines": ["# une palette de couleurs\n", "palette = np.array([\n", "  [255, 255, 255], # 0 -> blanc\n", "  [255, 0, 0],     # 1 -> rouge\n", "  [0, 255, 0],     # 2 -> vert\n", "  [0, 0, 255],     # 3 -> bleu\n", "  [0, 255, 255],   # 4 -> cyan\n", "  [255, 255, 0],   # 5 -> magenta\n", " ], dtype=np.uint8)"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 103, "lines": ["plt.imshow(palette[image]);"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["Remarquez que la forme g\u00e9n\u00e9rale n'a pas chang\u00e9, mais le r\u00e9sultat de l'indexation a une dimension suppl\u00e9mentaire de 3 couleurs\u00a0:"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 105, "lines": ["image.shape"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 106, "lines": ["palette[image].shape"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["### Indexation multiple (par tuple)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["Une fois que vous avez compris ce m\u00e9canisme d'indexation par un tableau, on peut encore g\u00e9n\u00e9raliser pour d\u00e9finir une indexation par deux (ou plus) tableaux de formes identiques."]}, {"block": 49, "type": "markdown", "linesLength": 5, "startIndex": 109, "lines": ["Ainsi lorsque `index1` et `index2` ont la m\u00eame forme\u00a0:\n", "* on peut \u00e9crire `A[index1, index2]`\n", "* qui a la m\u00eame forme externe que les `index`\n", "* o\u00f9 on a remplac\u00e9 `i, j` par `A[i][j]`\n", "* qui peut donc \u00eatre un tableau si `A` est de dimension > 2"]}, {"block": 50, "type": "code", "linesLength": 4, "startIndex": 114, "lines": ["# un tableau \u00e0 indexer\n", "ix, iy = np.indices((4, 3))\n", "A = 10 * ix + iy\n", "print(A)"]}, {"block": 51, "type": "code", "linesLength": 5, "startIndex": 118, "lines": ["# les deux tableaux d'indices sont carr\u00e9s 2x2\n", "index1 = [ [3, 2], [0, 1 ]]  # doivent \u00eatre < 4\n", "index2 = [ [2, 0], [0, 2 ]]  # doivent \u00eatre < 3\n", "# le r\u00e9sultat est donc carr\u00e9 2x2\n", "print(A[index1, index2])"]}, {"block": 52, "type": "markdown", "linesLength": 6, "startIndex": 123, "lines": ["Et donc si\u00a0:\n", "* `index1` et `index2` sont de dimension `(i, j, k)` \n", "* et `A` est  de dimension `(a, b, c)`\n", "* le r\u00e9sultat est de dimension `(i, j, k, c)`\n", "* il faut alors que les \u00e9l\u00e9ments  de `index1` soient dans `[0 .. a[` \n", "* et les \u00e9l\u00e9ments de `index2` dans `[0 .. b[`"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["#### Application \u00e0 la recherche de maxima"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 130, "lines": ["Imaginons que vous avez des mesures pour plusieurs instants\u00a0:"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 131, "lines": ["times = np.linspace(1000, 5000, num=5, dtype=int); print(times)"]}, {"block": 56, "type": "code", "linesLength": 3, "startIndex": 132, "lines": ["# on aurait 3 mesures \u00e0 chaque instant\n", "series = np.array( [ [10, 25, 32, 23, 12], [12, 8, 4, 10, 7], [100, 80, 90, 110, 120]])\n", "print(series)"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 135, "lines": ["Avec la fonction `np.maxargs` on peut retrouver les indices des points maxima dans `series`\u00a0:"]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 136, "lines": ["max_indices = np.argmax(series, axis=1)\n", "print(max_indices)"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["Pour trouver les maxima en question, on peut faire\u00a0:"]}, {"block": 60, "type": "code", "linesLength": 2, "startIndex": 139, "lines": ["# les trois maxima, un par serie\n", "maxima = series[ range(series.shape[0]), max_indices ]; print(maxima)"]}, {"block": 61, "type": "code", "linesLength": 2, "startIndex": 141, "lines": ["# et ils correspondent \u00e0 ces instants-ci\n", "times[max_indices]"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["### Indexation par un tableau de bool\u00e9ens"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["Une forme un peu sp\u00e9ciale d'indexation consiste \u00e0 utiliser un tableau de bool\u00e9ens, qui agit comme un masque\u00a0:"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 145, "lines": ["suite = np.array([1, 2, 3, 4, 5, 4, 3, 2, 1])"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 146, "lines": ["Je veux filtrer ce tableau et ne garder que les valeurs < 4"]}, {"block": 66, "type": "code", "linesLength": 3, "startIndex": 147, "lines": ["# je construis un masque\n", "hauts = suite >= 4\n", "print(hauts)"]}, {"block": 67, "type": "code", "linesLength": 2, "startIndex": 150, "lines": ["# je peux utiliser ce masque pour calculer les indices qui sont vrais\n", "suite[hauts]"]}, {"block": 68, "type": "code", "linesLength": 4, "startIndex": 152, "lines": ["# et utiliser maintenant ceci par un index de tableau \n", "# par exemple pour annuler ces valeurs\n", "suite[hauts] = 0\n", "print(suite)"]}]
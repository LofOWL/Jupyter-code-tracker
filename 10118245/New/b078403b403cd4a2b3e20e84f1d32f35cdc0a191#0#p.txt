[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Expressions g\u00e9n\u00e9ratrices"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Comment transformer une compr\u00e9hension de liste en it\u00e9rateur?"]}, {"block": 4, "type": "markdown", "linesLength": 5, "startIndex": 8, "lines": ["Nous venons de voir les fonctions g\u00e9n\u00e9ratrices qui sont un puissant outil pour cr\u00e9er facilement des it\u00e9rateurs. Nous verrons prochainement comment utiliser ces fonctions g\u00e9n\u00e9ratrices pour tranformer en quelques lignes de code vos propres objets en it\u00e9rateurs. \n", "\n", "Vous savez maintenant qu'en python on favorise la notion d'it\u00e9rateurs puisqu'ils se manipulent comme des objets it\u00e9rables et qu'ils sont en g\u00e9n\u00e9ral beaucoup plus compacts en m\u00e9moire que l'it\u00e9rable correspondant. \n", "\n", "Comme les compr\u00e9hensions de listes sont fr\u00e9quemment utilis\u00e9es en python, mais qu'elles sont des it\u00e9rables potentiellement gourmands en ressources m\u00e9moire, on souhaiterait pouvoir cr\u00e9er un it\u00e9rateur directement \u00e0 partir d'une compr\u00e9hension de liste. C'est possible et tr\u00e8s facile en python. Il suffit de remplacer les crochets par des parenth\u00e8ses, regardons cela."]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 13, "lines": ["# c'est une compr\u00e9hension de liste\n", "comprehension = [x**2 for x in range(100) if x%17 == 0] \n", "print(comprehension)"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 16, "lines": ["# c'est une expression g\u00e9n\u00e9ratrice\n", "generator = (x**2 for x in range(100) if x%17 == 0) \n", "print(generator)"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Ensuite pour utiliser une expression g\u00e9n\u00e9ratrice, c'est tr\u00e8s simple, on l'utilise comme n'importe quel it\u00e9rateur."]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["generator is iter(generator) # generator est bien un it\u00e9rateur"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 21, "lines": ["# affiche les premiers carr\u00e9s des multiples de 17\n", "for count, carre in enumerate(generator, 1):\n", "    print(f'Contenu de generator apr\u00e8s {count} it\u00e9rations : {carre}')"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Avec une expression g\u00e9n\u00e9ratrice on n'est plus limit\u00e9 comme avec les compr\u00e9hensions par le nombre d'\u00e9l\u00e9ments:"]}, {"block": 11, "type": "code", "linesLength": 19, "startIndex": 25, "lines": ["# trop grand pour une compr\u00e9hension,\n", "# mais on peut cr\u00e9er le g\u00e9n\u00e9rateur sans souci\n", "generator = (x**2 for x in range(10**18) if x%17==0) \n", "\n", "# on va calculer tous les carr\u00e9s de multiples de 17 \n", "# plus petits que 10**10 et dont les 4 derniers chiffres sont 1316\n", "recherche = set()\n", "\n", "# le point important, c'est qu'on n'a pas besoin de \n", "# cr\u00e9er une liste de 10**18 \u00e9l\u00e9ments \n", "# qui serait beaucoup trop grosse pour la mettre dans la m\u00e9moire vive\n", "\n", "# avec un g\u00e9n\u00e9rateur, on ne paie que ce qu'on utilise..\n", "for x in generator:\n", "    if x > 10**10:\n", "        break\n", "    elif str(x)[-4:] == '1316':\n", "        recherche.add(x)\n", "print(recherche)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["### Compr\u00e9hension *vs* expression g\u00e9n\u00e9ratrice"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["#### Digression : liste *vs* it\u00e9rateur"]}, {"block": 15, "type": "markdown", "linesLength": 3, "startIndex": 47, "lines": ["En python3, nous avons d\u00e9j\u00e0 rencontr\u00e9 la fonction `range` qui retourne les premiers entiers.\n", "\n", "Ou plut\u00f4t, c'est **comme si** elle retournait les premiers entiers lorsqu'on fait une boucle `for` "]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["# on peut parcourir un range comme si c'\u00e9tait une liste\n", "for i in range(4):\n", "    print(i)"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["mais en r\u00e9alit\u00e9 le r\u00e9sultat de `range` exhibe un comportement un peu \u00e9trange, en ce sens que:"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 54, "lines": ["# mais en fait la fonction range ne renvoie PAS une liste (depuis python3)\n", "range(4)"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["# et en effet ce n'est pas une liste\n", "isinstance(range(4), list)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["La raison de fond pour ceci, c'est que **le fait de construire une liste** est une op\u00e9ration relativement co\u00fbteuse - toutes proportions gard\u00e9es - car il est n\u00e9cessaire d'allouer de la m\u00e9moire pour **stocker tous les \u00e9l\u00e9ments** de la liste \u00e0 un instant donn\u00e9; alors qu'en fait dans l'immense majorit\u00e9 des cas, on n'a **pas r\u00e9ellement besoin** de cette place m\u00e9moire, tout ce dont on a besoin c'est d'it\u00e9rer sur un certain nombre de valeurs mais **qui peuvent \u00eatre calcul\u00e9es** au fur et \u00e0 mesure que l'on parcourt la liste. "]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["#### Compr\u00e9hension et expression g\u00e9n\u00e9ratrice"]}, {"block": 22, "type": "markdown", "linesLength": 5, "startIndex": 60, "lines": ["\u00c0 la lumi\u00e8re de ce qui vient d'\u00eatre dit, on peut voir qu'une compr\u00e9hension n'est **pas toujours le bon choix**, car par d\u00e9finition elle **construit une liste** de r\u00e9sultats - de la fonction appliqu\u00e9e successivment aux entr\u00e9es.\n", "\n", "Or dans les cas o\u00f9, comme pour `range`, on n'a pas r\u00e9ellement besoin de cette liste **en temps que telle** mais seulement de cet artefact pour pouvoir it\u00e9rer sur la liste des r\u00e9sultats, il est pr\u00e9f\u00e9rable d'utiliser une **expression g\u00e9n\u00e9ratrice**.\n", "\n", "Voyons tout de suite sur un exemple \u00e0 quoi cela ressemblerait."]}, {"block": 23, "type": "code", "linesLength": 7, "startIndex": 65, "lines": ["# dans le premier calcul de arrivee \n", "# pour rappel, la compr\u00e9hension est entre []\n", "# arrivee = [x**2 for x in depart]\n", "\n", "# on peut \u00e9crire presque la m\u00eame chose avec des () \u00e0 la place \n", "arrivee2 = (x**2 for x in depart)\n", "arrivee2"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["Comme pour `range`, le r\u00e9sultat de l'expression g\u00e9n\u00e9ratrice ne se laisse pas regarder avec `print`, mais comme pour `range`, on peut it\u00e9rer sur le r\u00e9sultat:"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 73, "lines": ["for x, y in zip(depart, arrivee2):\n", "    print(f\"x={x} => y={y}\")"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Il n'est pas **toujours** possible de remplacer une compr\u00e9hension par une expression g\u00e9n\u00e9ratrice, mais c'est **souvent souhaitable**, car de cette fa\u00e7on on peut faire de substantielles \u00e9conomies en termes de performances. On peut le faire d\u00e8s lors que l'on a seulement besoin d'it\u00e9rer sur les r\u00e9sultats."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Il faut juste un peu se m\u00e9fier, car comme on parle ici d'it\u00e9rateurs, comme toujours si on essaie de faire plusieurs fois une boucle sur le m\u00eame it\u00e9rateur, il ne se passe plus rien, car l'it\u00e9rateur a \u00e9t\u00e9 \u00e9puis\u00e9"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["for x, y in zip(depart, arrivee2):\n", "    print(f\"x={x} => y={y}\")"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["### Pour aller plus loin"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["Vous pouvez regarder [cette int\u00e9ressante discussion de Guido van Rossum](http://python-history.blogspot.fr/2010/06/from-list-comprehensions-to-generator.html ) sur les compr\u00e9hensions et les expressions g\u00e9n\u00e9ratrices."]}]
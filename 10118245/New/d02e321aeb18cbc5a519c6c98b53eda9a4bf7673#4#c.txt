[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Comparaison de fonctions"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Exercice - niveau interm\u00e9diaire"]}, {"block": 3, "type": "code", "linesLength": 3, "startIndex": 7, "lines": ["\n", "# Pour charger l'exercice\n", "from corrections.exo_compare_all import exo_compare_all"]}, {"block": 4, "type": "markdown", "linesLength": 9, "startIndex": 10, "lines": ["\u00c0 pr\u00e9sent nous allons \u00e9crire une version tr\u00e8s simplifi\u00e9e de l'outil qui est utilis\u00e9 dans ce cours pour corriger les exercices. Vous aurez sans doute remarqu\u00e9 que les fonctions de correction (voyez par exemple xxx), prennent en argument la fonction \u00e0 corriger.\n", "\n", "On vous demande d'\u00e9crire une fonction `compare` qui prend en argument \n", " * deux fonctions `f` et `g`; imaginez que l'une d'entre elles fonctionne et qu'on cherche \u00e0 valider l'autre; dans cette version simplifi\u00e9e toutes les fonctions acceptent exactement un argument;\n", " * une liste d'entr\u00e9es `entrees`; vous pouvez supposer que chacune de ces entr\u00e9es est dans le domaine de `f` et de `g` (dit autrement, on peut appeler `f` et `g` sur chacune des entr\u00e9es sans craindre qu'une exception soit lev\u00e9e);\n", "\n", "Le r\u00e9sultat attendu pour le retour de `compare` est une liste qui contient autant de bool\u00e9ens que d'\u00e9l\u00e9ments dans `entrees`, chacun indiquant si avec l'entr\u00e9e correspondante on a pu v\u00e9rifier que `f(entree) == g(entree)`.\n", "\n", "Dans cette premi\u00e8re version de l'exercice vous pouvez enfin supposer que les entr\u00e9es ne sont pas modifi\u00e9es par `f` ou `g`. "]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["Pour information dans cet exercice:\n", " * `factorial` correspond \u00e0 `math.factorial`\n", " * `fact` et `broken_fact` sont des fonctions impl\u00e9ment\u00e9es par nos soins, la premi\u00e8re est correcte alors que la seconde retourne 0 au lieu de 1 pour l'entr\u00e9e 0."]}, {"block": 6, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["# par exemple\n", "exo_compare_all.example()"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Ce qui, dit autrement, veut tout simplement dire que `fact` et `factorial` co\u00efncident sur les entr\u00e9es 0, 1 et 5, alors que `broken_fact` et `factorial` ne renvoient pas la m\u00eame valeur avec l'entr\u00e9e `0`."]}, {"block": 8, "type": "code", "linesLength": 3, "startIndex": 25, "lines": ["# c'est \u00e0 vous\n", "def compare_all(f, g, entrees):\n", "    \"<votre code>\""]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["# pour v\u00e9rifier votre code\n", "exo_compare_all.correction(compare_all)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["## Exercice - niveau avanc\u00e9"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["# Pour charger l'exercice\n", "from corrections.exo_compare_args import exo_compare_args"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### `compare` revisit\u00e9e"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Nous avons d\u00e9j\u00e0 fait un peu plus t\u00f4t cette semaine, au sujet de la programmation fonctionnelle, un exercice au sujet d'une fonction `compare` qui comparait le r\u00e9sultat de deux fonctions, toutes deux \u00e0 un argument, sur une liste de valeurs d'entr\u00e9e."]}, {"block": 14, "type": "markdown", "linesLength": 9, "startIndex": 35, "lines": ["Nous reprenons ici la m\u00eame id\u00e9e, mais en levant l'hypoth\u00e8se que les deux fonctions attendent un seul argument. Il faut \u00e9crire une nouvelle fonction `compare_args` qui prend en entr\u00e9e\n", " * deux fonctions `f` et `g` comme la derni\u00e8re fois,\n", " * mais cette fois une liste (ou un tuple) `argument_tuples` de **tuples** d'arguments d'entr\u00e9e\n", " \n", " Et comme la fois pr\u00e9c\u00e9dente on attend en retour une liste `retour` de bool\u00e9ens, de m\u00eame taille que `argument_tuples`, telle que, si `len(argument_tuples)` vaut $n$:\n", " \n", "$\\forall i \\in \\{1,...,n\\}$, si `argument_tuples[i]` == [ $a_1$,...,$a_j$ ], alors\n", "\n", "`retour(i) == True` $\\Longleftrightarrow$  f ($a_1$,...,$a_j$) == g ($a_1$,...,$a_j$)"]}, {"block": 15, "type": "markdown", "linesLength": 5, "startIndex": 44, "lines": ["Pour information, dans tout cet exercice:\n", " * `factorial` correspond \u00e0 `math.factorial`\n", " * `fact` et `broken_fact` sont des fonctions impl\u00e9ment\u00e9es par nos soins, la premi\u00e8re est correcte alors que la seconde retourne 0 au lieu de 1 pour l'entr\u00e9e 0.\n", " * `add` correspond \u00e0 l'addition binaire `operator.add`\n", " * `plus` et `broken_plus` sont des additions binaires que nous avons \u00e9crites, l'une \u00e9tant correcte et l'autre \u00e9tant fausse lorsque le premier argument est nul."]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["exo_compare_args.example()"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["# ATTENTION vous devez aussi d\u00e9finir les arguments de la fonction\n", "def compare_args(votre, signature):\n", "    \"<votre_code>\""]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["exo_compare_args.correction(compare_args)"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# La librairie `asyncio`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["* boucle d'\u00e9v\u00e9nements"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["* synchronisation: `Queue`, `Lock` et `Semaphore`"]}, {"block": 4, "type": "markdown", "linesLength": 2, "startIndex": 4, "lines": ["* interaction avec les processus:\n", "  * package `asyncio.subprocess`"]}, {"block": 5, "type": "markdown", "linesLength": 2, "startIndex": 6, "lines": ["* `Transport` et `Protocol` / callback\n", "* `Streams` / API orient\u00e9es coroutine"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["# Utilitaires"]}, {"block": 7, "type": "code", "linesLength": 4, "startIndex": 9, "lines": ["import asyncio\n", "\n", "def reset_loop():\n", "    asyncio.set_event_loop(asyncio.new_event_loop())"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["from asynchelpers import start_timer, sequence"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["# synchronisation avec une queue"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["# pour \u00eatre robuste si on re-ex\u00e9cute ce fragment\n", "reset_loop()"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 17, "lines": ["queue = asyncio.Queue(maxsize=1)"]}, {"block": 12, "type": "code", "linesLength": 6, "startIndex": 18, "lines": ["async def producer(queue):\n", "    count = 1\n", "    while True:\n", "        await queue.put(f'tick{count}')\n", "        count += 1\n", "        await asyncio.sleep(1)"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 24, "lines": ["async def consumer(queue):\n", "    while True:\n", "        received = await queue.get()\n", "        print(f\"got {received}\")\n", "        "]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 29, "lines": ["# on ajoute les coroutines dans la boucle\n", "asyncio.ensure_future(producer(queue))\n", "asyncio.ensure_future(consumer(queue))"]}, {"block": 15, "type": "code", "linesLength": 6, "startIndex": 32, "lines": ["# interrompre avec la touche 'i' \n", "# plusieurs fois si n\u00e9cessaire\n", "try:\n", "    asyncio.get_event_loop().run_forever()\n", "except:\n", "    print(\"bye\")"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["# Limiter le parall\u00e8lisme avec `Queue`"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["reset_loop()"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["window = asyncio.Queue(maxsize = 4)"]}, {"block": 19, "type": "code", "linesLength": 8, "startIndex": 41, "lines": ["async def job(i):\n", "    # prendre un jeton dans la queue\n", "    await window.put(None)\n", "    # pas tout le monde la m\u00eame dur\u00e9e\n", "    duration = (i % 3) + 1\n", "    await sequence(f\"job{i} - duration {duration}\", delay=duration)\n", "    # lib\u00e9rer le jeton\n", "    await window.get()"]}, {"block": 20, "type": "code", "linesLength": 8, "startIndex": 49, "lines": ["for i in range(8):\n", "    asyncio.ensure_future(job(i))\n", "\n", "start_timer()\n", "try:\n", "    asyncio.get_event_loop().run_forever()\n", "except:\n", "    print('bye')"]}, {"block": 21, "type": "markdown", "linesLength": 9, "startIndex": 57, "lines": ["### S\u00e9quencement des jobs\n", "\n", "|     | j0 (1) | j1(2) | j2(3) | j3(1) | j4(2) | j5(3) | j6(1) | j7(2) |\n", "|-----|--------|-------|-------|-------|-------|-------|-------|-------|\n", "| 0-1 | `*`    | `*`   | `*`   | `*`   |       |       |       |       |\n", "| 1-2 |        | `*`   | `*`   |       | `*`   | `*`   |       |       |\n", "| 2-3 |        |       | `*`   |       | `*`   | `*`   | `*`   |       |\n", "| 3-4 |        |       |       |       |       | `*`   |       | `*`   |\n", "| 4-5 |        |       |       |       |       |       |       | `*`   |"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["# Conclusion"]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 67, "lines": ["* la librairie tire le meilleur profit possible de l'OS\n", "  * *signal()* : interruptions\n", "  * *select()* : \u00e9v\u00e9nements li\u00e9s aux entr\u00e9e-sorties"]}, {"block": 24, "type": "markdown", "linesLength": 4, "startIndex": 70, "lines": ["* en offrant une interface de programmation unifi\u00e9e pour\n", "  * les acc\u00e8s r\u00e9seau\n", "  * les processus externes\n", "  * objets utilitaires asynchrones"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["# \u00c9pilogue"]}, {"block": 26, "type": "markdown", "linesLength": 4, "startIndex": 75, "lines": ["* classes abstraites de bas niveau\n", "  * `Transport`, `Protocol`, `Stream`\n", "* commencer avec les librairies de haut niveau\n", "  * HTTP (`aoihttp`)- ssh (`asyncssh`) - telnet (`telnetlib3`) -  BdD's - ..."]}]
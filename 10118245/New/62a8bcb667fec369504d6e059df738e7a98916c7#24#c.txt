[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Usage avan\u00e7\u00e9s de `import`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "code", "linesLength": 2, "startIndex": 7, "lines": ["# notre utilitaire pour afficher le code des modules\n", "from modtools import show_module, find_on_disk"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### Attributs sp\u00e9ciaux"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Les objets de type module poss\u00e8dent des attributs sp\u00e9ciaux ; on les reconna\u00eet facilement car leur nom est en *`__truc__`*, c'est une convention g\u00e9n\u00e9rale dans tous le langage\u00a0: on en a d\u00e9j\u00e0 vu plusieurs exemples avec par exemple les m\u00e9thodes `__iter__()`."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Voici pour commencer les attributs sp\u00e9ciaux les plus utilis\u00e9es ; pour cela nous reprenons le package d'un notebook pr\u00e9c\u00e9dent\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["import package_jouet"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["##### `__name__`"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Le nom canonique du module\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 15, "lines": ["package_jouet.__name__"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 16, "lines": ["package_jouet.module_jouet.__name__"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["##### `__file__`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["L'emplacement du fichier duquel a \u00e9t\u00e9 charg\u00e9 le module ; pour un package ceci d\u00e9note un fichier `__init__.py`\u00a0:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["package_jouet.__file__"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["package_jouet.module_jouet.__file__"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["##### `__all__`"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 22, "lines": ["Il est possible de red\u00e9finir dans un module la variable `__all__`, de fa\u00e7on \u00e0 d\u00e9finir les symboles qui sont r\u00e9ellement concern\u00e9s par un `import *`, [comme c'est d\u00e9crit ici](https://docs.python.org/3/tutorial/modules.html#importing-from-a-package). \n", "\n", "Je rappelle toutefois que l'usage de `import *` est fortement d\u00e9conseill\u00e9 dans du code de production."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### Import absolu"]}, {"block": 19, "type": "markdown", "linesLength": 7, "startIndex": 26, "lines": ["La m\u00e9canique des imports telle qu'on l'a vue jusqu'ici est ce qui s'appelle un *import* absolu qui est depuis python-2.5 le m\u00e9canisme par d\u00e9faut : le module import\u00e9 est syst\u00e9matiquement cherch\u00e9 \u00e0 partir de `sys.path`.\n", "\n", "Dans ce mode de fonctionnement, si on trouve dans le m\u00eame r\u00e9pertoire deux fichiers `foo.py` et `bar.py`, et que dans le premier on fait\u00a0:\n", "\n", "    import bar\n", "    \n", "eh bien alors, malgr\u00e9 le fait qu'il existe ici m\u00eame un fichier `bar.py`, l'import ne r\u00e9ussit pas (sauf si le r\u00e9pertoire courant est dans `sys.path`; en g\u00e9n\u00e9ral ce n'est pas le cas)."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### Import relatif"]}, {"block": 21, "type": "markdown", "linesLength": 8, "startIndex": 34, "lines": ["Ce m\u00e9canisme d'import absolu a l'avantage d'\u00e9viter qu'un module local, par exemple `random.py`, ne vienne cacher le module `random` de la biblioth\u00e8que standard. Mais comment peut-on faire alors pour charger le module `random.py` local ? C'est \u00e0 cela que sert l'import relatif.\n", "\n", "Voyons cela sur un exemple\u00a0qui repose sur la hi\u00e9rarchie suivante\u00a0:\n", "\n", "    package_relatif/\n", "        __init__.py  (vide)\n", "        main.py\n", "        random.py"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Le fichier `__init__.py` ici est vide, et voici le code des deux autres modules\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["import package_relatif"]}, {"block": 24, "type": "code", "linesLength": 3, "startIndex": 44, "lines": ["# le code de main.py\n", "code = find_on_disk(package_relatif, \"main.py\")\n", "!cat $code"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Nous avons illustr\u00e9 dans le point d'entr\u00e9e `main.py` deux exemples d'import relatif\u00a0:"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Les deux clauses `as` sont bien s\u00fbr optionnelles, on les utilise ici uniquement pour bien identifier les diff\u00e9rents objets en jeu."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Le module local `random.py` expose une fonction `alea` qui g\u00e9n\u00e9re un string al\u00e9atoire en se basant sur le module standard `random`\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["# le code de random.py\n", "code = find_on_disk(package_relatif, \"random.py\")\n", "!cat $code"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Cet exemple montre comment on peut importer un module local de nom `random` **et** le module `random` qui provient de la librairie standard\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["import package_relatif.main"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["print(package_relatif.main.alea())"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["##### Pour remonter dans l'arborescence"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Il faut savoir \u00e9galement qu'on peut \"remonter\" dans l'arborescence de fichiers en utilisant plusieurs points `.` cons\u00e9cutifs. Voici un exemple fonctionnel, on part du m\u00eame contenu que ci-dessus avec un sous-package, comme ceci\u00a0:"]}, {"block": 34, "type": "markdown", "linesLength": 7, "startIndex": 58, "lines": ["    package_relatif/\n", "        __init__.py      (vide)\n", "        main.py\n", "        random.py\n", "        subpackage/\n", "            __init__.py  (vide)\n", "            submodule.py"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 65, "lines": ["# voyons le code de submodule:\n", "import package_relatif.subpackage"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["# le code de submodule/submodule.py\n", "code = find_on_disk(package_relatif.subpackage, \"submodule.py\")\n", "!cat $code"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["import package_relatif.subpackage.submodule"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 71, "lines": ["print(package_relatif.subpackage.submodule.alea())"]}, {"block": 39, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["**Ce qu'il faut retenir**\n", "\n", "Sur cet exemple, on montre comment un import relatif permet \u00e0 un module d'importer un module local qui a le m\u00eame nom qu'un module standard. "]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["### Avantages de l'import relatif"]}, {"block": 41, "type": "markdown", "linesLength": 7, "startIndex": 76, "lines": ["Bien s\u00fbr ici on aurait pu faire \n", "\n", "    import package_relatif.random\n", "    \n", "au lieu de \n", "\n", "    from . import random"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Mais l'import relatif pr\u00e9sente notamment l'avantage d'\u00eatre insensible aux renommages divers \u00e0 l'int\u00e9rieur d'une biblioth\u00e8que. "]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["Dit autrement, lorsque deux modules sont situ\u00e9s dans le m\u00eame r\u00e9pertoire, il semble naturel que l'import entre eux se fasse par un import relatif, plut\u00f4t que de devoir r\u00e9p\u00e9ter *ad nauseam* le nom de la biblioth\u00e8que - ici `package_relatif` - dans tous les imports."]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["### Frustrations li\u00e9es \u00e0 l'import relatif"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["#### Se base sur `__name__` et non sur `__file__`"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Toutefois, l'import relatif ne fonctionne pas toujours comme on pourrait s'y attendre. Le point important \u00e0 garder en t\u00eate est que lors d'un import relatif, **c'est l'attribut `__name__`** qui sert \u00e0 d\u00e9terminer le point de d\u00e9part."]}, {"block": 47, "type": "markdown", "linesLength": 13, "startIndex": 88, "lines": ["Concr\u00e8tement, lorsque dans `main.py` on fait\u00a0:\n", "\n", "    from . import random\n", "\n", "l'interpr\u00e9teur\u00a0:\n", "\n", "* d\u00e9termine que dans `main.py`, `__name__` vaut `package_relatif.main`;\n", "* il \"oublie\" le dernier morceau `main` pour calculer que le package courant est `package_relatif`\n", "* et c'est ce nom qui sert \u00e0 d\u00e9terminer le point de d\u00e9part de l'import relatif.\n", "\n", "Aussi cet import est-il retranscrit en\n", "\n", "    from package_relatif import random"]}, {"block": 48, "type": "markdown", "linesLength": 8, "startIndex": 101, "lines": ["De la m\u00eame mani\u00e8re\n", "\n", "    from .random import run\n", "    \n", "devient\n", "\n", "    from package_relatif.random import run\n", "    "]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["Par contre **l'attribut `__file__` n'est pas utilis\u00e9** : ce n'est pas parce que deux fichiers python sont dans le m\u00eame r\u00e9pertoire que l'import relatif va toujours fonctionner. Avant de voir cela sur un exemple, il nous faut revenir sur l'attribut `__name__`."]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["#### Digression sur l'attribut `__name__`"]}, {"block": 51, "type": "markdown", "linesLength": 7, "startIndex": 111, "lines": ["Il faut savoir en effet que le **point d'entr\u00e9e** du programme - c'est-\u00e0-dire le fichier qui est pass\u00e9 directement \u00e0 l'interpr\u00e9teur python - est consid\u00e9r\u00e9 comme un module dont l'attribut `__name__` vaut la cha\u00eene `\"__main__\"`.\n", "\n", "Concr\u00e8tement, si vous faites\n", "\n", "    python3 tests/montest.py\n", "    \n", "alors la valeur observ\u00e9e dans l'attribut `__name__` n'est pas `\"tests.montest\"`, mais la constante `\"__main__\"`."]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 118, "lines": ["C'est pourquoi d'ailleurs [(et c'est \u00e9galement expliqu\u00e9 ici)](https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts) vous trouverez  parfois \u00e0 la fin d'un fichier source une phrase comme celle-ci\u00a0:"]}, {"block": 53, "type": "markdown", "linesLength": 3, "startIndex": 119, "lines": ["    if __name__ == \"__main__\":\n", "        <faire vraiment quelque chose>\n", "        <comme par exemple tester le module>"]}, {"block": 54, "type": "markdown", "linesLength": 4, "startIndex": 122, "lines": ["Cet idiome tr\u00e8s r\u00e9pandu permet d'ins\u00e9rer \u00e0 la fin d'un module du code - souvent un code de test - qui\u00a0:\n", "\n", "* va \u00eatre ex\u00e9cut\u00e9 quand on le passe directement \u00e0 l'interpr\u00e9teur python, mais \n", "* qui n'**est pas ex\u00e9cut\u00e9** lorsqu'on importe le module."]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["#### L'attribut `__package__`"]}, {"block": 56, "type": "markdown", "linesLength": 4, "startIndex": 127, "lines": ["Pour r\u00e9sumer\u00a0:\n", "\n", "* le point d'entr\u00e9e - celui qui est donn\u00e9 \u00e0 `python` sur la ligne de commande - voit comme valeur pour `__name__` la constante `\"__main__\"`,\n", "* et le m\u00e9canisme d'import relatif se base sur `__name__` pour localiser les modules import\u00e9s."]}, {"block": 57, "type": "markdown", "linesLength": 3, "startIndex": 131, "lines": ["Du coup, par construction, il n'est quasiment pas possible d'utiliser les imports relatifs \u00e0 partir du script de lancement.\n", "\n", "Pour pallier \u00e0 ce type d'inconv\u00e9nients, il a \u00e9t\u00e9 introduit ult\u00e9rieurment (voir PEP 366 ci-dessous) la possibilit\u00e9 pour un module de d\u00e9finir (\u00e9crire) l'attribut `__package__`, pour contourner cette difficult\u00e9."]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["#### Ce qu'il faut retenir"]}, {"block": 59, "type": "markdown", "linesLength": 17, "startIndex": 135, "lines": ["On voit que tout ceci est rapidement assez scabreux. Cela explique sans doute l'usage relativement peu r\u00e9pandu des imports relatifs. \n", "\n", "De mani\u00e8re g\u00e9n\u00e9rale, une bonne pratique consiste \u00e0\u00a0:\n", "\n", "* consid\u00e9rer votre ou vos points d'entr\u00e9e comme des accessoires ; un point d'entr\u00e9e typiquement se contente d'importer une classe d'un module, de cr\u00e9er une instance et de lui envoyer une m\u00e9thode ;\n", "* toujours placer ces points d'entr\u00e9e dans un r\u00e9pertoire s\u00e9par\u00e9 ;\n", "* notamment si vous utilisez `setuptools` pour distribuer votre application via `pypi.org`, vous verrez que ces points d'entr\u00e9e sont compl\u00e8tement pris en charge par les outils d'installation.\n", "\n", "S'agissant des tests: \n", "\n", "* la technique qu'on a vue rapidement - de tester si `__name__` vaut `\"__main__\"` - est extr\u00eamement basique et limit\u00e9e. Le mieux est de ne pas l'utiliser en fait, en dehors de micro-maquettes.\n", "* en pratique on \u00e9crit les tests dans un r\u00e9pertoire s\u00e9par\u00e9 - souvent appel\u00e9 `tests` - et en tirant profit de la librairie `unittest`. \n", "* du coup les tests sont toujours ex\u00e9cut\u00e9s avec une phrase comme\n", "\n", "    python3 -m unittest tests.jeu_de_tests\n", "    \n", "et dans ce contexte-l\u00e0, il est possible par exemple pour les tests de recourir \u00e0 l'import relatif.\n"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 152, "lines": ["### Pour en savoir plus"]}, {"block": 61, "type": "markdown", "linesLength": 5, "startIndex": 153, "lines": ["Vous pourrez consulter\u00a0:\n", "\n", "* <https://www.python.org/dev/peps/pep-0328/> qui date du passage de 2.4 \u00e0 2.5, dans lequel on d\u00e9cide que tous les imports sans `.` sont absolus - ce n'\u00e9tait pas le cas au pr\u00e9alable.\n", "* <https://www.python.org/dev/peps/pep-0366/> qui introduit la possibilit\u00e9 de d\u00e9finir `__package__` pour contourner les probl\u00e8mes li\u00e9s aux imports relatifs dans un script.\n", "* <http://sametmax.com/un-gros-guide-bien-gras-sur-les-tests-unitaires-en-python-partie-1/> qui parle des tests unitaires qui est un tout autre et vaste sujet."]}]
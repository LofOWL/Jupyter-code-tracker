[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Visibilit\u00e9 des variables de boucle"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["### Une astuce"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["Dans ce compl\u00e9ment, nous allons beaucoup jouer avec le fait qu'une variable soit d\u00e9finie ou non. Pour nous simplifier la vie, et surtout rendre les cellules plus ind\u00e9pendantes les unes des autres si vous devez les rejouer, nous allons utiliser la formule un peu magique suivante&nbsp;:"]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 5, "lines": ["# on d\u00e9truit la variable i si elle existe\n", "if 'i' in locals(): \n", "    del i"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["qui repose d'une part sur l'instruction `del` que nous avons vue un peu plus t\u00f4t cette semaine, et sur la fonction *builtin* `locals` que nous verrons plus tard; cette formule a l'avantage qu'on peut l'ex\u00e9cuter dans n'importe quel contexte, que `i` soit d\u00e9finie ou non."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### Une variable de boucle reste d\u00e9finie au-del\u00e0 de la boucle"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Cela peut para\u00eetre \u00e9vident, mais explicitons-le tout de m\u00eame&nbsp;: une variable de boucle est d\u00e9finie (assign\u00e9e) dans la boucle et **reste *visible*** une fois la boucle termin\u00e9e. Le plus simple est de le voir sur un exemple&nbsp;:"]}, {"block": 9, "type": "code", "linesLength": 5, "startIndex": 11, "lines": ["# La variable 'i' n'est pas d\u00e9finie\n", "try:\n", "    i\n", "except NameError as e:\n", "    print(e)"]}, {"block": 10, "type": "code", "linesLength": 7, "startIndex": 16, "lines": ["# si \u00e0 pr\u00e9sent on fait une boucle\n", "# avec i comme variable de boucle\n", "for i in [0]:\n", "    pass\n", "\n", "# alors maintenant i est d\u00e9finie\n", "i"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["On dit que la variable *fuite* (en anglais \"*leak*\"), dans ce sens qu'elle continue d'exister  au del\u00e0 du bloc de la boucle \u00e0 proprement parler."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["On peut \u00eatre tent\u00e9 de tirer profit de ce trait, en lisant la valeur de la variable apr\u00e8s la boucle;  l'objet de ce compl\u00e9ment est de vous inciter \u00e0 la prudence, et d'attirer votre attention sur certains points qui peuvent \u00eatre sources d'erreur."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### Attention aux boucles vides"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Tout d'abord, il faut faire attention \u00e0 ne pas \u00e9crire du code qui d\u00e9pende de ce trait **si la boucle peut \u00eatre vide**. En effet, si la boucle ne s'ex\u00e9cute pas du tout, la variable n'**est pas affect\u00e9e** et donc elle n'est pas d\u00e9finie. L\u00e0 aussi c'est \u00e9vident, mais \u00e7a peut l'\u00eatre moins quand on lit du code r\u00e9el, comme par exemple&nbsp;:"]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["# on d\u00e9truit la variable i si elle existe\n", "if 'i' in locals(): \n", "    del i"]}, {"block": 16, "type": "code", "linesLength": 6, "startIndex": 30, "lines": ["def length(l):\n", "    for i, x in enumerate(l):\n", "        pass\n", "    return i + 1\n", "\n", "length([1, 2, 3])"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["\u00c7a a l'air correct, sauf que&nbsp;:"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["length([])"]}, {"block": 19, "type": "markdown", "linesLength": 6, "startIndex": 38, "lines": ["Ce r\u00e9sultat m\u00e9rite une explication. Nous verrons plus tard, en semaine 4, l'exception `UnboundLocalError`, mais pour le moment sachez qu'elle se produit lorsque l'on a dans une fonction une variable locale et une variable globale de m\u00eame nom. Alors, pourquoi l'appel `length([1, 2, 3])` retourne-t-il sans encombre, alors que pour l'appel `length([])` il y a une exception? Cela est li\u00e9 \u00e0 la mani\u00e8re dont python d\u00e9termine qu'une variable est locale. \n", "\n", "Une variable est locale dans une fonction si elle est assign\u00e9e dans la fonction explicitement (avec une op\u00e9ration d'affectation) ou implicitement (par exemple avec une boucle `for`\n", " comme ici), nous reviendrons sur ce point un peu plus tard. Mais pour les fonctions, pour une raison d'efficacit\u00e9, une variable est d\u00e9finie comme locale \u00e0 la phase de pr\u00e9-compilation, c'est-\u00e0-dire *avant* l'ex\u00e9cution du code. Le pr\u00e9-compilateur ne peut pas savoir quel sera l'argument pass\u00e9 \u00e0 la fonction, il peut simplement savoir qu'il y a une boucle `for` utilisant la variable `i`, il en conclut que `i` est locale pour toute la fonction. \n", "\n", "Lors du premier appel, on passe une liste \u00e0 la fonction, liste qui est parcourue par la boucle `for`. En sortie de boucle, on a bien une variale locale `i` qui vaut 3. Lors du deuxi\u00e8me appel par contre, on passe une liste vide \u00e0 la fonction, la boucle `for` ne peut rien parcourir, donc elle retourne imm\u00e9diatement. Lorsque l'on arrive \u00e0 la ligne `return i + 1` de la fonction, la variable `i` n'a pas de valeur (on doit donc chercher `i` dans le module), mais `i` a \u00e9t\u00e9 d\u00e9finie par le pr\u00e9-compilateur comme \u00e9tant locale, on a donc dans la m\u00eame fonction une variable `i` locale et une r\u00e9f\u00e9rence \u00e0 une variable `i` globale, ce qui provoque l'exception `UnboundLocalError`."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["### Comment faire alors ?"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["##### Utiliser une autre variable"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["La premi\u00e8re voie consiste \u00e0 d\u00e9clarer une variable externe \u00e0 la boucle et \u00e0 l'affecter \u00e0 l'int\u00e9rieur de la boucle, c'est-\u00e0-dire&nbsp;:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["candidates = [3, -12, 1, 8]"]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 48, "lines": ["# plut\u00f4t que de faire ceci\n", "for item in candidates:\n", "    if (item**2 + 2 * item - 3) == 0:\n", "        break\n", "print('trouv\u00e9 solution', item)"]}, {"block": 25, "type": "code", "linesLength": 8, "startIndex": 53, "lines": ["# il vaut mieux faire ceci\n", "solution = None\n", "for item in candidates:\n", "    if ( item**2 + 2 * item - 3 ) == 0:\n", "        solution = item\n", "        break\n", "\n", "print('trouv\u00e9 solution', solution)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["##### Au minimum initialiser la variable"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Au minimum, si vous utilisez la variable de boucle apr\u00e8s la boucle, il est vivement conseill\u00e9 de l'**initialiser** explicitement **avant** la boucle, pour vous pr\u00e9munir contre les boucles vides, comme ceci&nbsp;:"]}, {"block": 28, "type": "code", "linesLength": 10, "startIndex": 63, "lines": ["# une version plus robuste de la fonction length de tout \u00e0 l'heure\n", "def length(l):\n", "    # on initialise i explicitement pour le cas o\u00f9 l est vide\n", "    i = -1\n", "    for i, x in enumerate(l):\n", "        pass\n", "    # comme cela i est toujours d\u00e9clar\u00e9e\n", "    return i + 1\n", "\n", "length([])"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["### Les compr\u00e9hensions"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["Notez bien que par contre, les variables de compr\u00e9hension **ne fuitent pas** (contrairement \u00e0 ce qui se passait en python2):"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 75, "lines": ["# on d\u00e9truit la variable i si elle existe\n", "if 'i' in locals(): \n", "    del i"]}, {"block": 32, "type": "code", "linesLength": 8, "startIndex": 78, "lines": ["# en python3, les variables de compr\u00e9hension ne fuitent pas\n", "[i**2 for i in range(3)]\n", "\n", "# ici i est \u00e0 nouveau ind\u00e9finie\n", "try:\n", "    i\n", "except NameError as e:\n", "    print(\"OOPS\", e)"]}]
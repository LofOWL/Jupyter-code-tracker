[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Op\u00e9rations logiques"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["M\u00eame si les tableaux contiennent habituellement des nombres, on peut \u00eatre amen\u00e9s \u00e0 faire des op\u00e9rations logiques et du coup \u00e0 manipuler des tableaux de bool\u00e9ens. Nous allons voir quelques \u00e9l\u00e9ments \u00e0 ce sujet."]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 8, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt"]}, {"block": 5, "type": "code", "linesLength": 4, "startIndex": 10, "lines": ["%matplotlib inline\n", "plt.ion()\n", "%pylab inline\n", "pylab.rcParams['figure.figsize'] = (6, 6)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Op\u00e9rations logiques"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["On peut faire des op\u00e9rations logiques entre tableaux exactement comme on fait des op\u00e9rations arithm\u00e9tiques\u00a0:"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["On va partir de deux tableaux presque identiques. J'en profite pour vous signaler qu'on peut copier un tableau avec tout simplement `np.copy`\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["a = np.arange(25).reshape(5, 5)\n", "print(a)"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 19, "lines": ["b = np.copy(a)\n", "b[2, 2] = 1000\n", "print(b)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Dans la lign\u00e9e de ce qu'on a vu jusqu'ici en mati\u00e8re de programmation vectorielle, une op\u00e9ration logique va ici aussi nous retourner un tableau de la m\u00eame taille\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["# la comparaison par == ne nous\n", "# retourne pas directement un bool\u00e9en\n", "# mais un tableau de la m\u00eame taille que a et b\n", "print(a == b)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### `all` et `any`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Si votre intention est de v\u00e9rifier que les deux tableaux sont enti\u00e8rement identiques, utilisez `np.all` - et non pas le *built-in* natif `all` de python\u00a0- qui va v\u00e9rifier que tous les \u00e9l\u00e9ments du tableau sont vrais\u00a0:"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 29, "lines": ["# oui\n", "np.all(a == a)"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["# oui\n", "np.all(a == b)"]}, {"block": 17, "type": "code", "linesLength": 6, "startIndex": 33, "lines": ["# oui\n", "# on peut faire aussi bien\n", "# np.all(x)\n", "# ou \n", "# x.all()\n", "(a == a).all()"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 39, "lines": ["# par contre : non! \n", "# ceci n'est pas conseill\u00e9\n", "# m\u00eame si \u00e7a peut parfois fonctionner\n", "all(a == a)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["C'est bien s\u00fbr la m\u00eame chose pour `any` qui va v\u00e9rifier qu'il y a au moins un \u00e9l\u00e9ment vrai. Comme en python natif, un nombre qui est nul est consid\u00e9r\u00e9 comme faux\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["np.zeros(5).any()"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["np.ones(5).any()"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["### Masques"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Mais en g\u00e9n\u00e9ral, c'est rare qu'on ait besoin de consolider de la sorte un bool\u00e9en sur tout un tableau, on utilise plut\u00f4t les tableaux logiques comme des masques, pour faire ou non des op\u00e9rations sur un autre tableau."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["J'en profite pour introduire une fonction de `matplotlib` qui s'appelle `imshow` et qui permet d'afficher une image\u00a0:"]}, {"block": 25, "type": "code", "linesLength": 9, "startIndex": 49, "lines": ["# construisons un disque centr\u00e9 au milieu de l'image\n", "\n", "width = 128\n", "center = width / 2\n", "\n", "ix, iy = np.indices((width, width))\n", "image = (ix-center)**2 + (iy-center)**2\n", "# pour afficher l'image en niveaux de gris\n", "plt.imshow(image, cmap='gray');"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["Maintenant je peux cr\u00e9er un masque qui produise des rayures en diagonale, donc selon la valeur de `(i+j)`. Par exemple\u00a0:"]}, {"block": 27, "type": "code", "linesLength": 4, "startIndex": 59, "lines": ["# pour faire des rayures \n", "# de 6 pixels de large \n", "rayures = (ix + iy) % 8 <= 5\n", "plt.imshow(rayures, cmap='gray');"]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 63, "lines": ["# en fait c'est bien s\u00fbr \n", "# un tableau de bool\u00e9ens\n", "print(rayures)"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["je vous montre aussi comment inverser un masque parce que c'est un peu abscons\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 9, "startIndex": 67, "lines": ["# on pourrait penser faire `not rayures` mais non,\n", "#   c'est un peu comme pour all() et any()\n", "# on ne peut pas non plus d'ailleurs faire \n", "#   anti_rayures.not() parce not est un mot cl\u00e9\n", "# et on ne peut pas non plus faire\n", "#   anti_rayures.logical_not() - et \u00e7a c'est plut\u00f4t un d\u00e9faut\n", "\n", "anti_rayures = np.logical_not(rayures)\n", "plt.imshow(anti_rayures, cmap='gray');"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["Maintenant je peux utiliser le masque `rayures` pour faire des choses sur l'image. Par exemple simplement\u00a0:"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["# pour effacer les rayures\n", "plt.imshow(image*rayures, cmap='gray');"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# ou garder l'autre moiti\u00e9\n", "plt.imshow(image*anti_rayures, cmap='gray');"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 81, "lines": ["image"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["np.logical_not(image)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["### Expression conditionnelle et `np.where`"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["Noous avons vu en python natif l'expression conditionnelle\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 85, "lines": ["3 if True else 2"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["Pour reproduire cette construction en `numpy` vous avez \u00e0 votre disposition `np.where`. Pour l'illustrer nous allons construire deux images facilement discernables. Et pour \u00e7a on va utiliser `np.isclose`, qui est tr\u00e8s utile pour comparer que deux nombres sont suffisamment proches, surtout pour les calculs flottants en fait, mais \u00e7a nous convient tr\u00e8s bien ici aussi\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 87, "lines": ["np.isclose?"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Pour \u00e9laborer une image qui contient un grand cercle, je vais dire que la distance au centre (je rappelle que c'est le contenu de `image`) est suffisamment proche de $64^2$, ce que vaut `image` au milieu de chaque bord\u00a0:"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 89, "lines": ["big_circle = np.isclose(image, 64 **2, 10/100)\n", "plt.imshow(big_circle, cmap='gray');"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 91, "lines": ["small_circle = np.isclose(image, 32 **2, 10/100)\n", "plt.imshow(small_circle, cmap='gray');"]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 93, "lines": ["En utilisant `np.where`, je peux simuler quelque chose comme ceci\u00a0:\n", "\n", "    mixed = big_circle if rayures else small_circle"]}, {"block": 45, "type": "code", "linesLength": 3, "startIndex": 96, "lines": ["# sauf que \u00e7a se pr\u00e9sente en fait comme ceci\u00a0:\n", "mixed = np.where(rayures, big_circle, small_circle)\n", "plt.imshow(mixed, cmap='gray');"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 99, "lines": ["Remarquez enfin qu'on peut aussi faire la m\u00eame chose en tirant profit que `True` == 1 et `False` == 0\u00a0:"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 100, "lines": ["mixed2 = rayures * big_circle + (1-rayures) * small_circle\n", "plt.imshow(mixed2, cmap='gray');"]}]
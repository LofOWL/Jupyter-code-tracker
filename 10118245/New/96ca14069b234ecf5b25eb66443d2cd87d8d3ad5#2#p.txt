[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Passage d'arguments"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Exercice - niveau basique"]}, {"block": 2, "type": "markdown", "linesLength": 6, "startIndex": 2, "lines": ["Vous devez \u00e9crire une fonction `distance` qui prend un nombre quelconque d'arguments num\u00e9riques non complexes, et qui retourne la racine carr\u00e9e de la somme des carr\u00e9s des arguments. \n", "\n", "Plus pr\u00e9cis\u00e9ment :\n", "$distance$ ($x_1$, ..., $x_n$) = $\\sqrt{\\sum x_i^2}$\n", "\n", "Par convention on fixe que $ distance() = 0. $"]}, {"block": 3, "type": "heading", "linesLength": 1, "startIndex": 8, "lines": ["Exercice - niveau interm\u00e9daire"]}, {"block": 4, "type": "markdown", "linesLength": 7, "startIndex": 9, "lines": ["On vous demande d'\u00e9crire une fonction qui prend en argument\n", " * une fonction `f`, dont vous savez seulement que le premier argument est num\u00e9rique, et qu'elle ne prend **que des arguments positionnels** (sans valeur par d\u00e9faut)\n", " * un nombre quelconque - mais au moins 1 - d'arguments positionnels `args`, dont on sait qu'ils pourraient \u00eatre pass\u00e9s \u00e0 `f`\n", " \n", "Et on attend en retour le r\u00e9sultat de `f` appliqu\u00e9s \u00e0 tous ces arguments, mais avec le premier d'entre eux multipl\u00e9 par deux.\n", "\n", "Formellement: doubler_premier(f, $x_1$, $x_2$,..., $x_n$) = f($2*x_1$, $x_2$,..., $x_n$)"]}, {"block": 5, "type": "heading", "linesLength": 1, "startIndex": 16, "lines": ["Exercice - niveau interm\u00e9daire"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Vous devez maintenant \u00e9crire une deuxi\u00e8me version qui peut fonctionner avec une fonction quelconque (elle peut avoir des arguments nomm\u00e9s avec valeurs par d\u00e9faut)"]}, {"block": 7, "type": "heading", "linesLength": 1, "startIndex": 18, "lines": ["Exercice - niveau avanc\u00e9"]}, {"block": 8, "type": "heading", "linesLength": 1, "startIndex": 19, "lines": ["`validation` revisit\u00e9e"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Nous avons d\u00e9j\u00e0 fait un peu plus t\u00f4t cette semaine, au sujet de la programmation fonctionnelle, un exercice au sujet d'une fonction `validation` qui comparait le r\u00e9sultat de deux fonctions, toutes deux \u00e0 un argument, sur une liste de valeurs d'entr\u00e9e."]}, {"block": 10, "type": "markdown", "linesLength": 9, "startIndex": 21, "lines": ["Nous reprenons ici la m\u00eame id\u00e9e, mais en levant l'hypoth\u00e8se que les deux fonctions attendent un seul argument. Il faut \u00e9crire une nouvelle version de la fonction `validation` qui prend en entr\u00e9e\n", " * deux fonctions `f` et `g` comme la derni\u00e8re fois,\n", " * mais cette fois une liste (ou un tuple) `argument_tuples` de **tuples** d'arguments d'entr\u00e9e\n", " \n", " Et comme la fois pr\u00e9c\u00e9dente on attend en retour une liste `retour` de bool\u00e9ens, de m\u00eame taille que `argument_tuples`, telle que, si `len(argument_tuples)` vaut $n$:\n", " \n", "$\\forall i \\in \\{1,...,n\\}$, si `argument_tuples[i]` == [ $a_1$,...,$a_j$ ], alors\n", "\n", "`return(i) == True` $\\Longleftrightarrow$  f ($a_1$,...,$a_j$) == g ($a_1$,...,$a_j$)"]}, {"block": 11, "type": "markdown", "linesLength": 5, "startIndex": 30, "lines": ["Pour information:\n", " * `factorial` correspond \u00e0 `math.factorial`\n", " * `fact` et `broken_fact` sont des fonctions impl\u00e9ment\u00e9es par nos soins, la premi\u00e8re est correcte alors que la seconde retourne 0 au lieu de 1 pour l'entr\u00e9e 0.\n", " * `add` correspond \u00e0 l'addition binaire `operator.add`\n", " * `plus` et `broken_plus` sont des additions binaires \u00e9crites par nous, l'une \u00e9tant correcte et l'autre \u00e9tant fausse lorsque le premier argument est nul."]}]
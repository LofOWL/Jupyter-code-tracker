[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Les slices en python"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Ce support de cours reprend les notions de *slicing* vues dans la vid\u00e9o."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["Nous allons illustrer les slices sur la chaine suivante; rappelez-vous toutefois que ce m\u00e9canisme fonctionne avec toutes les s\u00e9quences comme les listes ou les tuples."]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 5, "lines": ["chaine = \"abcdefghijklmnopqrstuvwxyz\" ; print(chaine)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["### Slice sans pas"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["On a vu en cours qu'une slice permet de d\u00e9signer toute une plage d'\u00e9l\u00e9ments d'une s\u00e9quence. Ainsi on peut \u00e9crire"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 8, "lines": ["chaine[2:6]"]}, {"block": 9, "type": "markdown", "linesLength": 8, "startIndex": 9, "lines": ["Les d\u00e9butants ont parfois du mal avec les bornes. Il faut se souvenir que:\n", "\n", "* les indices **commencent** comme toujours **\u00e0 z\u00e9ro**\n", "* le premier indice `debut` est inclus\n", "* le second indice `fin` est exclu\n", "* on obtient en tout `fin-debut` items dans le r\u00e9sultat\n", "\n", "Ainsi ci-dessus le r\u00e9sultat contient `6 - 2 = 4` \u00e9l\u00e9ments."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["#### Bornes omises"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["On peut omettre une borne:"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 19, "lines": ["# si on omet la premi\u00e8re borne, cela signifie que \n", "# la slice commence au d\u00e9but de l'objet\n", "chaine[:6]"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["# et bien entendu c'est la m\u00eame chose si on omet la deuxi\u00e8me borne:\n", "chaine[24:]"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 24, "lines": ["# ou m\u00eame omettre les deux bornes, auquel cas on\n", "# fait une copie de l'objet - on y reviendra plus tard:\n", "chaine[:]"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["#### Indices n\u00e9gatifs"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["On peut utiliser des indices n\u00e9gatifs pour compter \u00e0 partir de la fin:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["chaine[3:-3]"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["chaine[-3:]"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["### Slice avec pas"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Il est \u00e9galement possible de pr\u00e9ciser un *pas*, de fa\u00e7on \u00e0 ne choisir par exemple, dans la plage donn\u00e9e, qu'un \u00e9l\u00e9ment sur deux:"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 33, "lines": ["# le pas est pr\u00e9cis\u00e9 apr\u00e8s un deuxi\u00e8me deux-points (:)\n", "# ici on va choisir un caract\u00e8re sur deux dans la plage [3:-3]\n", "chaine[3:-3:2]"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["Comme on le devine, le troisi\u00e8me \u00e9l\u00e9ment de la slice, ici `2`, d\u00e9termine le pas. On ne retient donc, dans la chaine `def...` que `d`, puis `f`, et ainsi de suite.\n", "\n", "On peut pr\u00e9ciser du coup la borne de fin (ici `-3`) avec un peu de libert\u00e9, puisqu'ici on obtiendrait un r\u00e9sultat identique avec `-4`:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["chaine[3:-4:2]"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["### Pas n\u00e9gatif"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 41, "lines": ["Il est m\u00eame possible de sp\u00e9cifier un pas n\u00e9gatif. Dans ce cas, de mani\u00e8re un peu contre-intuitive, il faut pr\u00e9ciser un d\u00e9but (le premier indice de la slice) qui soit *plus \u00e0 droite* que la fin (le second indice).\n", "\n", "Pour prendre un exemple, comme l'\u00e9l\u00e9ment d'indice `-3` - c-\u00e0-d. `x` - est plus \u00e0 droite que l'\u00e9l\u00e9ment d'indice `3` - c-\u00e0-d. `d` - \u00e9videmment so on ne pr\u00e9cisait pas le pas (qui revient \u00e0 choisir un pas \u00e9gal \u00e0 `1`), on obtiendrait une liste vide:"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["chaine[-3:3]"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Si maintenant on pr\u00e9cise un pas n\u00e9gatif, on obtient cette fois"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["chaine[-3:3:-2]"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["### Conclusion"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["\u00c0 nouveau, souvenez-vous que tous ces m\u00e9canismes fonctionnent avec de nombreux autres types que les chaines de caract\u00e8res. En voici deux exemples, qui anticipent tous les deux sur la suite, mais qui devraient illustrer les vastes possiblit\u00e9s qui sont offertes avec les slices."]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["#### Listes"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Par exemple sur les listes: "]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 51, "lines": ["liste = [0, 2, 4, 8, 16, 32, 64, 128]\n", "liste"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 53, "lines": ["liste[-1:1:-2]"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Et m\u00eame ceci - qui peut \u00eatre d\u00e9routant (nous reviendrons naturellement sur tout ceci)"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 55, "lines": ["liste[2:4] = [100, 200, 300, 400, 500]\n", "liste"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["#### `numpy`"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["La librairie `numpy` permet de manipuler des tableaux ou matrices. En anticipant (beaucoup) sur son usage que nous reverrons bien entendu en d\u00e9tails, voici un aper\u00e7u de ce qu'on peut faire avec des slices sur des objets `numpy`:"]}, {"block": 40, "type": "code", "linesLength": 6, "startIndex": 60, "lines": ["# ces deux premi\u00e8res cellules sont \u00e0 admettre\n", "# on construit un tableau ligne\n", "import numpy as np\n", "\n", "un_cinq = np.array([1, 2, 3, 4, 5]) \n", "un_cinq"]}, {"block": 41, "type": "code", "linesLength": 6, "startIndex": 66, "lines": ["# ces deux premi\u00e8res cellules sont \u00e0 admettre\n", "# on le combine avec lui-m\u00eame - et en utilisant une slice un peu magique\n", "# pour former un tableau carr\u00e9 5x5\n", "\n", "array = 10 * un_cinq[:, np.newaxis] + un_cinq\n", "array"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["Sur ce tableau de taille 5x5, nous pouvons aussi faire du slicing et extraire le sous-tableau 3x3 au centre:"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 73, "lines": ["extrait = array[1:4, 1:4]\n", "extrait"]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Cr\u00e9ation de tableaux"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Passons rapidement en revue quelques m\u00e9thodes pour cr\u00e9er des tableaux `numpy`\u00a0:"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 8, "lines": ["import numpy as np"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### Non initialis\u00e9\u00a0: `np.empty`"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["La m\u00e9thode la plus efficace pour cr\u00e9er un tableau `numpy` consiste \u00e0 faire l'allocation de la m\u00e9moire mais sans l'initialiser\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 11, "lines": ["memory = np.empty(dtype=np.int8,\n", "                  shape=(1_000, 1_000))"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["J'en profite pour attirer votre attention sur l'impression des gros tableaux, o\u00f9 on s'efforce de vous montrer les coins\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["print(memory)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Il se *peut* que vous voyiez ici des valeurs particuli\u00e8res\u00a0; selon votre OS, il y a une probabilit\u00e9 non null que vous ne voyiez ici que des z\u00e9ros. C'est un peu comme avec les dictionnaires qui, depuis la version 3.6, peuvent donner l'impression de conserver l'ordre dans lequel les cl\u00e9s ont \u00e9t\u00e9 cr\u00e9\u00e9es. Ici c'est un peu la m\u00eame chose, vous ne devez pas \u00e9crire un programme qui repose sur le fait que `np.empty`  retourne un tableau garni de z\u00e9ros (utilisez alors `np.zeros`, qu'on va voir tout de suite)."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["### Tableaux constants"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["On peut aussi cr\u00e9er et initialiser un tableau avec `np.zeros` et `np.ones`\u00a0:"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["zeros = np.zeros(dtype=np.complex128, shape=(1_000, 100))\n", "print(zeros)"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 20, "lines": ["fours = 4 * np.ones(dtype=float, shape=(8, 8))\n", "fours"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["### Progression arithm\u00e9tique\u00a0: `arange`"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["En guise de rappel, avec `arange` on peut cr\u00e9er des tableaux de valeurs espac\u00e9es d'une valeur constante. \u00c7a ressemble donc un peu au `range` de python natif\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["np.arange(4)"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["np.arange(1, 5)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Sauf qu'on peut y passer un pas qui n'est pas entier\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["np.arange(5, 7, .5)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Progression arithm\u00e9tique\u00a0: `linspace`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Mais bien souvent, plut\u00f4t que de pr\u00e9ciser *le pas* entre deux valeurs, on pr\u00e9f\u00e8re pr\u00e9ciser *le nombre* de points\u00a0; et aussi inclure la deuxi\u00e8me borne. C'est ce que fait `linspace`, c'est tr\u00e8s utile pour mod\u00e9liser une fonction sur un intervalle, on a d\u00e9j\u00e0 vu des exemples de ce genre\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 30, "lines": ["%matplotlib inline\n", "import matplotlib.pyplot as plt\n", "plt.ion()"]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 33, "lines": ["X = np.linspace(-3., +3.)\n", "Y = np.exp(X)\n", "\n", "plt.plot(X, Y);"]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 37, "lines": ["# par d\u00e9faut linspace cr\u00e9e 50 points\n", "# avec moins de points\n", "\n", "X = np.linspace(1/10, 10, num = 5)\n", "plt.plot(X, np.log(X));"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Pour des intervalles en progression g\u00e9om\u00e9trique, voyez `np.geomspace`."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["### Multi-dimensions\u00a0: `indices`"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["La m\u00e9thode `np.indices` se comporte un peu comme `arange` mais pour plusieurs directions\u00a0; voyons \u00e7a sur un exemple\u00a0:"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["ix, iy = np.indices((3, 5))"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["ix"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["iy"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Cette fonction s'appelle `indices` parce qu'elle produit des tableaux (ici 2 car on lui a pass\u00e9 une `shape` \u00e0 deux dimensions) qui contiennent, \u00e0 la case *(i, j)*, $i$ (pour le premier tableau) ou $j$ pour le second."]}, {"block": 33, "type": "markdown", "linesLength": 5, "startIndex": 49, "lines": ["Ainsi si vous voulez construire un tableau de taille (2, 4) dans lequel, par exemple\n", "\n", "    tab[i, j] = 200 * i + 2 * j + 50\n", "\n", "vous n'avez qu'\u00e0 faire\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 54, "lines": ["ix, iy = np.indices((2, 4))\n", "tab = 200*ix + 2*iy + 50\n", "tab"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["### Multi-dimensions\u00a0: `meshgrid`"]}, {"block": 36, "type": "markdown", "linesLength": 7, "startIndex": 58, "lines": ["Si vous voulez cr\u00e9er un tableau un peu comme avec `linspace`, mais en plusieurs dimensions\u00a0: imaginez par exemple que vous voulez tracer une fonction \u00e0 deux entr\u00e9es\u00a0:\n", "\n", "$f : (x, y) \\longrightarrow cos(x) + cos^2(y)$\n", "\n", "Sur un pav\u00e9 d\u00e9limit\u00e9 par\u00a0:\n", "\n", "$x \\in [-\\pi, +\\pi], y \\in [3\\pi, 5\\pi]$"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Il vous faut donc cr\u00e9er un tableau, disons de 50 x 50 points, qui r\u00e9alise un maillage uniforme de ce pav\u00e9, et pour \u00e7a vous pouvez utiliser `meshgrid`. Pour commencer\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 6, "startIndex": 66, "lines": ["# on fabrique deux tableaux qui \u00e9chantillonnent\n", "# de mani\u00e8re uniforme les intervalles en X et en Y\n", "# on prend un pas de 10 dans les deux sens, \u00e7a nous donnera\n", "# 100 points pour couvrir l'espace carr\u00e9 qui nous int\u00e9resse\n", "\n", "Xticks, Yticks = np.linspace(-np.pi, np.pi, num=10), np.linspace(3*np.pi, 5*np.pi, num=10)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["Avec meshgrid, on va cr\u00e9er deux tableaux, qui sont respectivement les (100) X et les (100) Y de notre maillage\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 7, "startIndex": 73, "lines": ["# avec meshgrid on les croise\n", "# \u00e7a fait comme un produit cart\u00e9sien, en extrayant les X et les Y du r\u00e9sultat\n", "\n", "X, Y = np.meshgrid(Xticks, Yticks)\n", "\n", "# chacun des deux est donc de taille 10 x 10\n", "X.shape, Y.shape"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["Qu'est-ce qu'on peut faire avec \u00e7a\u00a0? Eh bien en fait on a tout ce qu'il nous faut pour afficher notre fonction\u00a0:"]}, {"block": 42, "type": "code", "linesLength": 3, "startIndex": 81, "lines": ["# un tableau 10 x 10 qui contient les images de f()\n", "# sur les points de la grille\n", "Z = np.cos(X) + np.cos(Y)**2"]}, {"block": 43, "type": "code", "linesLength": 4, "startIndex": 84, "lines": ["from mpl_toolkits.mplot3d import Axes3D\n", "fig = plt.figure()\n", "ax = fig.add_subplot(111, projection='3d')\n", "ax.plot_wireframe(X, Y, Z);"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Je vous laisse vous convaincre qu'il est facile d'\u00e9crire `np.indices` \u00e0 partir de `np.meshgrid` et `np.arange`."]}]
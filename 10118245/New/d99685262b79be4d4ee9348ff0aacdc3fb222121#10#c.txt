[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["S\u00e9quences"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Exercice - niveau basique"]}, {"block": 2, "type": "heading", "linesLength": 1, "startIndex": 2, "lines": ["Slicing"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["On se donne une cha\u00eene de caract\u00e8res:"]}, {"block": 4, "type": "code", "linesLength": 2, "startIndex": 4, "lines": ["import string\n", "chaine = string.lowercase ; print chaine"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Pour chacune des sous-cha\u00eenes ci-dessous, \u00e9crire une expression de slicing sur `chaine` qui renvoie la sous-cha\u00eene. La cellule de code doit retourner `True`"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Par exemple pour obtenir \"def\":"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 8, "lines": ["chaine [ 3:6 ] == \"def\""]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["1) Pour obtenir \"vwx\" (n'h\u00e9sitez pas \u00e0 utiliser les indices n\u00e9gatifs)"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 10, "lines": ["chaine [ <votre code> ] == \"vwx\""]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["2) Pour obtenir \"wxyz\" (avec une seule constante)"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["chaine [ <votre code> ] == \"wxyz\""]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["3) Pour obtenir \"dfhjlnprtvxz\" (avec deux constantes)"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 14, "lines": ["chaine [ <votre code> ] == \"dfhjlnprtvxz\""]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["4) Pour obtenir \"xurolifc\" (avec deux constantes)"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 16, "lines": ["chaine [ <votre code> ] == \"xurolifc\""]}, {"block": 16, "type": "heading", "linesLength": 1, "startIndex": 17, "lines": ["Exercice - niveau interm\u00e9diaire"]}, {"block": 17, "type": "heading", "linesLength": 1, "startIndex": 18, "lines": ["Longueur"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["On vous donne une cha\u00eene \"composite\", dont on sait qu'elle a \u00e9t\u00e9 calcul\u00e9e \u00e0 partir de deux cha\u00eenes \"inconnue\" et \"connue\" comme ceci:"]}, {"block": 19, "type": "raw", "linesLength": 1, "startIndex": 20, "lines": ["composite = connue + inconnue + connue"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 21, "lines": ["L'exercice consiste \u00e0 retrouver la valeur de \"inconnue\" \u00e0 partir de celles de \"composite\" et \"connue\"\n", "\n", "Ne vous inqui\u00e9tez pas si vous ne comprenez pas encore le code d'initialisation :)"]}, {"block": 21, "type": "code", "linesLength": 8, "startIndex": 24, "lines": ["alphabet = \"0123456789abcdef\"\n", "# on calcule connue comme une chaine aleatoire\n", "import random\n", "connue = \"\".join(random.sample(alphabet, random.randint(5,10)))\n", "print \"connue=\",connue\n", "# pareil pour inconnue, a vous de retrouver sa valeur\n", "composite = connue + \"\".join(random.sample(alphabet, random.randint(5,10))) + connue\n", "print \"composite=\",composite"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["5) \u00c0 vous d'\u00e9crire une ligne de code pour retrouver \"inconnue\""]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["inconnue = <votre code>"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Rappel: la fonction len() permet de calculer la longueur d'une s\u00e9quence"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Indice: nous avons jusqu'\u00e0 maintenant toujours utilis\u00e9 des indices constants, mais vous pouvez utiliser aussi des expressions, bien entendu:"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 36, "lines": ["composite [ : len(connue) ] == connue"]}]
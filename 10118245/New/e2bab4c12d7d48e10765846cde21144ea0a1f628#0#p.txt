[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Passage d'arguments"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 2, "type": "heading", "linesLength": 1, "startIndex": 2, "lines": ["Motivation"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 3, "lines": ["Jusqu'ici nous avons d\u00e9velopp\u00e9 le mod\u00e8le simple qu'on trouve dans tous les langages de programmation, \u00e0 savoir qu'une fonction a un nombre fixe, suppos\u00e9 connu, d'arguments. Ce mod\u00e8le a cependant quelques limitations; les m\u00e9canismes de passage d'arguments que propose python, et que nous venons de voir dans les vid\u00e9os, visent \u00e0 lever ces limitations.\n", "\n", "Voyons de quelles limitations il s'agit."]}, {"block": 4, "type": "heading", "linesLength": 1, "startIndex": 6, "lines": ["Nombre d'arguments non connu \u00e0 l'avance"]}, {"block": 5, "type": "heading", "linesLength": 1, "startIndex": 7, "lines": ["Ou encore : introduction \u00e0 la forme `*arguments`"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Pour prendre un exemple aussi simple que possible, imaginons que `print` est comme dans python-3, non plus une instruction, mais une fonction. On peut faire cela en python-2 en [important le module `__future__`](https://docs.python.org/2/library/__future__.html) qui permet d'utiliser des fonctionnalit\u00e9s disponibles dans des versions ult\u00e9rieures de python. Dans le cas qui nous int\u00e9resse, l'import ci-dessous permet de remplacer l'instruction `print` par une fonction `print` qui se comporte comme dans python-3."]}, {"block": 7, "type": "markdown", "linesLength": 7, "startIndex": 9, "lines": ["Imaginons maintenant que nous voulons impl\u00e9menter une variante de `print`, c'est-\u00e0-dire une fonction `error`, qui se comporte exactement comme `print` sauf qu'elle ajoute en d\u00e9but de ligne une balise `ERROR`.\n", "\n", "Se posent alors deux probl\u00e8mes. \n", " * D'une part il nous faut un moyen de sp\u00e9cifier que notre fonction prend un nombre quelconque d'arguments. \n", " * D'autre part il faut une syntaxe pour repasser tous ces arguments \u00e0 la fonction `print`.\n", " \n", "On peut faire tout cela avec la notation en `*` comme ceci"]}, {"block": 8, "type": "heading", "linesLength": 1, "startIndex": 16, "lines": ["L\u00e9g\u00e8re variation"]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 17, "lines": ["Pour sophistiquer un peu cet exemple, on veut maintenant imposer \u00e0 la fonction erreur qu'elle re\u00e7oive un argument obligatoire de type entier qui repr\u00e9sente un code d'erreur, plus \u00e0 nouveau un nombre quelconque d'arguments pour `print`. \n", "\n", "Pour cela, on peut cr\u00e9er une signature qui va m\u00e9langer un argument traditionnel en premi\u00e8re position, qui sera obligatoire \u00e0 l'appel, et le tuple des arguments pour `print`, comme ceci"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Remarquons que maintenant la fonction `error` ne peut plus \u00eatre appel\u00e9e sans argument, puisqu'on a mentionn\u00e9 un param\u00e8tre obligatoire `error_code`."]}, {"block": 11, "type": "heading", "linesLength": 1, "startIndex": 21, "lines": ["Ajout de fonctionnalit\u00e9s"]}, {"block": 12, "type": "heading", "linesLength": 1, "startIndex": 22, "lines": ["Ou encore : la forme `argument=valeur_par_defaut`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Nous envisageons \u00e0 pr\u00e9sent le cas - tout \u00e0 fait ind\u00e9pendant de ce qui pr\u00e9c\u00e8de - o\u00f9 vous avez \u00e9crit une librairie graphique, dans laquelle vous exposez une fonction `ligne` d\u00e9finie comme suit. \u00c9videmment pour garder le code simple, nous imprimons seulement les coordonn\u00e9es du segment; souvenez vous que ce notebook utilise `print_function`:"]}, {"block": 14, "type": "markdown", "linesLength": 10, "startIndex": 24, "lines": ["Vous publiez cette librairie en version 1, vous avez des utilisateurs; et quelque temps plus tard vous \u00e9crivez une version 2 qui prend en compte la couleur. Ce qui vous conduit \u00e0 ajouter un param\u00e8tre pour `ligne`. \n", "\n", "Si vous le faites en d\u00e9clarant \n", "\n", "    def ligne(x1, y1, x2, y2, couleur):\n", "        ...\n", "      \n", "alors tous les utilisateurs de la version 1 vont devoir changer leur code - pour rester \u00e0 fonctionnalit\u00e9 \u00e9gale - en ajoutant un cinqui\u00e8me argument 'noir' \u00e0 leurs appels \u00e0 `ligne`.\n", "\n", "Vous pouvez \u00e9viter cet inconv\u00e9nient en d\u00e9finissant une deuxi\u00e8me version de `ligne` comme ceci"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Avec cette nouvelle d\u00e9finition, on peut aussi bien"]}, {"block": 16, "type": "heading", "linesLength": 1, "startIndex": 35, "lines": ["Les param\u00e8tres par d\u00e9faut sont tr\u00e8s utiles"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["Notez bien que ce genre de situation peut tout aussi bien se produire sans que vous ne publiiez de librairie, \u00e0 l'int\u00e9rieur d'une seule application. Par exemple, cette situation peut se produire si vous avez un jour \u00e0 ajouter un argument \u00e0 une fonction parce qu'elle doit faire face \u00e0 de nouvelles situations impr\u00e9vues, mais que vous n'avez pas le temps de modifier tout le code.\n", "\n", "Ou encore plus simplement, vous pouvez choisir d'utiliser ce passage de param\u00e8tres d\u00e8s le d\u00e9but de la conception. Si vous impl\u00e9mentez par exemple une fonction `ligne` dans un environnement r\u00e9aliste, il vous faut une interface qui pr\u00e9cise: les points concern\u00e9s, la couleur du trait, l'\u00e9paisseur du trait, le style du trait, le niveau de transparence, etc... Et il n'est vraiment pas utile que tous les appels \u00e0 `ligne` repr\u00e9cisent tout ceci int\u00e9gralement, aussi une bonne partie de ces param\u00e8tres seront tr\u00e8s constructivement d\u00e9clar\u00e9s avec une valeur par d\u00e9faut."]}, {"block": 18, "type": "heading", "linesLength": 1, "startIndex": 39, "lines": ["Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 19, "type": "heading", "linesLength": 1, "startIndex": 40, "lines": ["\u00c9crire un wrapper"]}, {"block": 20, "type": "heading", "linesLength": 1, "startIndex": 41, "lines": ["Ou encore : la forme `**keywords`"]}, {"block": 21, "type": "markdown", "linesLength": 5, "startIndex": 42, "lines": ["La notion de *wrapper* - emballage, en anglais - est tr\u00e8s r\u00e9pandue en informatique, et consiste, \u00e0 partir d'un morceau de code souche existant (fonction ou classe) \u00e0 d\u00e9finir une variante qui se comporte comme la souche, mais avec quelques l\u00e9g\u00e8res diff\u00e9rences.\n", "\n", "La fonction `error` \u00e9tait d\u00e9j\u00e0 un premier exemple de *wrapper*. Maintenant nous voulons d\u00e9finir un *wrapper* `ligne_rouge`, qui sous-traite \u00e0 la fonction `ligne` mais toujours avec la couleur rouge. \n", "\n", "Maintenant que l'on a inject\u00e9 la notion de param\u00e8tre par d\u00e9faut dans le syst\u00e8me de signature des fonctions, se repose la question de savoir comment passer \u00e0 l'identique les arguments de `ligne_rouge` \u00e0 `ligne`. "]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 47, "lines": ["\u00c9videmment, une premi\u00e8re option consiste \u00e0 regarder la signature de `ligne`:\n", "\n", "    def ligne(x1, y1, x2, y2, couleur=\"noir\")"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Et \u00e0 en d\u00e9duire une impl\u00e9mentation de `ligne_rouge` comme ceci"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Toutefois, avec cette impl\u00e9mentation, si la signature de `ligne` venait \u00e0 changer, on serait vraisembablement amen\u00e9 \u00e0 changer celle de `ligne_rouge`, sauf \u00e0 perdre en fonctionnalit\u00e9. Imaginons en effet que `ligne` devienne dans une version suivante"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 52, "lines": ["Alors le wrapper ne nous permet plus de profiter de la nouvelle fonctionnalit\u00e9. \n", "De mani\u00e8re g\u00e9n\u00e9rale, on cherche au maximum \u00e0 se pr\u00e9munir contre de tels d\u00e9pendances. \n", "Aussi, il est de beacoup pr\u00e9f\u00e9rable d'impl\u00e9menter `ligne_rouge` comme suit, o\u00f9 vous remarquerez que **la seule hypoth\u00e8se** faite sur `ligne` est qu'elle accepte un argument nomm\u00e9 `couleur`."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Ce qui permet maintenant de faire"]}, {"block": 27, "type": "heading", "linesLength": 1, "startIndex": 56, "lines": ["Pour en savoir plus - la forme g\u00e9n\u00e9rale"]}, {"block": 28, "type": "markdown", "linesLength": 10, "startIndex": 57, "lines": ["Une fois assimil\u00e9 ce qui pr\u00e9c\u00e8de, vous avez de quoi comprendre une \u00e9norme majorit\u00e9 (99% au moins) du code python. \n", "\n", "Dans le cas g\u00e9n\u00e9ral, il est possible de combiner les 4 formes d'arguments:\n", " * des expressions (cas des arguments \"normaux\", dits positionnels)\n", " * des expressions nomm\u00e9es, comme `nom=<expression>`\n", " * des `*expressions`\n", " * des `**expressions`\n", " \n", "Vous pouvez [vous reporter \u00e0 cette page](https://docs.python.org/2/reference/expressions.html#calls\n", ") pour une description d\u00e9taill\u00e9e de ce cas g\u00e9n\u00e9ral."]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 67, "lines": ["\u00c0 l'appel d'une fonction, il faut r\u00e9soudre les arguments, c'est-\u00e0-dire associer une valeur \u00e0 chaque param\u00e8tre formel (ceux qui apparaissent dans le `def`) \u00e0 partir des valeurs figurant dans l'appel.\n", "\n", "L'id\u00e9e est que pour faire cela, les arguments de l'appel ne sont pas pris dans l'ordre o\u00f9 ils apparaissent, mais les arguments positionnels sont utilis\u00e9s en premier. La logique est que, naturellement les arguments positionnnels (ou ceux qui proviennent d'une `*expression`) viennent sans nom, et donc ne peuvent pas \u00eatre utilis\u00e9s pour r\u00e9soudre des arguments nomm\u00e9s."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Voici un tout petit exemple pour vous donner une id\u00e9e de la complexit\u00e9 de ce m\u00e9canisme lorsqu'on m\u00e9lange toutes les 4 formes d'arguments \u00e0 l'appel de la fonction (alors qu'on a d\u00e9fini la fonction avec 4 param\u00e8tres positionnels)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Si le probl\u00e8me ne vous semble pas clair, vous pouvez regarder la [documentation python d\u00e9crivant ce probl\u00e8me](https://docs.python.org/2/reference/expressions.html#calls). "]}]
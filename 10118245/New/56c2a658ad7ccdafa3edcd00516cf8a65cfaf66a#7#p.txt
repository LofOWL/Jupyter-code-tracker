[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Sequence unpacking"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["**Remarque pr\u00e9liminaire**\u00a0: nous avons vainement cherch\u00e9 une traduction raisonnable pour ce trait du langage, connue en anglais sous le nom de *sequence unpacking* ou encore parfois *tuple unpacking*, aussi pour \u00e9viter de cr\u00e9er de la confusion nous avons finalement d\u00e9cid\u00e9 de conserver le terme anglais \u00e0 l'identique."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### D\u00e9j\u00e0 rencontr\u00e9"]}, {"block": 5, "type": "markdown", "linesLength": 8, "startIndex": 9, "lines": ["L'affectation dans Python peut concerner plusieurs variables \u00e0 la fois. En fait nous en avons d\u00e9j\u00e0 vu un exemple en Semaine 1, avec la fonction `fibonacci` dans laquelle il y avait ce fragment\u00a0:\n", "\n", "```Python\n", "for i in range(2, n + 1):\n", "    f2, f1 = f1, f1 + f2\n", "```\n", "\n", "Nous allons dans ce compl\u00e9ment d\u00e9cortiquer les m\u00e9canismes derri\u00e8re cette phrase qui a probablement excit\u00e9 votre curiosit\u00e9. :)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["### Un exemple simple"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Commen\u00e7ons par un exemple simple \u00e0 base de tuple. Imaginons que l'on dispose d'un tuple `couple` dont on sait qu'il a deux \u00e9l\u00e9ments\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["couple = (100, 'spam')"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["On souhaite \u00e0 pr\u00e9sent extraire les deux valeurs, et les affecter \u00e0 deux variables distinctes. Une solution na\u00efve consiste bien s\u00fbr \u00e0 faire simplement\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 21, "lines": ["gauche = couple[0]\n", "droite = couple[1]\n", "print('gauche', gauche, 'droite', droite)"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 24, "lines": ["Cela fonctionne naturellement tr\u00e8s bien, mais n'est pas tr\u00e8s pythonique - comme on dit ;) Vous devez toujours garder en t\u00eate qu'il est rare en Python de manipuler des indices. D\u00e8s que vous voyez des indices dans votre code, vous devez vous demander si votre code est pythonique.\n", "\n", "On pr\u00e9f\u00e8rera la formulation \u00e9quivalente suivante\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["(gauche, droite) = couple\n", "print('gauche', gauche, 'droite', droite)"]}, {"block": 13, "type": "markdown", "linesLength": 3, "startIndex": 29, "lines": ["La logique ici consiste \u00e0 dire : affecter les deux variables de sorte que le tuple `(gauche, droite)` soit \u00e9gal \u00e0 `couple`. On voit ici la sup\u00e9riorit\u00e9 de cette notion d'unpacking sur la manipulation d'indices\u00a0: vous avez maintenant des variables qui expriment la nature de l'objet manipul\u00e9, votre code devient expressif, c'est-\u00e0-dire auto-document\u00e9.\n", "\n", "Remarquons que les parenth\u00e8ses ici sont optionnelles - comme lorsque l'on construit un tuple - et on peut tout aussi bien \u00e9crire, et c'est le cas d'usage le plus fr\u00e9quent d'omission des parenth\u00e8ses pour le tuple\u00a0:"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["gauche, droite = couple\n", "print('gauche', gauche, 'droite', droite)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["### Autres types"]}, {"block": 16, "type": "markdown", "linesLength": 4, "startIndex": 35, "lines": ["Cette technique fonctionne aussi bien avec d'autres types. Par exemple, on peut utiliser\u00a0:\n", "\n", "* une syntaxe de liste \u00e0 gauche du `=`\u00a0;\n", "* une liste comme expression \u00e0 droite du `=`."]}, {"block": 17, "type": "code", "linesLength": 4, "startIndex": 39, "lines": ["# comme ceci\n", "liste = [1, 2, 3]\n", "[gauche, milieu, droit] = liste\n", "print('gauche', gauche, 'milieu', milieu, 'droit', droit)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["Et on n'est m\u00eame pas oblig\u00e9s d'avoir le m\u00eame type \u00e0 gauche et \u00e0 droite du signe `=`, comme ici\u00a0:"]}, {"block": 19, "type": "code", "linesLength": 5, "startIndex": 44, "lines": ["# membre droit: une liste\n", "liste = [1, 2, 3]\n", "# membre gauche : un tuple\n", "gauche, milieu, droit = liste\n", "print('gauche', gauche, 'milieu', milieu, 'droit', droit)"]}, {"block": 20, "type": "markdown", "linesLength": 5, "startIndex": 49, "lines": ["En r\u00e9alit\u00e9, les seules contraintes fix\u00e9es par Python sont que\u00a0:\n", "\n", "* le terme \u00e0 droite du signe `=` soit un *it\u00e9rable* (tuple, liste, string, etc.)\u00a0;\n", "* le terme \u00e0 gauche soit \u00e9crit comme un tuple ou une liste - notons tout de m\u00eame que l'utilisation d'une liste \u00e0 gauche est rare et peu pythonique\u00a0;\n", "* les deux termes aient la m\u00eame longueur - en tout cas avec les concepts que l'on a vus jusqu'ici, mais voir aussi plus bas l'utilisation de `*arg` avec le *extended unpacking*."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["La plupart du temps le terme de gauche est \u00e9crit comme un tuple. C'est pour cette raison que les deux termes *tuple unpacking* et *sequence unpacking* sont en vigueur."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["### La fa\u00e7on *pythonique* d'\u00e9changer deux variables"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["Une caract\u00e9ristique int\u00e9ressante de l'affectation par *sequence unpacking* est qu'elle est s\u00fbre\u00a0; on n'a pas \u00e0 se pr\u00e9occuper d'un \u00e9ventuel ordre d'\u00e9valuation, les valeurs **\u00e0 droite** de l'affectation sont **toutes** \u00e9valu\u00e9es en premier, et ainsi on peut par exemple \u00e9changer deux variables comme ceci\u00a0:"]}, {"block": 24, "type": "code", "linesLength": 4, "startIndex": 57, "lines": ["a = 1\n", "b = 2\n", "a, b = b, a\n", "print('a', a, 'b', b)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["### *Extended unpacking*"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Le *extended unpacking* a \u00e9t\u00e9 introduit en Python 3\u00a0; commen\u00e7ons par en voir un exemple\u00a0:"]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 63, "lines": ["reference = [1, 2, 3, 4, 5]\n", "a, *b, c = reference\n", "print(f\"a={a} b={b} c={c}\")"]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 66, "lines": ["Comme vous le voyez, le m\u00e9canisme ici est une extension de *sequence unpacking*\u00a0; Python vous autorise \u00e0 mentionner **une seule fois**, parmi les variables qui apparaissent \u00e0 gauche de l'affectation, une variable **pr\u00e9c\u00e9d\u00e9e de `*`**, ici `*b`.\n", "\n", "Cette variable est interpr\u00e9t\u00e9e comme une **liste de longueur quelconque** des \u00e9l\u00e9ments de `reference`. On aurait donc aussi bien pu \u00e9crire\u00a0:"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 69, "lines": ["reference = range(20)\n", "a, *b, c = reference\n", "print(f\"a={a} b={b} c={c}\")"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["Ce trait peut s'av\u00e9rer pratique, lorsque par exemple on s'int\u00e9resse seulement aux premiers \u00e9l\u00e9ments d'une structure\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 5, "startIndex": 73, "lines": ["# si on sait que data contient prenom, nom, et un nombre inconnu d'autres informations\n", "data = [ 'Jean', 'Dupont', '061234567', '12', 'rue du chemin vert', '57000', 'METZ', ]\n", "# on peut utiliser la variable _ qui v\u00e9hicule l'id\u00e9e que l'on ne s'y int\u00e9resse pas vraiment\n", "prenom, nom, *_ = data\n", "print(f\"prenom={prenom} nom={nom}\")"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["On a vu les principaux cas d'utilisation de la *sequence unpacking*, voyons \u00e0 pr\u00e9sent quelques subtilit\u00e9s."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["### Plusieurs occurrences d'une m\u00eame variable"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["On peut utiliser **plusieurs fois** la m\u00eame variable dans la partie gauche de l'affectation\u00a0:"]}, {"block": 36, "type": "code", "linesLength": 5, "startIndex": 82, "lines": ["# ceci en toute rigueur est l\u00e9gal\n", "# mais en pratique on \u00e9vite de le faire\n", "entree = [1, 2, 3]\n", "a, a, a = entree\n", "print(f\"a = {a}\")"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["**Attention** toutefois, comme on le voit ici, Python **n'impose pas** que les diff\u00e9rentes occurrences de `a` correspondent **\u00e0 des valeurs identiques** (en langage savant, on dirait que cela ne permet pas de faire de l'unification). De mani\u00e8re beaucoup plus pragmatique, l'interpr\u00e9teur se contente de faire comme s'il faisait l'affectation plusieurs fois de gauche \u00e0 droite, c'est-\u00e0-dire comme s'il faisait\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["a = 1; a = 2; a = 3"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Cette technique n'est utilis\u00e9e en pratique que pour les parties de la structure dont on n'a que faire dans le contexte. Dans ces cas-l\u00e0, il arrive qu'on utilise le nom de variable `_`, dont on rappelle qu'il est l\u00e9gal, ou tout autre nom comme `ignored` pour manifester le fait que cette partie de la structure ne sera pas utilis\u00e9e, par exemple\u00a0:"]}, {"block": 40, "type": "code", "linesLength": 7, "startIndex": 90, "lines": ["entree = [1, 2, 3]\n", "\n", "_, milieu, _ = entree\n", "print('milieu', milieu)\n", "\n", "ignored, ignored, right = entree\n", "print('right', right)"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["### En profondeur"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["Le *sequence unpacking* ne se limite pas au premier niveau dans les structures, on peut extraire des donn\u00e9es plus profond\u00e9ment imbriqu\u00e9es dans la structure de d\u00e9part\u00a0; par exemple avec en entr\u00e9e la liste\u00a0:"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 99, "lines": ["structure = ['abc', [(1, 2), ([3], 4)], 5]"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["Si on souhaite extraire la valeur qui se trouve \u00e0 l'emplacement du `3`, on peut \u00e9crire\u00a0:"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 101, "lines": ["(a, (b, ((trois,), c)), d) = structure\n", "print('trois', trois)"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Ou encore, sans doute un peu plus lisible\u00a0:"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 104, "lines": ["(a, (b, ([trois], c)), d) = structure\n", "print('trois', trois)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["Naturellement on aurait aussi bien pu \u00e9crire ici quelque chose comme\u00a0:"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 107, "lines": ["trois = structure[1][1][0][0]\n", "print('trois', trois)"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["Affaire de go\u00fbt \u00e9videmment. Mais n'oublions pas une des phrases du Zen de Python $\\textit{Flat is better than nested}$, ce qui veut dire que ce n'est pas parce que vous pouvez faire des structures imbriqu\u00e9es complexes que vous devez le faire. Bien souvent, cela rend la lecture et la maintenance du code complexe, j'esp\u00e8re que l'exemple pr\u00e9c\u00e9dent vous en a convaincu."]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["### *Extended unpacking* et profondeur"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 111, "lines": ["On peut naturellement ajouter de l'*extended unpacking* \u00e0 n'importe quel \u00e9tage d'un *unpacking* imbriqu\u00e9\u00a0:"]}, {"block": 53, "type": "code", "linesLength": 4, "startIndex": 112, "lines": ["# un exemple tr\u00e8s alambiqu\u00e9 avec plusieurs variables *extended\n", "tree = [1, 2, [(3, 33, 'three', 'thirty-three')], ( [4, 44, ('forty', 'forty-four')])]\n", "*_,  ((_, *x3, _),), (*_, x4) = tree\n", "print(f\"x3={x3}, x4={x4}\")"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["Dans ce cas, la limitation d'avoir une seule variable de la forme `*extended` s'applique toujours, naturellement, mais \u00e0 chaque niveau dans l'imbrication, comme on le voit sur cet exemple."]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 117, "lines": ["## Pour en savoir plus\n", "\n", "* [Le PEP (en anglais) qui introduit le *extended unpacking*](https://www.python.org/dev/peps/pep-3132/)."]}]
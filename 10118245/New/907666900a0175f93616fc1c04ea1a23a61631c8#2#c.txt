[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["# La data science en g\u00e9n\u00e9ral\n", "## et en Python en particulier"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Qu'est-ce qu'un data scientist\u00a0?"]}, {"block": 4, "type": "markdown", "linesLength": 5, "startIndex": 9, "lines": ["J'aimerais commencer cette s\u00e9quence par quelques r\u00e9flexions g\u00e9n\u00e9rales sur ce qu'on appelle data science. Ce mot valise, r\u00e9cemment devenu \u00e0 la mode, et que tout le monde veut ajouter \u00e0 son CV, est un domaine qui regroupe tous les champs de l'analyse scientifique des donn\u00e9es. Cela demande donc, pour \u00eatre fait s\u00e9rieusement, de ma\u00eetriser\u00a0:\n", "\n", "1. un large champ de connaissances scientifiques, notamment des notions de statistiques appliqu\u00e9es\u00a0;\n", "2. les donn\u00e9es que vous manipulez\u00a0;\n", "3. un langage de programmation pour automatiser les traitements."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["#### Statistiques appliqu\u00e9es"]}, {"block": 6, "type": "markdown", "linesLength": 5, "startIndex": 15, "lines": ["Pour illustrer le premier point, pour quelque chose d'aussi simple qu'une moyenne, il est d\u00e9j\u00e0 possible de faire des erreurs. Quel int\u00e9r\u00eat de consid\u00e9rer une moyenne d'une distribution bimodale\u00a0?\n", "\n", "Par exemple, j'ai deux groupes de personnes et je veux savoir lequel a le plus de chance de gagner \u00e0 une \u00e9preuve de tir \u00e0 la corde. L'\u00e2ge moyen de mon groupe A est de 55 ans, l'\u00e2ge moyen de mon groupe B est de 30 ans. Il me semble alors pouvoir affirmer que le groupe B a plus de chances de gagner. Seulement, dans le groupe B il y a 10 enfants de 5 ans et 10 personnes de 55 ans et dans le groupe A j'ai une population homog\u00e8ne de 20 personnes ayant 55 ans. Finalement, \u00e7a sera sans doute le groupe A qui va gagner.\n", "\n", "Quelle erreur ai-je faite\u00a0? J'ai utilis\u00e9 un outil statistique qui n'\u00e9tait pas adapt\u00e9 \u00e0 l'analyse de mes groupes de personnes. Cette erreur peut vous para\u00eetre stupide, mais ces erreurs peuvent \u00eatre tr\u00e8s subtiles voire extr\u00eamement difficiles \u00e0 identifier."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["#### Connaissance des donn\u00e9es"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["C'est une des parties les plus importantes, mais largement sous estim\u00e9es\u00a0: analyser des donn\u00e9es sur lesquelles on n'a pas d'expertise est une aberration. Le risque principal est d'ignorer l'existence d'un facteur cach\u00e9, ou de supposer \u00e0 tort l'ind\u00e9pendance des donn\u00e9es (sachant que nombre d'outils statistiques ne fonctionnent que sur des donn\u00e9es ind\u00e9pendantes). Sans rentrer plus dans le d\u00e9tail, je vous conseille de lire cet article de [David Louapre sur le paradoxe de Simpson](https://sciencetonnante.wordpress.com/2013/04/29/le-paradoxe-de-simpson/) et [la vid\u00e9o associ\u00e9e](https://www.youtube.com/watch?v=vs_Zzf_vL2I), pour vous donner l'intuition que travailler sur des donn\u00e9es qu'on ne ma\u00eetrise pas peut conduire \u00e0 d'importantes erreurs d'interpr\u00e9tation."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["#### Ma\u00eetrise d'un langage de programmation"]}, {"block": 10, "type": "markdown", "linesLength": 5, "startIndex": 23, "lines": ["Comme vous l'avez sans doute compris, le succ\u00e8s grandissant de la data science est d\u00fb \u00e0 la d\u00e9mocratisation d'outils informatiques comme R, ou la suite d'outils disponibles dans Python, dont nous abordons certains aspects cette semaine.\n", "\n", "Il y a ici cependant de nouveau des difficult\u00e9s. Comme nous allons le voir il est tr\u00e8s facile de faire des erreurs qui seront totalement silencieuses, par cons\u00e9quent, vous obtiendrez presque toujours un r\u00e9sultat, mais totalement faux. Sans une profonde compr\u00e9hension des m\u00e9canismes et des impl\u00e9mentations, vous avez la garantie de faire n'importe quoi.\n", "\n", "Vous le voyez, je ne suis pas tr\u00e8s encourageant, pour faire de la data science vous devrez ma\u00eetriser la bases des outils statistiques, comprendre les donn\u00e9es que vous manipulez et ma\u00eetriser parfaitement les outils que vous utilisez. Beaucoup de gens pensent qu'en faisant un peu de R ou de Python on peut s'affirmer data scientist, c'est faux, et si vous \u00eates, par exemple, journaliste ou \u00e9conomiste et que vos r\u00e9sultats ont un impact politique, vous avez une vraie responsabilit\u00e9 et vos erreurs peuvent avoir d'importantes cons\u00e9quences."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Pr\u00e9sentation de pandas"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 29, "lines": ["Numpy est l'outil qui permet de manipuler des tableaux en Python, et pandas est l'outil qui permet d'ajouter des index \u00e0 ces tableaux. Par cons\u00e9quent, pandas repose enti\u00e8rement sur numpy et toutes les donn\u00e9es que vous manipulez en pandas sont des tableaux numpy.\n", "\n", "Pandas est un projet qui \u00e9volue r\u00e9guli\u00e8rement, on vous recommande donc d'utiliser au moins pandas dans sa version 0.21. Voici les version que l'on utilise ici."]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 32, "lines": ["import numpy as np\n", "print(f\"numpy version {np.__version__}\")\n", "\n", "import pandas as pd\n", "print(f\"pandas version {pd.__version__}\")"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["Il est important de comprendre que le monde de la data science en Python suit un autre paradigme que Python. L\u00e0 o\u00f9 Python favorise la clart\u00e9, la simplicit\u00e9 et l'uniformit\u00e9, numpy and pandas favorisent l'efficacit\u00e9. La cons\u00e9quence est une augmentation de la complexit\u00e9 et une moins bonne uniformit\u00e9. Aussi, personne ne joue le r\u00f4le de BDFL dans la communaut\u00e9 data science comme le fait Guido van Rossum pour Python. Nous entrons donc largement dans une autre philosophie que celle de Python."]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["#### Erreurs classiques en numpy"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Commen\u00e7ons par revenir rapidement sur numpy et en particulier sur des erreurs fr\u00e9quentes."]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 40, "lines": ["import numpy as np"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 41, "lines": ["x = np.ones((3, 3), dtype=np.uint8)\n", "print(x)"]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 43, "lines": ["# changeons la premi\u00e8re ligne de ce tableau\n", "x[0,:] = [255, 256, 12.532]\n", "print(x)"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 46, "lines": ["Comme on a cr\u00e9\u00e9 un tableau d'entiers cod\u00e9s sur 8 bits, chaque entier ne peut prendre qu'une valeur entre 0 et 255. Si on d\u00e9passe 255, alors il n'y aura pas de message d'erreur, mais le calcul est fait silencieusement modulo 255. Vous remarquez aussi que si vous ajoutez un float \u00e0 un tableau d'entier, le float sera simplement tronqu\u00e9 pour obtenir un entier. \u00c0 nouveau, vous ne voyez aucun avertissement, aucune erreur.\n", "\n", "Regardons maintenant ces autres cas\u00a0:"]}, {"block": 21, "type": "code", "linesLength": 6, "startIndex": 49, "lines": ["# dans un tableau d'entiers, on peut\n", "# modifier un \u00e9l\u00e9ment en \u00e9crivant une cha\u00eene\n", "# de caract\u00e8res si c'est\n", "# la repr\u00e9sentation str d'un entier\n", "x[0, 0] = '8'\n", "print(x, x.dtype)"]}, {"block": 22, "type": "code", "linesLength": 6, "startIndex": 55, "lines": ["# mais si on essaie la m\u00eame chose avec un flottant\n", "try:\n", "    x[0, 0] = '8.1'\n", "except ValueError as e:\n", "    print(f\"on ne peut pas modifier une case \u00e0 partir\"\n", "          f\" du str d'un float:\\n{e}\")"]}, {"block": 23, "type": "code", "linesLength": 6, "startIndex": 61, "lines": ["# et donc logiquement on ne peut pas non plus\n", "# avec un caract\u00e8re m\u00eame s'il est hexad\u00e9cimal\n", "try:\n", "    x[0, 0] = 'c'\n", "except ValueError as e:\n", "    print(f\"ni une cha\u00eene de caract\u00e8res:\\n{e}\")"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Une autre erreur classique est d'utiliser les op\u00e9rateurs logiques bool\u00e9ens pour former un masque au lieu des op\u00e9rateurs bitwises. Le moyen mn\u00e9motechnique est de penser qu'un masque est form\u00e9 de bits et donc qu'il faut utiliser un op\u00e9rateur logique bitwise, mais bon, \u00e7a aurait pu \u00eatre impl\u00e9ment\u00e9 autrement, et ce choix est discutable."]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 68, "lines": ["a = np.random.randint(1, 10, size=(3, 3))\n", "print(a)"]}, {"block": 26, "type": "code", "linesLength": 6, "startIndex": 70, "lines": ["# combien d'\u00e9l\u00e9ments pairs et sup\u00e9rieurs \u00e0 5 ?\n", "# l'op\u00e9rateur logique bool\u00e9en and ne marche pas\n", "try:\n", "    np.sum((a % 2 == 0) and (a > 5))\n", "except ValueError as e:\n", "    print(f\"and ne marche pas ici : {e}\")"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 76, "lines": ["# il faut utiliser l'op\u00e9rateur bitwise et ne pas oublier les parenth\u00e8ses\n", "np.sum((a % 2 == 0) & (a > 5))"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["#### Les structures de donn\u00e9es en pandas"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Il y a deux structures de donn\u00e9es principales en pandas, la classe `Series` et la classe `DataFrame`. Une `Series` est un tableau \u00e0 une dimension o\u00f9 chaque \u00e9l\u00e9ment est index\u00e9 avec essentiellement un autre array (souvent de cha\u00eenes de caract\u00e8res), et une `DataFrame` est un tableau \u00e0 deux dimensions ou les lignes et les colonnes sont index\u00e9es. La clef ici est de comprendre que l'int\u00e9r\u00eat de pandas est de pouvoir manipuler les tableaux numpy qui sont index\u00e9s, et le travail de pandas est de rendre les op\u00e9rations sur ces index tr\u00e8s efficaces."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["Vous pouvez bien s\u00fbr vous demander \u00e0 quoi cela sert, alors regardons un petit exemple. Nous allons revenir sur les notions utilis\u00e9es dans cet exemple, notre but ici est de vous montrer l'utilit\u00e9 de pandas sur un exemple."]}, {"block": 31, "type": "code", "linesLength": 7, "startIndex": 81, "lines": ["# seaborn est un module pour dessiner des courbes qui am\u00e9liore\n", "# sensiblement matplotlib, mais \u00e7a n'est pas ce qui nous int\u00e9resse ici.\n", "# seaborn vient avec quelques jeux de donn\u00e9es sur lesquels on peut jouer.\n", "import seaborn as sns\n", "\n", "# chargeons un jeu de donn\u00e9es qui repr\u00e9sente des pourboires\n", "tips = sns.load_dataset('tips')"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["`load_dataset` retourne une `DataFrame`."]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 89, "lines": ["type(tips)"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["Regardons maintenant \u00e0 quoi ressemble une `DataFrame`\u00a0:"]}, {"block": 35, "type": "code", "linesLength": 5, "startIndex": 91, "lines": ["# voici a quoi ressemble ces donn\u00e9es. On a la note totale (total_bill),\n", "# le pourboire (tip), le sexe de la personne qui a donn\u00e9 le pourboire,\n", "# si la personne est fumeur ou non fumeur (smoker), le jour du repas,\n", "# le moment du repas (time) et le nombre de personnes \u00e0 table (size)\n", "tips.head()"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["On voit donc un exemple de `DataFrame` qui repr\u00e9sente des donn\u00e9es index\u00e9es, \u00e0 la fois par des labels sur les colonnes, et par un rang entier sur les lignes. C'est l'utilisation de ces index qui va nous permettre de faire des requ\u00eates expressives sur ces donn\u00e9es."]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 97, "lines": ["# commen\u00e7ons par une rapide description statistique de ces donn\u00e9es\n", "tips.describe()"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 99, "lines": ["# prenons la moyennes par sexe\n", "tips.groupby('sex').mean()"]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 101, "lines": ["# et maintenant la moyenne par jour\n", "tips.groupby('day').mean()"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["# et pour finir la moyenne par moment du repas\n", "tips.groupby('time').mean()"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["Vous voyez qu'en quelques requ\u00eates simples et intuitives (nous reviendrons bien s\u00fbr sur ces notions) on peut gr\u00e2ce \u00e0 la notion d'index, obtenir des informations pr\u00e9cieuses sur nos donn\u00e9es. Vous voyez qu'en l'occurrence, travailler directement sur le tableau numpy aurait \u00e9t\u00e9 beaucoup moins ais\u00e9."]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["### Conclusion"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["Nous avons vu que la data science est une discipline complexe qui demande de nombreuses comp\u00e9tences. Une de ces comp\u00e9tences est la ma\u00eetrise d'un langage de programmation, et \u00e0 cet \u00e9gard la suite data science de Python qui se base sur numpy et pandas offre une solution tr\u00e8s performante."]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 108, "lines": ["Il nous reste une derni\u00e8re question \u00e0 aborder\u00a0: R ou la suite data science de Python\u00a0?\n", "\n", "Notre pr\u00e9f\u00e9rence va bien \u00e9videmment \u00e0 la suite data science de Python parce qu'elle b\u00e9n\u00e9ficie de toute la puissance de Python. R est un langage d\u00e9di\u00e9 \u00e0 la statistique qui n'offre pas la puissance d'un langage g\u00e9n\u00e9rique comme Python. Mais dans le contexte de la data science, R et la suite data science de Python sont deux excellentes solutions. \u00c0 tr\u00e8s grosse maille, la syntaxe de R est plus complexe que celle de Python, par contre, R est tr\u00e8s utilis\u00e9 par les statisticiens, il peut donc avoir une impl\u00e9mentation d'un nouvel algorithme de l'\u00e9tat de l'art plus rapidement que la suite data science de Python."]}]
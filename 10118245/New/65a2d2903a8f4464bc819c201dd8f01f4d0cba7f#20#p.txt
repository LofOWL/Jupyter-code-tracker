[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# boucle d'\u00e9v\u00e9nements `asyncio`"]}, {"block": 2, "type": "code", "linesLength": 1, "startIndex": 2, "lines": ["import asyncio"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["# utilitaire"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["fonctions synchrones (traditionnelles)"]}, {"block": 5, "type": "code", "linesLength": 1, "startIndex": 5, "lines": ["from asynchelpers import start_timer, show_timer"]}, {"block": 6, "type": "code", "linesLength": 5, "startIndex": 6, "lines": ["import time\n", "\n", "start_timer()\n", "time.sleep(1)\n", "show_timer('un message')"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["# d\u00e9j\u00e0 vu"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 12, "lines": ["`loop.run_until_complete()`\n", "\n", "* exactement un argument"]}, {"block": 9, "type": "markdown", "linesLength": 5, "startIndex": 15, "lines": ["```\n", "asyncio.get_event_loop().run_until_complete(\n", "    asyncio.gather(coro1, coro2, ...)\n", "))\n", "```"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["# ajout de traitements"]}, {"block": 11, "type": "markdown", "linesLength": 5, "startIndex": 21, "lines": ["`asyncio.ensure_future(coro)`\n", "\n", "* exactement un argument\n", "* ajoute une coroutine dans la boucle\n", "* **avant** ou **apr\u00e8s** le lancement de la boucle"]}, {"block": 12, "type": "markdown", "linesLength": 5, "startIndex": 26, "lines": ["`loop.run_forever()`\n", "\n", "* sans argument\n", "* travaille sur le contenu courant de la boucle\n", "* suppose l'utilisation de `ensure_future()`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["# *fork*"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["![figure fork](w8-s6-av-fig1.png)"]}, {"block": 15, "type": "code", "linesLength": 8, "startIndex": 33, "lines": ["async def c1():\n", "    show_timer(\">>> c1\")\n", "    await asyncio.sleep(1)\n", "    show_timer(\"forking\")\n", "    # fork\n", "    asyncio.ensure_future(c2())\n", "    await asyncio.sleep(1)\n", "    show_timer(\"<<< c1\")"]}, {"block": 16, "type": "code", "linesLength": 8, "startIndex": 41, "lines": ["# sera fork\u00e9e par c1() apr\u00e8s une seconde\n", "\n", "async def c2():\n", "    show_timer(\">>> c2\")\n", "    await asyncio.sleep(2)\n", "    show_timer(\"<<< c2\")\n", "    \n", "    "]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["asyncio.ensure_future(c1())"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 50, "lines": ["start_timer()\n", "\n", "# interrompre apr\u00e8s 2s\n", "try:\n", "    asyncio.get_event_loop().run_forever()\n", "except KeyboardInterrupt:\n", "    print(\"bye\")"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["# r\u00e9initialisation de la boucle"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["asyncio.set_event_loop(asyncio.new_event_loop())"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["*je vous demande de l'admettre pour l'instant*"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["# `loop.stop()`"]}, {"block": 23, "type": "code", "linesLength": 8, "startIndex": 61, "lines": ["async def c1_stop():\n", "    show_timer(\">>> c1\")\n", "    await asyncio.sleep(1)\n", "    show_timer(\"forking\")\n", "    # fork\n", "    asyncio.ensure_future(c2_stop())\n", "    await asyncio.sleep(1)\n", "    show_timer(\"<<< c1\")"]}, {"block": 24, "type": "code", "linesLength": 8, "startIndex": 69, "lines": ["# sera fork\u00e9e par c1() apr\u00e8s une seconde\n", "\n", "async def c2_stop():\n", "    show_timer(\">>> c2\")\n", "    await asyncio.sleep(2)\n", "    show_timer(\"<<< c2\")\n", "    # attention c'est une m\u00e9thode bloquante\n", "    asyncio.get_event_loop().stop()"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 77, "lines": ["asyncio.ensure_future(c1_stop())"]}, {"block": 26, "type": "code", "linesLength": 9, "startIndex": 78, "lines": ["start_timer()\n", "\n", "# s'arr\u00eate tout seul\n", "try:\n", "    asyncio.get_event_loop().run_forever()\n", "except KeyboardInterrupt:\n", "    print(\"bye\")\n", "    \n", "print(\"done\")"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["# `run_until_complete` sur une boucle non-vide "]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["asyncio.set_event_loop(asyncio.new_event_loop())"]}, {"block": 29, "type": "code", "linesLength": 5, "startIndex": 89, "lines": ["# on simule un job asynchrone de dur\u00e9e duration\n", "async def job(name, duration):\n", "    show_timer(f\">>> {name}\")\n", "    await asyncio.sleep(duration)\n", "    show_timer(f\"<<< {name}\")    "]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["async def short():\n", "    await job(\"short\", 1)"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 96, "lines": ["async def long():\n", "    await job(\"long\", 2)"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 98, "lines": ["# on remplit la boucle\n", "asyncio.ensure_future(long())"]}, {"block": 33, "type": "code", "linesLength": 5, "startIndex": 100, "lines": ["# et on appelle run_until_complete\n", "start_timer()\n", "\n", "asyncio.get_event_loop().run_until_complete(short())\n", "print(\"done\")"]}, {"block": 34, "type": "code", "linesLength": 8, "startIndex": 105, "lines": ["# il reste des choses \u00e0 faire dans la boucle\n", "start_timer()\n", "\n", "# interrompre apr\u00e8s 1s\n", "try:\n", "    asyncio.get_event_loop().run_forever()\n", "except KeyboardInterrupt:\n", "    print(\"bye\")"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["# `run_until_complete` vs `run_forever`"]}, {"block": 36, "type": "markdown", "linesLength": 5, "startIndex": 114, "lines": ["* `run_until_complete`\n", "\n", "   * prend exactement un argument\n", "   * retourne la valeur\n", "   * ins\u00e9rer un fragment asynchrone au milieu d'un code synchrone\n"]}, {"block": 37, "type": "markdown", "linesLength": 4, "startIndex": 119, "lines": ["* `run_forever`\n", "  * ne prend pas d'argument\n", "  * ne retourne pas (sauf en cas de `stop()`)\n", "  * orient\u00e9 traitement massivement asynchrone"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 123, "lines": ["# `get_event_loop()`"]}, {"block": 39, "type": "markdown", "linesLength": 2, "startIndex": 124, "lines": ["* mod\u00e8le mental\n", "  * 1 thread = 1 boucle"]}, {"block": 40, "type": "markdown", "linesLength": 5, "startIndex": 126, "lines": ["* `get_event_loop()` \n", "  * boucle par d\u00e9faut du thread courant\n", "  * utile pour r\u00e9f\u00e9rencer \"la bonne boucle\" - voir e.g. le code de `c2_stop()`\n", "  * inutile de passer une instance de boucle\n", "  * ne *cr\u00e9e pas* de boucle en dehors du thread principal  "]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 131, "lines": ["# `new_event_loop()` et `set_event_loop()`"]}, {"block": 42, "type": "markdown", "linesLength": 3, "startIndex": 132, "lines": ["* `new_event_loop()`\n", "  * cr\u00e9e une nouvelle boucle\n", "  * n\u00e9cessaire dans un thread suppl\u00e9mentaire"]}, {"block": 43, "type": "markdown", "linesLength": 2, "startIndex": 135, "lines": ["* set_event_loop(loop)\n", "  * installe cet objet comme boucle par d\u00e9faut"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 137, "lines": ["# r\u00e9sum\u00e9"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["* `ensure_future()`"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 139, "lines": ["* `run_until_complete()` et `run_forever()`"]}, {"block": 47, "type": "markdown", "linesLength": 3, "startIndex": 140, "lines": ["* `get_event_loop()` \n", "  * acc\u00e9de \u00e0 la boucle (du thread) courant(e)\n", "  * `new_event_loop()` et `set_event_loop()`"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 143, "lines": ["* `loop.stop()`"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# M\u00e9thodes sp\u00e9cifiques aux listes"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Voici quelques unes des m\u00e9thodes disponibles sur le type `list`."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Trouver l'information"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["Pour commencer, rappelons comment retrouver la liste des m\u00e9thodes d\u00e9finies sur le type `list`:"]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 6, "lines": ["help(list)"]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 7, "lines": ["Je vous conseille pour l'instant d'ignorer les m\u00e9thodes dont le nom commence et termine par `__` (nous parlerons de ceci en semaine 5);  vous trouvez alors les m\u00e9thodes utiles list\u00e9es entre `append` et `sort`. \n", "\n", "Certaines de ces m\u00e9thodes ont \u00e9t\u00e9 vues dans la vid\u00e9o sur les s\u00e9quences, c'est le cas notamment de `count` et `index`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": [" Nous allons \u00e0 pr\u00e9sent d\u00e9crire les autres, partiellement et bri\u00e8vement. Un autre compl\u00e9ment d\u00e9crit la m\u00e9thode `sort`. Reportez-vous au lien donn\u00e9 en fin de notebook pour obtenir une information plus compl\u00e8te."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Donnons-nous pour commencer une liste t\u00e9moin&nbsp;:"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 12, "lines": ["liste = list(range(4))\n", "print('liste', liste)"]}, {"block": 11, "type": "markdown", "linesLength": 5, "startIndex": 14, "lines": ["**Avertissements**: \n", "\n", "* soyez bien attentifs au nombre de fois o\u00f9 vous ex\u00e9cutez les cellules de ce notebook\n", "* par exemple une liste renvers\u00e9e deux fois peut donner l'impression que `reverse` ne marche pas :) \n", "* n'h\u00e9sitez pas \u00e0 utiliser le menu *Cell -> Run All* pour r\u00e9ex\u00e9cuter en une seule fois le notebook entier."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["### `append`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["La m\u00e9thode `append` permet d'ajouter **un \u00e9l\u00e9ment** \u00e0 la fin d'une liste:"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["liste.append('ap')\n", "print('liste', liste)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### `extend`"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["La m\u00e9thode `extend` r\u00e9alise la m\u00eame op\u00e9ration, mais avec **tous les \u00e9l\u00e9ments** de la liste qu'on lui passe en argument:"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 25, "lines": ["liste.extend(['ex1', 'ex2'])\n", "print('liste', liste)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### `append` *vs* `+`"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Ces deux m\u00e9thodes `append` et `extend` sont donc assez voisines; avant de voir d'autres m\u00e9thodes de `list`, prenons un peu le temps de comparer leur comportement avec l'addition `+` de liste. L'\u00e9l\u00e9ment cl\u00e9 ici, on l'a d\u00e9j\u00e0 vu dans la vid\u00e9o, est que la liste est un objet **mutable**. `append` et `extend` **modifient** la liste sur laquelle elles travaillent, alors que l'addition **cr\u00e9e un nouvel objet**:"]}, {"block": 20, "type": "code", "linesLength": 5, "startIndex": 29, "lines": ["# pour cr\u00e9er une liste avec les n premiers entiers, on utilise \n", "# la fonction built-in range(), que l'on convertit en liste\n", "# on aura l'occasion d'y revenir\n", "l1 = list(range(5))\n", "print(l1)"]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 34, "lines": ["# le fait d'utiliser + cr\u00e9e une nouvelle liste\n", "l2 = l1 + [10, 11, 12]\n", "# si bien que maintenant les deux objets sont diff\u00e9rents\n", "print('l1', l1)\n", "print('l2', l2)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Comme on le voit, apr\u00e8s une addition, les deux termes de l'addition sont inchang\u00e9s; alors que si on avait utilis\u00e9 `extend`, on aurait obtenu ceci:"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 40, "lines": ["# on recr\u00e9e une liste \n", "e1 = list(range(5))\n", "print(e1)"]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 43, "lines": ["# avec extend on modifie la liste\n", "e2 = e1.extend([10, 11, 12])\n", "# et du coup il est inutile pour extend de renvoyer quoi que ce soit\n", "print('e1', e1)\n", "print('e2', e2)"]}, {"block": 25, "type": "markdown", "linesLength": 4, "startIndex": 48, "lines": ["C'est pour cette raison que:\n", "\n", "* l'addition est disponible sur tous les types s\u00e9quences - on peut toujours r\u00e9aliser l'addition puisqu'on cr\u00e9e un nouvel objet pour stocker le r\u00e9sultat de l'addition;\n", "* mais `append` et `extend` ne sont par exemple **pas disponibles** sur les cha\u00eenes de caract\u00e8res, qui sont **immuables** - si `e1` \u00e9tait une chaine, on ne pourrait pas la modifier pour lui ajouter des \u00e9l\u00e9ments."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["### `insert`"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Reprenons notre inventaire des m\u00e9thodes de `list`, et pour cela rappelons nous le contenu de la variable `liste`:"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["liste"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["La m\u00e9thode `insert` permet, comme le nom le sugg\u00e8re, d'ins\u00e9rer un \u00e9l\u00e9ment \u00e0 une certaine position; comme toujours les indices commencent \u00e0 z\u00e9ro et donc:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["liste.insert(2, '1 bis')\n", "print('liste', liste)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["On peut remarquer qu'un r\u00e9sultat analogue peut \u00eatre obtenu avec une affectation de slice; par exemple pour ins\u00e9rer au rang 5 (i.e. avant `ap`), on pourrait aussi bien faire:"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 59, "lines": ["liste[5:5] = ['3 bis']\n", "print('liste', liste)"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["### `remove`"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["La m\u00e9thode `remove` d\u00e9truit la **premi\u00e8re occurence** d'un objet dans la liste:"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 63, "lines": ["liste.remove(3)\n", "print('liste', liste)"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["### `pop`"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["La m\u00e9thode `pop` prend en argument un indice; elle permet d'extraire l'\u00e9l\u00e9ment \u00e0 cet indice. En un seul appel on obtient la valeur de l'\u00e9l\u00e9ment et on l'enl\u00e8ve de la liste:"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 67, "lines": ["popped = liste.pop(0)\n", "print('popped', popped, 'liste', liste)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Si l'indice n'est pas pr\u00e9cis\u00e9, c'est le dernier \u00e9l\u00e9ment de la liste qui est vis\u00e9"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["popped = liste.pop()\n", "print('popped', popped, 'liste', liste)"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["### `reverse`"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Enfin `reverse` renverse la liste, le premier \u00e9l\u00e9ment devient le dernier:"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 74, "lines": ["liste.reverse()\n", "print('liste', liste)"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["On peut remarquer ici que le r\u00e9sultat se rapproche de ce qu'on peut obtenir avec une op\u00e9ration de slicing comme ceci"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["liste2 = liste[::-1]\n", "print('liste2', liste2)"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["**\u00e0 la diff\u00e9rence toutefois** qu'avec le slicing c'est une copie de la liste initiale qui est retourn\u00e9e, la liste de d\u00e9part n'est quant \u00e0 elle pas modifi\u00e9e."]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["### Pour en savoir plus"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["https://docs.python.org/3/tutorial/datastructures.html#more-on-lists"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["### Note sp\u00e9cifique aux notebooks"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["#### `help` avec `?`"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["Je vous signale en passant que dans un notebook vous pouvez obtenir de l'aide avec un point d'interrogation `?` ins\u00e9r\u00e9 avant ou apr\u00e8s un symbole. Par exemple pour obtenir des pr\u00e9cisions sur la m\u00e9thode `list.pop`, on peut faire soit:"]}, {"block": 52, "type": "code", "linesLength": 2, "startIndex": 85, "lines": ["# fonctionne dans tous les environnements python\n", "help(list.pop)"]}, {"block": 53, "type": "code", "linesLength": 5, "startIndex": 87, "lines": ["# sp\u00e9cifique aux notebooks\n", "# l'affichage obtenu est l\u00e9g\u00e8rement diff\u00e9rent\n", "# tapez la touche 'Esc' - ou cliquez la petite croix \n", "# pour faire disparaitre le dialogue qui appara\u00eet en bas\n", "list.pop?"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["#### Compl\u00e9tion avec `Tab`"]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["Dans un notebook vous avez aussi la compl\u00e9tion; si vous tapez - dans une cellule de code - le d\u00e9but d'un symbole connu dans l'environnement:"]}, {"block": 56, "type": "code", "linesLength": 3, "startIndex": 94, "lines": ["# placez votre curseur \u00e0 la fin de la ligne apr\u00e8s 'li'\n", "# et appuyez sur la touche 'Tab'\n", "li"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["Vous voyez appara\u00eetre un dialogue avec les noms connus qui commencent par `li`; utilisez les fl\u00eaches pour choisir, et 'Return' pour s\u00e9lectionner."]}]
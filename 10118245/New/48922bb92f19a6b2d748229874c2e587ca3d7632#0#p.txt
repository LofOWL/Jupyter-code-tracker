[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# *Context managers* et exceptions"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["On a vu jusqu'ici dans la vid\u00e9o comment \u00e9crire un context manager; on a vu notamment qu'il \u00e9tait bon pour la m\u00e9thode `__exit__()` de retourner `False`, de fa\u00e7on \u00e0 ce que l'exception soit propag\u00e9e \u00e0 l'instruction `with`:"]}, {"block": 4, "type": "code", "linesLength": 15, "startIndex": 8, "lines": ["import time\n", "\n", "class Timer1:\n", "    def __enter__(self):\n", "        print(\"Entering Timer1\")\n", "        self.start = time.time()\n", "        return self\n", "    \n", "    # en r\u00e8gle g\u00e9n\u00e9rale on se contente de propager l'exception \n", "    # \u00e0 l'instruction with englobante\n", "    def __exit__(self, *args):\n", "        print(f\"Total duration {time.time()-self.start:2f}\")\n", "\n", "        # et pour cela il suffit que __exit__ retourne False\n", "        return False"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Ainsi si le corps de l'instruction l\u00e8ve une exception, celle-ci est propag\u00e9e :"]}, {"block": 6, "type": "code", "linesLength": 8, "startIndex": 24, "lines": ["import time\n", "try:\n", "    with Timer1():\n", "        time.sleep(0.5)\n", "        1/0\n", "except Exception as e:\n", "    # on va bien recevoir cette exception\n", "    print(f\"OOPS -> {type(e)}\")"]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 32, "lines": ["\u00c0 la toute premi\u00e8re it\u00e9ration de la boucle, on fait une division par 0 qui l\u00e8ve l'exception `ZeroDivisionError`, qui passe bien \u00e0 l'appelant.\n", "\n", "Il est important, lorsqu'on con\u00e7oit un context manager, de bien **propager** les exceptions qui ne sont pas li\u00e9es au fonctionnement attendu du context manager. Par exemple un objet de type fichier va par exemple devoir attraper les exceptions li\u00e9es \u00e0 la fin du fichier, mais doit par contre laisser passer une exception comme `ZeroDivisionError`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["### Les param\u00e8tres de `__exit__`"]}, {"block": 9, "type": "markdown", "linesLength": 7, "startIndex": 36, "lines": ["Si on a besoin de filtrer entre les exceptions - c'est-\u00e0-dire en laisser passer certaines et pas d'autres - il nous faut quelque chose de plus pour pouvoir faire le tri. \n", "Comme [vous pouvez le retrouver ici](https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers), la m\u00e9thode `__exit__` re\u00e7oit trois arguments\u00a0:\n", "\n", "    def __exit__(self, exc_type, exc_value, traceback):\n", "\n", "* si l'on sort du bloc `with` sans qu'une exception soit lev\u00e9e, ces trois arguments valent `None`;\n", "* par contre si une exception est lev\u00e9e, ils permettent d'acc\u00e9der respectivement au type, \u00e0 la valeur de l'exception, et \u00e0 l'\u00e9tat de la pile lorsque l'exception est lev\u00e9e."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["Pour illustrer cela, \u00e9crivons une nouvelle version de `Timer` qui filtre, disons, l'exception `ZeroDivisionError` que je choisis au hasard, c'est uniquement pour illustrer le m\u00e9canisme."]}, {"block": 11, "type": "code", "linesLength": 26, "startIndex": 44, "lines": ["# une deuxi\u00e8me version de Timer\n", "# qui propage toutes les exceptions sauf 'OSError'\n", "\n", "class Timer2:\n", "    def __enter__(self):\n", "        print(\"Entering Timer1\")\n", "        self.start = time.time()\n", "        # rappel : le retour de __enter__ est ce qui est pass\u00e9\n", "        # \u00e0 la clause `as` du `with`\n", "        return self\n", "    \n", "    def __exit__(self, exc_type, exc_value, traceback):\n", "        if exc_type is None:\n", "            # pas d'exception lev\u00e9e dans le corps du 'with'\n", "            print(f\"Total duration {time.time()-self.start:2f}\")\n", "            # dans ce cas la valeur de retour n'est pas utilis\u00e9e\n", "        else:\n", "            # il y a eu une exception de type 'exc_type'\n", "            if exc_type in (ZeroDivisionError,) :\n", "                print(\"on \u00e9touffe\")\n", "                # on peut l'\u00e9touffer en retournant True\n", "                return True\n", "            else:\n", "                print(f\"OOPS : on propage l'exception {exc_type} - {exc_value}\")\n", "                # et pour \u00e7a il suffit .. de ne rien faire du tout\n", "                # ce qui renverra None "]}, {"block": 12, "type": "code", "linesLength": 7, "startIndex": 70, "lines": ["# commen\u00e7ons avec un code sans souci\n", "try:\n", "    with Timer2():\n", "        time.sleep(0.5)\n", "except Exception as e:\n", "    # on va bien recevoir cette exception\n", "    print(f\"OOPS -> {type(e)}\")"]}, {"block": 13, "type": "code", "linesLength": 8, "startIndex": 77, "lines": ["# avec une exception filtr\u00e9e\n", "try:\n", "    with Timer2():\n", "        time.sleep(0.5)\n", "        1/0\n", "except Exception as e:\n", "    # on va bien recevoir cette exception\n", "    print(f\"OOPS -> {type(e)}\")"]}, {"block": 14, "type": "code", "linesLength": 8, "startIndex": 85, "lines": ["# avec une autre exception \n", "try:\n", "    with Timer2():\n", "        time.sleep(0.5)\n", "        raise OSError()\n", "except Exception as e:\n", "    # on va bien recevoir cette exception\n", "    print(f\"OOPS -> {type(e)}\")"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["### La biblioth\u00e8que `contextlib`"]}, {"block": 16, "type": "markdown", "linesLength": 3, "startIndex": 94, "lines": ["Je vous signale aussi [la biblioth\u00e8que `contextlib`](https://docs.python.org/3/library/contextlib.html) qui offre quelques utilitaires pour se d\u00e9finir un contextmanager.\n", "\n", "Notamment, elle permet d'impl\u00e9menter un context manager sous une forme compacte \u00e0 l'aide d'une fonction - et du d\u00e9corateur `contextmanager`:"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 97, "lines": ["from contextlib import contextmanager"]}, {"block": 18, "type": "code", "linesLength": 6, "startIndex": 98, "lines": ["# l'objet compact_timer est un context manager !\n", "@contextmanager\n", "def compact_timer(message):\n", "    start = time.time()\n", "    yield\n", "    print(f\"{message}: duration = {time.time() - start}\")"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 104, "lines": ["with compact_timer(\"Squares sum\"):\n", "    print(sum(x**2 for x in range(10**5)))"]}, {"block": 20, "type": "markdown", "linesLength": 5, "startIndex": 106, "lines": ["Un peu comme on peut impl\u00e9menter un it\u00e9rateur \u00e0 partir d'une fonction g\u00e9n\u00e9ratrice qui fait (n'importe quel nombre de) `yield`, ici on impl\u00e9mente un context manager compact sous la forme d'une fonction.\n", "\n", "Comme vous l'avez sans doute devin\u00e9 sur la base de cet exemple, pour \u00eatre propre il faut que la fonction fasse **exactement un `yield`**: ce qui se passe avant le `yield` est du ressort de `__enter__`, et la fin est du ressort de `__exit__()`. \n", "\n", "Bien entendu on n'a pas la m\u00eame puissance d'expression avec cette m\u00e9thode par rapport \u00e0 une vraie classe, mais cela permet de cr\u00e9er des context managers avec le minimum de code."]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# \u00c9valuation des tests"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Quels tests sont \u00e9valu\u00e9s ?"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["On a vu dans la vid\u00e9o que l'instruction conditionnelle `if` permet d'impl\u00e9menter simplement des branchements \u00e0 plusieurs choix, comme dans cet exemple:"]}, {"block": 5, "type": "code", "linesLength": 9, "startIndex": 9, "lines": ["s = 'berlin'\n", "if 'a' in s:\n", "    print('avec a')\n", "elif 'b' in s:\n", "    print('avec b')\n", "elif 'c' in s:\n", "    print('avec c')\n", "else:\n", "    print('sans a ni b ni c')"]}, {"block": 6, "type": "markdown", "linesLength": 2, "startIndex": 18, "lines": ["Comme on s'en doute, les expressions conditionnelles **sont \u00e9valu\u00e9es jusqu'\u00e0 obtenir un r\u00e9sultat vrai** - ou consid\u00e9r\u00e9 comme vrai -, et le bloc correspondant est alors ex\u00e9cut\u00e9. Le point important ici est qu'**une fois qu'on a obtenu un r\u00e9sultat vrai**, on sort de l'expression conditionnelle **sans \u00e9valuer les autres conditions**. \n", "En termes savant, on parle d'\u00e9valuation paresseuse: on s'arr\u00eate d\u00e8s qu'on peut."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Dans notre exemple, on aura \u00e9valu\u00e9 \u00e0 la sortie `'a' in s`, et aussi `'b' in s`, mais pas `'c' in s`"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["### Pourquoi c'est important ?"]}, {"block": 9, "type": "markdown", "linesLength": 4, "startIndex": 22, "lines": ["C'est important de bien comprendre quels sont les tests qui sont r\u00e9ellement \u00e9valu\u00e9s pour deux raisons:\n", "\n", "* d'abord, pour des raisons de performance; comme on n'\u00e9value que les tests n\u00e9cessaires, si un des tests prend du temps, il est peut-\u00eatre pr\u00e9f\u00e9rable de le faire en dernier;\n", "* mais aussi et surtout, il se peut tout \u00e0 fait qu'un test fasse des **effets de bord**, c'est-\u00e0-dire qu'il modifie un ou plusieurs objets."]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 26, "lines": ["Dans notre premier exemple, les conditions elles-m\u00eames sont inoffensives; la valeur de `s` reste *identique*, que l'on *\u00e9value ou non* les diff\u00e9rentes conditions.\n", "\n", "Mais nous allons voir ci-dessous qu'il est relativement facile d'\u00e9crire des conditions qui **modifient** par **effet de bord** les objets mutables sur lesquelles elles op\u00e8rent, et dans ce cas il est crucial de bien assimiler la r\u00e8gle des \u00e9valuations des expressions dans un `if`. "]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["### Rappel sur la m\u00e9thode `pop`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Pour illustrer la notion d'**effet de bord**, nous revenons sur la m\u00e9thode de liste `pop()` qui, on le rappelle, renvoie un \u00e9l\u00e9ment de liste **apr\u00e8s l'avoir effac\u00e9** de la liste. "]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 32, "lines": ["# on se donne une liste\n", "liste = ['premier', 'deuxieme', 'troisieme']\n", "print(f\"liste={liste}\")"]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 35, "lines": ["# pop(0) renvoie le premier element de la liste, et raccourcit la liste\n", "element = liste.pop(0)\n", "print(f\"apr\u00e8s pop(0), element={element} et liste={liste}\")"]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 38, "lines": ["# et ainsi de suite\n", "element = liste.pop(0)\n", "print(f\"apr\u00e8s pop(0), element={element} et liste={liste}\")"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["### Conditions avec effet de bord"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Une fois ce rappel fait, voyons maintenant l'exemple suivant:"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["liste = list(range(5))\n", "print('liste en entree:', liste, 'de taille', len(liste))"]}, {"block": 20, "type": "code", "linesLength": 9, "startIndex": 45, "lines": ["if liste.pop(0) <= 0:\n", "    print('cas 1')\n", "elif liste.pop(0) <= 1:\n", "    print('cas 2')\n", "elif liste.pop(0) <= 2:\n", "    print('cas 3')\n", "else:\n", "    print('cas 4')\n", "print('liste en sortie de taille', len(liste))"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Avec cette entr\u00e9e, le premier test est vrai (car `pop(0)` renvoie 0), aussi on n'ex\u00e9cute en tout `pop()` qu'**une seule fois**, et donc \u00e0 la sortie la liste n'a \u00e9t\u00e9 raccourcie que d'un \u00e9l\u00e9ment."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Ex\u00e9cutons \u00e0 pr\u00e9sent le m\u00eame code avec une entr\u00e9e diff\u00e9rente:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["liste = list(range(5, 10))\n", "print('en entree: liste=', liste, 'de taille', len(liste))"]}, {"block": 24, "type": "code", "linesLength": 9, "startIndex": 58, "lines": ["if liste.pop(0) <= 0:\n", "    print('cas 1')\n", "elif liste.pop(0) <= 1:\n", "    print('cas 2')\n", "elif liste.pop(0) <= 2:\n", "    print('cas 3')\n", "else:\n", "    print('cas 4')\n", "print('en sortie: liste=', liste, 'de taille', len(liste))"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["On observe que cette fois la liste a \u00e9t\u00e9 **raccourcie 3 fois**, car les trois tests se sont r\u00e9v\u00e9l\u00e9s faux."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["Cet exemple vous montre qu'il faut \u00eatre attentif avec des conditions qui font des effets de bord. Bien entendu, ce type de pratique est de mani\u00e8re g\u00e9n\u00e9rale \u00e0 utiliser avec beaucoup de discernement."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["### Court-circuit (*short-circuit*)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["La logique que l'on vient de voir est celle qui s'applique aux diff\u00e9rentes branches d'un `if`; c'est la m\u00eame logique qui est \u00e0 l'\u0153uvre aussi lorsque python \u00e9value une condition logique \u00e0 base de `and` et `or`. C'est ici aussi une forme d'\u00e9valuation paresseuse."]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Pour illustrer cela, nous allons nous d\u00e9finir deux fonctions toutes simples qui renvoient `True` et `False` mais avec une impression de sorte qu'on voit lorsqu'elles sont ex\u00e9cut\u00e9es:"]}, {"block": 30, "type": "code", "linesLength": 3, "startIndex": 72, "lines": ["def true():\n", "    print('true')\n", "    return True"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 75, "lines": ["def false():\n", "    print('false')\n", "    return False"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 78, "lines": ["true()"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Ceci va nous permettre d'illustrer notre point, qui est que lorsque python \u00e9value un `and` ou un `or`, il **n'\u00e9value la deuxi\u00e8me condition que si c'est n\u00e9cessaire**. Ainsi par exemple: "]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 80, "lines": ["false() and true()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Dans ce cas, python \u00e9value la premi\u00e8re partie du `and` - qui provoque l'impression de `false` - et comme le r\u00e9sultat est faux, il n'est **pas n\u00e9cessaire** d'\u00e9valuer la seconde condition, on sait que de toute fa\u00e7on le r\u00e9sultat du `and` est forc\u00e9ment faux. C'est pourquoi vous ne voyez pas l'impression de `true`."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["De mani\u00e8re sym\u00e9trique avec un `or`:"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 83, "lines": ["true() or false()"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["\u00c0 nouveau ici il n'est pas n\u00e9cessaire d'\u00e9valuer `false()`, et donc seul `true` est imprim\u00e9 \u00e0 l'\u00e9valuation."]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["\u00c0 titre d'exercice, essayez de dire combien d'impressions sont \u00e9mises lorsqu'on \u00e9value cette expression un peu plus compliqu\u00e9e:"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 86, "lines": ["true() and (false() or true()) or (true () and false())"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# D\u00e9corateurs"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau (tr\u00e8s) avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 5, "startIndex": 3, "lines": ["Le m\u00e9canisme des d\u00e9corateurs - qui rappelle un peu, pour ceux qui connaissent, les macros Lisp - est un m\u00e9canisme tr\u00e8s puissant. Sa port\u00e9e va bien au del\u00e0 de simplement rajouter du code avant et apr\u00e8s une fonction, comme dans le cas de `NbAppels` que nous avons vu dans la vid\u00e9o.  \n", "\n", "Par exemple, les notions de m\u00e9thodes de classe (`@classmethod`) et de m\u00e9thodes statiques (`@staticmethod`) sont impl\u00e9ment\u00e9es comme des d\u00e9corateurs. Pour une liste plus repr\u00e9sentative de ce qu'il est possible de faire avec les d\u00e9corateurs, je vous invite \u00e0 parcourir m\u00eame rapidement ce [recueil de d\u00e9corateurs](https://wiki.python.org/moin/PythonDecoratorLibrary) qui propose du code (\u00e0 titre indicatif, car rien de ceci ne fait partie de la librairie standard) pour des th\u00e8mes qui sont propices \u00e0 la d\u00e9coration de code.\n", "\n", "Nous allons voir en d\u00e9tails quelques-uns de ces exemples."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Un d\u00e9corateur impl\u00e9ment\u00e9 comme une classe"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Dans la vid\u00e9o on a vu `NbAppels` pour compter le nombre de fois qu'on appelle une fonction. Pour m\u00e9moire on avait \u00e9crit:"]}, {"block": 6, "type": "code", "linesLength": 9, "startIndex": 10, "lines": ["# un rappel du code montr\u00e9 dans la vid\u00e9o\n", "class NbAppels(object):\n", "    def __init__(self, f):\n", "        self.f = f\n", "        self.appels = 0\n", "    def __call__(self, *args):\n", "        self.appels += 1\n", "        print(f\"{self.appels}-\u00e8me appel \u00e0 {self.f.__name__}\")\n", "        return self.f(*args)"]}, {"block": 7, "type": "code", "linesLength": 17, "startIndex": 19, "lines": ["# nous utilisons ici une impl\u00e9mentation en log(n)\n", "# de la fonction de fibonacci\n", "\n", "@NbAppels\n", "def fibo_aux(n):\n", "    \"Fibonacci en log(n)\"\n", "    if n < 1: \n", "        return 0, 1\n", "    u, v = fibo_aux(n//2)\n", "    u, v = u * (2 * v - u), u*u + v*v\n", "    if n % 2 == 1:\n", "        return v, u + v\n", "    else:\n", "        return u, v\n", "\n", "def fibo_log(n):\n", "    return fibo_aux(n)[0]"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 36, "lines": ["# pour se convaincre que nous sommes bien en log2(n)\n", "from math import log"]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 38, "lines": ["n1 = 100\n", "\n", "log(n1)/log(2)"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 41, "lines": ["fibo_log(n1)"]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 42, "lines": ["# on multiplie par 2**4 = 16,\n", "# donc on doit voir 4 appels de plus \n", "n2 = 1600\n", "\n", "log(n2)/log(2)"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 47, "lines": ["fibo_log(n2)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["### `memoize` impl\u00e9ment\u00e9 comme une fonction"]}, {"block": 14, "type": "markdown", "linesLength": 4, "startIndex": 49, "lines": ["\n", "Ici nous allons impl\u00e9menter `memoize`, un d\u00e9corateur qui permet de m\u00e9moriser les r\u00e9sultats d'une fonction, et de les cacher pour ne pas avoir \u00e0 les recalculer la fois suivante. \n", "\n", "Alors que `NbAppels` \u00e9tait **impl\u00e9ment\u00e9 comme une classe**, pour varier un peu, nous allons impl\u00e9menter cette fois **`memoize` comme une vraie fonction**, pour vous montrer les deux alternatives que l'on a quand on veut impl\u00e9menter un d\u00e9corateur: une vraie fonction ou une classe de callables."]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["##### Le code du d\u00e9corateur"]}, {"block": 16, "type": "code", "linesLength": 31, "startIndex": 54, "lines": ["# une premi\u00e8re impl\u00e9mentation de memoize\n", "\n", "# un d\u00e9corateur de fonction\n", "# impl\u00e9ment\u00e9 comme une fonction\n", "def memoize(a_decorer):\n", "    \"\"\"\n", "    Un d\u00e9corateur pour conserver les r\u00e9sultats\n", "    pr\u00e9c\u00e9dents et \u00e9viter de les recalculer\n", "    \"\"\"\n", "    def decoree(*args):\n", "        # si on a d\u00e9j\u00e0 calcul\u00e9 le r\u00e9sultat\n", "        # on le renvoie\n", "        try:\n", "            return decoree.cache[args]\n", "        # si les arguments ne sont pas hashables, \n", "        # par exemple s'ils contiennent une liste\n", "        # on ne peut pas cacher et on re\u00e7oit TypeError\n", "        except TypeError:\n", "            return a_decorer(*args)\n", "        # les arguments sont hashables mais on\n", "        # n'a pas encore calcul\u00e9 cette valeur\n", "        except KeyError:\n", "            # on fait vraiment le calcul\n", "            result = a_decorer(*args)\n", "            # on le range dans le cache\n", "            decoree.cache[args] = result\n", "            # on le retourne\n", "            return result\n", "    # on initialise l'attribut 'cache'\n", "    decoree.cache = {}\n", "    return decoree"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["##### Comment l'utiliser"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["Avant de rentrer dans le d\u00e9tail du code, voyons comment cela s'utiliserait; il n'y a pas de changement de ce point de vue par rapport \u00e0 l'option d\u00e9velopp\u00e9e dans la vid\u00e9o:"]}, {"block": 19, "type": "code", "linesLength": 8, "startIndex": 87, "lines": ["# cr\u00e9er une fonction d\u00e9cor\u00e9e\n", "@memoize\n", "def fibo_cache(n):\n", "    \"\"\"\n", "    Un fibonacci hyper-lent (exponentiel) se transforme\n", "    en temps lin\u00e9aire une fois que les r\u00e9sultats sont cach\u00e9s\n", "    \"\"\"\n", "    return n if n <= 1 else fibo_cache(n-1) + fibo_cache(n-2)"]}, {"block": 20, "type": "markdown", "linesLength": 5, "startIndex": 95, "lines": ["Bien que l'impl\u00e9mentation utilise un algorithme \u00e9pouvantablement lent, le fait de lui rajouter du caching redonne \u00e0 l'ensemble un caract\u00e8re lin\u00e9aire. \n", "\n", "En effet, si vous y r\u00e9fl\u00e9chissez une minute, vous verrez qu'avec le cache, lorsqu'on calcule `fibo_cache(n)`, on calcule d'abord `fibo_cache(n-1)`, puis lorsqu'on \u00e9value `fibo_cache(n-2)` le r\u00e9sultat **est d\u00e9j\u00e0 dans le cache** si bien qu'on peut consid\u00e9rer ce deuxi\u00e8me calcul comme, sinon instantan\u00e9, du moins du m\u00eame ordre de grandeur qu'une addition. \n", "\n", "On peut calculer par exemple:"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 100, "lines": ["fibo_cache(300)"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 101, "lines": ["qu'il serait hors de question de calculer sans le caching.\n", "\n", "On peut naturellement inspecter le cache, qui est rang\u00e9 dans l'attribut `cache` de l'objet fonction lui-m\u00eame:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["len(fibo_cache.cache)"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["et voir que, comme on aurait pu le pr\u00e9dire, on a calcul\u00e9 et m\u00e9moris\u00e9 les 301 premiers r\u00e9sultats, pour n allant de 0 \u00e0 300."]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["##### Comment \u00e7a marche ?"]}, {"block": 26, "type": "markdown", "linesLength": 6, "startIndex": 107, "lines": ["On l'a vu dans la vid\u00e9o avec `NbAppels`, tout se passe exactement comme si on avait \u00e9crit:\n", "\n", "    def fibo_cache(n):\n", "        <le code>\n", "        \n", "    fibo_cache = memoize(fibo_cache)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["Donc `memoize` est une fonction qui prend en argument une fonction `a_decorer` qui ici vaut `fibo_cache`, et retourne une autre fonction, `decoree`; on s'arrange naturellement pour que `decoree` retourne le m\u00eame r\u00e9sultat que `a_decorer`, avec seulement des choses suppl\u00e9mentaires."]}, {"block": 28, "type": "markdown", "linesLength": 5, "startIndex": 114, "lines": ["Les points cl\u00e9s de l'impl\u00e9mentation sont les suivants.\n", " * On attache \u00e0 l'objet fonction `decoree`, sous la forme d'un attribut`cache`, un dictionnaire qui va nous permettre de retrouver les valeurs d\u00e9j\u00e0 calcul\u00e9es, \u00e0 partir d'un hash des arguments.\n", " * On ne peut pas cacher le r\u00e9sultat d'un objet qui ne serait pas globalement immuable; or si on essaie on re\u00e7oit l'exception `TypeError`, et dans ce cas on recalcule toujours le r\u00e9sultat. C'est de toute fa\u00e7ons plus s\u00fbr.\n", " * Si on ne trouve pas les arguments dans le cache, on re\u00e7oit l'exception `KeyError`, dans ce cas on calcule le r\u00e9sultat, et on le retourne apr\u00e8s l'avoir rang\u00e9 dans le cache.\n", " * Vous remarquerez aussi qu'on initialise l'attribut `cache` dans l'objet `decoree` \u00e0 l'appel du d\u00e9corateur (une seule fois, juste apr\u00e8s avoir d\u00e9fini la fonction), et non pas dans le code de `decoree` qui lui est \u00e9valu\u00e9 \u00e0 chaque appel."]}, {"block": 29, "type": "markdown", "linesLength": 4, "startIndex": 119, "lines": ["Cette impl\u00e9mentation, sans \u00eatre parfaite, est tout \u00e0 fait utilisable dans un environnement r\u00e9el, modulo les remarques de bon sens suivantes:\n", " * \u00e9videmment l'approche ne fonctionne que pour des fonctions d\u00e9terministes; s'il y a de l'al\u00e9atoire dans la logique de la fonction, il ne faut pas utiliser ce d\u00e9corateur;\n", " * tout aussi \u00e9videmment, la consommation m\u00e9moire peut \u00eatre importante si on applique le caching sans discrimination;\n", " * enfin en l'\u00e9tat la fonction decor\u00e9e ne peut pas \u00eatre appel\u00e9e avec des arguments nomm\u00e9s; en effet on utilise le tuple `args` comme cl\u00e9 pour retrouver dans le cache la valeur associ\u00e9e aux arguments."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 123, "lines": ["### D\u00e9corateurs, *docstring* et `help`"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 124, "lines": ["En fait, avec cette impl\u00e9mentation, il reste aussi un petit souci:"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 125, "lines": ["help(fibo_cache)"]}, {"block": 33, "type": "markdown", "linesLength": 4, "startIndex": 126, "lines": ["Et ce n'est pas exactement ce qu'on veut; ce qui se passe ici c'est que `help` utilise les attributs `__doc__` et `__name__` de l'objet qu'on lui passe. Et dans notre cas `fibo_cache` est une fonction qui a \u00e9t\u00e9 cr\u00e9\u00e9e par l'instruction:\n", "\n", "    def decoree(*args):\n", "        # etc."]}, {"block": 34, "type": "markdown", "linesLength": 2, "startIndex": 130, "lines": ["Pour arranger \u00e7a et faire en sorte que `help` nous affiche ce qu'on veut, il faut s'occuper de ces deux attributs. Et plut\u00f4t que de faire \u00e7a \u00e0 la main, il existe [un utilitaire `functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps), qui fait tout le travail n\u00e9cessaire. Ce qui nous donne une deuxi\u00e8me version de ce d\u00e9corateur, avec deux lignes suppl\u00e9mentaires signal\u00e9es par des `+++`\n", ";:"]}, {"block": 35, "type": "code", "linesLength": 36, "startIndex": 132, "lines": ["# une deuxi\u00e8me impl\u00e9mentation de memoize, avec la doc \n", "\n", "import functools                                 # +++\n", "\n", "# un decorateur de fonction\n", "# impl\u00e9ment\u00e9 comme une fonction\n", "def memoize(a_decorer):\n", "    \"\"\"\n", "    Un d\u00e9corateur pour conserver les r\u00e9sultats\n", "    pr\u00e9c\u00e9dents et \u00e9viter de les recalculer\n", "    \"\"\"\n", "    # on d\u00e9core la fonction pour qu'elle ait les\n", "    # propri\u00e9t\u00e9s de a_decorer : __doc__ et __name__\n", "    @functools.wraps(a_decorer)                  # +++\n", "    def decoree (*args):\n", "        # si on a d\u00e9j\u00e0 calcul\u00e9 le r\u00e9sultat\n", "        # on le renvoie\n", "        try:\n", "            return decoree.cache[args]\n", "        # si les arguments ne sont pas hashables, \n", "        # par exemple une liste, on ne peut pas cacher \n", "        # et on re\u00e7oit TypeError\n", "        except TypeError:\n", "            return a_decorer(*args)\n", "        # les arguments sont hashables mais on\n", "        # n'a pas encore calcul\u00e9 cette valeur\n", "        except KeyError:\n", "            # on fait vraiment le calcul\n", "            result = a_decorer(*args)\n", "            # on le range dans le cache\n", "            decoree.cache[args] = result\n", "            # on le retourne\n", "            return result\n", "    # on initialise l'attribut 'cache'\n", "    decoree.cache = {}\n", "    return decoree"]}, {"block": 36, "type": "code", "linesLength": 8, "startIndex": 168, "lines": ["# cr\u00e9er une fonction d\u00e9cor\u00e9e\n", "@memoize\n", "def fibo_cache2(n):\n", "    \"\"\"\n", "    Un fibonacci hyper-lent (exponentiel) se transforme\n", "    en temps lin\u00e9aire une fois que les r\u00e9sultats sont cach\u00e9s\n", "    \"\"\"\n", "    return n if n <= 1 else fibo_cache2(n-1) + fibo_cache2(n-2)"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 176, "lines": ["Et on obtient \u00e0 pr\u00e9sent une aide en ligne coh\u00e9rente:"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 177, "lines": ["help(fibo_cache2)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 178, "lines": ["### On peut d\u00e9corer les classes aussi"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 179, "lines": ["De la m\u00eame fa\u00e7on qu'on peut d\u00e9corer une fonction, on peut d\u00e9corer une classe.\n", "\n", "Pour ne pas alourdir le compl\u00e9ment, et aussi parce que le m\u00e9canisme de m\u00e9taclasse offre une autre alternative qui est souvent plus pertinente, nous ne donnons pas d'exemple ici, cela vous est laiss\u00e9 \u00e0 titre d'exercice si vous \u00eates int\u00e9ress\u00e9."]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 182, "lines": ["### Un d\u00e9corateur peut lui-m\u00eame avoir des arguments"]}, {"block": 42, "type": "markdown", "linesLength": 11, "startIndex": 183, "lines": ["Reprenons l'exemple de `memoize`, mais imaginons qu'on veuille ajouter un trait de \"dur\u00e9e de validit\u00e9 du cache\". Le code du d\u00e9corateur a besoin de conna\u00eetre la dur\u00e9e pendant laquelle on doit garder les r\u00e9sultats dans le cache. \n", "\n", "On veut pouvoir pr\u00e9ciser ce param\u00e8tre, appelons le `cache_timeout`,  pour chaque fonction; par exemple on voudrait \u00e9crire quelque chose comme\n", "\n", "    @memoize_expire(600)\n", "    def resolve_host(hostname):\n", "        ...\n", "       \n", "    @memoize_expire(3600*24)\n", "    def network_neighbours(hostname):\n", "        ..."]}, {"block": 43, "type": "markdown", "linesLength": 12, "startIndex": 194, "lines": ["Ceci est possible \u00e9galement avec les d\u00e9corateurs, avec cette syntaxe pr\u00e9cis\u00e9ment. Le mod\u00e8le qu'il faut avoir \u00e0 l'esprit pour bien comprendre le code qui suit est le suivant et se base sur deux objets :\n", " * le premier objet, `memoize_expire`, est ce qu'on appelle une *factory* \u00e0 d\u00e9corateurs, c'est-\u00e0-dire que l'interpr\u00e9teur va d'abord appeler `memoize_expire(600)` qui doit retourner un d\u00e9corateur;\n", " * le deuxi\u00e8me objet est ce d\u00e9corateur retourn\u00e9 par `memoize_expire(600)` qui lui m\u00eame doit se comporter commes les d\u00e9corateurs sans argument que l'on a vus jusqu'ici.\n", " \n", "Pour faire court, cela signifie que l'interpr\u00e9teur fera\n", "\n", "    resolve_host = (memoize_expire(600))(resolve_host)\n", "    \n", "Ou encore si vous pr\u00e9f\u00e9rez\n", "\n", "    memoize = memoize_expire(600)\n", "    resolve_host = memoize(resolve_host)"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 206, "lines": ["Ce qui nous m\u00e8ne au code suivant:"]}, {"block": 45, "type": "code", "linesLength": 43, "startIndex": 207, "lines": ["import time\n", "\n", "# comme pour memoize, on est limit\u00e9 ici et on ne peut pas\n", "# supporter les appels \u00e0 la **kwds, voir plus haut \n", "# la discussion sur l'impl\u00e9mentation de memoize\n", "\n", "# memoize_expire est une factory \u00e0 d\u00e9corateur\n", "def memoize_expire(timeout):\n", "\n", "    # memoize_expire va retourner un decorateur sans argument\n", "    # c'est \u00e0 dire un objet qui se comporte\n", "    # comme notre tout premier `memoize`\n", "    def memoize(a_decorer):\n", "        # \u00e0 partir d'ici on fait un peu comme dans\n", "        # la premiere version de memoize\n", "        def decoree(*args):\n", "            try:\n", "                # sauf que disons qu'on met dans le cache un tuple\n", "                # (valeur, timestamp)\n", "                valeur, timestamp = decoree.cache[args]\n", "                # et la on peut acceder a timeout\n", "                # parce que la liaison en python est lexicale \n", "                if (time.time()-timestamp) <= timeout:\n", "                    return valeur\n", "                else:\n", "                    # on fait comme si on ne connaissait pas,\n", "                    raise KeyError\n", "            # si les arguments ne sont pas hashables, \n", "            # par exemple une liste, on ne peut pas cacher \n", "            # et on re\u00e7oit TypeError\n", "            except TypeError:\n", "                return a_decorer(*args)\n", "            # les arguments sont hashables mais on\n", "            # n'a pas encore calcul\u00e9 cette valeur\n", "            except KeyError:\n", "                result = a_decorer(*args)\n", "                decoree.cache[args] = (result, time.time())\n", "                return result\n", "\n", "        decoree.cache = {}\n", "        return decoree\n", "    # le retour de memoize_expire, c'est memoize\n", "    return memoize"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 250, "lines": ["@memoize_expire(0.5)\n", "def fibo_cache_expire(n):\n", "    return n if n<=1 else fibo_cache_expire(n-2)+fibo_cache_expire(n-1)"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 253, "lines": ["fibo_cache_expire(300)"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 254, "lines": ["fibo_cache_expire.cache[(200,)]"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 255, "lines": ["##### Remarquez la cl\u00f4ture"]}, {"block": 50, "type": "markdown", "linesLength": 5, "startIndex": 256, "lines": ["Pour conclure sur cet exemple, vous remarquez que dans le code de `decoree` on acc\u00e8de \u00e0 la variable `timeout`. \u00c7a peut para\u00eetre un peu \u00e9tonnant, si vous pensez que `decoree` est appel\u00e9e **bien apr\u00e8s** que la fonction `memoize_expire` ait fini son travail. En effet, `memoize_expire` est \u00e9valu\u00e9e **une fois** juste apr\u00e8s **la d\u00e9finition** de `fibo_cache`. Et donc on pourrait penser que la valeur de `timeout` ne serait plus disponible dans le contexte de `decoree`.\n", "\n", "Pour comprendre ce qui se passe, il faut se souvenir que python est un langage \u00e0 liaison lexicale. Cela signifie que la *r\u00e9solution* de la variable `timeout` se fait au moment de la compilation (de la production du byte-code), et non au moment o\u00f9 est appel\u00e9 `decoree`. \n", "\n", "Ce type de construction s'appelle [une **clot\u00fbre**](http://fr.wikipedia.org/wiki/Fermeture_%28informatique%29), en r\u00e9f\u00e9rence au lambda calcul: on parle de terme clos lorsqu'il n'y a plus de r\u00e9f\u00e9rence non r\u00e9solue dans une expression. C'est une technique de programmation tr\u00e8s r\u00e9pandue notamment dans les applications r\u00e9actives, o\u00f9 on programme beaucoup avec des *callbacks*; par exemple il est presque impossible de programmer en JavaScript sans \u00e9crire une cl\u00f4ture. "]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 261, "lines": ["### On peut cha\u00eener les d\u00e9corateurs"]}, {"block": 52, "type": "markdown", "linesLength": 9, "startIndex": 262, "lines": ["Pour revenir \u00e0 notre sujet, signalons enfin que l'on peut aussi \"cha\u00eener les d\u00e9corateurs\"; imaginons par exemple qu'on dispose d'un d\u00e9corateur `add_field` qui ajoute dans une classe un *getter* et un *setter* bas\u00e9s sur un nom d'attribut.\n", "\n", "C'est-\u00e0-dire que\n", "\n", "    @add_field('name')\n", "    class Foo:\n", "        pass\n", "\n", "donnerait pour `Foo` une classe qui dispose des m\u00e9thodes `get_name` et `set_name` (exercice pour les courageux: \u00e9crire `add_field`)."]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 271, "lines": ["Alors la syntaxe des d\u00e9corateurs vous permet de faire quelque chose comme:"]}, {"block": 54, "type": "markdown", "linesLength": 4, "startIndex": 272, "lines": ["    @add_field('name')\n", "    @add_field('address')\n", "    class Foo:\n", "        pass"]}, {"block": 55, "type": "markdown", "linesLength": 5, "startIndex": 276, "lines": ["Ce qui revient \u00e0 faire:\n", "\n", "    class Foo: pass\n", "    Foo = (add_field('address'))(Foo)\n", "    Foo = (add_field('name'))(Foo)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 281, "lines": ["### Discussion"]}, {"block": 57, "type": "markdown", "linesLength": 11, "startIndex": 282, "lines": ["Dans la pratique, \u00e9crire un d\u00e9corateur est un exercice assez d\u00e9licat. Le vrai probl\u00e8me est bien souvent la cr\u00e9ation d'objets suppl\u00e9mentaires: on n'appelle plus la fonction de d\u00e9part mais un wrapper autour de la fonction de d\u00e9part. \n", "\n", "Ceci a tout un tas de cons\u00e9quences, et le lecteur attentif aura par exemple remarqu\u00e9:\n", " * que dans l'\u00e9tat du code de `singleton`, bien que l'on ait correctement mis \u00e0 jour `__doc__` et `__name__` sur la classe d\u00e9cor\u00e9e, `help(Spam)` ne renvoie pas le texte attendu, il semble que `help` sur une instance de classe ne se comporte pas exactement comme attendu;\n", " * que si on essaie de combiner les d\u00e9corateurs `NbAppels` et `memoize` sur une - encore nouvelle - version de fibonacci, le code obtenu ne converge pas; en fait les technique que nous avons utilis\u00e9es dans les deux cas ne sont pas compatibles entre elles.\n", "\n", "De mani\u00e8re plus g\u00e9n\u00e9rale, il y a des gens pour trouver des d\u00e9fauts \u00e0 ce syst\u00e8me de d\u00e9corateurs; je vous renvoie notamment \u00e0 [ce blog](http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html) qui, pour r\u00e9sumer, insiste sur le fait que les objets d\u00e9cor\u00e9s n'ont **pas exactement** les m\u00eames propri\u00e9t\u00e9s que les objets originaux. L'auteur y explique que lorsqu'on fait de l'introspection profonde - c'est-\u00e0-dire lorsqu'on \u00e9crit du code qui \"fouille\" dans les objets qui repr\u00e9sentent le code lui-m\u00eame - les objets d\u00e9cor\u00e9s ont parfois du mal \u00e0 se *faire passer* pour les objets qu'ils remplacent.\n", "\n", "\u00c0 chacun de voir les avantages et les inconv\u00e9nients de cette technique. C'est l\u00e0 encore beaucoup une question de go\u00fbt. Dans certains cas simples, comme par exemple pour `NbAppels`, la d\u00e9coration revient \u00e0 simplement ajouter du code avant et apr\u00e8s l'appel \u00e0 la fonction \u00e0 d\u00e9corer. Et dans ce cas, vous remarquerez qu'on peut aussi faire le m\u00eame genre de choses avec un *context manager* (je laisse \u00e7a en exercice aux \u00e9tudiants int\u00e9ress\u00e9s).\n", "\n", "Ce qui est clair toutefois est que la technique des d\u00e9corateurs est quelque chose qui peut \u00eatre tr\u00e8s  utile, mais dont il ne faut pas abuser. En particulier de notre point de vue, la possibilit\u00e9 de combiner les d\u00e9corateurs, si elle existe bien dans le langage d'un point de vue syntaxique, est dans la pratique \u00e0 utiliser avec la plus extr\u00eame prudence. "]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 293, "lines": ["### Pour en savoir plus"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 294, "lines": ["Maintenant que vous savez presque tout sur les d\u00e9corateurs, vous pouvez retourner lire ce [recueil de d\u00e9corateurs](https://wiki.python.org/moin/PythonDecoratorLibrary) mais plus en d\u00e9tails."]}]
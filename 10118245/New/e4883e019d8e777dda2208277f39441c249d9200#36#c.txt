[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Construction de liste par compr\u00e9hension"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 3, "lines": ["Ce m\u00e9canisme tr\u00e8s pratique permet de construire simplement une liste \u00e0 partir d'une autre (ou de **tout autre type it\u00e9rable** en r\u00e9alit\u00e9, mais nous y viendrons).\n", "\n", "Pour l'introduire en deux mots, disons que la compr\u00e9hension de liste est \u00e0 l'instruction `for` ce que l'expression conditionnelle est \u00e0 l'instruction  `if`, c'est-\u00e0-dire qu'il s'agit d'une **expression \u00e0 part enti\u00e8re**."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["### Cas le plus simple"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Voyons tout de suite un exemple"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 8, "lines": ["depart = [-5, -3, 0, 3, 5, 10]\n", "arrivee = [x**2 for x in depart]\n", "arrivee"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Le r\u00e9sultat de cette expression est donc une liste, dont les \u00e9l\u00e9ments sont les r\u00e9sultats de l'expression `x**2` pour `x` prenant toutes les valeurs de `depart`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["**Remarque**: si on prend un point de vue un peu plus math\u00e9matique, ceci revient donc \u00e0 appliquer une certaine fonction (ici $x \\rightarrow x^2$) \u00e0 une collection de valeurs, et \u00e0 retourner la liste des r\u00e9sultats. Dans les langages fonctionnels, cette op\u00e9ration est connue sous le nom de `map`."]}, {"block": 9, "type": "code", "linesLength": 5, "startIndex": 13, "lines": ["# profitons de cette occasion pour voir \n", "# comment tracer une courbe avec matplotlib\n", "%matplotlib inline\n", "import matplotlib.pyplot as plt\n", "plt.ion()"]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 18, "lines": ["# si on met le depart et l'arrivee \n", "# en abscisse et en ordonnee, on trace\n", "# une version tronqu\u00e9e de la courbe de f: x -> x**2\n", "plt.plot(depart, arrivee);"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["### Restriction \u00e0 certains \u00e9l\u00e9ments"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Il est possible \u00e9galement de ne prendre en compte que certains des \u00e9l\u00e9ments de la liste de d\u00e9part, comme ceci"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["[x**2 for x in depart if x%2 == 0]"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["qui cette fois ne contient que les carr\u00e9s des \u00e9l\u00e9ments pairs de `depart`. "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["**Remarque**: pour prolonger la remarque pr\u00e9c\u00e9dente, cette op\u00e9ration s'appelle fr\u00e9quemment `filter` dans les langages de programmation."]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### Autres types"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["On peut fabriquer une compr\u00e9hension \u00e0 partir de tout objet it\u00e9rable, pas forc\u00e9ment une liste, mais le r\u00e9sultat est toujours une liste, comme on le voit sur ces quelques exemples:"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["[ord(x) for x in 'abc']"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["[chr(x) for x in (97, 98, 99)]"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Nous verrons tr\u00e8s bient\u00f4t que des m\u00e9canismes similaires sont disponibles avec les dictionnaires et les ensembles."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### Imbrications"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["On peut \u00e9galement imbriquer plusieurs niveaux pour ne construire qu'une seule liste, comme par exemple"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["[n + p for n in [2, 4] for p in [10, 20, 30]]"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Bien s\u00fbr on peut aussi restreindre ces compr\u00e9hensions, comme par exemple"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["[n + p for n in [2, 4] for p in [10, 20, 30] if n*p >= 40]"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Observez surtout que le r\u00e9sultat ci-dessus est une liste simple (de profondeur 1), \u00e0 comparer avec "]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["[[n + p for n in [2, 4]] for p in [10, 20, 30]]"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["qui est de profondeur 2, et o\u00f9 les r\u00e9sultats atomiques apparaissent dans un ordre diff\u00e9rent "]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Un moyen mn\u00e9motechnique pour se souvenir dans quel ordre les compr\u00e9hensions imbriqu\u00e9es produisent leur r\u00e9sultat, est de penser \u00e0 la version \"na\u00efve\" du code qui produirait le m\u00eame r\u00e9sultat; dans ce code les clause `for` et `if` apparaissent **dans le m\u00eame ordre** que dans la compr\u00e9hension"]}, {"block": 31, "type": "code", "linesLength": 10, "startIndex": 42, "lines": ["# notre exemple:\n", "# [n + p for n in [2, 4] for p in [10, 20, 30] if n*p >= 40]\n", "# est \u00e9quivalent \u00e0 ceci:\n", "\n", "resultat = []\n", "for n in [2, 4]:\n", "    for p in [10, 20, 30]:\n", "        if n*p >= 40:\n", "            resultat.append(n + p)\n", "resultat"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["### Compr\u00e9hension *vs* expression g\u00e9n\u00e9ratrice"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["#### Digression : liste *vs* it\u00e9rateur"]}, {"block": 34, "type": "markdown", "linesLength": 3, "startIndex": 54, "lines": ["En python3, nous avons d\u00e9j\u00e0 rencontr\u00e9 la fonction `range` qui retourne les premiers entiers.\n", "\n", "Depuis python3 toutefois, cette fonction exhibe un comportement un peu \u00e9trange, en ce sens que:"]}, {"block": 35, "type": "code", "linesLength": 3, "startIndex": 57, "lines": ["# on peut parcourir un range comme si c'\u00e9tait une liste\n", "for i in range(4):\n", "    print(i)"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["# mais en fait la fonction range ne renvoie PAS une liste (depuis python3)\n", "range(4)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["range(4) == [0, 1, 2, 3]"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["La raison de fond pour ceci, c'est que **le fait de construire une liste** est une op\u00e9ration relativement co\u00fbteuse - toutes proportions gard\u00e9es - car il est n\u00e9cessaire d'allouer de la m\u00e9moire pour **stocker tous les \u00e9l\u00e9ments** de la liste \u00e0 un instant donn\u00e9; alors qu'en fait dans l'immense majorit\u00e9 des cas, on n'a **pas r\u00e9ellement besoin** de cette place m\u00e9moire, tout ce dont on a besoin c'est d'it\u00e9rer sur un certain nombre de valeurs mais **qui peuvent \u00eatre calcul\u00e9es** au fur et \u00e0 mesure que l'on parcourt la liste. "]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["#### Compr\u00e9hensions et expression g\u00e9n\u00e9ratrice"]}, {"block": 40, "type": "markdown", "linesLength": 5, "startIndex": 65, "lines": ["\u00c0 la lumi\u00e8re de ce qui vient d'\u00eatre dit, on peut voir qu'une compr\u00e9hension n'est **pas toujours le bon choix**, car par d\u00e9finition elle **construit une liste** de r\u00e9sultats - de la fonction appliqu\u00e9e successivment aux entr\u00e9es.\n", "\n", "Or dans les cas o\u00f9, comme pour `range`, on n'a pas r\u00e9ellement besoin de cette liste **en temps que telle** mais seulement de cet artefact pour pouvoir it\u00e9rer sur la liste des r\u00e9sultats, il est pr\u00e9f\u00e9rable d'utiliser une **expression g\u00e9n\u00e9ratrice**.\n", "\n", "Voyons tout de suite sur un exemple \u00e0 quoi cela ressemblerait."]}, {"block": 41, "type": "code", "linesLength": 5, "startIndex": 70, "lines": ["# dans le premier calcul de arrivee \n", "# dans lequel, pour rappel, la compr\u00e9hension est entre []\n", "# on peut \u00e9crire presque la m\u00eame chose avec des () \u00e0 la place \n", "arrivee2 = (x**2 for x in depart)\n", "arrivee2"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Comme pour `range`, le r\u00e9sultat de l'expression g\u00e9n\u00e9ratrice ne se laisse pas regarder avec `print`, mais comme pour `range`, on peut it\u00e9rer sur le r\u00e9sultat:"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 76, "lines": ["for x, y in zip(depart, arrivee2):\n", "    print(\"x={} => y={}\".format(x, y))"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["Il n'est pas **toujours** possible de remplacer une compr\u00e9hension par une expression g\u00e9n\u00e9ratrice, mais c'est **souvent souhaitable**, car de cette fa\u00e7on on peut faire de substantielles \u00e9conomies en termes de performances. On peut le faire d\u00e8s lors que l'on a seulement besoin d'it\u00e9rer sur les r\u00e9sultats."]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["### Note sur `map` et `filter`"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Avant que les compr\u00e9hensions ne soient introduites, on utilisait deux fonctions built-in intitul\u00e9es `map` (nom qui provient \u00e0 l'origine de Lisp) et `filter`. Leur usage est \u00e0 pr\u00e9sent d\u00e9conseill\u00e9, car le code est moins lisible. On les trouve encore dans du code existant."]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["Pour donner un aper\u00e7u de ces fonctions, au cas o\u00f9 vous en rencontriez dans du code existant, voici comment on \u00e9crirait"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 83, "lines": ["[x**2 for x in depart if x%2 == 0]"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["Avec `map` et `filter` cela donnerait"]}, {"block": 51, "type": "code", "linesLength": 7, "startIndex": 85, "lines": ["def pair(x): \n", "    return x%2 == 0\n", "\n", "def carre(x): \n", "    return x**2\n", "\n", "list(map(carre, list(filter(pair, depart))))"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Ou encore, sur une ligne"]}, {"block": 53, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["list(map(lambda x: x**2, [x for x in depart if x%2 == 0]))"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 94, "lines": ["**Remarque**: l'instruction `lambda` permet de d\u00e9finir une fonction, que l'on appelle fonction lambda, \u00e0 la vol\u00e9e et sans la nommer. Nous y reviendrons dans les semaines \u00e0 venir. Mais \u00e0 notre avis au moins, les fonctions lambda ont perdu beaucoup de leur int\u00e9r\u00eat depuis, pr\u00e9cis\u00e9ment, l'introduction des compr\u00e9hensions. "]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["### Pour en savoir plus"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["Voyez [la section sur les compr\u00e9hensions de liste](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) dans la documentation python."]}]
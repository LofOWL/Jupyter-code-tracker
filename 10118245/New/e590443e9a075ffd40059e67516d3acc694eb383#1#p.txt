[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `Series` en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Cr\u00e9ation d'une Series"]}, {"block": 4, "type": "markdown", "linesLength": 6, "startIndex": 9, "lines": ["Un objet de type `Series` est un tableau numpy \u00e0 une dimension avec un index, par\n", "cons\u00e9quent, une Series a une certaine similarit\u00e9 avec un dictionnaire,\n", "et peut d'ailleurs \u00eatre directement construite \u00e0 partir de ce\n", "dictionnaire. Notons que comme pour un dictionnaire, l'acc\u00e8s ou la\n", "modification est en O(1), c'est-\u00e0-dire \u00e0 temps constant ind\u00e9pendamment\n", "du nombre d'\u00e9l\u00e9ments dans la Series. "]}, {"block": 5, "type": "code", "linesLength": 7, "startIndex": 15, "lines": ["# Regardons la construction d'une Series\n", "import numpy as np\n", "import pandas as pd\n", "\n", "# \u00e0 partir d'un it\u00e9rable\n", "s = pd.Series([x**2 for x in range(10)])\n", "print(s)"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 22, "lines": ["# en contr\u00f4lant maintenant le type\n", "s = pd.Series([x**2 for x in range(10)], dtype='int8')\n", "print(s)"]}, {"block": 7, "type": "code", "linesLength": 6, "startIndex": 25, "lines": ["# en d\u00e9finissant un index, par d\u00e9faut l'index est un rang d\u00e9marrant \u00e0 0\n", "s = pd.Series([x**2 for x in range(10)], \n", "              index=[x for x in 'abcdefghij'],\n", "              dtype='int8',\n", "             )\n", "print(s)"]}, {"block": 8, "type": "code", "linesLength": 3, "startIndex": 31, "lines": ["# et directement \u00e0 partir d'un dictionnaire, les clefs forment l'index\n", "d = {k:v**2 for k, v in zip('abcdefghij', range(10))}\n", "print(d)"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["s = pd.Series(d, dtype='int8')\n", "print(s)"]}, {"block": 10, "type": "markdown", "linesLength": 2, "startIndex": 36, "lines": ["\u00c9videmment, l'int\u00e9r\u00eat d'un index est de pouvoir acc\u00e9der \u00e0 un \u00e9l\u00e9ment\n", "par son index, comme nous aurons l'occasion de le revoir\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 38, "lines": ["print(s['f'])"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["### Index"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["L'index d'une Series est un objet impl\u00e9ment\u00e9 sous la forme d'un `ndarray` numpy, mais qui ne peut contenir que des objets hashables (pour garantir la performance de l'acc\u00e8s)."]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 41, "lines": ["# pour acc\u00e9der \u00e0 l'index d'un objet Series\n", "# attention, index est un attribut, pas une fonction\n", "print(s.index) "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["L'index va \u00e9galement supporter un certain nombre de m\u00e9thodes qui vont faciliter son utilisation. Pour plus de d\u00e9tails, voyez [la documentation de l'objet Index](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.html#pandas.Index) et de ses sous-classes. "]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["L'autre moiti\u00e9 de l'objet `Series` est accessible via l'attribut `values`. **ATTENTION** \u00e0 nouveau ici, c'est un **attribut** de l'objet et non pas une m\u00e9thode, ce qui est tr\u00e8s troublant par rapport \u00e0 l'interface d'un dictionnaire."]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 46, "lines": ["# regardons les valeurs de ma Series\n", "# ATTENTION !! values est un attribut, pas une fonction\n", "print(s.values) "]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Mais une Series a \u00e9galement une interface de dictionnaire \u00e0 laquelle on acc\u00e8de de la mani\u00e8re suivante\u00a0:"]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["# les clefs correspondent \u00e0 l'index\n", "k = s.keys() # attention ici c'est un appel de fonction !\n", "print(f\"Les clefs: {k}\") "]}, {"block": 20, "type": "code", "linesLength": 3, "startIndex": 53, "lines": ["# et les couples (clefs, valeurs) sous forme d'un objet zip\n", "for k,v in s.items(): # attention ici aussi c'est un appel de fonction !\n", "    print(k, v)"]}, {"block": 21, "type": "code", "linesLength": 3, "startIndex": 56, "lines": ["# pour finir remarquons que le test d'appartenance est possible sur les index\n", "print(f\"est-ce que a est dans s ? {'a' in s}\")\n", "print(f\"est-ce que z est dans s ? {'z' in s}\")"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Vous remarquez ici qu'alors que `values` et `index` sont des attributs de la Series, `keys()` et `items()` sont des m\u00e9thodes. Voici un exemple des nombreuses petites inncoh\u00e9rences de pandas avec lesquelles il faut vivre. "]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["### Pi\u00e8ges \u00e0 \u00e9viter"]}, {"block": 24, "type": "markdown", "linesLength": 5, "startIndex": 61, "lines": ["Avant d'aller plus loin, il faut faire attention \u00e0 la gestion du type\n", "des objets contenus dans notre Series (on aura le m\u00eame probl\u00e8me avec\n", "les DataFrame). Alors qu'un ndarray numpy a un type qui ne change pas,\n", "une Series peut implicitement changer le type de ses valeurs lors\n", "d'op\u00e9rations d'affectations. "]}, {"block": 25, "type": "code", "linesLength": 3, "startIndex": 66, "lines": ["# cr\u00e9ons une series et regardons le type de ses valeurs\n", "s = pd.Series({k:v**2 for k, v in zip('abcdefghij', range(10))})\n", "print(s.values.dtype)"]}, {"block": 26, "type": "code", "linesLength": 7, "startIndex": 69, "lines": ["# On a d\u00e9j\u00e0 vu que l'on ne pouvait pas modifier lors d'une affectation le\n", "# type d'un ndarray numpy\n", "\n", "try:\n", "    s.values[2] = 'spam'\n", "except ValueError as e:\n", "    print(f\"On ne peut pas affecter une str \u00e0 un ndarray de int64:\\n{e}\")"]}, {"block": 27, "type": "code", "linesLength": 5, "startIndex": 76, "lines": ["# Par contre, on peut le faire sur une Series\n", "s['c'] = 'spam'\n", "\n", "# et maintenant le type des valeurs de la Series a chang\u00e9\n", "print(s.values.dtype)"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["C'est un point extr\u00eament important puisque toutes les op\u00e9rations vectoris\u00e9es vont avoir leur performance impact\u00e9e et le r\u00e9sultat obtenu peut m\u00eame \u00eatre faux. Regardons cela\u00a0:"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 82, "lines": ["s = pd.Series(range(10_000))\n", "print(s.values.dtype)"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["# combien de temps prend le calcul du carr\u00e9 des valeurs\n", "%timeit s**2"]}, {"block": 31, "type": "code", "linesLength": 8, "startIndex": 86, "lines": ["# ajoutons 'spam' \u00e0 la fin de la Series\n", "s[10_000] = 'spam'\n", "\n", "# oups, je me suis tromp\u00e9, enlevons cet \u00e9l\u00e9ment\n", "del s[10_000]\n", "\n", "# calculons de nouveau le temps de calcul pour obtenir le carr\u00e9 des valeurs\n", "%timeit s**2"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["# que se passe-t-il, pourquoi le calcul est maintenant plus long\n", "s.values.dtype"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 96, "lines": ["Maintenant, les op\u00e9rations vectoris\u00e9es le sont sur des objets Python et non plus sur des int64, il y a donc un impact sur la performance. \n", "\n", "Et on peut m\u00eame obtenir un r\u00e9sultat carr\u00e9ment faux. Regardons cela\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 99, "lines": ["# cr\u00e9ons une series de trois entiers\n", "s = pd.Series([1, 2, 3])\n", "print(s)"]}, {"block": 35, "type": "code", "linesLength": 7, "startIndex": 102, "lines": ["# puis ajoutons un nouvel \u00e9l\u00e9ment, mais ici je me trompe, c'est une str\n", "# au lieu d'un entier\n", "s[3] = '4'\n", "\n", "# \u00e0 part le type qui pourrait attirer mon attention, rien dans l'affichage\n", "# ne distingue les entiers de la str, \u00e0 part le dtype\n", "print(s)"]}, {"block": 36, "type": "code", "linesLength": 3, "startIndex": 109, "lines": ["# seulement si j'additionne, les entiers sont additionn\u00e9s, \n", "# mais les cha\u00eenes de caract\u00e8res concat\u00e9n\u00e9es. \n", "print(s+s)"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 112, "lines": ["### Alignement d'indexes"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["Un int\u00e9r\u00eat majeur de pandas est de faire de l'alignement d'indexes sur les objets que l'on manipule. Regardons un exemple."]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 114, "lines": ["argent_poche_janvier = pd.Series([30, 35, 20], index=['alice', 'bob', 'julie'])\n", "argent_poche_f\u00e9vrier = pd.Series([30, 35, 20], index=['alice', 'julie', 'sonia'])\n", "argent_poche_janvier + argent_poche_f\u00e9vrier"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 117, "lines": ["On voit que les deux Series ont bien \u00e9t\u00e9 align\u00e9es, mais on a un probl\u00e8me. Lorsqu'une valeur n'est pas d\u00e9finie, elle vaut `NaN` et si on ajoute `NaN` \u00e0 une autre valeur, le r\u00e9sultat est `NaN`. On peut corriger ce probl\u00e8me avec un appel explicite de la fonction add qui accepte un argument `fill_value` qui sera la valeur par d\u00e9faut en cas d'absence d'une valeur lors de l'op\u00e9ration."]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["argent_poche_janvier.add(argent_poche_f\u00e9vrier, fill_value=0)"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["### Acc\u00e9s aux \u00e9l\u00e9ments d'une Series"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Comme les Series sont bas\u00e9es sur des ndarray numpy, elles supportent les op\u00e9rations d'acc\u00e8s aux \u00e9l\u00e9ments des ndarray, notamment la notion de masque et les broadcasts, tout \u00e7a en conservant \u00e9videmment les indexes."]}, {"block": 44, "type": "code", "linesLength": 4, "startIndex": 121, "lines": ["s = pd.Series([30, 35, 20], index=['alice', 'bob', 'julie'])\n", "\n", "# qui a plus de 25 ans\n", "print(s[s>25])"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 125, "lines": ["# regardons uniquement 'alice' et 'julie'\n", "print(s[['alice', 'julie']])"]}, {"block": 46, "type": "code", "linesLength": 3, "startIndex": 127, "lines": ["# et affectons sur un masque\n", "s[s<=25] = np.NaN\n", "print(s)"]}, {"block": 47, "type": "code", "linesLength": 4, "startIndex": 130, "lines": ["# notons \u00e9galement, que naturellement les op\u00e9rations de broadcast \n", "# sont support\u00e9es\n", "s = s + 10\n", "print(s)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["### Slicing sur les Series"]}, {"block": 49, "type": "markdown", "linesLength": 9, "startIndex": 135, "lines": ["L'op\u00e9ration de slicing sur les Series est une source fr\u00e9quente d'erreur qui peut passer inaper\u00e7ue pour les raisons suivantes.\n", "\n", " - On peut slicer sur les labels des indexes, mais aussi sur la position (l'indice) d'un \u00e9l\u00e9ment dans la Series.\n", " - Les op\u00e9rations de slices sur les positions et les labels se comportent diff\u00e9remment, [un slice sur les positions exclut la borne de droite (comme tous les slices en Python), mais un slice sur un label inclus la borne de droite](http://pandas.pydata.org/pandas-docs/stable/gotchas.html#endpoints-are-inclusive).\n", " - il peut y avoir ambigu\u00eft\u00e9 entre un label et la position d'un \u00e9l\u00e9ment lorsque le label est un entier.\n", " \n", "Nous allons d\u00e9tailler chacun de ces cas, mais sachez qu'il existe une solution qui \u00e9vite toute ambigu\u00eft\u00e9, c'est l'interface `loc` et `iloc` que nous allons discuter un peu plus loin. \n", "\n", "Regardons maintenant ces diff\u00e9rents probl\u00e8mes\u00a0:"]}, {"block": 50, "type": "code", "linesLength": 2, "startIndex": 144, "lines": ["s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'julie', 'sonia'])\n", "print(s)"]}, {"block": 51, "type": "code", "linesLength": 5, "startIndex": 146, "lines": ["# on peut acc\u00e9der directement \u00e0 la valeur correspondant \u00e0 alice\n", "print(s['alice'])\n", "\n", "# mais aussi par la position d'alice dans l'index\n", "print(s[0])"]}, {"block": 52, "type": "code", "linesLength": 3, "startIndex": 151, "lines": ["# On peut faire un slice sur les labels, dans ce cas la borne\n", "# de droite est incluse\n", "s['alice': 'julie']"]}, {"block": 53, "type": "code", "linesLength": 3, "startIndex": 154, "lines": ["# et on peut faire un slice sur les positions, mais dans ce cas \n", "# la borne de droite est exclue, comme un slice normal en Python\n", "s[0:2]"]}, {"block": 54, "type": "markdown", "linesLength": 7, "startIndex": 157, "lines": ["Ce comportement m\u00e9rite quelques explications. On voit bien que exclure la borne de droite peut se comprendre sur une position (si on exclut `i` on prend `i-1`), par contre, c'est mal d\u00e9fini pour un label. \n", "\n", "En effet, l'ordre d'un index est d\u00e9fini au moment de sa cr\u00e9ation et le label venant juste avant un autre label `L` ne peut pas \u00eatre trouv\u00e9 uniquement avec la connaissance de `L`. \n", "\n", "C'est pour cette raison que les concepteurs de pandas ont pr\u00e9f\u00e9r\u00e9 inclure la borne de droite. \n", "\n", "Regardons maintenant plus en d\u00e9tail cette notion d'ordre sur les indexes."]}, {"block": 55, "type": "code", "linesLength": 3, "startIndex": 164, "lines": ["# Regardons le slice sur un index avec un ordre particulier\n", "s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'julie', 'sonia'])\n", "print(s['alice':'julie'])"]}, {"block": 56, "type": "code", "linesLength": 3, "startIndex": 167, "lines": ["# Si on change l'ordre de l'index, \u00e7a change la signification du slice\n", "s = pd.Series([30, 35, 20, 28], index=['alice', 'bob', 'sonia', 'julie'])\n", "print(s['alice':'julie'])"]}, {"block": 57, "type": "markdown", "linesLength": 3, "startIndex": 170, "lines": ["Vous devez peut-\u00eatre vous demander si un slice sur l'index est toujours d\u00e9fini. La r\u00e9ponse est non ! Pour qu'un slice soit d\u00e9fini sur un index, il faut que [l'index ait une croissance monotonique ou qu'il n'y ait pas de label dans l'index qui soit dupliqu\u00e9. ](https://pandas.pydata.org/pandas-docs/stable/advanced.html#non-monotonic-indexes-require-exact-matches)\n", "\n", "Donc la croissance monotonique n'est pas n\u00e9cessaire tant qu'il n'y a pas de duplication de labels. Regardons cela."]}, {"block": 58, "type": "code", "linesLength": 4, "startIndex": 173, "lines": ["# mon index a des labels dupliqu\u00e9s, mais a une croissance monotonique\n", "s = pd.Series([30, 35, 20, 12], index=['a', 'a', 'b', 'c'])\n", "# le slice est d\u00e9fini\n", "s['a': 'b']"]}, {"block": 59, "type": "code", "linesLength": 7, "startIndex": 177, "lines": ["# mon index a des labels dupliqu\u00e9s et n'a pas de croissance monotonique\n", "s = pd.Series([30, 35, 20, 12], index=['a', 'b', 'c', 'a'])\n", "# le slice n'est plus d\u00e9fini\n", "try:\n", "    s['a': 'b']\n", "except KeyError as e:\n", "    print(f\"Je n'arrive pas \u00e0 extraire un slice :\\n{e}\")"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Pour finir sur les probl\u00e8mes que l'on peut rencontrer avec les slices, que se passe-t-il si on a un index qui a pour label des entiers ? Lorsque l'on va faire un slice, il va y avoir ambigu\u00eft\u00e9 entre la position du label et le label lui m\u00eame. Dans ce cas, pandas donne la priorit\u00e9 \u00e0 la position, mais ce qui est troublant, c'est que lorsqu'on acc\u00e8de \u00e0 un seul \u00e9l\u00e9ment en dehors d'un slice, pandas donne la priorit\u00e9 \u00e0 l'index. Encore une petite inconsistance. "]}, {"block": 61, "type": "code", "linesLength": 3, "startIndex": 185, "lines": ["s = pd.Series(['a', 'b', 'c'], index=[2, 0, 1])\n", "print(f\"si on acc\u00e8de diretement \u00e0 un \u00e9l\u00e9ment, priorit\u00e9 au label : {s[0]}\")\n", "print(f\"si on calcul un slice, priorit\u00e9 \u00e0 la position : {s[2:0]}\")"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 188, "lines": ["### `loc` et `iloc`"]}, {"block": 63, "type": "markdown", "linesLength": 3, "startIndex": 189, "lines": ["La solution \u00e0 tous ces probl\u00e8mes est de dire explicitement ce que l'on veut faire. On peut en effet dire explicitement si l'on veut utiliser les labels ou les positions, c'est ce qu'on vous recommande de faire pour \u00e9viter les comportements implicites.\n", "\n", "Pour utiliser les labels il faut utiliser `s.loc[]` et pour utiliser les positions if faut utiliser `s.iloc[]` (le `i` est pour localisation implicite, c'est-\u00e0-dire la position). Regardons cela. "]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 192, "lines": ["print(s)"]}, {"block": 65, "type": "code", "linesLength": 2, "startIndex": 193, "lines": ["# acc\u00e8s au label\n", "print(s.loc[0])"]}, {"block": 66, "type": "code", "linesLength": 2, "startIndex": 195, "lines": ["# acc\u00e8s \u00e0 la position\n", "print(s.iloc[0])"]}, {"block": 67, "type": "code", "linesLength": 2, "startIndex": 197, "lines": ["# slice sur les labels, ATTENTION, inclus la borne de droite\n", "print(s.loc[2:0])"]}, {"block": 68, "type": "code", "linesLength": 2, "startIndex": 199, "lines": ["# slice sur les positions, ATTENTION, exclus la borne de droite\n", "print(s.iloc[0:2])"]}, {"block": 69, "type": "markdown", "linesLength": 3, "startIndex": 201, "lines": ["Pour allez plus loin, vous pouvez lire la documentation officielle : \n", "\n", "http://pandas.pydata.org/pandas-docs/stable/indexing.html"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["### Conclusion"]}, {"block": 71, "type": "markdown", "linesLength": 3, "startIndex": 205, "lines": ["Nous avons vu que les Series forment une extension des ndarray de dimension 1, en leur ajoutant un index qui permet une plus grande expressivit\u00e9 pour acc\u00e9der aux \u00e9l\u00e9ments. Seulement cette expressivit\u00e9 vient au prix de quelques subtilit\u00e9s (conversions implicites de type, acc\u00e8s aux labels ou aux positions) qu'il faut ma\u00eetriser. \n", "\n", "Nous verrons dans le prochain compl\u00e9ment la notion de DataFrame qui est sans doute la plus utile et la plus puissante structure de donn\u00e9es de pandas. Tous les pi\u00e8ges que nous avons vu pour les Series sont valables pour les DataFrames."]}]
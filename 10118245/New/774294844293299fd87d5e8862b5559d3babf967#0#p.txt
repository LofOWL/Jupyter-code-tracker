[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# H\u00e9riter des types *built-in*\u00a0?"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Vous vous demandez peut-\u00eatre s'il est possible d'h\u00e9riter des types *built-in*."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["La r\u00e9ponse est oui, et nous allons voir un exemple qui est parfois tr\u00e8s utile en pratique, c'est le type - ou plus exactement la famille de types - `namedtuple`"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### La notion de *record*"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["On se place dans un contexte voisin de celui de *record* - en fran\u00e7ais enregistrement - qu'on a d\u00e9j\u00e0 rencontr\u00e9 souvent\u00a0; pour ce notebook nous allons \u00e0 nouveau prendre le cas du point \u00e0 deux coordonn\u00e9es x et y. Nous avons d\u00e9j\u00e0 vu que pour impl\u00e9menter un point on peut utiliser\u00a0:"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["##### un dictionnaire"]}, {"block": 8, "type": "code", "linesLength": 3, "startIndex": 12, "lines": ["p1 = {'x': 1, 'y': 2}\n", "# ou de mani\u00e8re \u00e9quivalente\n", "p1 = dict(x=1, y=2)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["##### ou une classe"]}, {"block": 10, "type": "code", "linesLength": 6, "startIndex": 16, "lines": ["class Point:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "\n", "p2 = Point(1, 2)"]}, {"block": 11, "type": "markdown", "linesLength": 4, "startIndex": 22, "lines": ["Nous allons voir une troisi\u00e8me fa\u00e7on de s'y prendre, qui pr\u00e9sente deux caract\u00e9ristiques\u00a0:\n", "\n", "* les objets seront non-mutables (en fait ce sont des tuples)\u00a0;\n", "* et accessoirement on pourra acc\u00e9der aux diff\u00e9rents champs par leur nom aussi bien que par un index."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Pous faire \u00e7a il nous faut donc cr\u00e9er une sous-classe de `tuple`\u00a0; pour nous simplifier la vie, [le module `collections`  nous offre un utilitaire](https://docs.python.org/3/library/collections.html#collections.namedtuple)\u00a0:"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["##### `namedtuple`"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["from collections import namedtuple"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Techniquement, il s'agit d'une fonction\u00a0:"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["type(namedtuple)"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": [" qui **renvoie une classe** - oui les classes sont des objets comme les autres\u00a0; par exemple pour cr\u00e9er une classe `TuplePoint`, on ferait\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 32, "lines": ["# on passe \u00e0 namedtuple\n", "#  - le nom du type qu'on veut cr\u00e9er\n", "#  - la liste ordonn\u00e9e des composants (champs)\n", "TuplePoint = namedtuple('TuplePoint', ['x', 'y'])"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Et maintenant si je cr\u00e9e un objet\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["p3 = TuplePoint(1, 2)"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["# cet objet est un tuple\n", "isinstance(p3, tuple)"]}, {"block": 22, "type": "code", "linesLength": 3, "startIndex": 40, "lines": ["# auquel je peux acc\u00e9der par index\n", "# comme un tuple\n", "p3[0]"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["# mais aussi par nom via un attribut\n", "p3.x"]}, {"block": 24, "type": "code", "linesLength": 5, "startIndex": 45, "lines": ["# et comme c'est un tuple il est immuable\n", "try:\n", "    p3.x = 10\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)} {e}\")"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["### \u00c0 quoi \u00e7a sert"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Les `namedtuple` ne sont pas d'un usage fr\u00e9quent, mais on en a d\u00e9j\u00e0 rencontr\u00e9 un exemple dans le notebook sur le module `pathlib`. En effet le type de retour de la m\u00e9thode `Path.stat` est un `namedtuple`\u00a0:"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 52, "lines": ["from pathlib import Path\n", "dot_stat = Path('.').stat()"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 54, "lines": ["dot_stat"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["isinstance(dot_stat, tuple)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["### Nom"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Quand on cr\u00e9e une classe avec l'instruction `class`, on ne mentionne le nom de la classe qu'une seule fois. Ici vous avez remarqu\u00e9 qu'il faut en pratique le donner deux fois. Pour \u00eatre pr\u00e9cis, le param\u00e8tre qu'on a pass\u00e9 \u00e0 `namedtuple` sert \u00e0 ranger le nom dans l'attribut `__name__` de la classe cr\u00e9\u00e9e\u00a0:"]}, {"block": 32, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["Foo = namedtuple('Bar', ['spam', 'eggs'])"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 59, "lines": ["# Foo est le nom de la variable classe\n", "foo = Foo(1, 2)"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 61, "lines": ["# mais cette classe a son attribut __name__ mal positionn\u00e9\n", "Foo.__name__"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Il est donc \u00e9videmment pr\u00e9f\u00e9rable d'utiliser deux fois le m\u00eame nom.."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["### M\u00e9moire"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["\u00c0 titre de comparaison voici la place prise par chacun de ces objets\u00a0; le `namedtuple` ne semble pas de ce point de vue sp\u00e9cialement attractif par rapport \u00e0 une instance\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 6, "startIndex": 66, "lines": ["import sys\n", "\n", "# p1 = dict / p2 = instance / p3 = namedtuple\n", "\n", "for p in p1, p2, p3:\n", "    print(sys.getsizeof(p))"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["### D\u00e9finir des m\u00e9thodes sur un `namedtuple`"]}, {"block": 40, "type": "markdown", "linesLength": 3, "startIndex": 73, "lines": ["Dans un des compl\u00e9ments de la s\u00e9quence pr\u00e9c\u00e9dente, intitul\u00e9 *\"Manipuler des ensembles d'instances\"*, nous avions vu comment red\u00e9finir le protocole *hashable* sur des instances, en mettant en \u00e9vidence la n\u00e9cessit\u00e9 de disposer d'instances non mutables lorsqu'on veut red\u00e9finir `__hash__()`.\n", "\n", "Voyons ici comment on pourrait tirer parti d'un `namedtuple` pour refaire proprement notre classe `Point2` - souvenez-vous, il s'agissait de rechercher dans un ensemble de points."]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["Point2 = namedtuple('Point2', ['x', 'y'])"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["Sans utiliser le mot-cl\u00e9 `class`, il faudrait se livrer \u00e0 une petite gymnastique pour red\u00e9finir les m\u00e9thodes sp\u00e9ciales sur la classe `Point2`. Nous allons utiliser l'h\u00e9ritage pour arriver au m\u00eame r\u00e9sultat\u00a0:"]}, {"block": 43, "type": "code", "linesLength": 11, "startIndex": 78, "lines": ["# ce code est tr\u00e8s proche du code utilis\u00e9 dans le pr\u00e9c\u00e9dent compl\u00e9ment\n", "class Point2(namedtuple('Point2', ['x', 'y'])):\n", "\n", "    # l'\u00e9galit\u00e9 va se baser naturellement sur x et y\n", "    def __eq__(self, other):\n", "        return self.x == other.x and self.y == other.y\n", "\n", "    # du coup la fonction de hachage \n", "    # d\u00e9pend aussi de x et de y\n", "    def __hash__(self):\n", "        return (11 * self.x + self.y) // 16"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["Avec ceci en place on peut maintenant faire: "]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["# trois points \u00e9gaux au sens de cette classe\n", "q1, q2, q3 = Point2(10, 10), Point2(10, 10), Point2(10, 10)"]}, {"block": 46, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["# deux objets distincts\n", "q1 is q2"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["# mais \u00e9gaux\n", "q1 == q2"]}, {"block": 48, "type": "code", "linesLength": 3, "startIndex": 96, "lines": ["# ne font qu'un dans un ensemble\n", "s = {q1, q2}\n", "len(s)"]}, {"block": 49, "type": "code", "linesLength": 3, "startIndex": 99, "lines": ["# et on peut les trouver\n", "# par le troisi\u00e9me\n", "q3 in s"]}, {"block": 50, "type": "code", "linesLength": 5, "startIndex": 102, "lines": ["# et les instances ne sont pas mutables\n", "try:\n", "    q1.x = 100\n", "except Exception as e:\n", "    print(f\"OOPS {type(e)}\")"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["# Pour en savoir plus"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["Vous pouvez vous reporter [\u00e0 la documentation officielle](https://docs.python.org/3/library/collections.html#collections.namedtuple)."]}, {"block": 53, "type": "markdown", "linesLength": 7, "startIndex": 109, "lines": ["Si vous \u00eates int\u00e9ress\u00e9s de savoir comment on peut bien arriver \u00e0 rendre les objets d'une classe immuable, vous pouvez commencer par regarder le code utilis\u00e9 par `namedtuple` pour cr\u00e9er son r\u00e9sultat, en l'invoquant avec le mode bavard (cette possibilit\u00e9 a disparu malheureusement dans python-3.7).\n", "\n", "Vous y remarquerez notamment\u00a0:\n", "\n", "* une red\u00e9finition de [la m\u00e9thode sp\u00e9ciale `__new__`](https://docs.python.org/3/reference/datamodel.html#object.__new__),\n", "\n", "* et aussi un usage des `property` que l'on a rencontr\u00e9s en d\u00e9but de semaine."]}, {"block": 54, "type": "code", "linesLength": 2, "startIndex": 116, "lines": ["# ex\u00e9cuter ceci pour voir le d\u00e9tail de ce que fait `namedtuple` \n", "Point = namedtuple('Point', ['x', 'y'], verbose=True)"]}]
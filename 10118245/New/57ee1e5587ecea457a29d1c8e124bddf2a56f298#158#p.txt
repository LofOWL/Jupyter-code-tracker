[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Les diff\u00e9rentes copies"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["### Deux types de copie"]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 4, "lines": ["Pour r\u00e9sumer les deux grands types de copie que l'on a vues dans la vid\u00e9o: \n", " * La *shallow copy* - de l'anglais *shallow* qui signifie superficiel\n", " * La *deep copy* - de *deep* qui signifie profond"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Le module `copy`"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 8, "lines": ["Pour r\u00e9aliser une copie, la m\u00e9thode la plus simple, en ceci qu'elle fonctionne avec tous les types de mani\u00e8re identique, consiste \u00e0 utiliser [le module standard `copy`](https://docs.python.org/2/library/copy.html), et notamment\n", " * `copy.copy` pour une copie superficielle\n", " * `copy.deepcopy` pour une copie en profondeur"]}, {"block": 7, "type": "code", "linesLength": 3, "startIndex": 11, "lines": ["import copy\n", "#help(copy.copy)\n", "#help(copy.deepcopy)"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Un exemple"]}, {"block": 9, "type": "code", "linesLength": 13, "startIndex": 15, "lines": ["# On se donne un objet de d\u00e9part\n", "\n", "source = [ \n", "    [1, 2, 3],  # le premier \u00e9l\u00e9ment est une liste\n", "    {1, 2, 3},  # un ensemble\n", "    (1, 2, 3),  # un tuple\n", "    '123',       # un string\n", "    123,         # un entier\n", "]\n", "\n", "# et on en fait deux copies\n", "shallow_copy = copy.copy(source)\n", "deep_copy = copy.deepcopy(source)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["### Objets *\u00e9gaux* au sens logique"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Bien s\u00fbr ces trois objets se ressemblent si on fait une comparaison *logique*"]}, {"block": 13, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["print 'source == shallow_copy:', source == shallow_copy\n", "print 'source == deep_copy:', source == deep_copy"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### Inspectons les objets de premier niveau"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Mais par contre si on compare **l'identit\u00e9** des objets de premier niveau, on voit que `source` et `shallow_copy` partagent leurs objets:"]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 35, "lines": ["for i in range(len(source)):\n", "    print \"source[{}] is shallow_copy[{}]\".format(i, i),\\\n", "           source[i] is shallow_copy[i]"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Alors que naturellement ce **n'est pas le cas** avec la copie en profondeur"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 39, "lines": ["for i in range(len(source)):\n", "    print \"source[{}] is deep_copy[{}]\".format(i, i),\\\n", "           source[i] is deep_copy[i]"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["On remarque  tout de suite que les trois derniers objets n'ont pas \u00e9t\u00e9 dupliqu\u00e9s comme on aurait pu s'y attendre; cela est d\u00fb, ici encore, \u00e0 l'optimisation qui est mise en place dans python pour impl\u00e9menter les types immuables comme des singletons lorsque c'est possible. Cela a \u00e9t\u00e9 vu en d\u00e9tail dans le compl\u00e9ment consacr\u00e9 \u00e0 l'op\u00e9rateur `is`."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["### On modifie la source"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["Il doit \u00eatre clair \u00e0 pr\u00e9sent que, pr\u00e9cis\u00e9ment parce que `deep_copy` est une copie en profondeur, on peut modifier `source` sans impacter du tout `deep_copy`."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["S'agissant de `shallow_copy`, par contre, seuls les \u00e9l\u00e9ments de premier niveau ont \u00e9t\u00e9 copi\u00e9s. Aussi si on fait une modification par exemple **\u00e0 l'int\u00e9rieur** de la liste qui est le premier fils de `source`, cela sera **r\u00e9percut\u00e9** dans `shallow_copy`"]}, {"block": 23, "type": "code", "linesLength": 5, "startIndex": 46, "lines": ["print \"avant, source      \", source\n", "print \"avant, shallow_copy\", shallow_copy\n", "source[0].append(4)\n", "print \"apr\u00e8s, source      \", source\n", "print \"apr\u00e8s, shallow_copy\", shallow_copy"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Si par contre on remplace compl\u00e8tement un \u00e9l\u00e9ment de premier niveau dans la source, cela ne sera pas r\u00e9percut\u00e9 dans la copie superficielle"]}, {"block": 25, "type": "code", "linesLength": 5, "startIndex": 52, "lines": ["print \"avant, source      \", source\n", "print \"avant, shallow_copy\", shallow_copy\n", "source[0] = 'remplacement'\n", "print \"apr\u00e8s, source      \", source\n", "print \"apr\u00e8s, shallow_copy\", shallow_copy"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["### Copie et circularit\u00e9"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": [" Le module `copy` est semble-t-il capable de copier - m\u00eame en profondeur - des objets contenant des r\u00e9f\u00e9rences circulaires."]}, {"block": 28, "type": "code", "linesLength": 3, "startIndex": 59, "lines": ["l = [None] \n", "l[0] = l\n", "l"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["copy.copy(l)"]}, {"block": 30, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["copy.deepcopy(l)"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["### Pour en savoir plus"]}, {"block": 32, "type": "markdown", "linesLength": 7, "startIndex": 65, "lines": ["On peut se reporter \u00e0 [la section sur le module `copy`](https://docs.python.org/2/library/copy.html) dans la documentation python.\n", "\n", "Signalons \u00e9galement [pythontutor.com](http://www.pythontutor.com) qui est un site tr\u00e8s utile pour comprendre comment python impl\u00e9mente les objets, les r\u00e9f\u00e9rences et les partages. \n", "Toutefois `pythontutor.com` ne supporte pas le module `copy` ce qui est un peu dommage.\n", "On peut toutefois exp\u00e9rimenter avec des listes en utilisant le slicing `[:]` pour des copies superficielles.\n", "\n", "<img src=\"media/pt_shallow_copy.png\" />"]}]
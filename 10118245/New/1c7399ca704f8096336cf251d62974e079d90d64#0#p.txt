[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# *Context managers* et exceptions"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["On a vu jusqu'ici dans la vid\u00e9o comment \u00e9crire un context manager, mais on n'a pas envisag\u00e9 le cas o\u00f9 une exception serait lev\u00e9e pendant la dur\u00e9e de vie du context manager."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Et c'est tr\u00e8s important, car si je me contente de faire\u00a0:"]}, {"block": 5, "type": "code", "linesLength": 11, "startIndex": 9, "lines": ["import time\n", "\n", "class Timer1:\n", "    def __enter__(self):\n", "        print(\"Entering Timer1\")\n", "        self.start = time.time()\n", "        return self\n", "    \n", "    def __exit__(self, *args):\n", "        print(f\"Total duration {time.time()-self.start:2f}\")\n", "        return True"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Alors dans les cas nominaux, tout se passe comme attendu\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 4, "startIndex": 21, "lines": ["with Timer1():\n", "    n = 0\n", "    for i in range(2*10**6):\n", "        n += i**2"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["Mais par contre, dans le cas o\u00f9 j'ex\u00e9cute du code qui l\u00e8ve une exception, \u00e7a ne va plus du tout\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 26, "lines": ["with Timer1():\n", "    n = 0\n", "    for i in range(2*10**6):\n", "        n += i**2 / 0"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["\u00c0 la toute premi\u00e8re it\u00e9ration de la boucle, on fait une division par 0, qui l\u00e8ve l'exception `ZeroDivisionError`, mais tel qu'est con\u00e7ue notre classe de context manager, cette exception **est \u00e9touff\u00e9e** et n'est pas correctement propag\u00e9e \u00e0 l'ext\u00e9rieur."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Il est important, lorsqu'on con\u00e7oit un context manager, de bien **propager** les exceptions qui ne sont pas li\u00e9es au fonctionnement attendu du context manager. Par exemple un objet de type fichier va en effet attraper par exemple les exceptions li\u00e9es \u00e0 la fin du fichier, mais doit par contre laisser passer une exception comme `ZeroDivisionError`."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["### Les param\u00e8tres de `__exit__`"]}, {"block": 13, "type": "markdown", "linesLength": 5, "startIndex": 33, "lines": ["Comme [vous pouvez le retrouver ici](https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers), la m\u00e9thode `__exit__` re\u00e7oit trois arguments\u00a0:\n", "\n", "    def __exit__(self, exc_type, exc_value, traceback):\n", "\n", "lorsqu'on sort du bloc `with` sans qu'une exception soit lev\u00e9e, ces trois arguments valent `None`. Par contre si une exception est lev\u00e9e, ils permettent d'acc\u00e9der au type, \u00e0 la valeur de l'exception, et \u00e0 l'\u00e9tat de la pile lorsque l'exception est lev\u00e9e."]}, {"block": 14, "type": "code", "linesLength": 21, "startIndex": 38, "lines": ["# une deuxi\u00e8me version de Timer\n", "# qui propage correctement les exceptions\n", "\n", "class Timer2:\n", "    def __enter__(self):\n", "        print(\"Entering Timer1\")\n", "        self.start = time.time()\n", "        # rappel : le retour de __enter__ est ce qui est pass\u00e9\n", "        # \u00e0 la clause `as` du `with`\n", "        return self\n", "    \n", "    def __exit__(self, exc_type, exc_value, traceback):\n", "        if exc_type is None:\n", "            print(f\"Total duration {time.time()-self.start:2f}\")\n", "            # ceci indique que tout s'est bien pass\u00e9\n", "            return True\n", "        else:\n", "            print(f\"OOPS : on propage l'exception {exc_type} - {exc_value}\")\n", "            # c'est ici que je propage l'exception au dehors du with\n", "            raise exc_type(exc_value)\n", "        return True"]}, {"block": 15, "type": "code", "linesLength": 7, "startIndex": 59, "lines": ["try:\n", "    with Timer2():\n", "        n = 0\n", "        for i in range(2*10**6):\n", "            n += i**2 / 0\n", "except Exception as e:\n", "    print(f\"L'exception a bien \u00e9t\u00e9 propag\u00e9e, {type(e)} - {e}\")"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["### Pour en savoir plus"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 67, "lines": ["Je vous signale enfin [la librairie `contextlib`](https://docs.python.org/3/library/contextlib.html) qui offre quelques utilitaires pour se d\u00e9finir un contextmanager.\n", "\n", "Notamment, un peu comme on peut impl\u00e9menter un it\u00e9rateur comme un g\u00e9n\u00e9rateur qui fait (n'importe quel nombre de) `yield`, on peut \u00e9galement impl\u00e9menter un context manager simple sous la forme d'une fonction qui fait un `yield`."]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Indexes et slices"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 7, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 11, "lines": ["J'esp\u00e8re que vous \u00eates \u00e0 pr\u00e9sent convaincus qu'il est possible de faire \u00e9norm\u00e9ment de choses avec numpy en faisant des op\u00e9rations entre tableaux, et sans aller r\u00e9f\u00e9rencer un par un les \u00e9l\u00e9ments des tableaux, ni faire de boucle `for`.\n", "\n", "Il est temps maintenant de voir que l'on peut *aussi* manipuler les tableaux numpy avec des indexes."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["### Indexation par des entiers et tuples"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["La fa\u00e7on la plus naturelle d'utiliser un tableau, habituellement c'est \u00e0 travers des indices. On peut aussi bien s\u00fbr acc\u00e9der aux \u00e9l\u00e9ments d'un tableau numpy par des indices\u00a0:"]}, {"block": 7, "type": "code", "linesLength": 6, "startIndex": 16, "lines": ["# une fonction qui cr\u00e9e un tableau\n", "# tab[i, j] = i + 10 * j\n", "def background(n):\n", "    i = np.arange(n)\n", "    j = i.reshape((n, 1))\n", "    return i + 10 * j"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["a5 = background(5)\n", "print(a5)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Avec un seul index on obtient naturellement une ligne"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 25, "lines": ["a5[1]"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["# qu'on peut a nouveau indexer\n", "a5[1][2]"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["# ou plus simplement indexer par un tuple\n", "a5[1, 2]"]}, {"block": 13, "type": "code", "linesLength": 5, "startIndex": 30, "lines": ["# Naturellement on peut affecter une case\n", "# individuellement\n", "a5[2][1] = 221\n", "a5[3, 2] += 300\n", "print(a5)"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["# Ou toute une ligne\n", "a5[1] = np.arange(100, 105); print(a5)"]}, {"block": 15, "type": "code", "linesLength": 3, "startIndex": 37, "lines": ["# et on on peut aussi changer \n", "# toute une ligne par broadcasting\n", "a5[4] = 400; print(a5)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["# Slicing"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Gr\u00e2ce au slicing on peut aussi r\u00e9f\u00e9rencer une colonne\u00a0:"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 42, "lines": ["a5 = background(5); print(a5)"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["a5[:, 3]"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["C'est un tableau \u00e0 une dimension, mais vous pouvez tout de m\u00eame modifier la colonne par une affectation\u00a0:"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["a5[:, 3] = range(300, 305); print(a5)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["ou, ici \u00e9galement bien s\u00fbr, par broadcasting\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 47, "lines": ["# on affecte un scalaire \u00e0 une colonne\n", "a5[:, 2] = 200; print(a5)"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 49, "lines": ["# ou on ajoute un scalaire \u00e0 une colonne \n", "a5[:, 4] += 400; print(a5)"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Les slices peuvent prendre une forme g\u00e9n\u00e9rale\u00a0:"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["a8 = background(8); print(a8)"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 53, "lines": ["# toutes les lignes de rang 1, 4, 7\n", "a8[1::3]"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 55, "lines": ["# toutes les colonnes de rang 1, 5, 9\n", "a8[:, 1::4]"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 57, "lines": ["# et on peut bien s\u00fbr les modifier\n", "a8[:, 1::4] = 0; print(a8)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Du coup le slicing peut servir \u00e0 extraire des blocs\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["# un bloc au hasard dans a8\n", "print(a8[5:8, 2:5])"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["### `newaxis`"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["On peut utiliser \u00e9galement le symbole sp\u00e9cial `np.newaxis` en conjonction avec un slice pour \"d\u00e9caler\" les dimensions\u00a0:"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["X = np.arange(1, 7); print(X)"]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["X.shape"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["Y = X[:, np.newaxis]; print(Y)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["Y.shape"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["Et ainsi de suite\u00a0:"]}, {"block": 39, "type": "code", "linesLength": 1, "startIndex": 69, "lines": ["Z = Y[:, np.newaxis]; Z"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["Z.shape"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["De cette fa\u00e7on par exemple, en combinant le slicing pour cr\u00e9er X et Y, et le broadcasting pour cr\u00e9er leur somme,  je peux cr\u00e9er facilement la table de tous les tirages de 2 d\u00e9s \u00e0 6 faces\u00a0:"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 72, "lines": ["dice2 = X + Y; print(dice2)"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Ou tous les tirages \u00e0 trois d\u00e9s\u00a0:"]}, {"block": 44, "type": "code", "linesLength": 1, "startIndex": 74, "lines": ["dice3 = X + Y + Z; print(dice3)"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["J'en profite pour introduire un utilitaire qui n'a rien \u00e0 voir, mais\u00a0: avec `np.unique`, vous pourriez calculer le nombre d'occurrences dans le tableau, et ainsi calculer les probabilit\u00e9s d'apparition de tous les nombres entre 3 et 18\u00a0:"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["np.unique(dice3, return_counts=True)"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 77, "lines": ["### Diff\u00e9rences avec les listes"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["Avec l'indexation et le slicing, on peut cr\u00e9er des tableaux qui sont des vues sur des fragments d'un tableau; on peut \u00e9galement d\u00e9former leur dimension gr\u00e2ce \u00e0 `newaxis`; on peut modifier ces fragments, en utilisant un scalaire, un tableau, ou ne slice sur un autre tableau; les possibilit\u00e9s sont infinies."]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Il est cependant utile de souligner quelques diff\u00e9rences entre les tableaux numpy et, les listes natives, pour ce qui concerne les indexations et le *slicing*."]}, {"block": 50, "type": "markdown", "linesLength": 3, "startIndex": 80, "lines": ["#### On ne peut pas changer la taille d'un tableau avec le slicing\n", "\n", "La taille d'un objet numpy est par d\u00e9finition constante; cela signifie qu'on ne peut pas, par exemple, modifier sa taille totale avec du slicing c'est \u00e0 mettre en contraste avec, si vous vous souvenez\u00a0:"]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["##### Listes"]}, {"block": 52, "type": "code", "linesLength": 4, "startIndex": 84, "lines": ["# on peut faire ceci\n", "liste = [0, 1, 2]\n", "liste[1:2] = [100, 102, 102]\n", "liste"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["##### Tableaux"]}, {"block": 54, "type": "code", "linesLength": 6, "startIndex": 89, "lines": ["# on ne peut pas faire cela\n", "array = np.array([0, 1, 2])\n", "try:\n", "    array[1:2] = np.array([100, 102, 102])\n", "except Exception as e:\n", "    print(f\"OOPS, {type(e)}, {e}\")"]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 95, "lines": ["##### On peut modifier un tableau en modifiant une slice\n", "\n", "Une slice sur un objet numpy renvoie une **vue** sur un extrait du tableau, et en changeant la vue on change le tableau; ici encore c'est \u00e0 mettre en contraste avec ce qui se passe sur les listes\u00a0:"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["##### Listes"]}, {"block": 57, "type": "code", "linesLength": 3, "startIndex": 99, "lines": ["# une slice d'une liste est une shallow copy\n", "liste = [0, 1, 2] \n", "liste[1:2]"]}, {"block": 58, "type": "code", "linesLength": 4, "startIndex": 102, "lines": ["# en modifiant la slice,\n", "# on ne modifie pas la liste\n", "liste[1:2][0] = 999999\n", "liste"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["##### Tableaux"]}, {"block": 60, "type": "code", "linesLength": 3, "startIndex": 107, "lines": ["# une slice d'un tableau numpy est un extrait du tableau\n", "array = np.array([0, 1, 2])\n", "array[1:2]"]}, {"block": 61, "type": "code", "linesLength": 2, "startIndex": 110, "lines": ["array[1:2][0] = 100\n", "array"]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Fonctions avec ou sans valeur de retour"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["### Le style proc\u00e9dural"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Une proc\u00e9dure est une fonction qui se contente de d\u00e9rouler des instructions. Voici un exemple d'une telle fonction:"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["def affiche_carre(n):\n", "    print(\"le carre de\", n, \"vaut\", n*n)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["qui s'utiliserait comme ceci"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["affiche_carre(12)"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["### Le style fonctionnel"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Mais en fait, il serait dans notre cas beaucoup plus commode de d\u00e9finir une fonction qui **retourne** le carr\u00e9 d'un nombre, afin de pouvoir \u00e9crire quelque chose comme:"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["    surface = carre(15)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["quitte \u00e0 imprimer cette valeur ensuite si n\u00e9cessaire. Jusqu'ici nous avons fait beaucoup appel \u00e0 `print`, mais dans la pratique, imprimer n'est pas un but en soi, au contraire bien souvent."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["### L'instruction `return`"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Voici comment on pourrait \u00e9crire une fonction `carre` qui **retourne** (on dit aussi **renvoie**) le carr\u00e9 de son argument:"]}, {"block": 14, "type": "code", "linesLength": 5, "startIndex": 19, "lines": ["def carre(n):\n", "    return n*n\n", "\n", "if carre(8) <= 100: \n", "    print('petit appartement')"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["La s\u00e9mantique (le mot savant pour \"comportement\") de l'instruction `return` est assez simple. La fonction qui est en cours d'ex\u00e9cution **s'ach\u00e8ve** imm\u00e9diatement, et l'objet cit\u00e9 dans l'instruction `return` est retourn\u00e9 \u00e0 l'appelant, qui peut utiliser cette valeur comme n'importe quelle expression. "]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### Le singleton `None`"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Le terme m\u00eame de fonction, si vous vous rappelez vos souvenirs de math\u00e9matiques, sugg\u00e8re qu'on calcule un r\u00e9sultat \u00e0 partir de valeurs d'entr\u00e9e. Dans la pratique il est assez rare qu'on d\u00e9finisse une fonction qui ne retourne rien."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["En fait **toutes** les fonctions retournent quelque chose. Lorsque le programmeur n'a pas pr\u00e9vu d'instruction `return`, python retourne un objet sp\u00e9cial, baptis\u00e9 `None`. Voici par exemple ce qu'on obtient si on essaie d'afficher la valeur de retour de notre premi\u00e8re fonction, qui, on le rappelle, ne retourne rien:"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 28, "lines": ["# ce premier appel provoque l'impression d'une ligne\n", "retour = affiche_carre(15)"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 30, "lines": ["# voyons ce qu'a retourn\u00e9 la fonction affiche_carre\n", "print('retour =', retour)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["L'objet `None` est un singleton pr\u00e9d\u00e9fini par python, un peu comme `True` et `False`. Ce n'est pas par contre une valeur bool\u00e9enne, nous aurons l'occasion d'en reparler."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### Un exemple un peu plus r\u00e9aliste"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Pour illustrer l'utilisation de `return` sur un exemple plus utile, voyons le code suivant:"]}, {"block": 24, "type": "code", "linesLength": 22, "startIndex": 35, "lines": ["def premier(n):\n", "    \"\"\"\n", "    Retourne un bool\u00e9en selon que n est premier ou non\n", "    Retourne None pour les entr\u00e9es n\u00e9gatives ou nulles\n", "    \"\"\"\n", "    # retourne None pour les entr\u00e9es non valides\n", "    if n <= 0:\n", "        return\n", "    # traiter le cas singulier\n", "    elif n == 1:\n", "        return False\n", "    # chercher un diviseur dans [2..n-1]\n", "    # bien s\u00fbr on pourrait s'arr\u00eater \u00e0 la racine carr\u00e9e de n\n", "    # mais ce n'est pas notre sujet\n", "    else:\n", "        for i in range(2, n):\n", "            if n % i == 0:\n", "                # on a trouv\u00e9 un diviseur,\n", "                # on peut sortir de la fonction\n", "                return False\n", "    # \u00e0 ce stade, le nombre est bien premier\n", "    return True"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Cette fonction teste si un entier est premier ou non; il s'agit naturellement d'une version d'\u00e9cole, il existe  d'autres m\u00e9thodes beaucoup plus adapt\u00e9es \u00e0 cette t\u00e2che. On peut toutefois v\u00e9rifier que cette version est fonctionnelle pour de petits entiers comme suit. On rappelle que 1 n'est pas consid\u00e9r\u00e9 comme un nombre premier:"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 58, "lines": ["for test in [-2, 1, 2, 4, 19, 35]:\n", "    print(f\"premier({test:2d}) = {premier(test)}\")"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["##### `return` sans valeur "]}, {"block": 28, "type": "markdown", "linesLength": 3, "startIndex": 61, "lines": ["Pour les besoins de cette discussion, nous avons choisi de retourner `None` pour les entiers n\u00e9gatifs ou nuls, une mani\u00e8re comme une autre de signaler que la valeur en entr\u00e9e n'est pas valide. \n", "\n", "Ceci n'est pas forc\u00e9ment une bonne pratique, mais elle nous permet ici d'illustrer que dans le cas o\u00f9 on ne mentionne pas de valeur de retour, python retourne `None`. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["##### `return` interrompt la fonction"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Comme on peut s'en convaincre en instrumentant le code - ce que vous pouvez faire \u00e0 titre d'exercice en ajoutant des fonctions `print` - dans le cas d'un nombre qui n'est pas premier la boucle `for` ne va pas jusqu'\u00e0 son terme."]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["On aurait pu d'ailleurs tirer profit de cette propri\u00e9t\u00e9 pour \u00e9crire la fonction de mani\u00e8re l\u00e9g\u00e8rement diff\u00e9rente comme ceci:"]}, {"block": 32, "type": "code", "linesLength": 19, "startIndex": 67, "lines": ["def premier_sans_else(n):\n", "    \"\"\"\n", "    Retourne un bool\u00e9en selon que n est premier ou non\n", "    Retourne None pour les entr\u00e9es n\u00e9gatives ou nulles\n", "    \"\"\"\n", "    # retourne None pour les entr\u00e9es non valides\n", "    if n <= 0:\n", "        return\n", "    # traiter le cas singulier\n", "    if n == 1:\n", "        return False\n", "    # par rapport \u00e0 la premi\u00e8re version, on a supprim\u00e9\n", "    # la clause else: qui est inutile\n", "    for i in range(2, n):\n", "        if n % i == 0:\n", "            # on a trouve un diviseur\n", "            return False\n", "    # a ce stade c'est que le nombre est bien premier\n", "    return True"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["C'est une question de style et de go\u00fbt. En tous cas, les deux versions sont tout \u00e0 fait \u00e9quivalentes, comme on le voit ici:"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 87, "lines": ["for test in [-2, 2, 4, 19, 35]:\n", "    print(f\"pour n ={test:2d} premier \u2192 {premier(test)}, \"\n", "          f\"premier_sans_else \u2192 {premier_sans_else(test)}\")"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["##### Digression sur les chaines"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["Vous remarquerez dans cette derni\u00e8re cellule, si vous regardez bien le param\u00e8tre de `print`,  qu'on peut accoler deux chaines (ici deux *f-strings*) sans m\u00eame les ajouter; un petit d\u00e9tail pour \u00e9viter d'alourdir le code:"]}, {"block": 37, "type": "code", "linesLength": 3, "startIndex": 92, "lines": ["# quand deux chaines apparaissent imm\u00e9diatement\n", "# l'une apr\u00e8s l'autre sans op\u00e9rateur, elles sont concat\u00e9n\u00e9es\n", "\"abc\" \"def\""]}]
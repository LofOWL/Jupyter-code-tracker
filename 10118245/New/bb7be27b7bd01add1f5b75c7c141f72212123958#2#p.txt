[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Gestion de sous-process"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau (tr\u00e8s) avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Dans ce second notebook, nous allons \u00e9tudier un deuxi\u00e8me programme python, que j'appelle `game.py` (en fait c'est le pr\u00e9sent notebook)."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Fonctions de `game.py`"]}, {"block": 5, "type": "markdown", "linesLength": 7, "startIndex": 9, "lines": ["Son travail va consister \u00e0 faire plusieurs choses en m\u00eame temps; pour rester le plus simple possible, on va se contenter des trois fonctions suivantes\u00a0:\n", "\n", "* *scheduler* (chef d'orchestre)\u00a0: on veut lancer \u00e0 des moments pr\u00e9programm\u00e9s des instances (sous-processes) de `players.py`;\n", "\n", "* *multiplexer* (agr\u00e9gateur) : on veut lire et imprimer au fur et \u00e0 mesure les messages \u00e9mis par les sous-processes\u00a0;\n", "\n", "* horloge : on veut \u00e9galement afficher chaque seconde le temps \u00e9coul\u00e9 depuis le d\u00e9but."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["En pratique, le programme `game.py` serait plut\u00f4t le serveur du jeu qui re\u00e7oit les mouvements de tous les joueurs, et diffuse ensuite en retour, en mode broadcast, un \u00e9tat du jeu \u00e0 tous les participants."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Mais dans notre version hyper simpliste, \u00e7a donne un comportement que j'ai essay\u00e9 d'illustrer comme ceci\u00a0:"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["![](media/game.png)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["##### Remarque concernant les notebooks et le clavier"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 20, "lines": ["Lorsqu'on ex\u00e9cute du code python dans un notebook, les entr\u00e9es clavier sont en fait intercept\u00e9es par le browser web; du coup on ne peut pas facilement (du tout?) faire tourner dans un notebook un programme asynchrone qui r\u00e9agirait aussi aux \u00e9v\u00e9nements de type entr\u00e9e clavier.\n", "\n", "C'est pour cette raison que le clavier appara\u00eet sur ma figure en filigrane. Si vous allez jusqu'\u00e0 ex\u00e9cuter ce notebook localement sur votre machine (voir plus bas), vous pourrez utiliser le clavier pour ajouter \u00e0 la vol\u00e9e des \u00e9l\u00e9ments dans le sc\u00e9nario - en entrant des num\u00e9ros de 1 \u00e0 4 au moment voulu. "]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["##### Terminaison"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Pour rester simple et en l'absence de clavier, j'ai choisi de terminer le programme lorsque le dernier sous-processus se termine."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### Le programme `game.py`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["C'est ce notebook qui va jouer pour nous le r\u00f4le du programme `game.py`."]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["import asyncio\n", "import sys"]}, {"block": 16, "type": "code", "linesLength": 4, "startIndex": 29, "lines": ["# cette constante est utile pour d\u00e9clarer qu'on a l'intention\n", "# de lire les sorties (stout et stderr)\n", "# de nos sous-process par l'interm\u00e9diaire de pipes\n", "from subprocess import PIPE"]}, {"block": 17, "type": "markdown", "linesLength": 5, "startIndex": 33, "lines": ["Commen\u00e7ons par la classe `Scheduler`; c'est celle qui va se charger de lancer les sous-processes selon un sc\u00e9nario. Pour ne pas se compliquer la vie on choisit de repr\u00e9senter un sc\u00e9nario (un script) comme une liste de tuples de la forme\n", "\n", "`script = [ (secondes, predef), ...]`\n", "\n", "qui signifie de lancer, un d\u00e9lai de `secondes` secondes apr\u00e8s le d\u00e9but du programme, le programme `players.py` dans la configuration `predef` - de 1 \u00e0 4 donc."]}, {"block": 18, "type": "code", "linesLength": 133, "startIndex": 38, "lines": ["class Scheduler:\n", "\n", "    def __init__(self, script):\n", "\n", "        # on trie le script par ordre chonologique\n", "        self.script = list(script)\n", "        self.script.sort(key = lambda time_predef : time_predef[0])\n", "\n", "        # juste pour donner un num\u00e9ro \u00e0 chaque process\n", "        self.counter = 1\n", "        # combien de process sont actifs\n", "        self.running = 0\n", "\n", "    async def run(self):\n", "        \"\"\"\n", "        fait tout le travail, c'est-\u00e0-dire\n", "        * lance tous les sous-process \u00e0 l'heure indiqu\u00e9e\n", "        * et aussi en pr\u00e9ambule, pour le mode avec clavier,\n", "          arme une callback sur l'entr\u00e9e standard \n", "        \"\"\"\n", "        # pour le mode avec clavier (pas fonctionnel dans le notebook)\n", "        # on arme une callback sur stdin\n", "        asyncio.get_event_loop().add_reader(\n", "            # il nous faut un file descriptor, pas un objet python\n", "            sys.stdin.fileno(),\n", "            # la callback\n", "            Scheduler.read_keyboard_line,\n", "            # les arguments de la callback\n", "            # cette fois c'est un objet python\n", "            self, sys.stdin\n", "        )\n", "        # le sc\u00e9nario pr\u00e9d\u00e9fini\n", "        epoch = 0\n", "        for tick, predef in self.script:\n", "            # attendre le bon moment\n", "            await asyncio.sleep(tick - epoch)\n", "            # pour le prochain\n", "            epoch = tick\n", "            asyncio.ensure_future(self.fork_players(predef))\n", "\n", "    async def fork_players(self, predef):\n", "        \"\"\"\n", "        lance maintenant une instance de players avec cette config\n", "\n", "        puis\n", "        \u00e9coute \u00e0 la fois sdtout et stderr, et les imprime \n", "        (bon c'est vrai que players n'\u00e9crit rien sur stderr)\n", "        attend la fin du sous-process (avec wait())\n", "        et retourne son code de retour (exitcode) du sous-process\n", "\n", "        par commodit\u00e9 on d\u00e9cide d'arr\u00eater la boucle principale \n", "        lorsqu'il n'y a plus aucun process actif\n", "        \"\"\"\n", "\n", "        # la commande \u00e0 lancer pour forker une instance de players.py\n", "        command = f\"python3 -u data/players.py {predef}\".split()\n", "        # pour afficher un nom un peu plus parlant\n", "        worker = f\"ps#{self.counter} (predef {predef})\"\n", "        # housekeeping\n", "        self.counter += 1\n", "        self.running += 1\n", "        # c'est l\u00e0 que \u00e7a se passe : on forke\n", "        print(8 * '>', f\"worker {worker}\")\n", "        process = await asyncio.create_subprocess_exec(\n", "            *command,\n", "            stdout=PIPE, stderr=PIPE,\n", "        )\n", "        # et on lit et \u00e9crit les canaux du sous-process\n", "        stdout, stderr = await asyncio.gather(\n", "            self.read_and_display(process.stdout, worker),\n", "            self.read_and_display(process.stderr, worker))\n", "        # qu'il ne faut pas oublier d'attendre pour que l'OS sache\n", "        # qu'il peut nettoyer\n", "        retcod = await process.wait()\n", "        # le process est termin\u00e9\n", "        self.running -= 1\n", "        print(8 * '<', f\"worker {worker} - exit code {retcod}\"\n", "              f\" - {self.running} still running\")\n", "        # si c'\u00e9tait le dernier on sort de la boucle principale\n", "        if self.running == 0:\n", "            print(\"no process left - bye\")\n", "            asyncio.get_event_loop().stop()\n", "        # sinon on retourne le code de retour\n", "        return retcod\n", "                    \n", "    async def read_and_display(self, stream, worker):\n", "        \"\"\"\n", "        une coroutine pour afficher les sorties d'un canal \n", "        stdout ou stderr d'un sous-process\n", "        retourne lorsque le process est termin\u00e9\n", "        \"\"\"\n", "        while True:\n", "            bytes = await stream.readline()\n", "            # l'OS nous signale qu'on en a termin\u00e9 \n", "            # avec ce process en renvoyant ici un objet bytes vide\n", "            if not bytes:\n", "                break\n", "            # ici on se contente d'imprimer, du coup\n", "            # il faut convertir en str (bien qu'ici \n", "            # players n'\u00e9crit que de l'ASCII)\n", "            line = bytes.decode().strip()\n", "            print(8 * ' ', f\"got `{line}` from {worker}\")\n", "    \n", "    # ceci est seulement fonctionnel si vous ex\u00e9cutez \n", "    # le programme localement sur votre ordinateur\n", "    # car depuis un notebook le clavier est intercept\u00e9\n", "    # par le serveur web\n", "    def read_keyboard_line(self, stdin):\n", "        \"\"\"\n", "        ceci est une callback; eh oui :)\n", "        c'est pourquoi d'ailleurs ce n'est pas une coroutine\n", "        cependant on est s\u00fbr qu'elle n'est appel\u00e9e \n", "        que lorsqu'il y a r\u00e9ellement quelque chose \u00e0 lire\n", "        \"\"\"\n", "        line = stdin.readline().strip()\n", "        # ici je triche compl\u00e8tement\n", "        # lorsqu'on est dans un notebook, pour bien faire\n", "        # on ne devrait pas regarder stdin du tout\n", "        # mais pour garder le code le plus simple possible\n", "        # je choisis d'ignorer les lignes vides ici\n", "        # comme \u00e7a mon code marche dans les deux cas\n", "        if not line:\n", "            return\n", "        # on traduit la ligne tap\u00e9e au clavier \n", "        # en un entier entre 1 et 4\n", "        try:\n", "            predef = int(line)\n", "            if not (1 <= predef <= 4):\n", "                raise ValueError('entre 1 et 4')\n", "        except Exception as e:\n", "            print(f\"{line} doit \u00eatre entre 1 et 4 {type(e)} - {e}\")\n", "            return\n", "        asyncio.ensure_future(self.fork_players(predef))"]}, {"block": 19, "type": "markdown", "linesLength": 2, "startIndex": 171, "lines": ["\n", "\u00c0 ce stade on a d\u00e9j\u00e0 le c\u0153ur de la logique du *scheduler*, et aussi du multiplexer. Il ne nous manque plus que l'horloge\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 10, "startIndex": 173, "lines": ["class Clock:\n", "\n", "    def __init__(self):\n", "        self.clock_seconds = 0\n", "\n", "    async def run(self):\n", "        while True:\n", "            print(f\"clock = {self.clock_seconds:04d}s\")\n", "            await asyncio.sleep(1)\n", "            self.clock_seconds += 1"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 183, "lines": ["Et enfin pour mettre tous ces morceaux en route il nous faut une boucle d'\u00e9v\u00e9nements : "]}, {"block": 22, "type": "code", "linesLength": 14, "startIndex": 184, "lines": ["class Game:\n", "\n", "    def __init__(self, script):\n", "        self.script = script\n", "\n", "    def mainloop(self):\n", "        loop = asyncio.get_event_loop()\n", "\n", "        clock = Clock()\n", "        asyncio.ensure_future(clock.run())\n", "\n", "        scheduler = Scheduler(self.script)\n", "        asyncio.ensure_future(scheduler.run())\n", "        loop.run_forever()"]}, {"block": 23, "type": "markdown", "linesLength": 4, "startIndex": 198, "lines": ["Et maintenant je peux lancer une session simple; pour ne pas \u00eatre noy\u00e9 par les sorties on va se contenter de lancer\u00a0:\n", "\n", "* 0.5 seconde apr\u00e8s le d\u00e9but une instance de `players.py 1`\n", "* 1 seconde apr\u00e8s le d\u00e9but une instance de `players.py 2`"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 202, "lines": ["game = Game( [(0.5, 1), (1., 2)])\n", "game.mainloop()"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 204, "lines": ["### Conclusion"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 205, "lines": ["Notre but avec cet exemple est de vous montrer, apr\u00e8s les exemples des vid\u00e9os qui reposent en grande majorit\u00e9 sur `asyncio.sleep`, que la boucle d'\u00e9v\u00e9nements de `asyncio` permet d'avoir acc\u00e8s, de mani\u00e8re simple et efficace, \u00e0 des \u00e9v\u00e9nements de niveau OS. Dans un compl\u00e9ment pr\u00e9c\u00e9dent nous avions aper\u00e7u la gestion de requ\u00eates HTTP ; ici nous avons illustr\u00e9 la gestion de sous-process. \n", "\n", "Actuellement on peut trouver des biblioth\u00e8ques au dessus de `asyncio` pour manipuler de cette fa\u00e7on quasiment tous les protocoles r\u00e9seau, et autres acc\u00e8s \u00e0 des bases de donn\u00e9es."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 208, "lines": ["### Ex\u00e9cution en local"]}, {"block": 28, "type": "markdown", "linesLength": 10, "startIndex": 209, "lines": ["Si vous voulez ex\u00e9cuter ce code localement sur votre machine : \n", "\n", "Tout d'abord sachez que je n'ai pas du tout essay\u00e9 ceci sur un OS Windows - et d'ailleurs \u00e7a m'int\u00e9resserait assez de savoir si \u00e7a fonctionne ou pas.\n", "\n", "Cela \u00e9tant dit, il vous suffit alors de t\u00e9l\u00e9charger le pr\u00e9sent notebook au format python. Vous aurez aussi besoin\u00a0:\n", "\n", "* [du code de `players.py`](data/players.py), \u00e9videmment; \n", "* et de modifier le fichier t\u00e9l\u00e9charg\u00e9 pour lancer `players.py` au lieu de `data/players.py`, qui ne fait de sens probablement que sur le serveur de notebooks.\n", "\n", "Comme on l'a indiqu\u00e9 plus haut, si vous l'ex\u00e9cutez en local vous pourrez cette fois interagir aussi via la clavier, et ajouter \u00e0 la vol\u00e9e des sous-process qui n'\u00e9taient pas pr\u00e9vus initialement dans le sc\u00e9nario."]}, {"block": 29, "type": "markdown", "linesLength": 5, "startIndex": 219, "lines": ["# Pour aller plus loin\n", "\n", "Je vous signale enfin, si vous \u00eates int\u00e9ress\u00e9s \u00e0 creuser encore davantage, [ce tutorial int\u00e9ressant qui impl\u00e9mente un jeu complet](https://7webpages.com/blog/writing-online-multiplayer-game-with-python-asyncio-getting-asynchronous/).\n", "\n", "Naturellement ce tutorial est lui bas\u00e9 sur du code r\u00e9seau et non, comme nous y sommes contraints, sur une architecture de type sous-process; [le jeu en question est m\u00eame en ligne ici](http://snakepit-game.com/)..."]}]
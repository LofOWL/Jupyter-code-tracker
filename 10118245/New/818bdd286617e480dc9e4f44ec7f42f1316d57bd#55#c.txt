[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Passage d'arguments par r\u00e9f\u00e9rence"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Entre le code qui appelle une fonction, et le code de la fonction elle-m\u00eame:"]}, {"block": 4, "type": "code", "linesLength": 5, "startIndex": 4, "lines": ["def ma_fonction(dans_fonction):\n", "    print(dans_fonction)\n", "    \n", "dans_appelant = [ \"texte\" ]\n", "ma_fonction(dans_appelant)"]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 9, "lines": ["on peut se demander quelle est exactement la nature de la relation entre l'appelant et l'appel\u00e9, c'est-\u00e0-dire ici `dans_appelant` et `dans_fonction`. \n", "\n", "C'est l'objet de ce compl\u00e9ment."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["### Passage par valeur - passage par r\u00e9f\u00e9rence "]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 13, "lines": ["Si vous avez appris d'autres langages de programmation comme C ou C++, on a pu vous parler de deux modes de passage de param\u00e8tres:\n", " * par valeur: cela signifie qu'on communique \u00e0 la fonction, non pas l'entit\u00e9 dans l'appelant, mais seulement **sa valeur**; en clair, **une copie**;\n", " * par r\u00e9f\u00e9rence: cela signifie qu'on passe \u00e0 la fonction une **r\u00e9f\u00e9rence** \u00e0 l'argument dans l'appelant, donc essentiellement les deux codes **partagent** la m\u00eame m\u00e9moire."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["### python fait du passage par r\u00e9f\u00e9rence"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Certains langages comme Pascal - et C++ si on veut - proposent ces deux modes. En python, tous les passages de param\u00e8tres se font **par r\u00e9f\u00e9rence**."]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 18, "lines": ["# chargeons la magie pour pythontutor\n", "%load_ext ipythontutor"]}, {"block": 11, "type": "code", "linesLength": 6, "startIndex": 20, "lines": ["%%ipythontutor curInstr=4\n", "def ma_fonction(dans_fonction):\n", "    print(dans_fonction)\n", "    \n", "dans_appelant = [ \"texte\" ]\n", "ma_fonction(dans_appelant)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Ce qui signifie qu'on peut voir le code ci-dessus comme \u00e9tant - pour simplifier - \u00e9quivalent \u00e0 ceci:"]}, {"block": 13, "type": "code", "linesLength": 6, "startIndex": 27, "lines": ["dans_appelant = [ \"texte\" ]\n", "\n", "# ma_fonction (dans_appelant)\n", "# \u2192 on entre dans la fonction\n", "dans_fonction = dans_appelant\n", "print(dans_fonction)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["On peut le voir encore d'une autre fa\u00e7on en instrumentant le code comme ceci - on rappelle que la fonction built-in `id` retourne l'adresse m\u00e9moire d'un objet:"]}, {"block": 15, "type": "code", "linesLength": 6, "startIndex": 34, "lines": ["def ma_fonction(dans_fonction):\n", "    print('dans ma_fonction', dans_fonction , id(dans_fonction))\n", "    \n", "dans_appelant = [ \"texte\" ]\n", "print('dans appelant   ', dans_appelant, id(dans_appelant))\n", "ma_fonction(dans_appelant)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["### Des r\u00e9f\u00e9rences partag\u00e9es"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["On voit donc que l'appel de fonction cr\u00e9e des r\u00e9f\u00e9rences partag\u00e9es, exactement comme l'affectation, et que tout ce que nous avons vu au sujet des r\u00e9f\u00e9rences partag\u00e9es s'applique exactement \u00e0 l'identique:"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 42, "lines": ["# on ne peut pas modifier un immuable dans une fonction\n", "def increment(n):\n", "    n += 1\n", "\n", "compteur = 10\n", "increment(compteur)\n", "print(compteur)"]}, {"block": 19, "type": "code", "linesLength": 7, "startIndex": 49, "lines": ["# on peut par contre ajouter dans une liste\n", "def insert(liste, valeur):\n", "    liste.append(valeur)\n", "    \n", "liste = [ \"un\" ]\n", "insert(liste, \"texte\")\n", "print(liste)"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 56, "lines": ["Pour cette raison, il est important de bien pr\u00e9ciser, quand vous documentez une fonction, si elle fait des effets de bord sur ses arguments (c'est-\u00e0-dire qu'elle modifie ses arguments), ou si elle produit une copie. Rappelez-vous par exemple le cas de la m\u00e9thode `sort` sur les listes, et de la fonction de commodit\u00e9 `sorted`, que nous avions vues en semaine 2.\n", "\n", "De cette fa\u00e7on, on saura s'il faut ou non copier l'argument avant de le passer \u00e0 votre fonction."]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Cl\u00e9s immuables"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9daire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Nous avons vu comment manipuler un dictionnaire, il nous reste \u00e0 voir un peu plus en d\u00e9tail les contraintes qui sont mises par le langage sur ce qui peut servir de cl\u00e9 dans un dictionnaire. On parle dans ce compl\u00e9ment sp\u00e9cifiquement des clefs contruites \u00e0 partir des types `builtin`. Le cas de vos propres classes utilis\u00e9es comme clefs de dictionnaires n'est pas abord\u00e9 dans ce compl\u00e9ment."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Une cl\u00e9 doit \u00eatre immuable"]}, {"block": 5, "type": "markdown", "linesLength": 9, "startIndex": 9, "lines": ["Si vous vous souvenez de la vid\u00e9o sur les tables de hash, la m\u00e9canique interne du dictionnaire repose sur le calcul, \u00e0 partir de chaque cl\u00e9, d'une fonction de hachage.\n", "\n", "C'est-\u00e0-dire que pour simplifier, on localise la pr\u00e9sence d'une cl\u00e9 en calculant d'abord\n", "\n", "$ f ( cl\u00e9 )  = hash  $\n", "\n", "puis on poursuit la recherche en utilisant $hash$ comme indice dans le tableau contenant les couples (cl\u00e9, valeur).\n", "\n", "On le rappelle, c'est cette astuce qui permet de r\u00e9aliser les op\u00e9rations sur les dictionnaires en temps constant - c'est-\u00e0-dire ind\u00e9pendamment du nombre d'\u00e9l\u00e9ments."]}, {"block": 6, "type": "markdown", "linesLength": 6, "startIndex": 18, "lines": ["Cependant, pour que ce m\u00e9canisme fonctionne, il est indispensable que **la valeur de la cl\u00e9 reste inchang\u00e9e** pendant la dur\u00e9e de vie du dictionnaire. Sinon, bien entendu, on pourrait avoir le sc\u00e9nario suivant:\n", " * on range un tuple `(clef, valeur)` \u00e0 un premier indice $f(clef) = hash_1 $\n", " * on modifie la valeur de $clef$ qui devient $clef'$\n", " * on recherche notre valeur \u00e0 l'indice $f(clef')  = hash_2 \\neq hash_1$\n", "\n", "et donc avec ces hypoth\u00e8ses on n'a plus la garantie de bon fonctionnement de la logique."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["### Une cl\u00e9 doit \u00eatre globalement immuable"]}, {"block": 8, "type": "markdown", "linesLength": 11, "startIndex": 25, "lines": ["Nous avons depuis le d\u00e9but du cours longuement insist\u00e9 sur le caract\u00e8re mutable ou immuable des diff\u00e9rents types pr\u00e9d\u00e9finis de python. Vous devez donc \u00e0 pr\u00e9sent avoir au moins en partie ce tableau en t\u00eate:\n", "\n", "| Type | Mutable ? |\n", "|------|-----------|\n", "| `int`, `float` | immuable |\n", "|`complex`,`bool` | immuable |\n", "|`str` | immuable |\n", "|`list` | mutable |\n", "|`dict` | mutable |\n", "|`set` | mutable |\n", "|`frozenset` | immuable |"]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["Le point important ici, est qu'il **ne suffit pas**, pour une cl\u00e9, d'\u00eatre **de type immuable**.\n", "\n", "On peut le voir sur un exemple tr\u00e8s simple; donnons nous donc un dictionnaire"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 39, "lines": ["d = {}"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["Et commen\u00e7ons avec un objet de type immuable, un tuple d'entiers"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 41, "lines": ["bonne_cle = (1, 2)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Cet objet est non seulement **de type immuable**, mais tous ses composants et sous-composants sont **immuables**, on peut donc l'utiliser comme cl\u00e9 dans le dictionnaire"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["d[bonne_cle] = \"pas de probleme ici\"\n", "print(d)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Si \u00e0 pr\u00e9sent on essaie d'utiliser comme cl\u00e9 un tuple qui contient une liste:"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["mauvaise_cle = (1, [1, 2])"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Il se trouve que cette cl\u00e9, **bien que de type immuable**, peut \u00eatre **indirectement modifi\u00e9e** puisque:"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 48, "lines": ["mauvaise_cle[1].append(3)\n", "print(mauvaise_cle)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Et c'est pourquoi on ne peut pas utiliser cet objet comme cl\u00e9 dans le dictionnaire"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 51, "lines": ["# provoque une exception\n", "d[mauvaise_cle] = 'on ne peut pas faire ceci'"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Pour conclure, il faut retenir qu'un objet n'est \u00e9ligible pour \u00eatre utilis\u00e9 comme cl\u00e9 que s'il est **compos\u00e9 de types immuables du haut en bas** de la structure de donn\u00e9es."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["La raison d'\u00eatre principale du type `tuple`, que nous avons vu la semaine pass\u00e9e, et du type `frozenset`, que nous verrons tr\u00e8s prochainement, est pr\u00e9cis\u00e9ment de construire de tels objets globalement immuables."]}, {"block": 23, "type": "markdown", "linesLength": 3, "startIndex": 55, "lines": ["### \u00c9pilogue\n", "\n", "Tout ceci est valable pour les types *builtin*. Nous verrons que pour les types d\u00e9finis par l'utilisateur - les classes donc - que nous effleurons \u00e0 la fin de cette semaine et que nous \u00e9tudions plus en profondeur en semaine 6, c'est un autre m\u00e9canisme qui est utilis\u00e9 pour calculer la cl\u00e9 de hachage d'une instance de classe."]}]
[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Attributs de classe et attributs d'instance"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 2, "type": "markdown", "linesLength": 5, "startIndex": 2, "lines": ["Nous avons vu jusqu'\u00e0 pr\u00e9sent que l'on peut ajouter des attributs \u00e0 toutes sortes d'objets en python, et notamment \u00e0\n", " * un module,\n", " * une fonction,\n", " * une classe,\n", " * une instance de classe."]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 7, "lines": ["En particulier nous avons vu que, **en r\u00e8gle g\u00e9n\u00e9rale** : \n", " * une *m\u00e9thode* est un *attribut de classe*,\n", " * et que les *donn\u00e9es* qui d\u00e9crivent l'objet sont rang\u00e9es dans des *attributs de l'instance*."]}, {"block": 4, "type": "heading", "linesLength": 1, "startIndex": 10, "lines": ["Propos de ce compl\u00e9ment"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 11, "lines": ["Dans ce compl\u00e9ment, nous allons approfondir les notions d'attributs de classe et d'attributs d'instance. Nous allons tout d'abord voir qu'un attribut est cherch\u00e9 **en premier dans l'instance puis dans la classe**. Ce faisant nous verrons que le langage permet \u00e9galement :\n", " * d'attacher des *donn\u00e9es \u00e0 une classe* - pour d\u00e9finir une valeur par d\u00e9faut valable pour toutes les instances de la classe, ou de\n", " * *d\u00e9finir une m\u00e9thode sur une instance* - pour sp\u00e9cialiser un comportement pour un seul objet, et ainsi \u00e9viter de d\u00e9finir une nouvelle classe pour un seul objet. \n", " \n", "Nous d\u00e9montrons ce dernier point, rare en pratique, dans la derni\u00e8re partie de ce compl\u00e9ment qui est de niveau avanc\u00e9e."]}, {"block": 6, "type": "heading", "linesLength": 1, "startIndex": 16, "lines": ["Un attribut de donn\u00e9e d\u00e9fini sur la classe"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Voyons pour commencer un exemple de classe avec un attribut de donn\u00e9es qui est en fait un attribut qui r\u00e9f\u00e9rence un objet `builtin` contenant des donn\u00e9es, comme par exemple `int`, `list` ou `str`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Naturellement, on aurait pu aussi d\u00e9finir des m\u00e9thodes dans cette classe, mais nous avons choisi de montrer le plus petit exemple possible."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["La classe `Spam` poss\u00e8de donc maintenant l'attribut `attribut` qui vaut"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Cr\u00e9ons \u00e0 pr\u00e9sent une instance de cette classe :"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["On peut naturellement attacher \u00e0 cette instance un attribut `attribut`, comme on l'a d\u00e9j\u00e0 vu :"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Le point important de ce compl\u00e9ment, c'est qu'une **instance** \u00e0 laquelle on n'a pourtant pas attach\u00e9 d'attribut `attribut` peut tout de m\u00eame **r\u00e9f\u00e9rencer** cet attribut et **trouver celui de la classe** comme si c'\u00e9tait le sien:"]}, {"block": 13, "type": "heading", "linesLength": 1, "startIndex": 23, "lines": ["Discussion"]}, {"block": 14, "type": "markdown", "linesLength": 7, "startIndex": 24, "lines": ["En fait, on a d\u00e9j\u00e0 vu ce m\u00e9canisme en action; c'est exactement la m\u00eame chose qui se passe lorsqu'on a :\n", " * une classe qui d\u00e9finit la m\u00e9thode `foo`\n", " * et une instance `obj` de la classe sur laquelle on appelle la m\u00e9thode en faisant\n", " \n", "    obj.foo()\n", "\n", "Le m\u00e9canisme de recherche d'un attribut sur une instance est le m\u00eame, que cet attribut repr\u00e9sente une m\u00e9thode ou une donn\u00e9e. En effet, en python tout est un objet et un attribut peut r\u00e9f\u00e9rencer n'importer quel objet. \u00c7a n'est que lorsque l'interpr\u00e9teur python acc\u00e8de \u00e0 l'objet qu'il peut finalement conna\u00eetre son type. "]}, {"block": 15, "type": "heading", "linesLength": 1, "startIndex": 31, "lines": ["Conclusion"]}, {"block": 16, "type": "markdown", "linesLength": 7, "startIndex": 32, "lines": ["Comme on l'a vu, le m\u00e9canisme d'attributs, bien qu'extr\u00eamement simple, est tr\u00e8s souple et tr\u00e8s puissant. \n", "\n", "Le langage ne fait pas de diff\u00e9rence entre attributs de donn\u00e9es et de m\u00e9thodes puisqu'un attribut r\u00e9f\u00e9rence n'importe quel objet et qu'en python tout est en objet, donc en particulier les donn\u00e9es et les m\u00e9thodes. \n", "\n", "On peut attacher, au choix, **\u00e0 une instance ou \u00e0 une classe**, des attributs repr\u00e9sentant **n'importe quel objet**, et la recherche de ces attributs se fait dans l'ordre **instance** puis **classe**.\n", "\n", "Nous verrons dans la prochaine vid\u00e9o que les m\u00e9canismes d'h\u00e9ritage ne font que prolonger ce m\u00e9canisme de recherche d'attributs."]}, {"block": 17, "type": "heading", "linesLength": 1, "startIndex": 39, "lines": ["Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 18, "type": "heading", "linesLength": 1, "startIndex": 40, "lines": ["Un attribut de m\u00e9thode d\u00e9fini sur une instance"]}, {"block": 19, "type": "markdown", "linesLength": 3, "startIndex": 41, "lines": ["D\u00e9finir un attribut de donn\u00e9es dans une classe, comme on vient de le voir, pr\u00e9sente un int\u00e9r\u00eat pratique; il est parfois commode de d\u00e9finir une constante, ou une valeur par d\u00e9faut, au niveau de la classe, qui s'applique alors \u00e0 tous les objets.\n", "\n", "Nous allons \u00e0 pr\u00e9sent illustrer la possibilit\u00e9 de d\u00e9finir une m\u00e9thode au niveau d'une instance. Comme ceci est rare en pratique, il s'agit ici de bien comprendre les m\u00e9canismes du langage plut\u00f4t que de d\u00e9couvrir une technique de programmation. Pour cela nous prenons \u00e0 nouveau une classe jouet."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["Et nous cr\u00e9ons \u00e0 nouveau deux instances, une qui va se comporter comme la classe, et une qui aura un comportement sp\u00e9cial"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["On va maintenant attacher \u00e0 la classe une m\u00e9thode `__repr__` pour red\u00e9finir comment imprimer les objets de la classe `Eggs`"]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 46, "lines": ["Jusqu'ici rien de nouveau. \n", "\n", "Nous allons maintenant attacher une m\u00e9thode `__repr__` **\u00e0 une instance** en propre. C'est ici que les choses se compliquent un tout petit peu. Nous avons deux choix pour cela. "]}, {"block": 23, "type": "heading", "linesLength": 1, "startIndex": 49, "lines": ["Premi\u00e8re technique"]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 50, "lines": ["La premi\u00e8re technique consiste \u00e0 d\u00e9finir une fonction **sans argument**. C'est surprenant car nous avons vu jusqu'ici que `__repr__` s'attend \u00e0 recevoir **un argument**.\n", " \n", "Voyons d'abord le code "]}, {"block": 25, "type": "markdown", "linesLength": 5, "startIndex": 53, "lines": ["Avant d'aller plus loin, souvenez-vous qu'avant de parler de classes on a parl\u00e9 de fonctions; on pourrait tr\u00e8s bien avoir envie de ranger dans un attribut une vraie fonction et de pouvoir l'appeler comme une fonction, mais pas comme une m\u00e9thode, c'est-\u00e0-dire sans mettre en \u0153uvre la *magie* qui consiste \u00e0 mettre l'objet lui-m\u00eame comme premier argument.\n", "\n", "Il faut donc pouvoir diff\u00e9rencier entre ces deux cas, selon que l'on veut ou non ajouter l'instance comme premier objet de l'appel qui est fait lorsqu'on \u00e9crit `obj.foo()`.\n", "\n", "C'est exactement ce qui se passe ici: la fonction que nous avons attach\u00e9e \u00e0 l'instance n'est pas de m\u00eame nature que celle attach\u00e9e \u00e0 la classe; voyons ces deux objets :"]}, {"block": 26, "type": "markdown", "linesLength": 3, "startIndex": 58, "lines": ["On voit que sur la classe, l'attribut `__repr__` est un objet de type `unbound method`, alors que sur l'instance c'est un objet de type `function` tout b\u00eate.\n", "\n", "Et c'est sur cette diff\u00e9rence que se base l'interpr\u00e9teur pour ajouter, ou non, l'objet en premier argument de l'appel."]}, {"block": 27, "type": "heading", "linesLength": 1, "startIndex": 61, "lines": ["Deuxi\u00e8me technique"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Si on veut se mettre dans un cadre plus conforme \u00e0 ce qui est habituel, il faut dire explicitement que la fonction est en fait une m\u00e9thode de l'instance. On commence par \u00e9crire une fonction qui prend bien **un argument** :"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["Mais au lieu de l'attacher telle quelle on la convertit en m\u00e9thode en d\u00e9finissant un nouvel objet de type `MethodType` :"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["apr\u00e8s quoi on verra cet objet s'afficher diff\u00e9remment des autres"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Et la valeur de l'attribut `__repr__` est bien maintenant vue comme une m\u00e9thode et non comme une fonction :"]}, {"block": 32, "type": "heading", "linesLength": 1, "startIndex": 66, "lines": ["Pour en savoir plus"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["Ce sujet est discut\u00e9 plus en profondeur dans [cet article de stackoverflow](http://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object)"]}]
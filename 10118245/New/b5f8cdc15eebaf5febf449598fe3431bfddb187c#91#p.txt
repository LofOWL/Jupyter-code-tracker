[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Introduction aux classes"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["On d\u00e9finit une classe lorsqu'on a besoin de cr\u00e9er un type sp\u00e9cifique au contexte de l'application. Il faut donc voir une classe au m\u00eame niveau qu'un type *builtin* comme `list` ou `dict`. "]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Un exemple simpliste"]}, {"block": 5, "type": "markdown", "linesLength": 8, "startIndex": 5, "lines": ["Par exemple, imaginons qu'on a besoin de manipuler des matrices $2\\times 2$\n", "\n", "$A = \\left( \\begin{array}{cc} a_{11} & a_{12} \\\\\n", "a_{21} & a_{22}\\end{array} \\right)$\n", "\n", "Et en guise d'illustration, nous allons utiliser le d\u00e9terminant; c'est juste un pr\u00e9texte pour impl\u00e9menter une m\u00e9thode sur cette classe, ne vous inqui\u00e9tez pas si le terme ne vous dit rien, ou vous rappelle de mauvais souvenirs. Tout ce qu'on a besoin de savoir c'est que, sur une matrice de ce type, le d\u00e9terminant vaut\n", "\n", "$ det (A) = a_{11}.a_{22} - a_{12}.a_{21}$"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Dans la pratique, on utiliserait la classe `matrix` de [`numpy`](http://www.numpy.org/) qui est une librairie de calcul scientifique tr\u00e8s populaire et largement utilis\u00e9e. Mais comme premier exemple de classe, nous allons \u00e9crire **notre propre classe `Matrix2`** pour voir les m\u00e9canismes de base des classes de python en action. Naturellement, il s'agit d'une  impl\u00e9mentation jouet."]}, {"block": 7, "type": "code", "linesLength": 13, "startIndex": 14, "lines": ["class Matrix2:\n", "    \"Une impl\u00e9mentation sommaire de matrice carr\u00e9e 2x2\"\n", "\n", "    def __init__(self, a11, a12, a21, a22):\n", "        \"construit une matrice \u00e0 partir des 4 coefficients\"\n", "        self.a11 = a11\n", "        self.a12 = a12\n", "        self.a21 = a21\n", "        self.a22 = a22\n", "        \n", "    def determinant(self):\n", "        \"renvoie le d\u00e9terminant de la matrice\"\n", "        return self.a11 * self.a22 - self.a12 * self.a21"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### La premi\u00e8re version de `Matrix2`"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["##### Une classe peut avoir un *docstring*"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Pour commencer, vous remarquez qu'on peut attacher \u00e0 cette classe un *docstring* comme pour les fonctions"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["help(Matrix2)"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["La classe d\u00e9finit donc deux m\u00e9thodes, nomm\u00e9es `__init__` et `determinant`. "]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["##### La m\u00e9thode `__init__`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["La m\u00e9thode **`__init__`**, comme toutes celles qui ont un nom en `__`*nom*`__`, est une **m\u00e9thode sp\u00e9ciale**. En l'occurrence, il s'agit de ce qu'on appelle le **constructeur** de la classe, c'est-\u00e0-dire le code qui va \u00eatre appel\u00e9 lorsqu'on cr\u00e9e une instance. Voyons cela tout de suite sur un exemple."]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["matrice = Matrix2(1, 2, 2, 1)\n", "print(matrice)"]}, {"block": 16, "type": "markdown", "linesLength": 5, "startIndex": 36, "lines": ["Vous remarquez tout d'abord que `__init__` s'attend \u00e0 recevoir *5 arguments*, mais que nous appelons `Matrix2` avec seulement *4 arguments*. \n", "\n", "L'argument surnum\u00e9raire, le **premier** de ceux qui sont d\u00e9clar\u00e9s dans la m\u00e9thode, correspond \u00e0 l'**instance qui vient d'\u00eatre cr\u00e9\u00e9e** et qui est automatiquement pass\u00e9e par l'interpr\u00e9teur python \u00e0 la m\u00e9thode `__init__`. En ce sens, le terme constructeur est impropre puisque la m\u00e9thode `__init__` ne cr\u00e9e pas l'instance, elle ne fait que l'initialiser. Nous reviendrons sur le processus de cr\u00e9ation des objets lorsque nous parlerons des m\u00e9taclasses en derni\u00e8re semaine. \n", "\n", "La **convention** est de nommer le premier argument de ce constructeur **`self`**, nous y reviendrons un peu plus loin."]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 41, "lines": ["On voit \u00e9galement que le constructeur se contente de m\u00e9moriser, \u00e0 l'int\u00e9rieur de l'instance, les arguments qu'on lui passe, sous la forme d'**attributs** de l'**instance** `self`. \n", "\n", "C'est un cas extr\u00eamement fr\u00e9quent; de mani\u00e8re g\u00e9n\u00e9rale, il est recommand\u00e9 d'\u00e9crire des constructeurs passifs de ce genre; dit autrement, on \u00e9vite de faire trop de traitements dans le constructeur. "]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["##### La m\u00e9thode `determinant`"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["La classe d\u00e9finit aussi la m\u00e9thode `determinant`, qu'on utiliserait comme ceci"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 46, "lines": ["print(\"Determinant =\", matrice.determinant())"]}, {"block": 21, "type": "markdown", "linesLength": 2, "startIndex": 47, "lines": ["Vous voyez que la **syntaxe** pour appeler une m\u00e9thode sur un objet est **identique** \u00e0 celle que nous avons utilis\u00e9e jusqu'ici avec **les types de base**.\n", "Nous verrons dans quelques s\u00e9quences comment on peut pousser beaucoup plus loin la similitude, pour pouvoir par exemple calculer la **somme** de deux objets de la classe `Matrix2` avec l'op\u00e9rateur `+`, mais n'anticipons pas."]}, {"block": 22, "type": "markdown", "linesLength": 3, "startIndex": 49, "lines": ["Vous voyez aussi que, ici encore, la m\u00e9thode d\u00e9finie dans la classe attend  ***1 argument* `self`**, alors qu'apparemment nous ne lui en passons **aucun**. Comme tout \u00e0 l'heure avec le constructeur, le premier argument pass\u00e9 automatiquement par l'interpr\u00e9teur python \u00e0 `determinant` est l'objet `matrice` lui-m\u00eame.\n", "\n", "En fait on aurait pu aussi bien \u00e9crire, de mani\u00e8re parfaitement \u00e9quivalente"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 52, "lines": ["print(\"Determinant =\", Matrix2.determinant(matrice))"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["qui n'est presque jamais utilis\u00e9 en pratique, mais qui illustre bien ce qui se passe lorsqu'on invoque une m\u00e9thode sur un objet. En r\u00e9alit\u00e9, lorsque l'on \u00e9crit `matrice.determinant()` l'interpr\u00e9teur python va essentiellement convertir cette expression en `Matrix2.determinant(matrice)`."]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["### \u00c0 quoi \u00e7a sert ?"]}, {"block": 27, "type": "markdown", "linesLength": 5, "startIndex": 56, "lines": ["Ce cours n'est pas consacr\u00e9 \u00e0 la Programmation Orient\u00e9e Objet (OOP) en tant que telle. Voici toutefois quelques-uns des avantages qui sont g\u00e9n\u00e9ralement mis en avant.\n", "\n", " * Encapsulation\n", " * R\u00e9solution dynamique de m\u00e9thode\n", " * H\u00e9ritage "]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["##### Encapsulation"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 62, "lines": ["L'id\u00e9e de la notion d'encapsulation consiste \u00e0 ce que:\n", " * une classe d\u00e9finit son **interface**, c'est-\u00e0-dire les m\u00e9thodes par lesquelles on peut utiliser ce code,\n", " * mais reste tout \u00e0 fait libre de modifier son **impl\u00e9mentation**, et tant que cela n'impacte pas l'interface, **aucun changement** n'est requis dans les **codes utilisateurs**."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Nous verrons plus bas une deuxi\u00e8me impl\u00e9mentation de `Matrix2` qui est plus g\u00e9n\u00e9rale que notre premi\u00e8re version, mais qui utilise la m\u00eame interface, donc qui fonctionne exactement de la m\u00eame mani\u00e8re pour le code utilisateur."]}, {"block": 31, "type": "markdown", "linesLength": 12, "startIndex": 66, "lines": ["La notion d'encapsulation peut para\u00eetre \u00e0 premi\u00e8re vue banale; il ne faut pas s'y fier, c'est de cette mani\u00e8re qu'on peut efficacement d\u00e9couper un gros logiciel en petits morceaux ind\u00e9pendants, et r\u00e9ellement d\u00e9coupl\u00e9s les uns des autres, et ainsi g\u00e9rer la complexit\u00e9.\n", "\n", "La programmation objet est une des techniques permettant d'atteindre cette bonne propri\u00e9t\u00e9. Il faut reconna\u00eetre que certains langages comme Java et C++ ont des m\u00e9canismes plus sophistiqu\u00e9s, mais aussi plus complexes, pour garantir une bonne \u00e9tanch\u00e9it\u00e9 entre l'interface publique et les d\u00e9tails d'impl\u00e9mentation. Les choix faits en la mati\u00e8re en python reviennent, une fois encore, \u00e0 privil\u00e9gier la simplicit\u00e9.\n", "\n", "Aussi, il n'existe pas en python l'\u00e9quivalent des notions d'interface `public`, `private` et `protected` qu'on trouve en C++ et en Java. Il existe tout au plus une convention, selon laquelle les attributs commen\u00e7ant par un underscore (le tiret bas `_`) sont priv\u00e9s et ne *devraient* pas \u00eatre utilis\u00e9s par un code tiers, mais le langage ne fait rien pour garantir le bon usage de cette convention. \n", "\n", "Si vous d\u00e9sirez creuser ce point  nous vous conseillons de lire\n", " * [*Reserved classes of identifiers*](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers) o\u00f9 l'on d\u00e9crit \u00e9galement les noms priv\u00e9s \u00e0 une classe (les noms de variables en `__`*nom*), \n", " * [*Private Variables and Class-local References*](https://docs.python.org/3/tutorial/classes.html#tut-private), qui en donne une illustration.\n", "\n", "\n", "Malgr\u00e9 cette simplicit\u00e9 revendiqu\u00e9e, les classes de python permettent d'impl\u00e9menter en pratique une encapsulation tout \u00e0 fait acceptable, on peut en juger rien que par le nombre de librairies tierces existantes dans l'\u00e9cosyst\u00e8me python."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 78, "lines": ["##### R\u00e9solution dynamique de m\u00e9thode"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": ["Le deuxi\u00e8me atout de OOP, c'est le fait que l'envoi de m\u00e9thode est r\u00e9solu \u00e0 *run-time* et non pas \u00e0 *compile-time*. Ceci signifie qu'on peut \u00e9crire du code g\u00e9n\u00e9rique, qui pourra fonctionner avec des objets non connus *a priori*. Nous allons en voir un exemple tout de suite, en red\u00e9finissant le comportement de `print` dans la deuxi\u00e8me impl\u00e9mentation de `Matrix2`."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["##### H\u00e9ritage"]}, {"block": 35, "type": "markdown", "linesLength": 3, "startIndex": 81, "lines": ["L'h\u00e9ritage est le concept qui permet de :\n", " * dupliquer une classe presque \u00e0 l'identique, mais en red\u00e9finissant une ou quelques m\u00e9thodes seulement (h\u00e9ritage simple);\n", " * composer plusieurs classes en une seule, pour r\u00e9aliser en quelque sorte l'union des propri\u00e9t\u00e9s de ces classes (h\u00e9ritage multiple)."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["### Illustration"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["Nous revenons sur l'h\u00e9ritage dans la prochaine vid\u00e9o. Dans l'imm\u00e9diat, nous allons voir une seconde impl\u00e9mentation de la classe `Matrix2`, qui illustre l'encapsulation et l'envoi dynamique de m\u00e9thodes."]}, {"block": 38, "type": "code", "linesLength": 16, "startIndex": 86, "lines": ["class Matrix2:\n", "    \"\"\"Une deuxi\u00e8me impl\u00e9mentation, tout aussi\n", "    sommaire, mais diff\u00e9rente, de matrice carr\u00e9e 2x2\"\"\"\n", "    \n", "    def __init__(self, a11, a12, a21, a22):\n", "        \"construit une matrice \u00e0 partir des 4 coefficients\"\n", "        # on d\u00e9cide d'utiliser un tuple plut\u00f4t qu'une liste\n", "        self.a = (a11, a12, a21, a22)\n", "        \n", "    def determinant(self):\n", "        \"le d\u00e9terminant de la matrice\"\n", "        return self.a[0] * self.a[3] - self.a[1] * self.a[2]\n", "    \n", "    def __repr__(self):\n", "        \"comment pr\u00e9senter une matrice dans un print()\"\n", "        return \"<<mat-2x2 {}>>\".format(self.a)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["Pour une raison ou pour une autre, disons que l'on d\u00e9cide de remplacer les 4 attributs nomm\u00e9s `self.a11`, `self.a12`, etc., qui n'\u00e9taient pas tr\u00e8s extensibles, par un seul attribut `a` qui regroupe tous les coefficients de la matrice dans un seul tuple."]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Gr\u00e2ce \u00e0 l'**encapsulation**, on peut continuer \u00e0 utiliser la classe exactement de la m\u00eame mani\u00e8re"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 104, "lines": ["matrice = Matrix2(1, 2, 2, 1)\n", "print(\"Determinant =\", matrice.determinant())"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 106, "lines": ["Et en prime, gr\u00e2ce \u00e0 la **r\u00e9solution dynamique de m\u00e9thode**, et parce que dans cette seconde impl\u00e9mentation on a d\u00e9fini une autre m\u00e9thode sp\u00e9ciale `__repr__`, nous avons maintenant une impression beaucoup plus lisible de l'objet `matrice`"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 107, "lines": ["print(matrice)"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 108, "lines": ["Ce format d'impression reste d'ailleurs valable dans l'impression d'objets plus compliqu\u00e9s, comme par exemple"]}, {"block": 45, "type": "code", "linesLength": 4, "startIndex": 109, "lines": ["# on profite de ce nouveau format d'impression m\u00eame si on met\n", "# par exemple un objet Matrix2 \u00e0 l'int\u00e9rieur d'une liste\n", "composite = [matrice, None, Matrix2(1, 0, 0, 1)]\n", "print('composite=', composite)"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 113, "lines": ["Cela est possible parce que le code de `print` envoie la m\u00e9thode `__repr__` sur les objets qu'elle parcourt. Le langage fournit une fa\u00e7on de faire par d\u00e9faut, comme on l'a vu plus haut avec la premi\u00e8re impl\u00e9mentation de `Matrix2`; et en d\u00e9finissant notre propre m\u00e9thode `__repr__` nous pouvons surcharger ce comportement, et d\u00e9finir notre format d'impression."]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["Nous reviendrons sur les notions de surcharge et d'h\u00e9ritage dans les prochaines s\u00e9quences vid\u00e9os."]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["### La convention d'utiliser `self`"]}, {"block": 49, "type": "markdown", "linesLength": 3, "startIndex": 116, "lines": ["Avant de conclure, revenons rapidement sur le nom `self` qui est utilis\u00e9 comme nom pour le premier argument des m\u00e9thodes habituelles (nous verrons en semaine 7 d'autres sortes de m\u00e9thodes, les m\u00e9thodes statiques et de classe, qui ne re\u00e7oivent pas l'instance comme premier argument).\n", "\n", "Comme nous l'avons dit plus haut, le premier argument d'une m\u00e9thode s'appelle `self` **par convention**. Cette pratique est particuli\u00e8rement bien suivie, mais ce n'est qu'une convention, en ce sens qu'on aurait pu utiliser n'importe quel identificateur; pour le langage `self` n'a aucun sens particulier, ce n'est pas un mot cl\u00e9."]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["Ceci est \u00e0 mettre en contraste avec le choix fait dans d'autres langages, comme par exemple en C++ o\u00f9 l'instance peut dans certains cas \u00eatre r\u00e9f\u00e9renc\u00e9e par le mot-cl\u00e9 `this`, qui n'est pas mentionn\u00e9 dans la signature de la m\u00e9thode. En python, selon le manifeste, *explicit is better than implicit*, c'est pourquoi on mentionne l'instance dans la signature, sous le nom `self`."]}]
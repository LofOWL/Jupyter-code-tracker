[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Plusieurs variables dans une boucle `for`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Nous avons vu pr\u00e9c\u00e9demment (s\u00e9quence 'Les tuples', compl\u00e9ment 'Sequence unpacking') la possibilit\u00e9 d'affecter plusieurs variables \u00e0 partir d'un seul objet, comme ceci:"]}, {"block": 4, "type": "code", "linesLength": 3, "startIndex": 4, "lines": ["item = (1, 2)\n", "a, b = item\n", "print(\"a={} b={}\".format(a, b))"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["D'une fa\u00e7on analogue, il est possible de faire une boucle `for` qui it\u00e8re sur **une seule** liste mais qui *agit* sur **plusieurs variables**, comme ceci:"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 8, "lines": ["entrees = [(1, 2), (3, 4), (5, 6)]\n", "for a, b in entrees:\n", "    print(\"a={} b={}\".format(a, b))"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["\u00c0 chaque it\u00e9ration, on trouve dans `entree` un tuple (d'abord `(1, 2)`, puis \u00e0 l'iteration suivante `(3, 4)`, etc..); \u00e0 ce stade les variables `a` et `b` vont \u00eatre affect\u00e9es \u00e0, respectivement, le premier et le deuxi\u00e8me \u00e9l\u00e9ment du tuple, exactement comme dans le *sequence unpacking*. Cette m\u00e9canique est massivement utilis\u00e9e en python. "]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["### La fonction `zip`"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Voici un exemple tr\u00e8s simple qui utilise la technique qu'on vient de voir."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Imaginons qu'on dispose de deux listes de longueurs \u00e9gales, dont on sait que les entr\u00e9es correspondent une \u00e0 une, comme par exemple:"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 16, "lines": ["villes = [\"Paris\", \"Nice\", \"Lyon\"]\n", "populations = [2*10**6, 4*10**5, 10**6]"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Afin d'\u00e9crire facilement un code qui \"associe\" les deux listes entre elles, python fournit une fonction *built-in* baptis\u00e9e `zip`; voyons ce qu'elle peut nous apporter sur cet exemple:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["list(zip(villes, populations))"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["On le voit, on obtient en retour une liste compos\u00e9e de tuples. On peut \u00e0 pr\u00e9sent \u00e9crire une boucle `for` comme ceci:"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["for ville, population in zip(villes, populations):\n", "    print(population, \"habitants \u00e0\", ville)"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 23, "lines": ["Qui est, nous semble-t-il, beaucoup plus lisible que ce que l'on serait amen\u00e9 \u00e0 \u00e9crire avec des langages plus traditionnels. \n", "\n", "Tout ceci se g\u00e9n\u00e9ralise naturellement \u00e0 plus de deux variables."]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["for i, j, k in zip(range(3), range(100, 103), range(200, 203)):\n", "    print('i', i, 'j', j, 'k', k)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["**Remarque**: lorsqu'on passe \u00e0 `zip` des listes de tailles diff\u00e9rentes, le r\u00e9sultat est tronqu\u00e9, c'est l'entr\u00e9e **de plus petite taille** qui d\u00e9termine la fin du parcours."]}, {"block": 20, "type": "code", "linesLength": 4, "startIndex": 29, "lines": ["# on n'it\u00e8re que deux fois \n", "# car le premier argument de zip est de taille 2\n", "for units, tens in zip( [1, 2], [10, 20, 30, 40]):\n", "    print(units, tens)"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["### La fonction `enumerate`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Une autre fonction tr\u00e8s utile permet d'it\u00e9rer sur une liste avec l'indice dans la liste, il s'agit de `enumerate`:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 35, "lines": ["for i, ville in enumerate(villes):\n", "    print(i, ville)"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["Cette forme est **plus simple** et **plus lisible** que les formes suivantes qui sont \u00e9quivalentes, mais qui ne sont pas pythoniques:"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 38, "lines": ["for i in range(len(villes)):\n", "    print(i, villes[i])"]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 40, "lines": ["for i, ville in zip(range(len(villes)), villes):\n", "    print(i, ville)"]}]
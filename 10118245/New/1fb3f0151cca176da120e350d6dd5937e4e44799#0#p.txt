[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Expressions r\u00e9guli\u00e8res et le module `re`"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 2, "type": "markdown", "linesLength": 13, "startIndex": 2, "lines": ["Une expression r\u00e9guli\u00e8re est un objet math\u00e9matique permettant de d\u00e9crire un ensemble de textes qui poss\u00e8dent des propri\u00e9t\u00e9s communes;  vous en connaissez peut-\u00eatre un exemple, si vous utilisez au moins parfois un terminal et que vous tapez&nbsp;:\n", "\n", "    $ dir *.txt\n", "    \n", "et dans ce cas pr\u00e9cis l'expression r\u00e9guli\u00e8re *filtre* toutes les cha\u00eenes qui se terminent par `.txt`\n", "\n", "Le langage **Perl** avait \u00e9t\u00e9 le premier \u00e0 populariser l'utilisation des expressions r\u00e9guli\u00e8res, en en faisant un \"citoyen de premi\u00e8re classe\" dans le langage (c'est-\u00e0-dire support\u00e9 nativement dans le langage, et non au travers d'une librairie).\n", "\n", "En python, les expressions r\u00e9guli\u00e8res sont disponibles de mani\u00e8re plus traditionnelle, via le module `re` de la librairie standard, dont nous allons dire quelques mots.\n", "\n", "Dans la commande ci-dessus, `*.txt` est une expression r\u00e9guli\u00e8re tr\u00e8s simple. Le module `re` fournit le moyen de construire des expressions r\u00e9guli\u00e8res tr\u00e8s \u00e9labor\u00e9es et plus puissantes que ce que supporte le terminal. C'est pourquoi la syntaxe des regexps de `re` est un peu diff\u00e9rente; par exemple pour rechercher (on dit encore filtrer, de l'anglais *pattern matching*) la m\u00eame famille de cha\u00eenes que `*.txt` avec le module `re`, il nous faudra \u00e9crire l'expression r\u00e9guli\u00e8re sous une forme l\u00e9g\u00e8rement diff\u00e9rente.\n", "\n", "Le propos de ce compl\u00e9ment est de vous donner une premi\u00e8re introduction au module `re`. "]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 15, "lines": ["import re"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Je vous conseille d'avoir sous la main la [documentation du module `re`](https://docs.python.org/2/library/re.html) pendant que vous lisez ce compl\u00e9ment."]}, {"block": 5, "type": "heading", "linesLength": 1, "startIndex": 17, "lines": ["Avertissement"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 18, "lines": ["Dans ce compl\u00e9ment nous serons amen\u00e9s \u00e0 utiliser des traits qui d\u00e9pendent du LOCALE, c'est-\u00e0-dire pour faire simple de comment un ordinateur est configur\u00e9 vis-\u00e0-vis de la langue. \n", "\n", "Tant que vous ex\u00e9cutez ceci dans le notebook sur la plateforme, en principe tout le monde verra exactement la m\u00eame chose. Par contre si vous faites tourner le m\u00eame code sur votre ordinateur, il se peut que vous obteniez des r\u00e9sultats diff\u00e9rents."]}, {"block": 7, "type": "heading", "linesLength": 1, "startIndex": 21, "lines": ["Un exemple simple"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Voici deux exemples de cha\u00eenes."]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 23, "lines": ["sentences = ['Lacus a donec, vitae gravida:; proin sociis.', \n", "             'Neque ipsum! rhoncus cras quam.']"]}, {"block": 10, "type": "heading", "linesLength": 1, "startIndex": 25, "lines": ["`findall`"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["On peut **chercher tous** les mots se terminant par a ou m dans une cha\u00eene en faisant&nbsp;:"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 27, "lines": ["for sentence in sentences:\n", "    print 4*'-','dans >{}<'.format(sentence)\n", "    print re.findall (r\"\\w*[am]\\W\", sentence)"]}, {"block": 13, "type": "markdown", "linesLength": 8, "startIndex": 30, "lines": ["Ce code permet de chercher toutes (`findall`) les occurrences de l'expression r\u00e9guli\u00e8re, qui ici est le *raw-string* c'est-\u00e0-dire la cha\u00eene\n", "\n", "    `r\"\\w*[am]\\W\"`\n", "    \n", "Nous verrons tout \u00e0 l'heure comment fabriquer des expressions r\u00e9guli\u00e8res plus en d\u00e9tail, mais pour d\u00e9mystifier au moins celle-ci, on a mis bout \u00e0 bout des morceaux d'expression r\u00e9guli\u00e8res&nbsp;:\n", " * `\\w*` : il nous faut trouver une sous-cha\u00eene qui commence par un nombre quelconque, y compris nul (`*`) de caract\u00e8res alphanum\u00e9riques (`\\w`); ceci est d\u00e9fini en fonction de votre LOCALE, on y reviendra;\n", " * `[am]` : imm\u00e9diatement apr\u00e8s, il nous faut trouver un carat\u00e8re `a` ou `m`;\n", " * `\\W` : et enfin, il nous faut un caract\u00e8re qui ne soit pas alphanum\u00e9rique."]}, {"block": 14, "type": "heading", "linesLength": 1, "startIndex": 38, "lines": ["`split`"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["Une autre forme simple d'utilisation des regexps est `re.split`, qui fournit une **fonctionnalit\u00e9 voisine de `str.split`** qu'on a vue en semaine 2, mais ou les s\u00e9parateurs sont exprim\u00e9s comme une expression r\u00e9guli\u00e8re; ou encore on peut le voir un peu comme la n\u00e9gation de `findall`&nbsp;:"]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 40, "lines": ["for sentence in sentences:\n", "    print 4*'-','dans >{}<'.format(sentence)\n", "    print re.split (r\"\\W+\", sentence)"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["Ici l'expression r\u00e9guli\u00e8re, qui donc d\u00e9crit le s\u00e9parateur, est simplement `\\W+` c'est-\u00e0-dire toute suite d'au moins caract\u00e8re non alphanum\u00e9rique."]}, {"block": 18, "type": "heading", "linesLength": 1, "startIndex": 44, "lines": ["Pourquoi un *raw-string* ?"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["En guise de digression, il n'y a aucune obligation \u00e0 utiliser un *raw-string*; d'ailleurs on rappelle qu'il n'y a pas de diff\u00e9rence de nature entre un *raw-string* et une cha\u00eene usuelle&nbsp;:"]}, {"block": 20, "type": "code", "linesLength": 6, "startIndex": 46, "lines": ["raw = r'abc'\n", "regular = 'abc'\n", "# comme on a pris une 'petite' cha\u00eene ce sont les m\u00eames objets\n", "print 'is', raw is regular\n", "# et donc a fortiori\n", "print '==', raw == regular"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["Il se trouve que, comme dans notre premier exemple, le *backslash* `\\` \u00e0 l'int\u00e9rieur des expressions r\u00e9guli\u00e8res est d'un usage assez courant. C'est pourquoi on **utilise fr\u00e9quemment un *raw-string*** pour d\u00e9crire une expression r\u00e9guli\u00e8re, et en g\u00e9n\u00e9ral \u00e0 chaque fois qu'elle comporte un *backslash*."]}, {"block": 22, "type": "heading", "linesLength": 1, "startIndex": 53, "lines": ["(Petits outils d'affichage)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["Avant de voir un deuxi\u00e8me exemple, nous allons digresser \u00e0 nouveau, et pour am\u00e9liorer la pr\u00e9sentation, nous allons nous \u00e9crire deux petits outils de mise en page, qui n'ont rien \u00e0 voir avec les expressions r\u00e9guli\u00e8res *per se*&nbsp;:"]}, {"block": 24, "type": "code", "linesLength": 11, "startIndex": 55, "lines": ["# mettre en colonnes les inputs et les regexps\n", "def i_r (input, cols_in, regexp=None, cols_re=0):\n", "    if regexp:\n", "        return \"IN={} - RE={} ->\".format(input.rjust(cols_in),\n", "                                         regexp.ljust(cols_re))\n", "    else:\n", "        return \"IN={} ->\".format(input.rjust(cols_in))\n", "\n", "# afficher 'Match' ou 'None' plut\u00f4t que l'objet Match\n", "def m (match):\n", "    return 'MATCH' if match else 'Nope'    "]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Nous utiliserons `i_r` avec des tailles de colonnes choisies \u00e0 la main, comme&nbsp;:"]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["input = 'abd'\n", "regexp = 'a[bc]d'\n", "print i_r(input, 4, regexp, 7), m(re.match(regexp, input))"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Ici 4 et 7 repr\u00e9sentent la largeur des colonnes pour afficher `abd` et `a[bc]d` respectivement."]}, {"block": 28, "type": "heading", "linesLength": 1, "startIndex": 71, "lines": ["Un deuxi\u00e8me exemple"]}, {"block": 29, "type": "markdown", "linesLength": 3, "startIndex": 72, "lines": ["Nous allons maintenant voir comment on peut, d'abord v\u00e9rifier si une cha\u00eene est conforme au crit\u00e8re d\u00e9fini par l'expression r\u00e9guli\u00e8re, mais aussi *extraire* les morceaux de la cha\u00eene qui correspondent aux diff\u00e9rentes parties de l'expression. \n", "\n", "Pour cela supposons qu'on s'int\u00e9resse aux cha\u00eenes qui comportent 5 parties, une suite de chiffres, une suite de lettres, des chiffres \u00e0 nouveau, des lettres, et enfin de nouveau des chiffres."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["Avec ces trois chaines en entr\u00e9e&nbsp;:"]}, {"block": 31, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["inputs = [ '890hj000nnm890',    # cette entr\u00e9e convient\n", "           '123abc456def789',   # celle-ci aussi\n", "           '8090abababab879',   # celle-ci non\n", "           ]"]}, {"block": 32, "type": "heading", "linesLength": 1, "startIndex": 80, "lines": ["`match`"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Pour commencer, voyons que l'on peut facilement **v\u00e9rifier si une cha\u00eene v\u00e9rifie** ou non ce crit\u00e8re&nbsp;:"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 82, "lines": ["regexp1 = \"[0-9]+[A-Za-z]+[0-9]+[A-Za-z]+[0-9]+\""]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Ce qui nous donne, en utilisant les helpers `i_r` et `m` pour la mise en page&nbsp;:"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["for input in inputs:\n", "    print i_r (input,15), m(re.match(regexp1, input))"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 86, "lines": ["Ici plut\u00f4t que d'utiliser les raccourcis comme `\\w` j'ai pr\u00e9f\u00e9r\u00e9 \u00e9crire explicitement les ensembles de caract\u00e8res en jeu; ce cette fa\u00e7on on rend son code ind\u00e9pendant du LOCALE si c'est ce qu'on veut faire. Il y a deux morceaux qui interviennent tour \u00e0 tour&nbsp;:\n", " * `[0-9]+` signifie une suite de au moins un caract\u00e8re dans l'intervalle `[0-9]`,\n", " * `[A-Za-z]+` pour une suite d'au moins un caract\u00e8re dans l'intervalle `[A-Z]` ou dans l'intervalle `[a-z]`. "]}, {"block": 38, "type": "heading", "linesLength": 1, "startIndex": 89, "lines": ["Nommer un morceau (un groupe)"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 90, "lines": ["# on se concentre sur une entr\u00e9e correcte\n", "haystack = inputs[1]\n", "haystack"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["Maintenant, on va m\u00eame pouvoir donner un nom \u00e0 un morceau de la regexp, ici `needle`"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 94, "lines": ["# la m\u00eame regexp, mais on donne un nom \u00e0 un morceau\n", "regexp2 = \"[0-9]+[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+[0-9]+\""]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["Et une fois que c'est fait on peut demander \u00e0 l'outil de nous **retrouver la partie correspondante** dans la chaine initiale&nbsp;:"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 97, "lines": ["print re.match(regexp2, haystack).group('needle')"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 98, "lines": ["Dans cette expression on a utilis\u00e9 un **groupe nomm\u00e9** `(?P<needle>[0-9]+)`."]}, {"block": 45, "type": "heading", "linesLength": 1, "startIndex": 99, "lines": ["Un troisi\u00e8me exemple"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 100, "lines": ["Enfin, et c'est un trait qui n'est pas pr\u00e9sent dans tous les langages, on peut restreindre un morceau de cha\u00eene \u00e0 \u00eatre identique \u00e0 un groupe d\u00e9j\u00e0 vu avant dans la cha\u00eene; dans l'exemple ci-dessus on pourrait ajouter comme contrainte que le premier et le dernier groupes de chiffres soient identiques comme ceci&nbsp;:"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 101, "lines": ["regexp3 = \"(?P<id>[0-9]+)[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+(?P=id)\""]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["Avec les m\u00eames entr\u00e9es que tout \u00e0 l'heure"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 103, "lines": ["for input in inputs:\n", "    print i_r(input,15), m(re.match(regexp3, input))"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["La nouveaut\u00e9 ici est la **backreference** `(?P=id)`."]}, {"block": 51, "type": "heading", "linesLength": 1, "startIndex": 106, "lines": ["Comment utiliser la librairie"]}, {"block": 52, "type": "heading", "linesLength": 1, "startIndex": 107, "lines": ["Fonctions de commodit\u00e9 et *workflow*"]}, {"block": 53, "type": "markdown", "linesLength": 3, "startIndex": 108, "lines": ["Comme vous le savez peut-\u00eatre, une expression r\u00e9guli\u00e8re d\u00e9crite sous forme de cha\u00eene, comme par exemple `\"\\w*[am]\\W\"`, peut \u00eatre traduite dans un automate fini qui permet de faire le filtrage avec une cha\u00eene. C'est ce qui explique le *workflow* que nous avons r\u00e9sum\u00e9 dans cette figure&nbsp;:\n", "\n", "<img src=\"media/re-workflow.png\">"]}, {"block": 54, "type": "markdown", "linesLength": 5, "startIndex": 111, "lines": ["La m\u00e9thode recommand\u00e9e pour utiliser la librairie, lorsque vous avez le m\u00eame *pattern* \u00e0 appliquer \u00e0 un grand nombre de cha\u00eenes, est de \n", " * compiler **une seule fois** votre cha\u00eene en un objet de la classe `re.RegexObject`, en utilisant `re.compile`, \n", " * puis d'**utiliser directement cet objet** autant de fois que vous avez de cha\u00eenes.\n", " \n", "Nous avons utilis\u00e9 dans les exemples plus haut (et nous continuerons plus bas pour une meilleure lisibilit\u00e9) des **fonctions de commodit\u00e9** du module, qui ne **sont pas forc\u00e9ment** adapt\u00e9es dans tous les cas. "]}, {"block": 55, "type": "markdown", "linesLength": 3, "startIndex": 116, "lines": ["Ces fonctions de commodit\u00e9 fonctionnent toutes sur le m\u00eame th\u00e8me&nbsp;:\n", "    \n", "`re.match (regexp, input)`  $\\Longleftrightarrow$ `re.compile(regexp).match(input)`"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["C'est ainsi qu'au lieu de faire comme plus haut&nbsp;:"]}, {"block": 57, "type": "code", "linesLength": 3, "startIndex": 120, "lines": ["# imaginez 10**4 cha\u00eenes dans inputs\n", "for input in inputs:\n", "    print i_r(input,15), m(re.match(regexp3, input))"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 123, "lines": ["dans du vrai code on fera plut\u00f4t&nbsp;:"]}, {"block": 59, "type": "code", "linesLength": 6, "startIndex": 124, "lines": ["# on compile la cha\u00eene en automate une seule fois\n", "re_obj3 = re.compile (regexp3)\n", "\n", "# ensuite on part directement de l'automate\n", "for input in inputs:\n", "    print i_r(input,15), m(re_obj3.match(input))"]}, {"block": 60, "type": "markdown", "linesLength": 1, "startIndex": 130, "lines": ["qui ne compile qu'une fois la cha\u00eene en automate, et donc est plus efficace."]}, {"block": 61, "type": "heading", "linesLength": 1, "startIndex": 131, "lines": ["Exploiter le r\u00e9sultat"]}, {"block": 62, "type": "code", "linesLength": 1, "startIndex": 132, "lines": ["Les fonctions qui retournent un objet de la classe `re.MatchObject` "]}, {"block": 63, "type": "heading", "linesLength": 1, "startIndex": 133, "lines": ["Comment construire une expression r\u00e9guli\u00e8re"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 134, "lines": ["Nous pouvons \u00e0 pr\u00e9sent refaire une liste des constructions qui permettent d'\u00e9laborer une expression r\u00e9guli\u00e8re, en restant toutefois synth\u00e9tique puisque la [documentation du module `re`](https://docs.python.org/2/library/re.html) en donne une version exhaustive."]}, {"block": 65, "type": "heading", "linesLength": 1, "startIndex": 135, "lines": ["La brique de base : le caract\u00e8re"]}, {"block": 66, "type": "markdown", "linesLength": 14, "startIndex": 136, "lines": ["Au commencement il faut sp\u00e9cifier des caract\u00e8res&nbsp;:\n", " * **un seul** caract\u00e8re : \n", "   * vous le citez tel quel, en le pr\u00e9c\u00e9dent d'un backslash `\\` s'il a par ailleurs un sens sp\u00e9cial dans le micro-langage de regexps (comme `+`, `*`, `[` et autres ...),\n", "   * sachant que par ailleurs le `.`  est le *wildcard* pour un seul caract\u00e8re;\n", " * **un ensemble** de caract\u00e8res avec la notation `[...]` qui permet de d\u00e9crire\n", "   * ex. `[a1=]` : un ensemble in extenso, ici un caract\u00e8re parmi les 3: `a`, `1`, ou `=`,\n", "   * ex. `[a-z]` : un intervalle de caract\u00e8res\n", "   * ex. `[15e-g]` : un m\u00e9lange des deux, qui contiendrait ici `1`, `5`, `e`, `f` et `g`\n", "   * ex. `[^15e-g]` : une n\u00e9gation, qui a `^` comme premier caract\u00e8re dans les `[]`, ici tout sauf l'ensemble pr\u00e9c\u00e9dent;\n", " * un ensemble de caract\u00e8res pr\u00e9d\u00e9fini, qui peuvent alors d\u00e9pendre de l'environnement (i.e. UNICODE et LOCALE) avec les notations&nbsp;:\n", "   * `\\w` les caract\u00e8res alphanum\u00e9riques, et `\\W` (les autres),\n", "   * `\\s` les caract\u00e8res \"blancs\" - espace, tabulation, saut de ligne, etc..., et `\\S` (les autres),\n", "   * `\\d` pour les chiffres, et `\\D` (les autres),\n", " "]}, {"block": 67, "type": "code", "linesLength": 4, "startIndex": 150, "lines": ["input = \"abcd\"\n", "\n", "for regexp in ['abcd', 'ab[cd][cd]', r'abc.', r'abc\\.']:\n", "    print i_r(input, 4, regexp,10), m(re.match(regexp, input))"]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 154, "lines": ["Pour ce dernier exemple, comme on a backslash\u00e9 le `.` il faut que la cha\u00eene en entr\u00e9e contienne vraiment un `.`&nbsp;:"]}, {"block": 69, "type": "code", "linesLength": 1, "startIndex": 155, "lines": ["print re.match (r\"abc\\.\", \"abc.\")"]}, {"block": 70, "type": "heading", "linesLength": 1, "startIndex": 156, "lines": ["En s\u00e9rie ou en parall\u00e8le"]}, {"block": 71, "type": "markdown", "linesLength": 5, "startIndex": 157, "lines": ["Si je fais une analogie avec les montages \u00e9lectriques, jusqu'ici on a vu le montage en s\u00e9rie&nbsp;: on met des expressions r\u00e9guli\u00e8res bout \u00e0 bout, qui filtrent (`match`) la chaine en entr\u00e9e s\u00e9quentiellement du d\u00e9but \u00e0 la fin. On a *un peu* de marge pour sp\u00e9cifier des alternatives, lorsqu'on fait par exemple\n", "\n", "    \"ab[cd]ef\"\n", "    \n", "mais c'est limit\u00e9 \u00e0 **un seul** caract\u00e8re. Si on veut reconnaitre deux mots qui n'ont pas grand-chose \u00e0 voir comme `abc` **ou** `def`, il faut en quelque sorte mettre deux regexps en parall\u00e8le, et c'est ce que permet l'op\u00e9rateur `|`"]}, {"block": 72, "type": "code", "linesLength": 4, "startIndex": 162, "lines": ["regexp = \"abc|def\"\n", "\n", "for input in [ 'abc', 'def', 'aef' ]:\n", "    print i_r(input, 3, regexp,7), m(re.match(regexp, input))"]}, {"block": 73, "type": "heading", "linesLength": 1, "startIndex": 166, "lines": ["Fin(s) de cha\u00eene"]}, {"block": 74, "type": "markdown", "linesLength": 9, "startIndex": 167, "lines": ["Selon que vous utilisez `match` ou `search`, vous pr\u00e9cisez si vous vous int\u00e9ressez uniquement \u00e0 un match en d\u00e9but (`match`) ou n'importe o\u00f9 (`search`) dans la cha\u00eene.\n", "\n", "Mais ind\u00e9pendamment de cela, il peut \u00eatre int\u00e9ressant de \"coller\" l'expression en d\u00e9but ou en fin de ligne, et pour \u00e7a il existe des caract\u00e8res sp\u00e9ciaux&nbsp:;\n", " * `^` lorsqu'il est utilis\u00e9 comme un caract\u00e8re (c'est \u00e0 dire pas en d\u00e9but de `[]`) signifie un d\u00e9but de cha\u00eene;\n", " * `\\A` a le m\u00eame sens (sauf en mode MULTILINE), et je le recommande de pr\u00e9f\u00e9rence \u00e0 `^`qui est d\u00e9j\u00e0 pas mal surcharg\u00e9;\n", " * `$` matche une fin de ligne;\n", " * `\\Z` est voisin mais pas tout \u00e0 fait identique.\n", "\n", "Reportez-vous \u00e0 la documentation pour le d\u00e9tails des diff\u00e9rences."]}, {"block": 75, "type": "code", "linesLength": 4, "startIndex": 176, "lines": ["input = 'abcd'\n", "\n", "for regexp in [ 'bc', r'\\Aabc', '^abc', r'\\Abc', '^bc', r'bcd\\Z', 'bcd$', r'bc\\Z', 'bc$' ]:\n", "    print i_r(input, 4, regexp, 5), m(re.search(regexp,input))"]}, {"block": 76, "type": "markdown", "linesLength": 1, "startIndex": 180, "lines": ["On a en effet bien le pattern `bc` dans la chaine en entr\u00e9e, mais il n'est ni au d\u00e9but ni \u00e0 la fin."]}, {"block": 77, "type": "heading", "linesLength": 1, "startIndex": 181, "lines": ["Parenth\u00e9ser - (grouper)"]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 182, "lines": ["Pour pouvoir faire des montages \u00e9labor\u00e9s il faut pouvoir parenth\u00e9ser&nbsp;:"]}, {"block": 79, "type": "code", "linesLength": 7, "startIndex": 183, "lines": ["# une parenth\u00e9se dans une RE pour mettre en ligne\n", "# un d\u00e9but 'a', deux possibilit\u00e9s pour le milieu 'bc' ou 'de' \n", "# et une fin 'f'\n", "regexp = \"a(bc|de)f\"\n", "\n", "for input in [ 'abcf', 'adef', 'abf' ]:\n", "    print i_r(input, 4, regexp, 9), m(re.match(regexp, input))"]}, {"block": 80, "type": "markdown", "linesLength": 1, "startIndex": 190, "lines": ["Les parenth\u00e8ses jouent un r\u00f4le additionel de **groupe**; ce qui signifie qu'on **peut retrouver** le texte correspondant \u00e0 l'expression r\u00e9guli\u00e8re comprise dans les `()`. Par exemple pour le premier match&nbsp;:"]}, {"block": 81, "type": "code", "linesLength": 2, "startIndex": 191, "lines": ["input = 'abcf'\n", "print i_r(input, 4, regexp, 9), re.match(regexp, input).groups()"]}, {"block": 82, "type": "markdown", "linesLength": 1, "startIndex": 193, "lines": ["dans cet exemple, on n'a utilis\u00e9 qu'un seul groupe `()`, et le morceau de cha\u00eene qui correspond \u00e0 ce groupe se trouve donc \u00eatre le seul groupe retourn\u00e9 par `MatchObject.group`."]}, {"block": 83, "type": "heading", "linesLength": 1, "startIndex": 194, "lines": ["Compter les r\u00e9p\u00e9titions"]}, {"block": 84, "type": "markdown", "linesLength": 6, "startIndex": 195, "lines": ["Vous disposez des op\u00e9rateurs suivants&nbsp;:\n", " * `*` l'\u00e9toile qui signifie n'importe quel nombre, m\u00eame nul, d'occurrences  - par exemple, `(ab)*` pour indiquer `''` ou `'ab'` ou `'abab'` ou etc.,\n", " * `+` le plus qui signifie au moins une occurrence - e.g. `(ab)+` pour `ab` ou `abab` ou `ababab` ou etc.\n", " * `?` qui indique une option, c'est-\u00e0-dire 0 ou 1 occurence - e.g. `(ab)?` pour `''` ou `ab`, \n", " * `{n}` pour exactement n occurrences de `(ab)` - e.g. `(ab){3}` qui serait exactement \u00e9quivalent \u00e0 `ababab`;\n", " * `{m,n}` entre m et n fois inclusivement, c'est-\u00e0-dire que `*<re>*?` est exactement \u00e9quivalent \u00e0 `*<re>*{0,1}`."]}, {"block": 85, "type": "code", "linesLength": 7, "startIndex": 201, "lines": ["inputs = [ n*'ab'for n in [0, 1, 3, 4]] + [ 'foo' ]\n", "\n", "for regexp in [ '(ab)*', '(ab)+', '(ab){3}', '(ab){3,4}' ]:\n", "    # on ajoute \\A \\Z pour matcher toute la chaine\n", "    line_regexp = r\"\\A{}\\Z\".format(regexp)\n", "    for input in inputs:\n", "        print i_r(input, 8, line_regexp, 13), m(re.match(line_regexp, input))"]}, {"block": 86, "type": "heading", "linesLength": 1, "startIndex": 208, "lines": ["Nommer les groupes"]}, {"block": 87, "type": "markdown", "linesLength": 1, "startIndex": 209, "lines": ["Nous avons d\u00e9j\u00e0 vu un exemple de groupe nomm\u00e9 (voir `needle` plus haut); les op\u00e9rateurs que l'on peut citer dans cette "]}, {"block": 88, "type": "heading", "linesLength": 1, "startIndex": 210, "lines": ["Greedy *vs* non-greedy"]}, {"block": 89, "type": "markdown", "linesLength": 1, "startIndex": 211, "lines": ["Lorsqu'on stipule une r\u00e9p\u00e9tition un nombre ind\u00e9fini de fois, il se peut qu'il existe **plusieurs** fa\u00e7ons de filtrer l'entr\u00e9e avec l'expression r\u00e9guli\u00e8re. Que ce soit avec `*`, ou `+`, ou `?`, l'algorithme va toujours essayer de trouver la **s\u00e9quence la plus longue**, c'est pourquoi on qualifie l'approche de *greedy* - quelque chose comme glouton en fran\u00e7ais&nbsp;:"]}, {"block": 90, "type": "code", "linesLength": 9, "startIndex": 212, "lines": ["# si on cherche `<.*>` dans cette cha\u00eene\n", "line='<h1>Title</h1>'\n", "\n", "# sans rien pr\u00e9ciser\n", "re_greedy = '<(.*)>'\n", "\n", "# on obtient\n", "match = re.match(re_greedy, line)\n", "match.groups()\n"]}, {"block": 91, "type": "markdown", "linesLength": 1, "startIndex": 221, "lines": ["\u00c7a n'est pas forc\u00e9ment ce qu'on voulait faire; aussi on peut sp\u00e9cifier l'approche inverse, c'est-\u00e0-dire de trouver la **plus-petite** cha\u00eene qui matche, dans une approche dite *non-greedy*&nbsp;:"]}, {"block": 92, "type": "code", "linesLength": 7, "startIndex": 222, "lines": ["# la version non-greedy a un point d'interrogation apr\u00e8s +, * ou ?\n", "re_non_greedy = re_greedy = '<(.*?)>'\n", "\n", "# et cette fois, on obtient\n", "match = re.match(re_non_greedy, line)\n", "match.groups()\n", "\n"]}, {"block": 93, "type": "markdown", "linesLength": 1, "startIndex": 229, "lines": ["****"]}, {"block": 94, "type": "markdown", "linesLength": 1, "startIndex": 230, "lines": ["On peut mettre un \"\\n\" comme caract\u00e8re (et faire des RE multilignes)"]}, {"block": 95, "type": "markdown", "linesLength": 1, "startIndex": 231, "lines": ["lexer + parser "]}, {"block": 96, "type": "code", "linesLength": 7, "startIndex": 232, "lines": ["faire un quiz avec plusieurs r\u00e9ponses possibles pour *.txt en shell -> re()\n", "\n", "regexp = r`.*\\.txt`\n", "\n", "faire un exo sur les RE et les URLs\n", "retrouver le protocole, le hostname, le num\u00e9ro de port, le path\n", "v2 : idem + login/password"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["    <span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["# Premiers exemples"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["### les concepts de base en action"]}, {"block": 4, "type": "code", "linesLength": 1, "startIndex": 4, "lines": ["import asyncio"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["## coroutine"]}, {"block": 6, "type": "code", "linesLength": 12, "startIndex": 6, "lines": ["async def morceaux(message):\n", "\n", "    # on appelle le code synchrone normalement\n", "    print(message, \"d\u00e9but\")\n", "    # avec await on rend la main\n", "    await asyncio.sleep(0.5)\n", "\n", "    print(message, \"milieu\")\n", "    await asyncio.sleep(1)\n", "    \n", "    print(message, \"fin\")\n", "    return f'{message} par morceaux'"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["# objet coroutine"]}, {"block": 8, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["morceaux"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["morceaux(\"run\")"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["# boucle d'\u00e9v\u00e9nements"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 22, "lines": ["loop = asyncio.get_event_loop()"]}, {"block": 12, "type": "code", "linesLength": 1, "startIndex": 23, "lines": ["loop.run_until_complete(morceaux(\"run\"))"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["# plusieurs traitements"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 25, "lines": ["loop.run_until_complete(\n", "    asyncio.gather(morceaux(\"run1\"),\n", "                   morceaux(\"run2\")))"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["![run1-run2](w9-s2-av-fig1.png)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["# ce qu'il ne faut pas faire"]}, {"block": 17, "type": "code", "linesLength": 13, "startIndex": 30, "lines": ["import time \n", "\n", "async def famine(message):\n", "\n", "    print(message, \"d\u00e9but\")\n", "    # avec await on rend la main\n", "    await asyncio.sleep(0.5)\n", "\n", "    print(message, \"milieu\")\n", "    # on garde la main au lieu de la rendre\n", "    time.sleep(1)\n", "    print(message, \"fin\")\n", "    return f'{message} par famine'"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["## famine en action"]}, {"block": 19, "type": "code", "linesLength": 3, "startIndex": 44, "lines": ["loop.run_until_complete(\n", "    asyncio.gather(famine(\"run1\"),\n", "                   famine(\"run2\")))"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["# chronologie"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["![famine](w9-s2-av-fig2.png)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["# synchronisation avec une queue"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["import asyncio\n", "\n", "mainloop = asyncio.new_event_loop()"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 53, "lines": ["from asyncio import Queue\n", "queue = Queue(loop=mainloop)"]}, {"block": 25, "type": "code", "linesLength": 6, "startIndex": 55, "lines": ["async def producer(queue):\n", "    count = 1\n", "    while True:\n", "        await queue.put(f'tick{count}')\n", "        count += 1\n", "        await asyncio.sleep(1)"]}, {"block": 26, "type": "code", "linesLength": 5, "startIndex": 61, "lines": ["async def consumer(queue):\n", "    while True:\n", "        received = await queue.get()\n", "        print(f\"got {received}\")\n", "        "]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 66, "lines": ["# on ajoute les coroutines dans la boucle\n", "mainloop.create_task(producer(queue))\n", "mainloop.create_task(consumer(queue))"]}, {"block": 28, "type": "code", "linesLength": 5, "startIndex": 69, "lines": ["# on lance la boucle sans fin\n", "try:\n", "    mainloop.run_forever()\n", "except KeyboardInterrupt as e:\n", "    print(\"bye\")"]}]
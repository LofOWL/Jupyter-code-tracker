[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Le module `collections`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Maintenant que nous avons termin\u00e9 le tour des types de base fournis par le langage, vous pourrez trouver dans [le module `collections`](https://docs.python.org/3/library/collections.html) quelques types \u00e9tendus, qui fournissent des extensions souvent commodes des types de base. Nous allons en voir quelques exemples."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict) : un dictionnaire avec m\u00e9moire"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["Nous avons vu que le dictionnaire n'est pas une structure ordonn\u00e9e:"]}, {"block": 6, "type": "code", "linesLength": 7, "startIndex": 6, "lines": ["cluedo = {}\n", "cluedo['olive'] = 'green'\n", "cluedo['moutarde'] = 'mustard'\n", "cluedo['rose'] = 'scarlett'\n", "cluedo['pervenche'] = 'peacock'\n", "for cle, valeur in list(cluedo.items()):\n", "    print(cle, valeur)"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["Avec le type `OrderedDict`, on peut conserver l'ordre dans lequel les cl\u00e9s sont entr\u00e9es, au prix naturellement d'un surco\u00fbt en termes d'occupation m\u00e9moire :"]}, {"block": 8, "type": "code", "linesLength": 9, "startIndex": 14, "lines": ["from collections import OrderedDict\n", "\n", "cluedo = OrderedDict()\n", "cluedo['olive'] = 'green'\n", "cluedo['moutarde'] = 'mustard'\n", "cluedo['rose'] = 'scarlett'\n", "cluedo['pervenche'] = 'peacock'\n", "for cle, valeur in list(cluedo.items()):\n", "    print(cle, valeur)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### [`defaultdict`](https://docs.python.org/3/library/collections.html#defaultdict-objects) : un dictionnaire avec initialisation automatique"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 24, "lines": ["`defaultdict` est une sp\u00e9cialisation du type dictionnaire. Par opposition avec le type `dict` standard, lorsqu'on fait r\u00e9f\u00e9rence \u00e0 une cl\u00e9 manquante, un [m\u00e9canisme de `factory`](http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29) entre en jeu pour initialiser la valeur associ\u00e9e \u00e0 la cl\u00e9.\n", "\n", "Par exemple, supposons qu'on ait besoin de g\u00e9rer un dictionnaire dont les valeurs sont des ensembles. "]}, {"block": 11, "type": "code", "linesLength": 6, "startIndex": 27, "lines": ["# on dispose d'enregistrements comme par exemple\n", "enregistrements = [('a', 10), ('b', 20), ('a', 30), ('b', 40)]\n", "\n", "# on veut construire un dictionnaire qui \n", "# avec ces entr\u00e9es ressemblerait \u00e0\n", "# {'a' : {10, 30}, 'b' : {20, 40}}"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Avec le type `dict` standard, il faut se livrer \u00e0 une petite gymnastique du genre de :"]}, {"block": 13, "type": "code", "linesLength": 6, "startIndex": 34, "lines": ["cumul = {}\n", "for cle, valeur in enregistrements:\n", "    if cle not in cumul:\n", "        cumul[cle] = set()\n", "    cumul[cle].add(valeur)\n", "print(cumul)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["Ou encore, un peu mieux, toujours avec `dict` mais en utilisant `setdefault` :"]}, {"block": 15, "type": "code", "linesLength": 4, "startIndex": 41, "lines": ["cumul = {}\n", "for cle, valeur in enregistrements:\n", "    cumul.setdefault(cle, set()).add(valeur)\n", "print(cumul)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["*****"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["Avec `defaultdict` on peut pr\u00e9ciser comment les valeurs doivent \u00eatre initialis\u00e9es, le code est plus lisible :"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 47, "lines": ["from collections import defaultdict\n", "\n", "# la valeur par d\u00e9faut est une liste vide\n", "cumul = defaultdict(set)\n", "for cle, valeur in enregistrements:\n", "    cumul[cle].add(valeur)\n", "print(cumul)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["### Autres types"]}, {"block": 21, "type": "markdown", "linesLength": 5, "startIndex": 56, "lines": ["R\u00e9f\u00e9rez-vous \u00e0 la section sur le [module `collections`](https://docs.python.org/3/library/collections.html) dans la documentation standard pour davantage de d\u00e9tails sur les autres types offerts par ce module, comme\n", " * [`Counter`](https://docs.python.org/3/library/collections.html#collections.Counter)\n", "une autre sp\u00e9cialisation du type `dict`, dont les valeurs sont des entiers, sp\u00e9cialis\u00e9e pour compter des occurrences;\n", " * [deque](https://docs.python.org/3/library/collections.html#collections.deque) une sp\u00e9cialisation du type `list` optimis\u00e9e pour ajouter/enlever des \u00e9l\u00e9ments aux deux extr\u00e9mit\u00e9s de la liste;\n", " * [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple) ici il ne s'agit pas d'un type \u00e0 proprement parler, mais d'une fonction qui permet de cr\u00e9er des types. "]}]
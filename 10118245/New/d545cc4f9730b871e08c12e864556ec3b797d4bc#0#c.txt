[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Compl\u00e9ments sur la construction de tuples"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Les tuples et la virgule terminale"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["Comme on l'a vu on peut construire un couple indiff\u00e9remment comme ceci"]}, {"block": 3, "type": "code", "linesLength": 3, "startIndex": 3, "lines": ["couple1 = 1,2\n", "couple2 = (1,2)\n", "couple1 == couple2"]}, {"block": 4, "type": "markdown", "linesLength": 3, "startIndex": 6, "lines": ["En r\u00e9alit\u00e9 la parenth\u00e8se est tout \u00e0 fait superf\u00e9tatoire, il se trouve toutefois qu'elle est largement utilis\u00e9e pour am\u00e9liorer la lisibilit\u00e9 des programmes.\n", "\n", "Ajoutons que la derni\u00e8re virgule est optionnelle - en g\u00e9n\u00e9ral, c'est-\u00e0-dire pour les tuples \u00e0 au moins 2 \u00e9l\u00e9ments. C'est-\u00e0-dire qu'on peut aussi bien \u00e9crire aussi:"]}, {"block": 5, "type": "code", "linesLength": 3, "startIndex": 9, "lines": ["couple3 = 1,2,\n", "couple4 = (1,2,)\n", "couple3 == couple4"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["Qui est bien \u00e9quivalent aussi aux deux premi\u00e8res formes"]}, {"block": 7, "type": "code", "linesLength": 1, "startIndex": 13, "lines": ["couple1 == couple3"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["En g\u00e9n\u00e9ral d'ailleurs, la forme avec virgule terminale est plus pratique. Consid\u00e9rez par exemple l'initialisation suivante; on veut cr\u00e9er un tuple qui contient des listes (naturellement un tuple peut contenir n'importe quel objet python), et comme c'est assez long on pr\u00e9f\u00e8re mettre un \u00e9l\u00e9ment du tuple par ligne:"]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 15, "lines": ["mon_tuple = ( [1,2,3],\n", "              [4,5,6],\n", "              [7,8,9],\n", "            )"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["L'avantage lorsqu'on choisit cette forme (avec parenth\u00e8ses, et avec virgule terminale), c'est que d'abord il n'est pas n\u00e9cessaire de mettre un backslash \u00e0 la fin de chaque ligne; parce que l'on est \u00e0 l'int\u00e9rieur d'une zone parenth\u00e9s\u00e9e, l'interpr\u00e9teur python \"sait\" que l'instruction n'est pas termin\u00e9e et va se continuer sur la ligne suivante. \n", "\n", "Deuxi\u00e8mement, si on doit ult\u00e9rieurement ajouter ou enlever un \u00e9l\u00e9ment dans le tuple, il suffira d'enlever ou d'ajouter toute une ligne, sans avoir \u00e0 s'occuper des virgules; si on avait choisi de ne pas faire figurer la virgule terminale, alors pour ajouter un item dans le tuple apr\u00e8s le dernier, il ne faut pas oublier d'ajouter une virgule \u00e0 la ligne pr\u00e9c\u00e9dente, etc... Cette simplicit\u00e9 se r\u00e9percute au niveau du getionnaire de code source, ou les diff\u00e9rences dans le code sont plus faciles \u00e0 visualiser."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Pour revenir \u00e0 pr\u00e9sent sur le cas des tuples \u00e0 un seul \u00e9l\u00e9ment, c'est un cas particulier; parmi les 4 syntaxes qu'on a vues ci-dessus, on obtiendrait dans ce cas"]}, {"block": 12, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["simple1 = 1\n", "simple2 = (1)\n", "simple3 = 1,\n", "simple4 = (1,)"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["Il est bien \u00e9vident que la premi\u00e8re forme ne cr\u00e9e pas de tuple; en fait la seconde non plus, python lit ceci comme une expression parenth\u00e9s\u00e9e, et en fait ces deux formes cr\u00e9ent un entier simple:"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["type(simple2)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Les deux autres formes cr\u00e9ent par contre toutes les deux un tuple \u00e0 un \u00e9l\u00e9ment comme on cherchait \u00e0 le faire:"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 30, "lines": ["type(simple3)"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["simple3 == simple4"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Pour conclure, disons donc qu'il est conseill\u00e9 de $\\textbf{toujours mentionner une virgule terminale}$ lorsqu'on construit des tuples"]}, {"block": 19, "type": "heading", "linesLength": 1, "startIndex": 33, "lines": ["Construire des tuples \u00e9labor\u00e9s"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["On a vu qu'un tuple est un objet non mutable, il faut donc n\u00e9c\u00e9ssairement le construire en une fois, et on ne peut pas le fabriquer incr\u00e9mentalement comme on l'a vu pour les listes."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Une astuce utile consiste \u00e0 penser aux fonctions de conversion, pour construire un tuple \u00e0 partir de - par exemple - une liste"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Ainsi il est tout \u00e0 fait possible par exemple de faire ceci"]}, {"block": 23, "type": "code", "linesLength": 8, "startIndex": 37, "lines": ["# on frabrique une liste pas \u00e0 pas\n", "liste = range (10)\n", "liste[9]='Inconnu'\n", "del liste [2:5]\n", "print 'la liste', liste\n", "# on convertit le r\u00e9sultat en tuple\n", "mon_tuple = tuple (liste)\n", "print 'le tuple', mon_tuple"]}, {"block": 24, "type": "heading", "linesLength": 1, "startIndex": 45, "lines": ["Digression sur les noms de fonctions pr\u00e9d\u00e9finies"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 46, "lines": ["$\\textit{Remarque}$. Vous avez peut-\u00eatre observ\u00e9 que nous avons choisi de ne pas appeler notre tuple simplement $\\texttt{tuple}$. C'est une bonne pratique en g\u00e9n\u00e9ral d'\u00e9viter les noms de fonctions pr\u00e9d\u00e9finies par python. \n", "\n", "Ces variables en effet sont des variables \"comme les autres\". Imaginez qu'on ait en fait deux tuples \u00e0 construire comme ci-dessus, voici ce qu'on obtiendrait si on n'avait pas pris cette pr\u00e9caution"]}, {"block": 26, "type": "code", "linesLength": 4, "startIndex": 49, "lines": ["liste = range(10)\n", "tuple = tuple(liste)\n", "autre_liste = range(100)\n", "autre_tuple = tuple (autre_liste)                    "]}, {"block": 27, "type": "markdown", "linesLength": 3, "startIndex": 53, "lines": ["Ce qui s'est pass\u00e9 ici c'est que nous avons remplac\u00e9 (ligne 2) la valeur de la variable 'tuple', qui au d\u00e9part pointait vers la fonction de conversion, par un objet tuple. Ainsi en ligne 4, lorsqu'on appelle \u00e0 nouveau 'tuple', on essaie d'ex\u00e9cuter un objet qui n'est pas 'appelable' (not callable en anglais).\n", "\n", "D'un autre cot\u00e9, l'erreur est relativement facile \u00e0 trouver dans ce cas, en cherchant toutes les occurences de 'tuple' dans notre propre code on voit assez vite le probl\u00e8me."]}]
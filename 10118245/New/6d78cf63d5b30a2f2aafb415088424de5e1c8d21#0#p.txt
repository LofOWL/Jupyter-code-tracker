[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `DataFrame` en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Cr\u00e9ation d'une DataFrame"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Une DataFrame est un tableau numpy \u00e0 deux dimension avec un index pour les lignes et un index pour les colonnes. Il y a de nombreuses mani\u00e8res de construire une DataFrame."]}, {"block": 5, "type": "code", "linesLength": 16, "startIndex": 10, "lines": ["# Regardons la construction d'une DataFrame\n", "import numpy as np\n", "import pandas as pd\n", "\n", "# Cr\u00e9ons une Serie pour d\u00e9finir des ages\n", "age = pd.Series([30, 20, 50], index=['alice', 'bob', 'julie'])\n", "\n", "# et une Serie pour d\u00e9finir des tailles\n", "height = pd.Series([150, 170, 168], index=['alice', 'marc', 'julie'])\n", "\n", "# On peut maintenant combiner ces deux Series en DataFrame,\n", "# chaque Series d\u00e9finissant une colonne, une mani\u00e8re de le faire est \n", "# de d\u00e9finir un dictionnaire qui contient pour clef le nom de la colonne\n", "# et pour valeur la Series correspondante\n", "stat = pd.DataFrame({'age': age, 'height':height})\n", "print(stat)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["On remarque que pandas fait automatiquement l'alignement des index, lorsqu'une valeur n'est pas pr\u00e9sente, elle est automatiquement remplac\u00e9e par `NaN`. Pandas va \u00e9galement broadcaster une valeur unique d\u00e9finissant un colonne sur toutes les lignes. Regardons cela"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["stat = pd.DataFrame({'age': age, 'height':height, 'city': 'Nice'})\n", "print(stat)"]}, {"block": 8, "type": "code", "linesLength": 7, "startIndex": 29, "lines": ["# On peut maitenant acc\u00e9der aux indexes des lignes et des colonnes\n", "\n", "# l'index des lignes\n", "print(stat.index)\n", "\n", "# l'index des colonnes\n", "print(stat.columns)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Il y a de nombreuses mani\u00e8res d'acc\u00e9der maintenant aux \u00e9l\u00e9ments de la DataFrame, certaines sont bonnes et d'autres \u00e0 proscrire, commen\u00e7ons par prendre de bonnes habitudes. Comme il s'agit d'une structure \u00e0 deux dimensions, il faut donner un indice de ligne et de colonne."]}, {"block": 10, "type": "code", "linesLength": 7, "startIndex": 37, "lines": ["# Quel est l'age de alice\n", "a = stat.loc['alice', 'age']\n", "print(f\"l'age de alice est : {a}\")\n", "\n", "# Quel est la moyenne de tous les ages\n", "m = stat.loc[:, 'age'].mean()\n", "print(f\"L'age moyen est de {m:.1f} ans\")"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["stat.loc[:, 'age'].mean()"]}, {"block": 12, "type": "markdown", "linesLength": 4, "startIndex": 45, "lines": ["On peut d\u00e9j\u00e0 noter plusieurs choses int\u00e9ressantes\n", "\n", " - On peut utiliser `.loc[]` et `.iloc` comme pour les Series. Pour les DataFrame c'est encore plus important parce qu'il y a plus de risques d'ambigu\u00eft\u00e9s (notamment entre les lignes et le colonnes, on y reviendra). \n", " - la m\u00e9thode `mean` calcule la moyenne, \u00e7a n'est pas surprenant, mais ignore les `NaN`. C'est en g\u00e9n\u00e9ral ce que l'on veut. Si vous vous demandez comment savoir si la m\u00e9thode que vous utilisez ignore ou pas les `NaN`, le mieux est de regarder l'aide de cette m\u00e9thode. Il existe pour un certain nombre de m\u00e9thodes deux versions : une qui ignore les `NaN` et une autre qui les prend en compte&nbsp;; on reviendra dessus."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Une autre mani\u00e8re de construire une DataFrame est de partir d'un array numpy et de sp\u00e9cifier les indexes pour les lignes et les colonnes avec les arguments `index` et `columns`"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["a = np.random.randint(1, 20, 9).reshape(3,3)\n", "p = pd.DataFrame(a, index=['a', 'b', 'c'], columns=['x', 'y', 'z'])\n", "print(p)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["### Manipulation d'une DataFrame"]}, {"block": 16, "type": "code", "linesLength": 13, "startIndex": 54, "lines": ["# contruisons maintenant une DataFrame jouet\n", "\n", "# voici une liste de pr\u00e9noms\n", "names = ['alice', 'bob', 'marc', 'bill', 'sonia']\n", "\n", "# cr\u00e9ons trois Series qui formeront trois colonnes\n", "age = pd.Series([12, 13, 16, 11, 16], index=names)\n", "height = pd.Series([130, 140, 176, 120, 165], index=names)\n", "sex = pd.Series(list('fmmmf'), index=names)\n", "\n", "# cr\u00e9ons maintenant la DataFrame\n", "p = pd.DataFrame({'age':age, 'height':height, 'sex':sex})\n", "print(p)"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["# et chargeons le jeux de donn\u00e9es sur les pourboires de seaborn\n", "import seaborn as sns\n", "tips = sns.load_dataset('tips')"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Pandas offre de nombreuses possibilit\u00e9s d'explorer les donn\u00e9es. Attention, dans mes exemples je vais alterner entre le DataFrame `p` et le DataFrame `tips` suivant les besoins de l'explication. "]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["# afficher les premi\u00e8res lignes \n", "tips.head()"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 73, "lines": ["# et les derni\u00e8re lignes\n", "tips.tail()"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 75, "lines": ["# afficher l'index des lignes\n", "p.index"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["# et de colonnes\n", "p.columns"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# transposer \n", "p.T"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 81, "lines": ["# et afficher uniquement les valeurs\n", "p.values"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Pour finir, il y a la m\u00e9thodes `describe` qui permet d'obtenir des premi\u00e8res statistiques sur un DataFrame. `describe` permet de calculer des statistiques sur des type num\u00e9riques, mais aussi sur des types cha\u00eenes de caract\u00e8res. "]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["# par d\u00e9faut describe ne prend en compte que les colonnes num\u00e9riques\n", "p.describe()"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["# mais on peut le forcer en prendre en compte toutes les colonnes\n", "p.describe(include='all')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["### Requ\u00eates sur une DataFrame"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["On peut maintenant commencer \u00e0 faire des requ\u00eates sur les DataFrames. Les DataFrame supportent la notion de masque que l'on a vue pour les ndarray numpy et pour les Series. "]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["# p.loc prend soit un label de ligne\n", "print(p.loc['sonia'])"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["# ou alors un label de ligne ET de colonne\n", "print(p.loc['sonia', 'age'])"]}, {"block": 32, "type": "markdown", "linesLength": 12, "startIndex": 94, "lines": ["On peut mettre \u00e0 la place d'une label :\n", "\n", " - une liste de labels\n", " - un slice sur les labels\n", " - un masque (c'est-\u00e0-dire un tableau de bool\u00e9ens)\n", " - un callable qui retourne une des trois premi\u00e8res possibilit\u00e9s\n", " \n", "Noter que l'on peut \u00e9galement utiliser la notation `.iloc[]` avec les m\u00eames r\u00e8gles, mais elle est moins utile. \n", "\n", "Je recommande de toujours utiliser la notation `.loc[lignes, colonnes]` pour \u00e9viter toute ambigu\u00eft\u00e9. Nous verrons que les notations `.loc[lignes]` ou pire seulement `[label]` sont sources d'erreurs.\n", "\n", "Regardons maintenant d'autres exemples plus sophistiqu\u00e9s."]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 106, "lines": ["# gardons uniquement les femmes\n", "p.loc[p.loc[:,'sex']=='f',:]"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 108, "lines": ["# gardons uniquement les femmes de plus de 12 ans\n", "p.loc[(p.loc[:,'sex']=='f') & (p.loc[:, 'age'] > 12), :]"]}, {"block": 35, "type": "code", "linesLength": 16, "startIndex": 110, "lines": ["# quelle est la note moyenne des femmes\n", "note_f = tips.loc[tips.loc[:,'sex']=='Female', 'total_bill'].mean()\n", "print(f\"note moyenne des femmes : {note_f:.2f}\")\n", "\n", "# quelle est la note moyenne des hommes\n", "note_h = tips.loc[tips.loc[:,'sex']=='Male', 'total_bill'].mean()\n", "print(f\"note moyenne des hommes : {note_h:.2f}\")\n", "\n", "# qui laisse le plus grand pourcentage de pourboire : \n", "# les hommes ou les femmes\n", "\n", "pourboire_f  = tips.loc[tips.loc[:,'sex']=='Female', 'tip'].mean()\n", "pourboire_h  = tips.loc[tips.loc[:,'sex']=='Male', 'tip'].mean()\n", "\n", "print(f\"Les femmes laissent {pourboire_f/note_f:.2%} de pourboire\")\n", "print(f\"Les hommes laissent {pourboire_h/note_h:.2%} de pourboire\")"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["### Erreurs fr\u00e9quentes et ambigu\u00eft\u00e9s sur les requ\u00eates"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 127, "lines": ["Nous avons vu une mani\u00e8re simple et non ambigu\u00eb de faire des requ\u00eates sur les DataFrame, mais nous allons voir qu'il existe d'autres mani\u00e8res qui ont pour seul avantage d'\u00eatre plus concise, mais sources de nombreuses erreurs. \n", "\n", "**Souvenez-vous, utilisez toujours la notation `.loc[lignes, colonnes]` sinon, soyez s\u00fbr de savoir ce qui est r\u00e9ellement calcul\u00e9**."]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 130, "lines": ["# commen\u00e7ons par la notation la plus classique\n", "p['sex'] # prend forc\u00e9ment un label de colonne"]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 132, "lines": ["# mais par contre, si on passe un slice, c'est forc\u00e9ment des lignes\n", "p['alice': 'marc']"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 134, "lines": ["# on peut m\u00eame directement acc\u00e9der \u00e0 une colonne par son nom\n", "p.age"]}, {"block": 41, "type": "code", "linesLength": 7, "startIndex": 136, "lines": ["# mais il ne faut jamais le faire parce que si un attribut de m\u00eame \n", "# nom existe sur une DataFrame, alors la priorit\u00e9 est donn\u00e9e \u00e0 l'attribut\n", "# et non \u00e0 la colonne\n", "\n", "# ajoutons une colonne qui a pour nom une m\u00e9thode sur les DataFrame\n", "p['mean'] = 1\n", "print(p)"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 143, "lines": ["# je peux bien acc\u00e9der \u00e0 la colonne sex\n", "p.sex"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 145, "lines": ["# mais pas \u00e0 la colonne mean\n", "p.mean"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["# de nouveau, la seule m\u00e9thode non ambigu\u00eb est d'utiliser .loc\n", "p.loc[:,'mean']"]}, {"block": 45, "type": "code", "linesLength": 4, "startIndex": 149, "lines": ["# supprimons maintenant la colonne mean en place (sinon drop retourne\n", "# une nouvelle DataFrame)\n", "p.drop(columns='mean', inplace=True)\n", "print(p)"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 153, "lines": ["p"]}, {"block": 47, "type": "code", "linesLength": 0, "startIndex": 154, "lines": []}, {"block": 48, "type": "code", "linesLength": 0, "startIndex": 154, "lines": []}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Une limite de la boucle `for`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 7, "lines": ["Pour ceux qui veulent suivre le cours au niveau basique, retenez seulement que dans une boucle `for` sur un objet mutable, **il ne faut pas modifier le sujet** de la boucle.\n", "\n", "Ainsi par exemple il ne **faut pas faire** quelque chose comme ceci\u00a0:"]}, {"block": 4, "type": "code", "linesLength": 3, "startIndex": 10, "lines": ["# on veut enlever de l'ensemble toutes les cha\u00eenes \n", "# qui ne contiennent pas 'bert'\n", "ensemble = {'marc', 'albert'}"]}, {"block": 5, "type": "code", "linesLength": 6, "startIndex": 13, "lines": ["# ceci semble une bonne id\u00e9e mais ne fonctionne pas\n", "# provoque RuntimeError: Set changed size during iteration\n", "\n", "for valeur in ensemble:\n", "    if 'bert' not in valeur:\n", "        ensemble.discard(valeur)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["### Comment faire alors\u00a0?"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Premi\u00e8re remarque, votre premier r\u00e9flexe pourrait \u00eatre de penser \u00e0 une compr\u00e9hension d'ensemble\u00a0:"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 21, "lines": ["ensemble2 = {valeur for valeur in ensemble if 'bert' in valeur}\n", "ensemble2"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["C'est sans doute la meilleure solution. Par contre, \u00e9videmment, on n'a pas modifi\u00e9 l'objet ensemble initial, on a cr\u00e9\u00e9 un nouvel objet. En supposant que l'on veuille modifier l'objet initial, il nous faut faire la boucle sur une *shallow copy* de cet objet. Notez qu'ici, il ne s'agit d'\u00e9conomiser de la m\u00e9moire, puisque l'on fait une *shallow copy*."]}, {"block": 10, "type": "code", "linesLength": 11, "startIndex": 24, "lines": ["from copy import copy\n", "# on veut enlever de l'ensemble toutes les cha\u00eenes \n", "# qui ne contiennent pas 'bert'\n", "ensemble = {'marc', 'albert'}\n", "\n", "# si on fait d'abord une copie tout va bien\n", "for valeur in copy(ensemble):\n", "    if 'bert' not in valeur:\n", "        ensemble.discard(valeur)\n", "        \n", "print(ensemble)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["### Avertissement"]}, {"block": 12, "type": "markdown", "linesLength": 3, "startIndex": 36, "lines": ["Dans l'exemple ci-dessus, on voit que l'interpr\u00e9teur se rend compte que l'on est en train de modifier l'objet de la boucle, et nous le signifie.\n", "\n", "Ne vous fiez pas forc\u00e9ment \u00e0 cet exemple, il existe des cas -- nous en verrons plus loin dans ce document -- o\u00f9 l'interpr\u00e9teur peut accepter votre code alors qu'il n'ob\u00e9it pas \u00e0 cette r\u00e8gle, et du coup essentiellement se mettre \u00e0 faire n'importe quoi."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["### Pr\u00e9cisons bien la limite"]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 40, "lines": ["Pour \u00eatre tout \u00e0 fait clair, lorsqu'on dit qu'il ne faut pas modifier l'objet de la boucle `for`, il ne s'agit que du premier niveau. \n", "\n", "On ne doit pas modifier la **composition de l'objet en tant qu'it\u00e9rable**, mais on peut sans souci modifier chacun des objets qui constitue l'it\u00e9ration.\n", "\n", "Ainsi cette construction par contre est tout \u00e0 fait valide\u00a0:"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 45, "lines": ["liste = [[1], [2], [3]]\n", "print('avant', liste)"]}, {"block": 16, "type": "code", "linesLength": 3, "startIndex": 47, "lines": ["for sous_liste in liste:\n", "    sous_liste.append(100)\n", "print('apr\u00e8s', liste)"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["Dans cet exemple, les modifications ont lieu sur les \u00e9l\u00e9ments de `liste`, et non sur l'objet `liste` lui-m\u00eame, c'est donc tout \u00e0 fait l\u00e9gal."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["Pour bien comprendre la nature de cette limitation, il faut bien voir que cela soul\u00e8ve deux types de probl\u00e8mes distincts."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["### Difficult\u00e9 d'ordre s\u00e9mantique"]}, {"block": 21, "type": "markdown", "linesLength": 10, "startIndex": 54, "lines": ["D'un point de vue s\u00e9mantique, si l'on voulait autoriser ce genre de choses, il faudrait d\u00e9finir tr\u00e8s pr\u00e9cis\u00e9ment le comportement attendu.\n", "\n", "Consid\u00e9rons par exemple la situation d'une liste qui a 10 \u00e9l\u00e9ments, sur laquelle on ferait une boucle et que, par exemple au 5\u00e8me \u00e9l\u00e9ment, on enl\u00e8ve le 8\u00e8me \u00e9l\u00e9ment. Quel serait le comportement attendu dans ce cas\u00a0? Faut-il ou non que la boucle envisage alors le 8-\u00e8me \u00e9l\u00e9ment\u00a0?\n", "\n", "La situation serait encore pire pour les dictionnaires et ensembles pour lesquels l'ordre de parcours n'est pas sp\u00e9cifi\u00e9\u00a0; ainsi on pourrait \u00e9crire du code totalement ind\u00e9terministe si le parcours d'un ensemble essayait\u00a0:\n", "\n", " * d'enlever l'\u00e9l\u00e9ment *b* lorsqu'on parcourt l'\u00e9l\u00e9ment *a*\u00a0;\n", " * d'enlever l'\u00e9l\u00e9ment *a* lorsqu'on parcourt l'\u00e9l\u00e9ment *b*.\n", " \n", "On le voit, il n'est d\u00e9j\u00e0 pas tr\u00e8s simple d'expliciter sans ambigu\u00eft\u00e9 le comportement attendu d'une boucle `for` qui serait autoris\u00e9e \u00e0 modifier son propre sujet. "]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["### Difficult\u00e9 d'impl\u00e9mentation"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Voyons maintenant un exemple de code qui ne respecte pas la r\u00e8gle, et qui modifie le sujet de la boucle en lui ajoutant des valeurs"]}, {"block": 24, "type": "markdown", "linesLength": 7, "startIndex": 66, "lines": ["```\n", "# cette boucle ne termine pas\n", "liste = [1, 2, 3]\n", "for c in liste:\n", "    if c == 3:\n", "        liste.append(c)\n", "```"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Nous avons volontairement mis ce code **dans une cellule de texte** et non de code\u00a0: vous **ne pouvez pas l'ex\u00e9cuter** dans le notebook. Si vous essayez de l'ex\u00e9cuter sur votre ordinateur vous constaterez que la boucle ne termine pas : en fait \u00e0 chaque it\u00e9ration on ajoute un nouvel \u00e9l\u00e9ment dans la liste, et du coup la boucle a un \u00e9l\u00e9ment de plus \u00e0 balayer\u00a0; ce programme ne termine th\u00e9oriquement jamais. En pratique, ce sera le cas quand votre syst\u00e8me n'aura plus de m\u00e9moire disponible (sauvegardez vos documents avant d'essayer !)."]}]
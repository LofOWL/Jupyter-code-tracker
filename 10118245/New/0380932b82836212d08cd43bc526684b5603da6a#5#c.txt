[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Surcharge d'op\u00e9rateurs (1)"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 11, "startIndex": 7, "lines": ["Ce compl\u00e9ment vise \u00e0 illustrer certaines des possibilit\u00e9s de surcharge d'op\u00e9rateurs, ou plus g\u00e9n\u00e9ralement les m\u00e9canismes disponibles pour \u00e9tendre le langage et donner un sens \u00e0 des fragments de code comme:\n", " * `objet1 + objet2`\n", " * `item in objet`\n", " * `objet[key]`\n", " * `objet.key`\n", " * `for i in objet:`\n", " * `if objet:`\n", " * `objet(arg1, arg2)`  (et non pas `classe(arg1, arg2)`)\n", " * etc..\n", "\n", "que jusqu'ici, sauf pour la boucle `for` et pour le hachage, on n'a expliqu\u00e9 que pour des objets de type pr\u00e9d\u00e9fini."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Le m\u00e9canisme g\u00e9n\u00e9ral pour cela consiste \u00e0 d\u00e9finir des **m\u00e9thodes sp\u00e9ciales**, avec un nom en `__nom__`. Il existe un total de pr\u00e8s de 80 m\u00e9thodes dans ce syst\u00e8me de surcharges, aussi il n'est pas question ici d'\u00eatre exhaustif. Vous trouverez [dans ce document une liste compl\u00e8te de ces possibilit\u00e9s](https://docs.python.org/3/reference/datamodel.html#specialnames)."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Il nous faut \u00e9galement signaler que les m\u00e9canismes mis en jeu ici sont **de difficult\u00e9s assez variables**. Dans le cas le plus simple il suffit de d\u00e9finir une m\u00e9thode sur la classe pour obtenir le r\u00e9sultat (par exemple, d\u00e9finir `__call__` pour rendre un objet callable). Mais parfois on parle d'un ensemble de m\u00e9thodes qui doivent \u00eatre coh\u00e9rentes, voyez par exemple les [descriptors](https://docs.python.org/3/reference/datamodel.html#invoking-descriptors) qui mettent en jeu les m\u00e9thodes `__get__`, `__set__` et `__delete__`, et qui peuvent sembler particuli\u00e8rement cryptiques. On aura d'ailleurs l'occasion d'approfondir les descriptors en semaine 9 avec les sujets avanc\u00e9s."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 20, "lines": ["Nous vous conseillons de commencer par des choses simples, et surtout de n'utiliser ces techniques que lorsqu'elles apportent vraiment quelque chose. Le constructeur et l'affichage sont pratiquement toujours d\u00e9finis, mais pour tout le reste il convient d'utiliser ces traits avec le plus grand discernement. Dans tous les cas \u00e9crivez votre code avec la documentation sous les yeux, c'est plus prudent :)"]}, {"block": 7, "type": "markdown", "linesLength": 2, "startIndex": 21, "lines": ["Nous avons essay\u00e9 de pr\u00e9senter cette s\u00e9lection par difficult\u00e9 croissante. \n", "Par ailleurs, et pour all\u00e9ger la pr\u00e9sentation, cet expos\u00e9 a \u00e9t\u00e9 coup\u00e9 en trois notebooks diff\u00e9rents."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["*****"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["### Rappels"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 25, "lines": ["Pour rappel, on a vu dans la vid\u00e9o:\n", " * la m\u00e9thode `__init__` pour d\u00e9finir un **constructeur**, \n", " * et la m\u00e9thode `__str__` pour d\u00e9finir comment une instance s'imprime avec `print`."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["### Affichage : `__repr__` et `__str__`"]}, {"block": 12, "type": "markdown", "linesLength": 4, "startIndex": 29, "lines": ["Nous commen\u00e7ons par signaler la m\u00e9thode `__repr__` qui est assez voisine de `__str__`, et qui donc doit retourner un objet de type cha\u00eene de caract\u00e8res, sauf que:\n", " * `__str__` est utilis\u00e9e par `print` (affichage orient\u00e9 utilisateur du programme; priorit\u00e9 au confort visuel),\n", " * alors que `__repr__` est utilis\u00e9e par la fonction `repr()` (affichage orient\u00e9 programmeur, aussi peu ambigu que possible);\n", " * enfin il faut savoir que `__repr__` est utilis\u00e9e **aussi** par `print` si `__str__` n'est pas d\u00e9finie."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Pour cette derni\u00e8re raison, on trouve dans la nature `__repr__` plut\u00f4t plus souvent que `__str__`; voyez [ce lien](https://docs.python.org/3/reference/datamodel.html#object.__repr__) pour davantage de d\u00e9tails. "]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["##### Quand est utilis\u00e9e `repr()`"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["`repr()` est utilis\u00e9e massivement dans les informations de debugging comme les traces de pile lorsqu'une exception est lev\u00e9e. Elle est aussi utilis\u00e9e lorsque vous affichez un objet sans passer par `print`, c'est-\u00e0-dire par exemple: "]}, {"block": 16, "type": "code", "linesLength": 8, "startIndex": 36, "lines": ["class Foo: \n", "    def __repr__(self):\n", "        return 'custom repr'\n", "    \n", "foo = Foo()\n", "# lorsque vous affichez un objet comme ceci\n", "foo\n", "# en fait vous utilisez repr()"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["##### Deux exemples"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Voici deux exemples simples de classes; dans le premier on n'a d\u00e9fini que `__repr__`, dans le second on a red\u00e9fini les deux m\u00e9thodes:"]}, {"block": 19, "type": "code", "linesLength": 16, "startIndex": 46, "lines": ["# une classe qui ne d\u00e9finit que __repr__\n", "class Point:\n", "    \"premi\u00e8re version de Point - on ne d\u00e9finit que __repr__\"\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "    def __repr__(self):\n", "        return f\"Point({self.x},{self.y})\"\n", "    \n", "point = Point (0,100)\n", "\n", "print(\"avec print\", point)\n", "\n", "# si vous affichez un objet sans passer par print\n", "# vous utilisez repr()\n", "point"]}, {"block": 20, "type": "code", "linesLength": 21, "startIndex": 62, "lines": ["# la m\u00eame chose mais o\u00f9 on red\u00e9finit __str__ et __repr__\n", "class Point2:\n", "    \"seconde version de Point - on d\u00e9finit __repr__ et __str__\"\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "    def __repr__(self):\n", "        return f\"Point2({self.x},{self.y})\"\n", "    def __str__(self):\n", "        return f\"({self.x},{self.y})\"\n", "    \n", "point2 = Point2 (0,100)\n", "\n", "print(\"avec print\", point2)\n", "\n", "# les f-strings (ou format) utilisent aussi __str__\n", "print(f\"avec format {point2}\")\n", "\n", "# et si enfin vous affichez un objet sans passer par print\n", "# vous utilisez repr()\n", "point2"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["*****"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 84, "lines": ["### `__bool__`"]}, {"block": 23, "type": "markdown", "linesLength": 11, "startIndex": 85, "lines": ["Vous vous souvenez que la condition d'un test dans un `if` peut ne pas retourner un bool\u00e9en (nous avons vu cela en Semaine 4, S\u00e9quence \"Test if/elif/else et op\u00e9rateurs bool\u00e9ens\"). Nous avions not\u00e9 que pour les types pr\u00e9d\u00e9finis, sont consid\u00e9r\u00e9s comme *faux* les objets: `None`, la liste vide, un tuple vide, etc.\n", "\n", "Avec `__bool__` on peut red\u00e9finir le comportement des objets d'une classe vis-\u00e0-vis des conditions - ou si l'on pr\u00e9f\u00e8re, quel doit \u00eatre le r\u00e9sultat de `bool(instance)`.\n", "\n", "**Attention** pour \u00e9viter les comportements impr\u00e9vus, comme on est en train de red\u00e9finir le comportement des conditions, il **faut** renvoyer un **bool\u00e9en** (ou \u00e0 la rigueur 0 ou 1), on ne peut pas dans ce contexte retourner d'autres types d'objet.\n", "\n", "Nous allons **illustrer** cette m\u00e9thode dans un petit moment avec une nouvelle impl\u00e9mentation de la classe **`Matrix2`**.\n", "\n", "Remarquez enfin qu'en l'absence de m\u00e9thode `__bool__`, on cherche aussi la m\u00e9thode `__len__` pour d\u00e9terminer le r\u00e9sultat du test; une instance de longueur nulle est alors consid\u00e9r\u00e9 comme `False`, en coh\u00e9rence avec ce qui se passe avec les types *builtin* `list`, `dict`, `tuple`, etc.\n", "\n", "Ce genre de *protocole*, qui cherche d'abord une m\u00e9thode (`__bool__`), puis une autre (`__len__`) en cas d'absence de la premi\u00e8re, est relativement fr\u00e9quent dans la m\u00e9canique de surcharge des op\u00e9rateurs; c'est entre autres pourquoi la documentation est indispensable lorsqu'on surcharge les op\u00e9rateurs."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["### `__add__` et apparent\u00e9s (`__mul__`, `__sub__`, `__div__`, `__and__`, etc.)"]}, {"block": 25, "type": "markdown", "linesLength": 10, "startIndex": 97, "lines": ["On peut \u00e9galement red\u00e9finir les op\u00e9rateurs arithm\u00e9tiques et logiques. Dans l'exemple qui suit, nous allons l'illustrer sur l'addition de matrices. On rappelle pour m\u00e9moire que:\n", "\n", "$\\left( \\begin{array}{cc} a_{11} & a_{12} \\\\\n", "a_{21} & a_{22}\\end{array} \\right) \n", "+\n", "\\left( \\begin{array}{cc} b_{11} & b_{12} \\\\\n", "b_{21} & b_{22}\\end{array} \\right) \n", "= \n", "\\left( \\begin{array}{cc} a_{11}+b_{11} & a_{12}+b_{12} \\\\\n", "a_{21}+b_{21} & a_{22}+b_{22}\\end{array} \\right)$"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["### Une nouvelle version de la classe `Matrix2`"]}, {"block": 27, "type": "markdown", "linesLength": 8, "startIndex": 108, "lines": ["Voici (encore) une nouvelle impl\u00e9mentation de la classe de matrices 2x2, qui illustre cette fois:\n", " * la possibilit\u00e9 d'ajouter deux matrices;\n", " * la possibilit\u00e9 de faire un test sur une matrice - le test sera faux si la matrice a tous ses coefficients nuls;\n", " * et, bien que ce ne soit pas le sujet imm\u00e9diat, cette impl\u00e9mentation illustre aussi la possibilit\u00e9 de construire la matrice \u00e0 partir:\n", "   * soit des 4 coefficients, comme par exemple: `Matrix2(a, b, c, d)`\n", "   * soit d'une s\u00e9quence , comme par exemple: `Matrix2(range(4))`\n", " \n", " Cette derni\u00e8re possibilit\u00e9 va nous permettre de simplifier le code de l'addition, comme on va le voir."]}, {"block": 28, "type": "code", "linesLength": 40, "startIndex": 116, "lines": ["# notre classe Matrix2 avec encore une autre impl\u00e9mentation\n", "class Matrix2:\n", "\n", "    def __init__(self, *args):\n", "        \"\"\"\n", "        le constructeur accepte \n", "        (*) soit les 4 coefficients individuellement\n", "        (*) soit une liste - ou + g\u00e9n\u00e9ralement une s\u00e9quence - des m\u00eames\n", "        \"\"\"\n", "        # on veut pouvoir cr\u00e9er l'objet \u00e0 partir des 4 coefficients\n", "        # souvenez-vous qu'avec la forme *args, args est toujours un tuple\n", "        if len(args) == 4:\n", "            self.coefs = args\n", "        # ou bien d'une s\u00e9quence de 4 coefficients\n", "        elif len(args) == 1:\n", "            self.coefs = tuple(*args)\n", "\n", "    def __repr__(self):\n", "        \"l'affichage\"\n", "        return \"[\" + \", \".join([str(c) for c in self.coefs]) + \"]\"\n", "\n", "    def __add__(self, other):\n", "        \"\"\"\n", "        l'addition de deux matrices retourne un nouvel objet\n", "        la possibilit\u00e9 de cr\u00e9er une matrice \u00e0 partir\n", "        d'une liste rend ce code beaucoup plus facile a \u00e9crire\n", "        \"\"\"\n", "        return Matrix2([a + b for a, b in zip(self.coefs, other.coefs)])\n", "\n", "    def __bool__(self):\n", "        \"\"\"\n", "        on consid\u00e8re que la matrice est non nulle \n", "        si un au moins de ses coefficients est non nul\n", "        \"\"\"\n", "        # ATTENTION le retour doit \u00eatre un bool\u00e9en \n", "        # ou \u00e0 la rigueur 0 ou 1\n", "        for c in self.coefs:\n", "            if c:\n", "                return True\n", "        return False"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 156, "lines": ["On peut \u00e0 pr\u00e9sent cr\u00e9er deux objets, les ajouter, et v\u00e9rifier que la matrice nulle se comporte bien comme attendu:"]}, {"block": 30, "type": "code", "linesLength": 17, "startIndex": 157, "lines": ["zero     = Matrix2 ([0,0,0,0])\n", "\n", "matrice1 = Matrix2 (1,2,3,4)\n", "matrice2 = Matrix2 (list(range(10,50,10)))\n", "\n", "print('avant matrice1', matrice1)\n", "print('avant matrice2', matrice2)\n", "\n", "print('somme', matrice1 + matrice2)\n", "\n", "print('apr\u00e8s matrice1', matrice1)\n", "print('apr\u00e8s matrice2', matrice2)\n", "\n", "if matrice1: \n", "    print(matrice1,\"n'est pas nulle\")\n", "if not zero: \n", "    print(zero,\"est nulle\")"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 174, "lines": ["Voici en vrac quelques commentaires sur cet exemple."]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 175, "lines": ["##### Utiliser un tuple"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 176, "lines": ["Avant de parler de la surcharge des op\u00e9rateurs *per se*, vous remarquerez que l'on range les coefficients dans un **tuple**, de fa\u00e7on \u00e0 ce que notre objet `Matrix2` soit ind\u00e9pendant de l'objet qu'on a utilis\u00e9 pour le cr\u00e9er (et qui peut \u00eatre ensuite modifi\u00e9 par l'appelant)."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 177, "lines": ["##### Cr\u00e9er un nouvel objet"]}, {"block": 35, "type": "markdown", "linesLength": 5, "startIndex": 178, "lines": ["Vous remarquez que l'addition `__add__` renvoie un **nouvel objet**, au lieu de modifier `self` en place. C'est la bonne fa\u00e7on de proc\u00e9der tout simplement parce que lorsqu'on \u00e9crit \n", "\n", "    print('somme', matrice1 + matrice2)\n", "\n", " on ne s'attend pas du tout \u00e0 ce que `matrice1` soit modifi\u00e9e apr\u00e8s cet appel. "]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 183, "lines": ["##### Du code qui ne d\u00e9pend que des 4 op\u00e9rations"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 184, "lines": ["Le fait d'avoir d\u00e9fini l'addition nous permet par exemple de b\u00e9n\u00e9ficier de la fonction *builtin* `sum`. En effet le code de `sum` fait lui-m\u00eame des additions, il n'y a donc aucune raison de ne pas pouvoir l'ex\u00e9cuter avec en entr\u00e9e un liste de matrices puisque maintenant on sait les additionner, (mais on a d\u00fb toutefois passer \u00e0 `sum` comme \u00e9l\u00e9ment neutre `zero`):"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 185, "lines": ["sum([matrice1, matrice2, matrice1] , zero)"]}, {"block": 39, "type": "markdown", "linesLength": 3, "startIndex": 186, "lines": ["C'est un effet de bord du typage dynamique. On ne v\u00e9rifie pas *a priori* que tous les arguments pass\u00e9s \u00e0 `sum` savent faire une addition; *a contrario*, si ils savent s'additionner on peut ex\u00e9cuter le code de `sum`.\n", "\n", "De mani\u00e8re plus g\u00e9n\u00e9rale, si vous \u00e9crivez par exemple un morceau de code qui travaille sur les \u00e9l\u00e9ments d'un anneau (au sens anneau des entiers $\\mathbb{Z}$) - imaginez un code qui factorise des polyn\u00f4mes - vous pouvez esp\u00e9rer utiliser ce code avec n'importe quel anneau, c'est \u00e0 dire avec une classe qui impl\u00e9mente les 4 op\u00e9rations (pourvu bien s\u00fbr que cet ensemble soit effectivement un anneau)."]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 189, "lines": ["##### On peut aussi red\u00e9finir un ordre"]}, {"block": 41, "type": "markdown", "linesLength": 4, "startIndex": 190, "lines": ["La place nous manque pour illustrer la possibilit\u00e9, avec les op\u00e9rateurs `__eq__`, `__ne__`, `__lt__`, `__le__`, `__gt__`, et `__ge__`, de red\u00e9finir un ordre sur les instances d'une classe.\n", "\n", "Signalons \u00e0 cet \u00e9gard qu'il existe un m\u00e9canisme \"intelligent\" qui permet de d\u00e9finir un ordre \u00e0 partir d'un sous-ensemble seulement de ces m\u00e9thodes, l'id\u00e9e \u00e9tant que si vous savez faire `>`\n", " et `=`, vous savez s\u00fbrement faire tout le reste. Ce m\u00e9canisme est [document\u00e9 ici](https://docs.python.org/3/library/functools.html#functools.total_ordering); il repose sur **un d\u00e9corateur** (`@total_ordering`), un m\u00e9canisme que nous \u00e9tudierons en semaine 7, mais que vous pouvez utiliser d\u00e8s \u00e0 pr\u00e9sent."]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 194, "lines": ["De mani\u00e8re analogue \u00e0 `sum` qui fonctionne sur une liste de matrices, si on avait d\u00e9fini un ordre sur les matrices, on aurait pu alors utiliser les *builtin* `min` et `max` pour calculer une borne sup\u00e9rieure ou inf\u00e9rieure dans une s\u00e9quence de matrices."]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 195, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 196, "lines": ["##### Le produit avec un scalaire"]}, {"block": 45, "type": "markdown", "linesLength": 11, "startIndex": 197, "lines": ["On impl\u00e9menterait la multiplication de deux matrices d'une fa\u00e7on identique (quoique plus fastidieuse naturellement). \n", "\n", "La multiplication d'une matrice par un scalaire (un r\u00e9el ou complexe pour fixer les id\u00e9es), comme ici:\n", "\n", "    matrice2 = reel * matrice1\n", "\n", "peut \u00eatre \u00e9galement r\u00e9alis\u00e9e par surcharge de l'op\u00e9rateur `__rmul__`.\n", "\n", "Il s'agit d'une astuce, destin\u00e9e pr\u00e9cis\u00e9ment \u00e0 ce genre de situations, o\u00f9 on veut \u00e9tendre la classe de l'op\u00e9rande de **droite**, sachant que dans ce cas pr\u00e9cis l'op\u00e9rande de gauche est un type de base, qu'on ne peut pas \u00e9tendre (les classes *builtin* sont non mutables, pour garantir la stabilit\u00e9 de l'interpr\u00e9teur).\n", "\n", "Voici donc comment on s'y prendrait. Pour \u00e9viter de reproduire tout le code de la classe, on va l'\u00e9tendre \u00e0 la vol\u00e9e."]}, {"block": 46, "type": "code", "linesLength": 12, "startIndex": 208, "lines": ["# remarquez que les op\u00e9randes sont apparemment invers\u00e9s\n", "# dans le sens o\u00f9 pour evaluer \n", "#     reel * matrice\n", "# on \u00e9crit une m\u00e9thode qui prend en argument\n", "#   la matrice, puis le r\u00e9el\n", "# mais n'oubliez pas qu'on est en fait en train\n", "# d'\u00e9crire une m\u00e9thode sur la classe `Matrix2`\n", "def multiplication_scalaire(self, alpha):\n", "    return Matrix2 ([alpha * coef for coef in self.coefs])\n", "\n", "# on ajoute la m\u00e9thode sp\u00e9ciale __rmul__\n", "Matrix2.__rmul__ = multiplication_scalaire"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 220, "lines": ["matrice1"]}, {"block": 48, "type": "code", "linesLength": 1, "startIndex": 221, "lines": ["12 * matrice1"]}]
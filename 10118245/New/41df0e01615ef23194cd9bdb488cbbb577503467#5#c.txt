[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Le *broadcasting*"]}, {"block": 2, "type": "code", "linesLength": 1, "startIndex": 6, "lines": ["import numpy as np"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["Lorsqu'on a parl\u00e9 de programmation vectorielle, on a vu qu'on pouvait \u00e9crire quelque chose comme ceci\u00a0:"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 9, "lines": ["X = np.linspace(0, 2 * np.pi)\n", "Y = np.cos(X) + np.sin(X) + 2"]}, {"block": 6, "type": "markdown", "linesLength": 3, "startIndex": 11, "lines": ["Je vous fais remarquer que dans cette derni\u00e8re ligne on combine\u00a0:\n", "* deux tableaux de m\u00eames tailles - quand on ajoute `np.cos(X)` avec `np.sin(X)`,\n", "* ou un tableau avec un scalaire - quand on ajoute `2` au r\u00e9sultat."]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 14, "lines": ["En fait le *broadcasting* est ce qui permet\u00a0:\n", "* d'unifier le sens de ces deux op\u00e9rations,\n", "* et m\u00eame de donner du sens \u00e0 des cas plus g\u00e9n\u00e9raux, o\u00f9 on fait des op\u00e9rations entre des tableaux qui ont des *tailles diff\u00e9rentes*, mais assez semblables pour qu'on puisse tout de m\u00eame les combiner."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["## Exemples en 2D"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Nous allons commencer par quelques exemples simples, avant de g\u00e9n\u00e9raliser le m\u00e9canisme. Nous nous donnons pour commencer un tableau de base\u00a0:"]}, {"block": 10, "type": "code", "linesLength": 1, "startIndex": 19, "lines": ["a = 100 * np.ones((3, 5), dtype=np.int32); print(a)"]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 20, "lines": ["Je vais illustrer le broadcasting avec l'op\u00e9ration `+`, mais bien entendu ce m\u00e9canisme est \u00e0 l'\u0153uvre d\u00e8s que vous faites des op\u00e9rations entre deux tableaux qui n'ont pas les m\u00eames dimensions.\n", "\n", "Pour commencer je vais donc ajouter \u00e0 mon tableau de base un scalaire\u00a0:"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["### Broadcasting entre les dimensions `(3, 5)` et `(1,)`"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["print(a)"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 25, "lines": ["b = 3\n", "print(b)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["***"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Lorsque j'ajoute ces deux tableaux, c'est comme si j'avais ajout\u00e9 \u00e0 `a` la diff\u00e9rence\u00a0:"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 29, "lines": ["# pour \u00e9laborer c\n", "c = a + b\n", "print(c)"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 32, "lines": ["# c'est comme si j'avais\n", "# ajout\u00e9 \u00e0 a ce terme-ci\n", "print(c - a)"]}, {"block": 19, "type": "markdown", "linesLength": 5, "startIndex": 35, "lines": ["C'est un premier cas particulier de *broadcasting* dans sa version extr\u00eame.\n", "\n", "Le scalaire `b`, qui est en l'occurrence consid\u00e9r\u00e9 comme un tableau dont le `shape` vaut `(1,)`, est dupliqu\u00e9 dans les deux directions jusqu'\u00e0 obtenir ce tableau uniforme de taille `(5, 3)` et qui contient un `3` partout.\n", "\n", "Et c'est ce tableau, qui est maintenant de la m\u00eame taille que `a`, qui est ajout\u00e9 \u00e0 `a`."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["Je pr\u00e9cise que cette explication est du domaine du mod\u00e8le p\u00e9dagogique\u00a0; je ne dis pas que l'impl\u00e9mentation va r\u00e9ellement allouer un second tableau, bien \u00e9videmment on peut optimiser pour \u00e9viter cette construction inutile."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["### Broadcasting `(3, 5)` et `(5,)`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Voyons maintenant un cas un peu moins \u00e9vident. Je peux ajouter \u00e0 mon tableau de base une ligne, c'est-\u00e0-dire un tableau de taille `(5, )`. Voyons cela\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["print(a)"]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["b = np.arange(1, 6); print(b)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 45, "lines": ["b.shape"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["****"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["Ici encore, je peux ajouter les deux termes\u00a0:"]}, {"block": 28, "type": "code", "linesLength": 4, "startIndex": 48, "lines": ["# je peux ici encore\n", "# ajouter les tableaux\n", "c = a + b\n", "print(c)"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 52, "lines": ["# et c'est comme si j'avais\n", "# ajout\u00e9 \u00e0 a ce terme-ci\n", "print(c - a)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Avec le m\u00eame point de vue que tout \u00e0 l'heure, on peut se dire qu'on a d'abord transform\u00e9 (broadcast\u00e9) le tableau `b`\u00a0: "]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["depuis la dimension `(5,)`"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["vers la dimension `(3, 5)`"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 58, "lines": ["# d\u00e9part\n", "print(b)"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["# arriv\u00e9e\n", "print(c-a)"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["Vous commencez \u00e0 mieux voir comment \u00e7a fonctionne\u00a0; s'il existe une direction dans laquelle on peut \"tirer\" les donn\u00e9es pour faire coincider les formes, on peut faire du broadcasting. Et \u00e7a marche dans toutes les directions, comme on va le voir tout de suite."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["### Broadcasting `(3, 5)` et `(3, 1)`"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["Au lieu d'ajouter \u00e0 `a` une ligne, on peut lui ajouter une colonne, pourvu qu'elle ait la m\u00eame taille que les colonnes de `a`\u00a0:"]}, {"block": 38, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["print(a)"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 66, "lines": ["b = np.arange(1, 4)\\\n", "  .reshape(3, 1)\n", "print(b)"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["****"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Voyons comment se passe le broadcasting dans ce cas-l\u00e0\u00a0:"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["c = a + b\n", "print(c)"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 73, "lines": ["print(c - a)"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["Vous voyez que tout se passe exactement que lorsqu'on avait ajout\u00e9 une simple ligne, on a cette fois \"tir\u00e9\" la colonne dans la direction des lignes, pour passer\u00a0:"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["depuis la dimension `(3, 1)`"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["vers la dimension `(3, 5)`"]}, {"block": 47, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["# d\u00e9part\n", "print(b)"]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# arriv\u00e9e\n", "print(c-a)"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["### Broadcasting `(3, 1)` et `(1, 5)`"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 82, "lines": ["Nous avons maintenant tous les \u00e9l\u00e9ments en main pour comprendre un exemple plus int\u00e9ressant, o\u00f9 les deux tableaux ont des formes pas vraiment compatibles \u00e0 premi\u00e8re vue\u00a0:"]}, {"block": 51, "type": "code", "linesLength": 2, "startIndex": 83, "lines": ["col = np.arange(1, 4).reshape((3, 1))\n", "print(col)"]}, {"block": 52, "type": "code", "linesLength": 2, "startIndex": 85, "lines": ["line = 100 * np.arange(1, 6)\n", "print(line)"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["****"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["Gr\u00e2ce au broadcasting, on peut additionner ces deux tableaux pour obtenir ceci\u00a0: "]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 89, "lines": ["m = col + line; print(m)"]}, {"block": 56, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["Remarquez qu'ici les **deux** entr\u00e9es ont \u00e9t\u00e9 \u00e9tir\u00e9es pour atteindre une dimension commune."]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["Et donc pour illustrer le broadcasting dans ce cas, tout se passe comme si on avait\u00a0:"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["transform\u00e9 la colonne `(3, 1)`"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 93, "lines": ["en tableau `(3, 5)`"]}, {"block": 60, "type": "code", "linesLength": 1, "startIndex": 94, "lines": ["print(col)"]}, {"block": 61, "type": "code", "linesLength": 1, "startIndex": 95, "lines": ["print(col + np.zeros(5, dtype=np.int))"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["et transform\u00e9 la ligne `(1, 5)`"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["en tableau `(3, 5)`"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["print(line)"]}, {"block": 65, "type": "code", "linesLength": 2, "startIndex": 99, "lines": ["print(line + \n", "      np.zeros(3, dtype=np.int).reshape((3, 1)))"]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 101, "lines": ["avant d'additionner terme \u00e0 terme ces deux tableaux 3 x 5."]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["## En dimensions sup\u00e9rieures"]}, {"block": 68, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Pour savoir si deux tableaux peuvent \u00eatre compatibles via *broadcasting*, il faut comparer leurs formes. Je commence par vous donner des exemples. Ici encore quand on mentionne l'addition, cela vaut pour n'importe quel op\u00e9rateur binaire."]}, {"block": 69, "type": "markdown", "linesLength": 1, "startIndex": 104, "lines": ["### Exemples de dimensions compatibles"]}, {"block": 70, "type": "markdown", "linesLength": 5, "startIndex": 105, "lines": ["```\n", "A   15 x 3 x 5\n", "B   15 x 1 x 5\n", "A+B 15 x 3 x 5\n", "```"]}, {"block": 71, "type": "markdown", "linesLength": 6, "startIndex": 110, "lines": ["Cas de l'ajout d'un scalaire\n", "```\n", "A   15 x 3 x 5\n", "B            1\n", "A+B 15 x 3 x 5\n", "```"]}, {"block": 72, "type": "markdown", "linesLength": 5, "startIndex": 116, "lines": ["```\n", "A   15 x 3 x 5\n", "B        3 x 5\n", "A+B 15 x 3 x 5\n", "```"]}, {"block": 73, "type": "markdown", "linesLength": 5, "startIndex": 121, "lines": ["```\n", "A   15 x 3 x 5\n", "B        3 x 1\n", "A+B 15 x 3 x 5\n", "```"]}, {"block": 74, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["### Exemples de dimensions **non compatibles**"]}, {"block": 75, "type": "markdown", "linesLength": 5, "startIndex": 127, "lines": ["Deux lignes de longueurs diff\u00e9rentes\u00a0:\n", "``` \n", "A  3\n", "B  4 \n", "```"]}, {"block": 76, "type": "markdown", "linesLength": 5, "startIndex": 132, "lines": ["Un cas plus douteux\u00a0:\n", "```\n", "A      2 x 1\n", "B  8 x 4 x 3\n", "```"]}, {"block": 77, "type": "markdown", "linesLength": 5, "startIndex": 137, "lines": ["Comme vous le voyez sur tous ces exemples\u00a0:\n", "\n", "* on peut ajouter A et B lorsqu'il existe une dimension C qui \"\u00e9tire\" \u00e0 la fois celle de A et celle de B\u00a0;\n", "\n", "* on le voit sur le dernier exemple, mais on ne peut broadcaster que de **1** vers $n$\u00a0; lorsque $p>1$ divise $n$, on ne **peut pas** broadcaster de $p$ vers $n$, comme on pourrait peut-\u00eatre l'imaginer."]}, {"block": 78, "type": "markdown", "linesLength": 1, "startIndex": 142, "lines": ["Comme c'est un cours de python, plut\u00f4t que de formaliser \u00e7a sous une forme math\u00e9matique - je vous le laisse en exercice - je vais vous proposer plut\u00f4t une fonction python qui d\u00e9termine si deux tuples sont des `shape` compatibles de ce point de vue."]}, {"block": 79, "type": "code", "linesLength": 3, "startIndex": 143, "lines": ["# le module broadcasting n'est pas standard\n", "# c'est moi qui l'ai \u00e9crit pour illustrer le cours\n", "from broadcasting import compatible, compatible2"]}, {"block": 80, "type": "code", "linesLength": 2, "startIndex": 146, "lines": ["# on peut dupliquer selon un axe\n", "compatible((15, 3, 5), (15, 1, 5))"]}, {"block": 81, "type": "code", "linesLength": 2, "startIndex": 148, "lines": ["# ou selon deux axes\n", "compatible((15, 3, 5), (5, ))"]}, {"block": 82, "type": "code", "linesLength": 2, "startIndex": 150, "lines": ["# c'est bien clair que non\n", "compatible( (2,), (3,))"]}, {"block": 83, "type": "code", "linesLength": 2, "startIndex": 152, "lines": ["# on ne peut pas passer de 2 \u00e0 4\n", "compatible( (1, 2), (2, 4))"]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# L'op\u00e9rateur `is`"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "code", "linesLength": 1, "startIndex": 3, "lines": ["%load_ext ipythontutor"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Les op\u00e9rateurs `is` et `==`"]}, {"block": 5, "type": "markdown", "linesLength": 4, "startIndex": 5, "lines": ["* nous avons d\u00e9j\u00e0 parl\u00e9 de l'op\u00e9rateur `==` qui **compare la valeur** de deux objets;\n", "* python fournit aussi un op\u00e9rateur `is` qui permet de savoir si deux valeurs correspondent **au m\u00eame objet** en m\u00e9moire.\n", "\n", "Nous allons illustrer la diff\u00e9rence entre ces deux op\u00e9rateurs."]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 9, "lines": ["# deux listes identiques\n", "a = [1, 2]\n", "b = [1, 2]\n", "\n", "# les deux objets se ressemblent\n", "print('==', a == b)"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 15, "lines": ["# mais ce ne sont pas les m\u00eames objets\n", "print('is', a is b)"]}, {"block": 8, "type": "code", "linesLength": 8, "startIndex": 17, "lines": ["# par contre ici il n'y a qu'une liste\n", "a = [1, 2]\n", "\n", "# et les deux variables pointent vers le m\u00eame objet\n", "b = a\n", "\n", "# non seulement les deux expressions se ressemblent\n", "print('==', a == b)"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 25, "lines": ["# mais elles d\u00e9signent le m\u00eame objet\n", "print('is', a is b)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### La m\u00eame chose sous pythontutor"]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 28, "lines": ["%%ipythontutor curInstr=2\n", "a = [1, 2]\n", "b = [1, 2]"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 31, "lines": ["%%ipythontutor curInstr=1\n", "# \u00e9quivalent \u00e0 la forme ci-dessus\n", "a = b = [1, 2]"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["### Utilisez `is` plut\u00f4t que `==` lorsque c'est possible"]}, {"block": 14, "type": "markdown", "linesLength": 3, "startIndex": 35, "lines": ["La pratique usuelle est d'utiliser `is` lorsqu'on compare avec un objet qui est un singleton, comme typiquement `None`. \n", "\n", "Par exemple on pr\u00e9f\u00e8rera \u00e9crire&nbsp;:"]}, {"block": 15, "type": "code", "linesLength": 4, "startIndex": 38, "lines": ["undef = None\n", "\n", "if undef is None:\n", "    print('ind\u00e9fini')"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["plut\u00f4t que"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 43, "lines": ["if undef == None:\n", "    print('ind\u00e9fini')"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["qui se comporte de la m\u00eame mani\u00e8re (\u00e0 nouveau, parce qu'on compare avec `None`), mais est l\u00e9g\u00e8rement moins lisible, et franchement moins pythonique :)"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["Notez aussi et surtout que `is` est **plus efficace** que `==`. En effet `is` peut \u00eatre \u00e9valu\u00e9 en temps constant, puisqu'il s'agit essentiellement de comparer les deux adresses. Alors que pour `==` il peut s'agir de parcourir toute une structure de donn\u00e9es possiblement tr\u00e8s complexe.  "]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["### La fonction `id`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Pour bien comprendre le fonctionnement de `is` nous allons voir la fonction `id` qui retourne un identificateur unique pour chaque objet; un mod\u00e8le mental acceptable est celui d'adresse m\u00e9moire. "]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 50, "lines": ["id(True)"]}, {"block": 24, "type": "markdown", "linesLength": 3, "startIndex": 51, "lines": ["Comme vous vous en doutez, l'op\u00e9rateur `is` peut \u00eatre d\u00e9crit formellement \u00e0 partir de `id` comme ceci\n", "\n", "(`a is b`) $\\Longleftrightarrow$ (`id(a) == id(b)`)\n"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["### Certains types de base sont des singletons"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Un singleton est un objet qui n'existe qu'en un seul exemplaire dans la m\u00e9moire. Un usage classique des singletons en python est de minimiser le nombre d'objets immuables en m\u00e9moire. Voyons ce que cela nous donne avec des entiers "]}, {"block": 27, "type": "code", "linesLength": 3, "startIndex": 56, "lines": ["a = 3\n", "b = 3\n", "print('a', id(a), 'b', id(b))"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["Tiens, c'est curieux, nous avons ici deux objets, que l'on pourrait penser diff\u00e9rents, mais en fait ce sont les m\u00eames; `a` et `b` d\u00e9signent **le m\u00eame objet** python, et on a"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["a is b"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["Il se trouve que, dans le cas des petits entiers, python r\u00e9alise une optimisation de l'utilisation de la m\u00e9moire. Quel que soit le nombre de variables dont la valeur est `3`, un seul objet correspondant \u00e0 l'entier `3` est allou\u00e9 et cr\u00e9\u00e9, pour \u00e9viter d'engorger la m\u00e9moire. On dit que l'entier `3` est impl\u00e9ment\u00e9 comme un singleton; nous reverrons ceci en exercice."]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 62, "lines": ["On trouve cette optimisation avec quelques autres objets python, comme par exemple"]}, {"block": 32, "type": "code", "linesLength": 3, "startIndex": 63, "lines": ["a = \"\"\n", "b = \"\"\n", "a is b"]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Ou encore, plus surprenant:"]}, {"block": 34, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["a = \"foo\"\n", "b = \"foo\"\n", "a is b"]}, {"block": 35, "type": "markdown", "linesLength": 3, "startIndex": 70, "lines": ["**Conclusion** cette optimisation ne touche aucun type mutable (heureusement); pour les types immuables, il n'est pas extr\u00eamement important de savoir en d\u00e9tail quels objets sont impl\u00e9ment\u00e9s de la sorte. \n", "\n", "Ce qui est par contre extr\u00eamement important est de comprendre la diff\u00e9rence entre `is` et `==`, et de les utiliser \u00e0 bon escient au risque d'\u00e9crire du code fragile."]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["### Pour en savoir plus"]}, {"block": 37, "type": "markdown", "linesLength": 5, "startIndex": 74, "lines": ["Aux \u00e9tudiants de niveau avanc\u00e9, nous recommandons la lecture de la section \"Objects, values and types\" dans la documentation python\n", "\n", "https://docs.python.org/3/reference/datamodel.html#objects-values-and-types\n", "\n", "qui aborde \u00e9galement la notion de \"garbage collection\", que nous n'aurons pas le temps d'approfondir dans ce MOOC.\n"]}]
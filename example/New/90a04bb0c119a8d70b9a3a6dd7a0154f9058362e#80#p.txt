[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# It\u00e9rateurs"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau interm\u00e9daire"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 3, "lines": ["Dans ce compl\u00e9ment nous allons&nbsp;:\n", " * tout d'abord dire quelques mots du module `itertools` qui fournit sous forme d'it\u00e9rateurs des utilitaires communs qui peuvent \u00eatre tr\u00e8s utiles&nbsp;;\n", " * puis dans la partie avanc\u00e9e du compl\u00e9ment nous allons voir, comme un autre exemple d'it\u00e9rateurs, comment impl\u00e9menter notre propre it\u00e9rateur des permutations d'un ensemble fini."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["### Le module `itertools`"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["\u00c0 ce stade, j'esp\u00e8re que vous savez trouver [la documentation du module](https://docs.python.org/3/library/itertools.html) que je vous invite \u00e0 avoir sous la main."]}, {"block": 6, "type": "code", "linesLength": 1, "startIndex": 8, "lines": ["import itertools"]}, {"block": 7, "type": "markdown", "linesLength": 6, "startIndex": 9, "lines": ["Comme vous le voyez dans la doc, les fonctionnalit\u00e9s de `itertools` tombent dans 3 cat\u00e9gories&nbsp;:\n", " * des it\u00e9rateurs infinis, comme par exemple `cycle`,\n", " * des it\u00e9rateurs pour \u00e9num\u00e9rer les combinatoires usuelles en math\u00e9matiques, comme les permutations, les combinaisons, le produit cart\u00e9sien, etc.,\n", " * et enfin des it\u00e9rateurs correspondants \u00e0 des traits que nous avons d\u00e9j\u00e0 rencontr\u00e9s, mais impl\u00e9ment\u00e9s sous forme d'it\u00e9rateurs.\n", " \n", "\u00c0 nouveau, toutes ces fonctionnalit\u00e9s sont offertes **sous la forme d'it\u00e9rateurs**."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Pour d\u00e9tailler un tout petit peu cette derni\u00e8re famille, signalons&nbsp;:"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": [" * `chain` qui permet de **concat\u00e9ner** plusieurs it\u00e9rables sous la forme d'un **it\u00e9rateur**&nbsp;:"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 17, "lines": ["for x in itertools.chain((1, 2), [3, 4]):\n", "    print(x)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": [" * `islice` qui est une g\u00e9n\u00e9ralisation de `range`, mais sur une s\u00e9quence qui n'est pas n\u00e9cessairement les premiers entiers:"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 20, "lines": ["import string\n", "support = string.ascii_lowercase\n", "print(f'support={support}')"]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["# range\n", "for x in range(3, 8):\n", "    print(x)"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 26, "lines": ["# islice\n", "for x in itertools.islice(support, 3, 8):\n", "    print(x)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["### Impl\u00e9menter un it\u00e9rateur de permutations"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["##### C'est quoi d\u00e9j\u00e0 les permutations ?"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["En guise de rappel, l'ensemble des permutations d'un ensemble fini correspond \u00e0 toutes les fa\u00e7ons d'ordonner ses \u00e9l\u00e9ments&nbsp;; si l'ensemble est de cardinal $n$, il poss\u00e8de $n!$ permutations&nbsp;: on a $n$ fa\u00e7ons de choisir le premier \u00e9l\u00e9ment, $n-1$ fa\u00e7ons de choisir le second, etc."]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Un it\u00e9rateur sur les permutations est disponible au travers du module standard `itertools`. Cependant il nous a sembl\u00e9 int\u00e9ressant de vous montrer comment nous pourrions \u00e9crire nous-m\u00eames cette fonctionnalit\u00e9, de mani\u00e8re relativement simple."]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["Pour illustrer le concept, voici \u00e0 quoi ressemblent les 6 permutations d'un ensemble \u00e0 trois \u00e9l\u00e9ments&nbsp;:"]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["from itertools import permutations"]}, {"block": 22, "type": "code", "linesLength": 4, "startIndex": 36, "lines": ["set = {1, 2, 3}\n", "\n", "for p in permutations(set):\n", "    print(p)"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 40, "lines": ["##### Une impl\u00e9mentation "]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Voici une impl\u00e9mentation possible pour un it\u00e9rateur de permutations&nbsp;:"]}, {"block": 25, "type": "code", "linesLength": 71, "startIndex": 42, "lines": ["class Permutations:\n", "    \"\"\"\n", "    Un it\u00e9rateur qui \u00e9num\u00e8re les permutations de n\n", "    sous la forme d'une liste d'indices commen\u00e7ant \u00e0 0\n", "    \"\"\"\n", "    def __init__(self, n):\n", "        # le constructeur bien s\u00fbr ne fait (presque) rien\n", "        self.n = n\n", "        # au fur et \u00e0 mesure des it\u00e9rations\n", "        # le compteur va aller de 0 \u00e0 n-1\n", "        # puis retour \u00e0 0 et comme \u00e7a en boucle sans fin\n", "        self.counter = 0\n", "        # on se contente d'allouer un iterateur de rang n-1\n", "        # si bien qu'une fois qu'on a fini de construire\n", "        # l'objet d'ordre n on a n objets Permutations en tout\n", "        if n >= 2:\n", "            self.subiterator = Permutations(n-1)\n", "\n", "    # pour satisfaire le protocole de l'it\u00e9rable\n", "    def __iter__(self):\n", "        return self\n", "\n", "    # c'est ici bien s\u00fbr que se fait tout le travail\n", "    def __next__(self):\n", "\n", "        # pour n == 1\n", "        # le travail est tr\u00e8s simple\n", "        if self.n == 1:\n", "            # on doit renvoyer une fois la liste [0]\n", "            # car les indices commencent \u00e0 0\n", "            if self.counter == 0: \n", "                self.counter += 1\n", "                return [0]\n", "            # et ensuite c'est termin\u00e9\n", "            else:\n", "                raise StopIteration\n", "\n", "        # pour n >= 2\n", "        # lorsque counter est nul,\n", "        # on traite la permutation d'ordre n-1 suivante\n", "        # si next() l\u00e8ve StopIteration on n'a qu'\u00e0 laisser passer\n", "        # car en effet c'est qu'on a termin\u00e9\n", "        if self.counter == 0:\n", "            self.subsequence = next(self.subiterator)\n", "        #\n", "        # on ins\u00e8re alors n-1 (car les indices commencent \u00e0 0)\n", "        # successivement dans la sous-sequence\n", "        #\n", "        # naivement on \u00e9crirait\n", "        # result = self.subsequence[0:self.counter] \\\n", "        #    + [self.n - 1] \\\n", "        #    + self.subsequence[self.counter:self.n-1]\n", "        # mais c'est mettre le nombre le plus \u00e9lev\u00e9 en premier\n", "        # et donc \u00e0 it\u00e9rer les permutations dans le mauvais ordre,\n", "        # en commen\u00e7ant par la fin\n", "        #\n", "        # donc on fait plut\u00f4t une sym\u00e9trie\n", "        # pour ins\u00e9rer en commen\u00e7ant par la fin\n", "        cutter = self.n-1 - self.counter\n", "        result = self.subsequence[0:cutter] + [self.n - 1] \\\n", "                 + self.subsequence[cutter:self.n-1]\n", "        # \n", "        # on n'oublie pas de maintenir le compteur et de\n", "        # le remettre \u00e0 z\u00e9ro tous les n tours\n", "        self.counter = (self.counter+1) % self.n\n", "        return result\n", "\n", "    # la longeur de cet it\u00e9rateur est connue\n", "    def __len__(self):\n", "        import math\n", "        return math.factorial(self.n)"]}, {"block": 26, "type": "markdown", "linesLength": 15, "startIndex": 113, "lines": ["Ce qu'on a essay\u00e9 d'expliquer dans les commentaires, c'est qu'on proc\u00e8de en fin de compte par r\u00e9currence. Un objet `Permutations` de rang `n` poss\u00e8de un sous-it\u00e9rateur de rang `n-1` qu'on cr\u00e9e dans le constructeur. Ensuite l'objet de rang `n` va faire successivement (c'est-\u00e0-dire \u00e0 chaque appel de `next()`)&nbsp;:\n", " * appel *0* : \n", "   * demander \u00e0 son sous-it\u00e9rateur une permutation de rang `n-1` (en lui envoyant `next`),\n", "   * la stocker dans l'objet de rang `n`, ce sera utilis\u00e9 par les *n* premier appels,\n", "   * et construire une liste de taille `n` en ins\u00e9rant `n-1` \u00e0 la fin de la s\u00e9quence de taille `n-1`,\n", " * appel *1* : \n", "   * ins\u00e9rer `n-1` dans la m\u00eame s\u00e9quence de rang `n-1` mais cette fois 1 cran avant la fin,\n", " * ...\n", " * appel *n-1* :\n", "   * ins\u00e9rer `n-1` au d\u00e9but de la s\u00e9quence de rang `n-1`,\n", " * appel *n* :\n", "    * refaire `next()` sur le sous-it\u00e9rateur pour traiter une nouvelle sous-s\u00e9quence,\n", "    * la stocker dans l'objet de rang `n`, comme \u00e0 l'appel *0*, pour ce bloc de n appels,\n", "    * et construire la permutation en ins\u00e9rant *n-1* \u00e0 la fin, comme \u00e0 l'appel 0,\n", " * ..."]}, {"block": 27, "type": "markdown", "linesLength": 5, "startIndex": 128, "lines": ["On voit donc le caract\u00e8re cyclique d'ordre *n* qui est mat\u00e9rialis\u00e9 par `counter`, que l'on incr\u00e9mente \u00e0 chaque boucle mais modulo *n* - notez d'ailleurs que pour ce genre de comportement on dispose aussi de `itertools.cycle` comme on le verra dans une deuxi\u00e8me version, mais pour l'instant j'ai pr\u00e9f\u00e9r\u00e9 ne pas l'utiliser pour ne pas tout embrouiller ;) \n", "\n", "La terminaison se g\u00e8re tr\u00e8s simplement, car une fois que l'on a trait\u00e9 toutes les s\u00e9quences d'ordre *n-1* eh bien on a fini, on n'a m\u00eame pas besoin de lever StopIteration explicitement, sauf bien s\u00fbr dans le cas *n=1*.\n", "\n", "Le seul point un peu d\u00e9licat, si on veut avoir les permutations dans le \"bon\" ordre, consiste \u00e0 commencer \u00e0 ins\u00e9rer `n-1` par la droite (la fin de la sous-s\u00e9quence)."]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 133, "lines": ["##### Discussion"]}, {"block": 29, "type": "markdown", "linesLength": 5, "startIndex": 134, "lines": ["Il existe certainement des tas d'autres fa\u00e7ons de faire bien entendu. Le point important ici, et qui donne toute sa puissance \u00e0 la notion d'it\u00e9rateur, c'est **qu'\u00e0 aucun moment on ne construit** une liste ou une s\u00e9quence quelconque de** $n!$ termes**. \n", "\n", "C'est une erreur fr\u00e9quente chez les d\u00e9butants que de calculer une telle liste dans le constructeur, mais proc\u00e9der de cette fa\u00e7on c'est aller exactement \u00e0 l'oppos\u00e9 de ce pourquoi les it\u00e9rateurs ont \u00e9t\u00e9 con\u00e7us&nbsp;; au contraire, on veut \u00e9viter \u00e0 tout prix le co\u00fbt d'une telle construction.\n", "\n", "On peut le voir sur un code qui n'utiliserait que les 20 premi\u00e8res valeurs de l'it\u00e9rateur, vous constatez que ce code est imm\u00e9diat&nbsp;:"]}, {"block": 30, "type": "code", "linesLength": 10, "startIndex": 139, "lines": ["def show_first_items(iterable, nb_items):\n", "    \"\"\"\n", "    montre les <nb_items> premiers items de iterable\n", "    \"\"\"\n", "    print(\"Il y a {} items dans l'it\u00e9rable\".format(len(iterable)))\n", "    for i, item in enumerate(iterable):\n", "        print(item)\n", "        if i >= nb_items:\n", "            print('....')\n", "            break"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 149, "lines": ["show_first_items(Permutations(12), 20)"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 150, "lines": ["Ce tableau vous montre par ailleurs sous un autre angle comment fonctionne l'algorithme, si vous observez le `11` qui balaie en diagonale les 12 premi\u00e8res lignes, puis les 12 suivantes, etc.."]}, {"block": 33, "type": "markdown", "linesLength": 1, "startIndex": 151, "lines": ["##### Ultimes am\u00e9liorations"]}, {"block": 34, "type": "markdown", "linesLength": 3, "startIndex": 152, "lines": ["Derni\u00e8res remarques, sur des am\u00e9liorations possibles - mais tout \u00e0 fait optionnelles&nbsp;:\n", " * le lecteur attentif aura remarqu\u00e9 qu'au lieu d'un entier `counter` on aurait pu profitablement utiliser une instance de `itertools.cycle`, ce qui aurait eu l'avantage d'\u00eatre plus clair sur le propos de ce compteur;\n", " * aussi dans le m\u00eame mouvement, au lieu de se livrer \u00e0 la gymnastique qui calcule `cutter` \u00e0 partir de `counter`, on pourrait d\u00e8s le d\u00e9part cr\u00e9er dans le cycle les bonnes valeurs en commen\u00e7ant \u00e0 `n-1`."]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 155, "lines": ["C'est ce qu'on a fait dans cette deuxi\u00e8me version; apr\u00e8s avoir enlev\u00e9 la loghorr\u00e9e de commentaires \u00e7a redevient presque lisible ;)"]}, {"block": 36, "type": "code", "linesLength": 43, "startIndex": 156, "lines": ["import itertools\n", "\n", "class Permutations2:\n", "    \"\"\"\n", "    Un it\u00e9rateur qui \u00e9num\u00e8re les permutations de n\n", "    sous la forme d'une liste d'indices commen\u00e7ant \u00e0 0\n", "    \"\"\"\n", "    def __init__(self, n):\n", "        self.n = n\n", "        # on commence \u00e0 ins\u00e9rer \u00e0 la fin \n", "        self.cycle = itertools.cycle(list(range(n))[::-1])\n", "        if n >= 2:\n", "            self.subiterator = Permutations2(n-1)\n", "        # pour savoir quand terminer le cas n==1\n", "        if n == 1:\n", "            self.done = False\n", "\n", "    def __iter__(self):\n", "        return self\n", "\n", "    def __next__(self):\n", "        cutter = next(self.cycle)\n", "\n", "        # quand n==1 on a toujours la m\u00eame valeur 0\n", "        if self.n == 1:\n", "            if not self.done:\n", "                self.done = True\n", "                return [0]\n", "            else:\n", "                raise StopIteration\n", "\n", "        # au d\u00e9but de chaque s\u00e9quence de n appels\n", "        # il faut appeler une nouvelle sous-s\u00e9quence\n", "        if cutter == self.n-1:\n", "            self.subsequence = next(self.subiterator)\n", "        # dans laquelle on ins\u00e9re n-1\n", "        return self.subsequence[0:cutter] + [self.n-1] \\\n", "                 + self.subsequence[cutter:self.n-1]\n", "\n", "    # la longeur de cet it\u00e9rateur est connue\n", "    def __len__(self):\n", "        import math\n", "        return math.factorial(self.n)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 199, "lines": ["show_first_items(Permutations2(5), 20)"]}]
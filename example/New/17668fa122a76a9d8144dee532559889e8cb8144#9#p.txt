[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Construction de liste par compr\u00e9hension"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## R\u00e9vision - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 3, "startIndex": 7, "lines": ["Ce m\u00e9canisme tr\u00e8s pratique permet de construire simplement une liste \u00e0 partir d'une autre (ou de **tout autre type it\u00e9rable** en r\u00e9alit\u00e9, mais nous y viendrons).\n", "\n", "Pour l'introduire en deux mots, disons que la compr\u00e9hension de liste est \u00e0 l'instruction `for` ce que l'expression conditionnelle est \u00e0 l'instruction  `if`, c'est-\u00e0-dire qu'il s'agit d'une **expression \u00e0 part enti\u00e8re**."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["### Cas le plus simple"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Voyons tout de suite un exemple"]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 12, "lines": ["depart = (-5, -3, 0, 3, 5, 10)\n", "arrivee = [x**2 for x in depart]\n", "arrivee"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Le r\u00e9sultat de cette expression est donc une liste, dont les \u00e9l\u00e9ments sont les r\u00e9sultats de l'expression `x**2` pour `x` prenant toutes les valeurs de `depart`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["**Remarque**: si on prend un point de vue un peu plus math\u00e9matique, ceci revient donc \u00e0 appliquer une certaine fonction (ici $x \\rightarrow x^2$) \u00e0 une collection de valeurs, et \u00e0 retourner la liste des r\u00e9sultats. Dans les langages fonctionnels, cette op\u00e9ration est connue sous le nom de `map`, comme on l'a vu dans la s\u00e9quence pr\u00e9c\u00e9dente."]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["##### Digression"]}, {"block": 10, "type": "code", "linesLength": 5, "startIndex": 18, "lines": ["# profitons de cette occasion pour voir \n", "# comment tracer une courbe avec matplotlib\n", "%matplotlib inline\n", "import matplotlib.pyplot as plt\n", "plt.ion()"]}, {"block": 11, "type": "code", "linesLength": 4, "startIndex": 23, "lines": ["# si on met le depart et l'arrivee \n", "# en abscisse et en ordonnee, on trace\n", "# une version tronqu\u00e9e de la courbe de f: x -> x**2\n", "plt.plot(depart, arrivee);"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 27, "lines": ["### Restriction \u00e0 certains \u00e9l\u00e9ments"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Il est possible \u00e9galement de ne prendre en compte que certains des \u00e9l\u00e9ments de la liste de d\u00e9part, comme ceci"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 29, "lines": ["[x**2 for x in depart if x%2 == 0]"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["qui cette fois ne contient que les carr\u00e9s des \u00e9l\u00e9ments pairs de `depart`. "]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["**Remarque**: pour prolonger la remarque pr\u00e9c\u00e9dente, cette op\u00e9ration s'appelle fr\u00e9quemment `filter` dans les langages de programmation."]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["### Autres types"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["On peut fabriquer une compr\u00e9hension \u00e0 partir de tout objet it\u00e9rable, pas forc\u00e9ment une liste, mais le r\u00e9sultat est toujours une liste, comme on le voit sur ces quelques exemples:"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 34, "lines": ["[ord(x) for x in 'abc']"]}, {"block": 20, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["[chr(x) for x in (97, 98, 99)]"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Nous verrons tr\u00e8s bient\u00f4t que des m\u00e9canismes similaires sont disponibles avec les dictionnaires et les ensembles."]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["### Compr\u00e9hension *vs* expression g\u00e9n\u00e9ratrice"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 39, "lines": ["#### Digression : liste *vs* it\u00e9rateur"]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 40, "lines": ["En python3, nous avons d\u00e9j\u00e0 rencontr\u00e9 la fonction `range` qui retourne les premiers entiers.\n", "\n", "Ou plut\u00f4t, c'est **comme si** elle retournait les premiers entiers lorsqu'on fait une boucle `for` "]}, {"block": 26, "type": "code", "linesLength": 3, "startIndex": 43, "lines": ["# on peut parcourir un range comme si c'\u00e9tait une liste\n", "for i in range(4):\n", "    print(i)"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["mais en r\u00e9alit\u00e9 le r\u00e9sultat de `range` exhibe un comportement un peu \u00e9trange, en ce sens que:"]}, {"block": 28, "type": "code", "linesLength": 2, "startIndex": 47, "lines": ["# mais en fait la fonction range ne renvoie PAS une liste (depuis python3)\n", "range(4)"]}, {"block": 29, "type": "code", "linesLength": 2, "startIndex": 49, "lines": ["# et en effet ce n'est pas une liste\n", "isinstance(range(4), list)"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["La raison de fond pour ceci, c'est que **le fait de construire une liste** est une op\u00e9ration relativement co\u00fbteuse - toutes proportions gard\u00e9es - car il est n\u00e9cessaire d'allouer de la m\u00e9moire pour **stocker tous les \u00e9l\u00e9ments** de la liste \u00e0 un instant donn\u00e9; alors qu'en fait dans l'immense majorit\u00e9 des cas, on n'a **pas r\u00e9ellement besoin** de cette place m\u00e9moire, tout ce dont on a besoin c'est d'it\u00e9rer sur un certain nombre de valeurs mais **qui peuvent \u00eatre calcul\u00e9es** au fur et \u00e0 mesure que l'on parcourt la liste. "]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["#### Compr\u00e9hension et expression g\u00e9n\u00e9ratrice"]}, {"block": 32, "type": "markdown", "linesLength": 5, "startIndex": 53, "lines": ["\u00c0 la lumi\u00e8re de ce qui vient d'\u00eatre dit, on peut voir qu'une compr\u00e9hension n'est **pas toujours le bon choix**, car par d\u00e9finition elle **construit une liste** de r\u00e9sultats - de la fonction appliqu\u00e9e successivment aux entr\u00e9es.\n", "\n", "Or dans les cas o\u00f9, comme pour `range`, on n'a pas r\u00e9ellement besoin de cette liste **en temps que telle** mais seulement de cet artefact pour pouvoir it\u00e9rer sur la liste des r\u00e9sultats, il est pr\u00e9f\u00e9rable d'utiliser une **expression g\u00e9n\u00e9ratrice**.\n", "\n", "Voyons tout de suite sur un exemple \u00e0 quoi cela ressemblerait."]}, {"block": 33, "type": "code", "linesLength": 7, "startIndex": 58, "lines": ["# dans le premier calcul de arrivee \n", "# pour rappel, la compr\u00e9hension est entre []\n", "# arrivee = [x**2 for x in depart]\n", "\n", "# on peut \u00e9crire presque la m\u00eame chose avec des () \u00e0 la place \n", "arrivee2 = (x**2 for x in depart)\n", "arrivee2"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 65, "lines": ["Comme pour `range`, le r\u00e9sultat de l'expression g\u00e9n\u00e9ratrice ne se laisse pas regarder avec `print`, mais comme pour `range`, on peut it\u00e9rer sur le r\u00e9sultat:"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 66, "lines": ["for x, y in zip(depart, arrivee2):\n", "    print(f\"x={x} => y={y}\")"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["Il n'est pas **toujours** possible de remplacer une compr\u00e9hension par une expression g\u00e9n\u00e9ratrice, mais c'est **souvent souhaitable**, car de cette fa\u00e7on on peut faire de substantielles \u00e9conomies en termes de performances. On peut le faire d\u00e8s lors que l'on a seulement besoin d'it\u00e9rer sur les r\u00e9sultats."]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Il faut juste un peu se m\u00e9fier, car comme on parle ici d'it\u00e9rateurs, comme toujours si on essaie de faire plusieurs fois une boucle sur le m\u00eame it\u00e9rateur, il ne se passe plus rien, car l'it\u00e9rateur a \u00e9t\u00e9 \u00e9puis\u00e9"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["for x, y in zip(depart, arrivee2):\n", "    print(f\"x={x} => y={y}\")"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["### Pour en savoir plus"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["Voyez [la section sur les compr\u00e9hensions de liste](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) dans la documentation python."]}]
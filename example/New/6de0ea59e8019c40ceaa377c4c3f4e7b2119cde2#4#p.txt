[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Typages statique et dynamique"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Parmi les langages typ\u00e9s, on distingue les langages \u00e0 typage statique et \u00e0 typage dynamique. Ce notebook tente d'\u00e9claircir ces notions pour ceux qui n'y sont pas familiers."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Typage statique"]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 9, "lines": ["\u00c0 une extr\u00e9mit\u00e9 du spectre, on trouve les langages compil\u00e9s, dits \u00e0 typage statique, comme par exemple C/C++. \n", "\n", "En C on \u00e9crira, par exemple, une version simpliste de la fonction factoriel comme ceci"]}, {"block": 6, "type": "markdown", "linesLength": 10, "startIndex": 12, "lines": ["    #include <stdio.h>\n", "    \n", "    int factoriel (int n) {\n", "      int result = 1;\n", "      int loop;\n", "      for (loop = 1; loop <= n; loop ++) {\n", "        result *= loop;\n", "      }\n", "      return result;\n", "    }"]}, {"block": 7, "type": "markdown", "linesLength": 4, "startIndex": 22, "lines": ["Comme vous pouvez le voir - ou le deviner - toutes les **variables** utilis\u00e9es ici (comme par exemple `n`, `result` et `loop`) sont typ\u00e9es.\n", " * On doit appeler `factoriel` avec un argument `n` qui doit \u00eatre un entier (`int` est le nom du type entier).\n", " * Les variables internes `result` et `loop` sont de type entier.\n", " * `factoriel` retourne une valeur de type entier."]}, {"block": 8, "type": "markdown", "linesLength": 4, "startIndex": 26, "lines": ["Ces informations de type ont essentiellement trois fonctions.\n", " * En premier lieu, elles sont n\u00e9cessaires au compilateur. En C si le programmeur ne pr\u00e9cisait pas que `result` est de type entier, le compilateur n'aurait pas suffisamment d'\u00e9l\u00e9ments pour g\u00e9n\u00e9rer le code assembleur correspondant.\n", " * En contrepartie, le programmeur a un contr\u00f4le tr\u00e8s fin de l'usage qu'il fait de la m\u00e9moire et du hardware. Il peut choisir d'utiliser un entier sur 32 ou 64 bits, sign\u00e9 ou pas, ou construire avec `struct` et `union` un arrangement de ses donn\u00e9es.\n", " * Enfin, et surtout, ces informations de type permettent de faire un contr\u00f4le *a priori* de la validit\u00e9 du programme, par exemple, si \u00e0 un autre endroit dans le code on trouve"]}, {"block": 9, "type": "markdown", "linesLength": 9, "startIndex": 30, "lines": ["    int main (int argc, char *argv[]) {\n", "      /* le premier argument de la ligne de commande est argv[1] */\n", "      char *input = argv[1];\n", "      /* calculer son factoriel et afficher le resultat */\n", "      printf (\"Factoriel (%s) = %d\\n\",input,factoriel(input));\n", "      /*                                               ^^^                */\n", "      /* ici on appelle factoriel avec une entree 'chaine de caractere'   */\n", "      return 0;\n", "    }"]}, {"block": 10, "type": "markdown", "linesLength": 3, "startIndex": 39, "lines": ["alors le compilateur va remarquer qu'on essaie d'appeler `factoriel` avec comme argument `input` qui, pour faire simple, est une cha\u00eene de caract\u00e8res et comme `factoriel` s'attend \u00e0 recevoir un entier, ce programme n'a aucune chance de fonctionner.\n", "\n", "On parle alors de **typage statique**, en ce sens que chaque **variable** a exactement un type qui est d\u00e9fini par le programmeur une bonne fois pour toutes."]}, {"block": 11, "type": "markdown", "linesLength": 3, "startIndex": 42, "lines": ["C'est ce qu'on appelle le **contr\u00f4le de type**, ou *type-checking* en anglais. Si on ignore le point sur le contr\u00f4le fin de la m\u00e9moire, qui n'est pas crucial \u00e0 notre sujet, ce mod\u00e8le de contr\u00f4le de type pr\u00e9sente&nbsp;:\n", " * l'**inconv\u00e9nient** de demander davantage au programmeur (je fais abstraction, \u00e0 ce stade et pour simplifier, de [langages \u00e0 inf\u00e9rence de types](https://en.wikipedia.org/wiki/Type_inference) comme ML et Haskell)\n", " * et l'**avantage** de permettre un contr\u00f4le \u00e9tendu, et surtout pr\u00e9coce (avant m\u00eame de l'ex\u00e9cuter), de la bonne correction du programme."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["Cela \u00e9tant dit, le typage statique en C n'emp\u00eache pas le programmeur d\u00e9butant d'essayer d'\u00e9crire dans la m\u00e9moire \u00e0 partir d'un pointeur `NULL` - et le programme de s'interrompre brutalement. Il faut \u00eatre conscient des limites du typage statique."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["### Typage dynamique"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 47, "lines": ["\u00c0 l'autre bout du spectre, on trouve des langages comme, eh bien, python. "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 48, "lines": ["Pour comprendre cette notion de typage dynamique, regardons la fonction suivante `somme`."]}, {"block": 16, "type": "code", "linesLength": 11, "startIndex": 49, "lines": ["def somme(*largs):\n", "    \"retourne la somme de tous ses arguments\"\n", "    if not largs:\n", "        return 0\n", "    elif len(largs) == 1:\n", "        return largs[0]\n", "    else:\n", "        result = largs[0] + largs[1]\n", "        for i in range(2, len(largs)):\n", "            result += largs[i]\n", "        return result"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 60, "lines": ["Naturellement, vous n'\u00eates pas \u00e0 ce stade en mesure de comprendre le fonctionnement intime de la fonction. Mais vous pouvez tout de m\u00eame l'utiliser."]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 61, "lines": ["somme(12, 14, 300)"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 62, "lines": ["l1 = ['a', 'b', 'c']\n", "l2 = [0, 20, 30]\n", "l3 = ['spam', 'eggs']\n", "somme(l1, l2, l3)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 66, "lines": ["Vous pouvez donc constater que `somme` peut fonctionner avec des objets de types diff\u00e9rents. En fait, telle qu'elle est \u00e9crite, elle va fonctionner s'il est possible de faire `+` entre ses arguments. Ainsi par exemple on pourrait m\u00eame faire"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 67, "lines": ["# python sait faire + entre deux cha\u00eenes de caract\u00e8res\n", "somme('abc', 'def')"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Mais par contre on ne pourrait pas faire"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 70, "lines": ["# ceci va d\u00e9clencher une exception \u00e0 run-time\n", "somme(12, [1, 2, 3]) "]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["Il est utile de remarquer que le typage de python, qui existe bel et bien comme on le verra, est qualifi\u00e9 de dynamique parce que le type est attach\u00e9 **\u00e0 un objet** et non \u00e0 la variable qui le r\u00e9f\u00e9rence. On aura bien entendu l'occasion d'approfondir tout \u00e7a dans le cours."]}, {"block": 25, "type": "markdown", "linesLength": 3, "startIndex": 73, "lines": ["En python, on fait souvent r\u00e9f\u00e9rence au typage sous l'appellation *duck typing*, de mani\u00e8re imag\u00e9e\n", "\n", "> If it looks like a duck and quacks like a duck, it's a duck"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["*******"]}, {"block": 27, "type": "markdown", "linesLength": 4, "startIndex": 77, "lines": ["On voit qu'on se trouve dans une situation tr\u00e8s diff\u00e9rente de celle du programmeur C/C++, en ce sens que&nbsp;:\n", " * \u00e0 l'\u00e9criture du programme, il n'y aucun des surco\u00fbts qu'on trouve avec C ou C++ en terme de d\u00e9finition de type,\n", " * aucun contr\u00f4le de type n'est effecu\u00e9 *a priori* par le langage au moment de la d\u00e9finition de la fonction `somme`,\n", " * par contre au moment de l'\u00e9x\u00e9cution, s'il s'av\u00e8re qu'on tente de faire une somme entre deux types qui ne peuvent pas \u00eatre additionn\u00e9s, comme ci-dessus avec un entier et une liste, le programme ne pourra pas se d\u00e9rouler correctement."]}, {"block": 28, "type": "markdown", "linesLength": 5, "startIndex": 81, "lines": ["Il y a deux points de vue vis-\u00e0-vis de la question du typage. \n", "\n", "Les gens habitu\u00e9s au *typage statique* se plaignent du typage dynamique en disant qu'on peut \u00e9crire des programmes faux et qu'on s'en rend compte trop tard - \u00e0 l'ex\u00e9cution, en insistant sur les parties qui traitent des cas particuliers, qui sont moins fr\u00e9quemment utilis\u00e9es, et qui donc n\u00e9cessitent des tests plus approfondis pour s'assurer que la couverture des tests est compl\u00e8te.\n", "\n", "\u00c0 l'inverse les gens habitu\u00e9s au *typage dynamique* font valoir que le typage statique est tr\u00e8s partiel, par exemple, en C si on essaie d'\u00e9crire au bout d'un pointeur nul, l'OS ne le permet pas et le programme sort tout aussi brutalement. "]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["Bref, selon le point de vue, le typage dynamique est v\u00e9cu comme un inconv\u00e9nient (pas assez de bonnes propri\u00e9t\u00e9s d\u00e9tect\u00e9es par le langage) ou comme un avantage (pas besoin de passer du temps \u00e0 d\u00e9clarer le type des variables, ni \u00e0 faire des conversions pour satisfaire le compilateur). Vous remarquerez cependant qu'\u00e0 l'usage, en terme de vitesse de d\u00e9veloppement, les incov\u00e9nients du typage dynamique sont tr\u00e8s largement compens\u00e9s par ses avantages. "]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["### Type hints"]}, {"block": 31, "type": "markdown", "linesLength": 3, "startIndex": 88, "lines": ["Signalons enfin que depuis python-3.5, il est **possible** d'ajouter des annotations de type, pour expliciter les suppositions qui sont faites par le programmeur pour le bon foncionnement du code.\n", "\n", "Nous aurons l\u00e0 encore l'occasion de d\u00e9tailler ce point dans le cours, signalons simplement que ces annotations sont totalement optionnelles, et que m\u00eame lorsqu'elles sont pr\u00e9sentes elles ne sont pas utilis\u00e9es \u00e0 run-time par l'interpr\u00e9teur. L'id\u00e9e est plut\u00f4t de permettre \u00e0 de outils externes, [comme  par exemple `mypy`](http://www.mypy-lang.org), d'effectuer des contr\u00f4les plus pouss\u00e9s concernant la correction du programme."]}]
[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["Souvenez-vous de ce qu'on avait dit en semaine 3 s\u00e9quence 4, concernant les cl\u00e9s dans un dictionnaire ou les \u00e9l\u00e9ments dans un ensemble. Nous avions vu alors que, pour les types *builtin*, les cl\u00e9s devaient \u00eatre des objets immuables et m\u00eame globalement immuables."]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Nous allons voir dans ce compl\u00e9ment quelles sont les r\u00e8gles qui s'appliquent aux instances de classe, et notamment  comment on peut manipuler des ensembles d'instances d'une mani\u00e8re qui fasse du sens."]}, {"block": 4, "type": "markdown", "linesLength": 5, "startIndex": 4, "lines": ["Une instance de classe est presque toujours un objet mutable (voir \u00e0 ce sujet un prochain compl\u00e9ment sur les `namedtuple`s).\n", "\n", "Et pourtant, le langage vous permet d'ins\u00e9rer une instance dans un ensemble - ou de l'utiliser comme cl\u00e9 dans un dictionnaire.\n", "\n", "Nous allons voir ce m\u00e9canisme en action, et mettre en \u00e9vidence ses limites."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["### hachage par d\u00e9faut: bas\u00e9 sur `id()`"]}, {"block": 6, "type": "code", "linesLength": 9, "startIndex": 10, "lines": ["# une classe Point qui ne red\u00e9finit pas __eq__ ni __hash__\n", "class Point1:\n", "    \n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "        \n", "    def __repr__(self):\n", "        return f\"Pt[{self.x}, {self.y}]\""]}, {"block": 7, "type": "code", "linesLength": 6, "startIndex": 19, "lines": ["# deux instances \n", "p1 = Point1(2, 3)\n", "p2 = Point1(3, 4)\n", "\n", "# bien qu'ils soient mutables, on peut les mettre dans un ensemble\n", "s = {p1, p2}"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 25, "lines": ["Mais par contre soyez attentifs, car il faut savoir que pour la classe `Point1`, o\u00f9 nous n'avons rien red\u00e9fini, la fonction de hachage sur une instance de `Point1` ne d\u00e9pend que de la valeur de `id()` sur cet objet.\n", "\n", "Ce qui, dit autrement, signifie que deux objets qui sont distincts au sens de `id()` sont consid\u00e9r\u00e9s comme diff\u00e9rents, et donc peuvent coexister dans un ensemble, ou dans un dictionnaire, ce qui n'est pas forc\u00e9ment ce qu'on veut:"]}, {"block": 9, "type": "code", "linesLength": 4, "startIndex": 28, "lines": ["# un point similaire \u00e0 p1\n", "p0 = Point1(2, 3)\n", "# nos deux objets se ressemblent\n", "p0, p1"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# mais peuvent coexister dans un ensemble\n", "{ p0, p1 }"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["### `__hash__` et `__eq__` "]}, {"block": 12, "type": "markdown", "linesLength": 6, "startIndex": 35, "lines": ["Le protocole hashable permet de pallier \u00e0 cette d\u00e9ficience; pour cela il nous faut d\u00e9finir deux m\u00e9thodes:\n", "\n", "* `__eq__` qui, sans grande surprise, va servir \u00e0 \u00e9valuer `p == q` \n", "* et `__hash__` qui va retourner la cl\u00e9 de hachage sur un objet\n", "\n", "La subtilit\u00e9 \u00e9tant bien entendu que ces deux m\u00e9thodes doivent \u00eatre coh\u00e9rentes; c'est-\u00e0-dire que, de bon sens, si l'\u00e9galit\u00e9 se base sur nos deux attributs `x` et `y`, il faudra bien entendu que la fonction de hachage utilise elle aussi ces deux attributs, pour que la logique de la table de hachage (semaine 3 s\u00e9quence 3) fonctionne de mani\u00e8re satisfaisante."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["Voyons cela sur une sous-classe de `Point1`, dans laquelle nous d\u00e9finissons ces deux m\u00e9thodes:"]}, {"block": 14, "type": "code", "linesLength": 9, "startIndex": 42, "lines": ["class Point2(Point1):\n", "\n", "    # l'\u00e9galit\u00e9 va se baser naturellement sur x et y\n", "    def __eq__(self, other):\n", "        return self.x == other.x and self.y == other.y\n", "\n", "    # du coup la fonction de hachage aussi\n", "    def __hash__(self):\n", "        return (11 * self.x + self.y) // 16"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["On peut v\u00e9rifier que cette fois les choses fonctionnent correctement:"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 52, "lines": ["q0 = Point2(2, 3)\n", "q1 = Point2(2, 3)"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 54, "lines": ["# nos deux objets sont distincts pour is() mais \u00e9gaux pour ==\n", "print(f\"is \u2192 {q0 is q1} \\n== \u2192 {q0 == q1}\")"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 56, "lines": ["# un ensemble contenant les deux points n'en contient qu'un\n", "{q0, q1}"]}, {"block": 19, "type": "code", "linesLength": 7, "startIndex": 58, "lines": ["# et bien s\u00fbr c'est pareil pour un dictionnaire\n", "d = {}\n", "d[q0] = 1\n", "# les deux cl\u00e9s q0 et q1 sont les m\u00eames pour le dictionnaire\n", "# du coupe ici on \u00e9crase la (seule) valeur dans d\n", "d[q1] = 10000\n", "d"]}]
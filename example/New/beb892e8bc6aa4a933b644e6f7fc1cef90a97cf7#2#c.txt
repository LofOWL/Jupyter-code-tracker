[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Alg\u00e8bre lin\u00e9aire"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 7, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Un aspect important de l'utilisation de `numpy` consiste \u00e0 manipuler des matrices et vecteurs. Voici une rapide introduction \u00e0 ces fonctionnalit\u00e9s."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["### Produit matriciel - `np.dot`"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["**Rappel**\u00a0: On a d\u00e9j\u00e0 vu que `*` entre deux tableaux faisait une multiplication terme \u00e0 terme."]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 14, "lines": ["ligne = 1 + np.arange(3)\n", "print(ligne)"]}, {"block": 8, "type": "code", "linesLength": 2, "startIndex": 16, "lines": ["colonne = 1 + np.arange(3).reshape(3, 1)\n", "print(colonne)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["##### Ce n'est pas ce que l'on veut ici\u00a0!"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 19, "lines": ["# avec le broadcasting, numpy me laisse \u00e9crire ceci\n", "# mais **ce n'est pas** un produit matriciel\n", "print(ligne * colonne)"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["L'op\u00e9ration de produit matriciel s'appelle `np.dot`\u00a0:"]}, {"block": 12, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["m1 = np.array([[1, 1],\n", "               [2, 2]])\n", "print(m1)"]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 26, "lines": ["m2 = np.array([[10, 20],\n", "               [30, 40]])\n", "print(m2)"]}, {"block": 14, "type": "code", "linesLength": 2, "startIndex": 29, "lines": ["# comme fonction\n", "np.dot(m1, m2)"]}, {"block": 15, "type": "code", "linesLength": 2, "startIndex": 31, "lines": ["# comme m\u00e9thode\n", "m1.dot(m2)"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 33, "lines": ["Je vous signale aussi un op\u00e9rateur sp\u00e9cifique, not\u00e9 `@`, qui permet \u00e9galement de faire le produit matriciel."]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 34, "lines": ["m1 @ m2"]}, {"block": 18, "type": "code", "linesLength": 1, "startIndex": 35, "lines": ["m2 @ m1"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["C'est un op\u00e9rateur un peu *ad hoc* pour `numpy`, puisqu'il ne fait pas de sens avec les types usuels de Python\u00a0:"]}, {"block": 20, "type": "code", "linesLength": 5, "startIndex": 37, "lines": ["for x, y in ( (10, 20), (10., 20.), ([10], [20]), ((10,), (20,))):\n", "    try:\n", "        x @ y\n", "    except Exception as e:\n", "        print(f\"OOPS - {type(e)} - {e}\")"]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["### Produit scalaire - `np.dot` ou `@`"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 43, "lines": ["Ici encore, vous pouvez utiliser `dot` qui va intelligemment transposer le second argument\u00a0:"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 44, "lines": ["v1 = np.array([1, 2, 3])\n", "print(v1)"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 46, "lines": ["v2 = np.array([4, 5, 6])\n", "print(v2)"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 48, "lines": ["np.dot(v1, v2)"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 49, "lines": ["v1 @ v2"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 50, "lines": ["### Transpos\u00e9e"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 51, "lines": ["Vous pouvez acc\u00e9der \u00e0 une matrice transpos\u00e9e de deux fa\u00e7ons\u00a0:"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["* soit sous la forme d'un attribut `m.T`\u00a0:"]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 53, "lines": ["m = np.arange(4).reshape(2, 2)\n", "print(m)"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 55, "lines": ["print(m.T)"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["* soit par la m\u00e9thode `transpose()`\u00a0:"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 57, "lines": ["print(m)"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 58, "lines": ["m.transpose()"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 59, "lines": ["### Matrice identit\u00e9 - `np.eye`"]}, {"block": 36, "type": "code", "linesLength": 1, "startIndex": 60, "lines": ["np.eye(4, dtype=np.int)"]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["### Matrices diagonales - `np.diag`"]}, {"block": 38, "type": "markdown", "linesLength": 5, "startIndex": 62, "lines": ["Avec `np.diag`, vous pouvez dans les deux sens\u00a0:\n", "\n", "* extraire la diagonale d'une matrice\u00a0;\n", "\n", "* construire une matrice \u00e0 partir de sa diagonale."]}, {"block": 39, "type": "code", "linesLength": 2, "startIndex": 67, "lines": ["M = np.arange(4) + 10 * np.arange(4)[:, np.newaxis]\n", "print(M)"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 69, "lines": ["D = np.diag(M)\n", "print(D)"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["M2 = np.diag(D)\n", "print(M2)"]}, {"block": 42, "type": "markdown", "linesLength": 1, "startIndex": 73, "lines": ["### D\u00e9terminant - `np.linalg.det`"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["Avec la fonction `np.linalg.det` :"]}, {"block": 44, "type": "code", "linesLength": 3, "startIndex": 75, "lines": ["# une isom\u00e9trie\n", "M = np.array([[0, -1], [1, 0]])\n", "print(M)"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 78, "lines": ["# et donc\n", "np.linalg.det(M) == 1"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 80, "lines": ["### Valeurs propres - `np.linalg.eig`"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 81, "lines": ["Vous pouvez obtenir valeurs propres et vecteurs propres d'une matrice avec `np.eig`\u00a0:"]}, {"block": 48, "type": "code", "linesLength": 2, "startIndex": 82, "lines": ["# la sym\u00e9trie par rapport \u00e0 x=y\n", "S = np.array([[0, 1], [1, 0]])"]}, {"block": 49, "type": "code", "linesLength": 1, "startIndex": 84, "lines": ["values, vectors = np.linalg.eig(S)"]}, {"block": 50, "type": "code", "linesLength": 2, "startIndex": 85, "lines": ["# pas de d\u00e9formation\n", "values"]}, {"block": 51, "type": "code", "linesLength": 2, "startIndex": 87, "lines": ["# les deux diagonales\n", "vectors"]}, {"block": 52, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["### Syst\u00e8mes d'\u00e9quations - `np.linalg.solve`"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["Fabriquons-nous un syst\u00e8me d'\u00e9quations\u00a0:"]}, {"block": 54, "type": "code", "linesLength": 1, "startIndex": 91, "lines": ["x, y, z = 1, 2, 3"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 92, "lines": ["3*x + 2*y + z"]}, {"block": 56, "type": "code", "linesLength": 1, "startIndex": 93, "lines": ["2*x + 3*y +4*z"]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 94, "lines": ["5*x + 2*y + 6*z"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["On peut le r\u00e9soudre tout simplement comme ceci\u00a0:"]}, {"block": 59, "type": "code", "linesLength": 5, "startIndex": 96, "lines": ["coefficients= np.array([\n", "    [3, 2, 1],\n", "    [2, 3, 4],\n", "    [5, 2, 6],\n", "])"]}, {"block": 60, "type": "code", "linesLength": 5, "startIndex": 101, "lines": ["constants = [\n", "    10,\n", "    20,\n", "    27,\n", "]"]}, {"block": 61, "type": "code", "linesLength": 1, "startIndex": 106, "lines": ["X, Y, Z = np.linalg.solve(coefficients, constants)"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 107, "lines": ["Par contre bien s\u00fbr on est pass\u00e9 par les flottants, et donc on a le souci habituel avec la pr\u00e9cision des arrondis\u00a0:"]}, {"block": 63, "type": "code", "linesLength": 1, "startIndex": 108, "lines": ["Z"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["### R\u00e9sum\u00e9"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["En r\u00e9sum\u00e9, ce qu'on vient de voir\u00a0:"]}, {"block": 66, "type": "markdown", "linesLength": 11, "startIndex": 111, "lines": ["| outil             | propos                             |\n", "|:------------------|:-----------------------------------|\n", "| `np.dot`          | produit matriciel                  |\n", "| `np.dot`          | produit scalaire                   |\n", "| `np.transpose`    | transpos\u00e9e                         |\n", "| `np.eye`          | matrice identit\u00e9                   |\n", "| `np.diag`         | extrait la diagonale               |\n", "| `np.diag`         | ou construit une matrice diagonale |\n", "| `np.linalg.det`   | d\u00e9terminant                        |\n", "| `np.linalg.eig`   | valeurs propres                    |\n", "| `np.linalg.solve` | r\u00e9sout syst\u00e8me \u00e9quations           |"]}, {"block": 67, "type": "markdown", "linesLength": 3, "startIndex": 122, "lines": ["### Pour en savoir plus\n", "\n", "Voyez la [documentation compl\u00e8te](https://docs.scipy.org/doc/numpy/reference/routines.linalg.html) sur l'alg\u00e8bre lin\u00e9aire."]}]
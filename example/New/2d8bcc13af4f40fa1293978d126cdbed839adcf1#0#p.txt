[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["\u00c9valuation des tests"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau basique"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["On a vu dans la vid\u00e9o que l'instruction conditionnelle `if` permet d'impl\u00e9menter simplement des branchements \u00e0 plusieurs choix, comme dans cet exemple:"]}, {"block": 3, "type": "code", "linesLength": 7, "startIndex": 3, "lines": ["entree = 'bag'\n", "if 'a' not in entree:\n", "    print 'sans a'\n", "elif 'b' not in entree:\n", "    print 'sans b'\n", "else:\n", "    print 'avec a et avec b'"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["Comme on s'en doute, les expressions conditionnelles **sont \u00e9valu\u00e9es jusqu'\u00e0 obtenir un r\u00e9sultat vrai** - ou consid\u00e9r\u00e9 comme vrai -, et le bloc correspondant est alors ex\u00e9cut\u00e9. Le point important ici est qu'**une fois qu'on a obtenu un r\u00e9sultat vrai**, on sort de l'expression conditionnelle **sans \u00e9valuer les autres conditions**."]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 11, "lines": ["Dans l'exemple ci-dessus, les conditions elles-m\u00eames ne sont pas *actives*. On veut dire par l\u00e0: la valeur de `entree` reste *identique*, que l'on *\u00e9value ou non* les deux expressions:\n", " * `'a' not in entree`\n", " * `'b' not in entree`\n", "\n", "Mais nous allons voir ci-dessous qu'il est relativement facile d'\u00e9crire des conditions qui **modifient** les objets mutables sur lesquelles elles op\u00e8rent. On dit dans ce cas qu'elles font un **effet de bord**; et c'est pourquoi il est important de bien assimiler la r\u00e8gle des \u00e9valuations des expressions dans un `if`. "]}, {"block": 6, "type": "heading", "linesLength": 1, "startIndex": 16, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 7, "type": "heading", "linesLength": 1, "startIndex": 17, "lines": ["Rappel sur la m\u00e9thode `pop`\n"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 18, "lines": ["Pour illustrer la notions d'**effet de bord**, nous revenons sur la m\u00e9thode de liste `pop()` qui, on le rappelle, renvoie un \u00e9l\u00e9ment de liste apr\u00e8s l'avoir effac\u00e9 de la liste. "]}, {"block": 9, "type": "code", "linesLength": 3, "startIndex": 19, "lines": ["# on se donne une liste\n", "liste = ['premier', 'deuxieme', 'troisieme']\n", "print \"liste\", liste"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 22, "lines": ["# pop(0) renvoie le premier element de la liste, et raccourcit la liste\n", "element = liste.pop(0)\n", "print \"apr\u00e8s pop(0):\", \"\u00e9l\u00e9ment=\", element, \"et liste=\", liste"]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 25, "lines": ["# et ainsi de suite\n", "element = liste.pop(0)\n", "print \"apr\u00e8s pop(0):\", \"\u00e9l\u00e9ment=\", element, \"et liste=\", liste"]}, {"block": 12, "type": "heading", "linesLength": 1, "startIndex": 28, "lines": ["Conditions avec effet de bord"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["Une fois ce rappel fait, voyons maintenant l'exemple suivant:"]}, {"block": 14, "type": "code", "linesLength": 11, "startIndex": 30, "lines": ["liste = range(5)\n", "print 'liste en entree:', liste, 'de taille', len(liste)\n", "if liste.pop(0) <= 0:\n", "    print 'cas 1'\n", "elif liste.pop(0) <= 1:\n", "    print 'cas 2'\n", "elif liste.pop(0) <= 2:\n", "    print 'cas 3'\n", "else:\n", "    print 'cas 4'\n", "print 'liste en sortie de taille', len(liste)"]}, {"block": 15, "type": "markdown", "linesLength": 3, "startIndex": 41, "lines": ["Avec cette entr\u00e9e, le premier test est positif (car `pop(0)` renvoie 0), aussi on n'ex\u00e9cute en tout `pop()` qu'**une seule fois**, et donc \u00e0 la sortie la liste n'a \u00e9t\u00e9 raccourcie que d'un \u00e9l\u00e9ment.\n", "\n", "Ex\u00e9cutons \u00e0 pr\u00e9sent le m\u00eame code avec une entr\u00e9e diff\u00e9rente (vivement les fonctions !)"]}, {"block": 16, "type": "code", "linesLength": 11, "startIndex": 44, "lines": ["liste = range(5, 10)\n", "print 'liste en entree:', liste, 'de taille', len(liste)\n", "if liste.pop(0) <= 0:\n", "    print 'cas 1'\n", "elif liste.pop(0) <= 1:\n", "    print 'cas 2'\n", "elif liste.pop(0) <= 2:\n", "    print 'cas 3'\n", "else:\n", "    print 'cas 4'\n", "print 'liste en sortie de taille', len(liste)"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["On observe que cette fois la liste a \u00e9t\u00e9 raccourcie 3 fois, car les trois tests se sont r\u00e9v\u00e9l\u00e9s n\u00e9gatifs."]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["Cet exemple vous montre qu'il faut \u00eatre attentif avec des conditions qui font des effets de bord. Bien entendu, ce type de pratique est de mani\u00e8re g\u00e9n\u00e9rale **vivement d\u00e9conseill\u00e9**."]}, {"block": 19, "type": "heading", "linesLength": 1, "startIndex": 57, "lines": ["*Short-circuit*"]}, {"block": 20, "type": "markdown", "linesLength": 3, "startIndex": 58, "lines": ["La logique que l'on vient de voir s'applique aux diff\u00e9rentes branches d'un `if`. \n", "\n", "En fait, c'est la m\u00eame logique qui est \u00e0 l'\u0153uvre aussi lorsque python \u00e9value une condition logique \u00e0 base de `and` et `or`."]}, {"block": 21, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["Pour illustrer ceci, nous allons nous d\u00e9finir deux fonctions toutes simples qui renvoient `True` et `False` mais avec une impression de sorte qu'on voit lorsqu'elles sont ex\u00e9cut\u00e9es&nbsp;:"]}, {"block": 22, "type": "code", "linesLength": 6, "startIndex": 62, "lines": ["def true():\n", "    print 'true'\n", "    return True\n", "def false():\n", "    print 'false'\n", "    return False"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["true()"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["Ceci va nous permettre d'illustrer notre point, qui est que lorsque python \u00e9value un `and` ou un `or`, il **n'\u00e9value la deuxi\u00e8me condition que si c'est n\u00e9cessaire**. Ainsi par exemple&nbsp;: "]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 70, "lines": ["false() and true()"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 71, "lines": ["Dans ce cas, python \u00e9value la premi\u00e8re partie du `and` - qui provoque l'impression de `false` - et comme le r\u00e9sultat est faux, il n'est **pas n\u00e9cessaire** d'\u00e9valuer la seconde condition, on sait que de toute fa\u00e7on le r\u00e9sultat du `and` est forc\u00e9ment faux. C'est pourquoi vous ne voyez pas l'impression de `true`."]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 72, "lines": ["De mani\u00e8re sym\u00e9trique avec un `or`&nbsp;:"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 73, "lines": ["true() or false()"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 74, "lines": ["\u00c0 nouveau ici il n'est pas n\u00e9cessaire d'\u00e9valuer `false()`, et donc seul `true` est imprim\u00e9 \u00e0 l'\u00e9valuation."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 75, "lines": ["\u00c0 titre d'exercice, essayez de dire combien d'impressions sont \u00e9mises lorsqu'on \u00e9value cette expression un peu plus compliqu\u00e9e&nbsp;:"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 76, "lines": ["true() and (false() or true()) or (true () and false())"]}]
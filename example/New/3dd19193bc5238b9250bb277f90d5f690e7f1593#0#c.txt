[{"block": 0, "type": "heading", "linesLength": 1, "startIndex": 0, "lines": ["Construction de liste par compr\u00e9hension"]}, {"block": 1, "type": "heading", "linesLength": 1, "startIndex": 1, "lines": ["Compl\u00e9ment - niveau basique"]}, {"block": 2, "type": "markdown", "linesLength": 3, "startIndex": 2, "lines": ["Ce m\u00e9canisme tr\u00e8s pratique permet de construire simplement une liste \u00e0 partir d'une autre (ou de tout autre type iterable en r\u00e9alit\u00e9, mais nous y viendrons).\n", "\n", "Pour l'introduire en deux mots, disons que la compr\u00e9hension de liste est \u00e0 l'instruction `for` ce que l'expression conditionnelle est \u00e0 l'instruction  `if`, c'est-\u00e0-dire qu'il s'agit d'une **expression \u00e0 part enti\u00e8re**."]}, {"block": 3, "type": "heading", "linesLength": 1, "startIndex": 5, "lines": ["Cas le plus simple"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Voyons tout de suite un exemple"]}, {"block": 5, "type": "code", "linesLength": 2, "startIndex": 7, "lines": ["depart = [ 3, 7, 14, 28]\n", "[ x**2 for x in depart ]"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Comme vous l'avez sans doute devin\u00e9, le r\u00e9sultat de cette expression est une liste, dont les \u00e9l\u00e9ments sont les r\u00e9sultats de l'expression `x**2` pour `x` prenant toutes les valeurs de `depart`"]}, {"block": 7, "type": "heading", "linesLength": 1, "startIndex": 10, "lines": ["Restriction \u00e0 certains \u00e9l\u00e9ments"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Il est possible \u00e9galement de ne prendre en compte que certains des \u00e9l\u00e9ments de la liste de d\u00e9part, comme ceci"]}, {"block": 9, "type": "code", "linesLength": 1, "startIndex": 12, "lines": ["[ x**2 for x in depart if x%2 == 0 ]"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["qui cette fois ne contient que les carr\u00e9s des \u00e9l\u00e9ments pairs de `depart`"]}, {"block": 11, "type": "heading", "linesLength": 1, "startIndex": 14, "lines": ["Autres types"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Naturellement il n'est pas n\u00e9cessaire que l'objet de d\u00e9part soit une liste, ce pourrait \u00eatre aussi bien une cha\u00eene de caract\u00e8re, un tuple, ou autre.."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Nous verrons tr\u00e8s bient\u00f4t que des m\u00e9canismes similaires sont disponibles avec les dictionnaires et les ensembles."]}, {"block": 14, "type": "heading", "linesLength": 1, "startIndex": 17, "lines": ["Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 15, "type": "heading", "linesLength": 1, "startIndex": 18, "lines": ["Imbrications"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["On peut \u00e9galement imbriquer plusieurs niveaux pour ne construire qu'une seule liste, comme par exemple"]}, {"block": 17, "type": "code", "linesLength": 1, "startIndex": 20, "lines": ["[ n+p for n in [2,4] for p in [10,20,30] ]"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["Bien s\u00fbr on peut aussi restreindre ces compr\u00e9hensions, comme par exemple"]}, {"block": 19, "type": "code", "linesLength": 1, "startIndex": 22, "lines": ["[ n+p for n in [2,4] for p in [10,20,30] if n*p >= 40 ]"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Observez surtout que le r\u00e9sultat ci-dessus est une liste simple (de profondeur 1), \u00e0 comparer avec "]}, {"block": 21, "type": "code", "linesLength": 1, "startIndex": 24, "lines": ["[ [ n+p for n in [2,4] ] for p in [10,20,30] ]"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["qui est de profondeur 2, et o\u00f9 les r\u00e9sultats atomiques apparaissent dans un ordre diff\u00e9rent "]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Un moyen mn\u00e9motechnique pour se souvenir dans quel ordre les compr\u00e9hensions imbriqu\u00e9es produisent leur r\u00e9sultat, est de penser \u00e0 la version \"na\u00efve\" du code qui produirait le m\u00eame r\u00e9sultat; dans ce code les clause `for` et `if` apparaissent **dans le m\u00eame ordre** que dans la compr\u00e9hension"]}, {"block": 24, "type": "code", "linesLength": 6, "startIndex": 27, "lines": ["resultat=[]\n", "for n in [2,4]:\n", "    for p in [10,20,30]:\n", "        if n*p >= 40:\n", "            resultat.append(n+p)\n", "resultat"]}, {"block": 25, "type": "heading", "linesLength": 1, "startIndex": 33, "lines": ["Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 26, "type": "heading", "linesLength": 1, "startIndex": 34, "lines": ["Note sur `map` et `filter`\n"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Avant que les compr\u00e9hensions ne soient introduites, on utilisait deux fonctions \"builtin\" intitul\u00e9es `map` (nom qui provient \u00e0 l'origine de Lisp) et `filter`. Leur usage est \u00e0 pr\u00e9sent d\u00e9conseill\u00e9, car le code est beaucoup moins lisible. On les trouve encore dans du code existant  "]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Pour donner un aper\u00e7u de ces fonctions, au cas o\u00f9 vous en rencontriez dans du code existant, voici comment on \u00e9crirait"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 37, "lines": ["[ x**2 for x in depart if x%2 == 0 ]"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 38, "lines": ["Avec `map` et `filter` cela donnerait"]}, {"block": 31, "type": "code", "linesLength": 3, "startIndex": 39, "lines": ["def pair (x): return x%2 == 0\n", "def carre (x): return x**2\n", "map (carre, filter (pair,depart))"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Ou encore, sur une ligne"]}, {"block": 33, "type": "code", "linesLength": 1, "startIndex": 43, "lines": ["map (lambda x: x**2, filter (lambda x: x%2==0,depart))"]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["**Remarque**: la notation `lambda`, qui permet de d\u00e9finir une fonction \u00e0 la vol\u00e9e et sans la nommer, est toujours support\u00e9e (la preuve), mais \u00e0 notre avis au moins, a perdu beaucoup de son int\u00e9r\u00eat depuis, pr\u00e9cis\u00e9ment, l'introduction des compr\u00e9hensions, aussi nous ne recommandons pas non plus de l'utiliser dans du code nouveau."]}, {"block": 35, "type": "heading", "linesLength": 1, "startIndex": 45, "lines": ["Pour en savoir plus"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 46, "lines": ["La [section sur les compr\u00e9hensions de liste](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions) dans la documentation python"]}]
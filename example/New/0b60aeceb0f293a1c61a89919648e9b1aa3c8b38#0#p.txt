[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 2, "startIndex": 5, "lines": ["\n", "# `DataFrame` en pandas"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Cr\u00e9ation d'une DataFrame"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Une DataFrame est un tableau numpy \u00e0 deux dimension avec un index pour les lignes et un index pour les colonnes. Il y a de nombreuses mani\u00e8res de construire une DataFrame."]}, {"block": 5, "type": "code", "linesLength": 16, "startIndex": 10, "lines": ["# Regardons la construction d'une DataFrame\n", "import numpy as np\n", "import pandas as pd\n", "\n", "# Cr\u00e9ons une Serie pour d\u00e9finir des ages\n", "age = pd.Series([30, 20, 50], index=['alice', 'bob', 'julie'])\n", "\n", "# et une Serie pour d\u00e9finir des tailles\n", "height = pd.Series([150, 170, 168], index=['alice', 'marc', 'julie'])\n", "\n", "# On peut maintenant combiner ces deux Series en DataFrame,\n", "# chaque Series d\u00e9finissant une colonne, une mani\u00e8re de le faire est \n", "# de d\u00e9finir un dictionnaire qui contient pour clef le nom de la colonne\n", "# et pour valeur la Series correspondante\n", "stat = pd.DataFrame({'age': age, 'height':height})\n", "print(stat)"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["On remarque que pandas fait automatiquement l'alignement des index, lorsqu'une valeur n'est pas pr\u00e9sente, elle est automatiquement remplac\u00e9e par `NaN`. Pandas va \u00e9galement broadcaster une valeur unique d\u00e9finissant un colonne sur toutes les lignes. Regardons cela"]}, {"block": 7, "type": "code", "linesLength": 2, "startIndex": 27, "lines": ["stat = pd.DataFrame({'age': age, 'height':height, 'city': 'Nice'})\n", "print(stat)"]}, {"block": 8, "type": "code", "linesLength": 7, "startIndex": 29, "lines": ["# On peut maitenant acc\u00e9der aux indexes des lignes et des colonnes\n", "\n", "# l'index des lignes\n", "print(stat.index)\n", "\n", "# l'index des colonnes\n", "print(stat.columns)"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Il y a de nombreuses mani\u00e8res d'acc\u00e9der maintenant aux \u00e9l\u00e9ments de la DataFrame, certaines sont bonnes et d'autres \u00e0 proscrire, commen\u00e7ons par prendre de bonnes habitudes. Comme il s'agit d'une structure \u00e0 deux dimensions, il faut donner un indice de ligne et de colonne."]}, {"block": 10, "type": "code", "linesLength": 7, "startIndex": 37, "lines": ["# Quel est l'age de alice\n", "a = stat.loc['alice', 'age']\n", "print(f\"l'age de alice est : {a}\")\n", "\n", "# Quel est la moyenne de tous les ages\n", "m = stat.loc[:, 'age'].mean()\n", "print(f\"L'age moyen est de {m:.1f} ans\")"]}, {"block": 11, "type": "code", "linesLength": 1, "startIndex": 44, "lines": ["stat.loc[:, 'age'].mean()"]}, {"block": 12, "type": "markdown", "linesLength": 4, "startIndex": 45, "lines": ["On peut d\u00e9j\u00e0 noter plusieurs choses int\u00e9ressantes\n", "\n", " - On peut utiliser `.loc[]` et `.iloc` comme pour les Series. Pour les DataFrame c'est encore plus important parce qu'il y a plus de risques d'ambigu\u00eft\u00e9s (notamment entre les lignes et le colonnes, on y reviendra). \n", " - la m\u00e9thode `mean` calcule la moyenne, \u00e7a n'est pas surprenant, mais ignore les `NaN`. C'est en g\u00e9n\u00e9ral ce que l'on veut. Si vous vous demandez comment savoir si la m\u00e9thode que vous utilisez ignore ou pas les `NaN`, le mieux est de regarder l'aide de cette m\u00e9thode. Il existe pour un certain nombre de m\u00e9thodes deux versions : une qui ignore les `NaN` et une autre qui les prend en compte&nbsp;; on reviendra dessus."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 49, "lines": ["Une autre mani\u00e8re de construire une DataFrame est de partir d'un array numpy et de sp\u00e9cifier les indexes pour les lignes et les colonnes avec les arguments `index` et `columns`"]}, {"block": 14, "type": "code", "linesLength": 3, "startIndex": 50, "lines": ["a = np.random.randint(1, 20, 9).reshape(3,3)\n", "p = pd.DataFrame(a, index=['a', 'b', 'c'], columns=['x', 'y', 'z'])\n", "print(p)"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["### Manipulation d'une DataFrame"]}, {"block": 16, "type": "code", "linesLength": 13, "startIndex": 54, "lines": ["# contruisons maintenant une DataFrame jouet\n", "\n", "# voici une liste de pr\u00e9noms\n", "names = ['alice', 'bob', 'marc', 'bill', 'sonia']\n", "\n", "# cr\u00e9ons trois Series qui formeront trois colonnes\n", "age = pd.Series([12, 13, 16, 11, 16], index=names)\n", "height = pd.Series([130, 140, 176, 120, 165], index=names)\n", "sex = pd.Series(list('fmmmf'), index=names)\n", "\n", "# cr\u00e9ons maintenant la DataFrame\n", "p = pd.DataFrame({'age':age, 'height':height, 'sex':sex})\n", "print(p)"]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 67, "lines": ["# et chargeons le jeux de donn\u00e9es sur les pourboires de seaborn\n", "import seaborn as sns\n", "tips = sns.load_dataset('tips')"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Pandas offre de nombreuses possibilit\u00e9s d'explorer les donn\u00e9es. Attention, dans mes exemples je vais alterner entre le DataFrame `p` et le DataFrame `tips` suivant les besoins de l'explication. "]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["# afficher les premi\u00e8res lignes \n", "tips.head()"]}, {"block": 20, "type": "code", "linesLength": 2, "startIndex": 73, "lines": ["# et les derni\u00e8re lignes\n", "tips.tail()"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 75, "lines": ["# afficher l'index des lignes\n", "p.index"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["# et de colonnes\n", "p.columns"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# transposer \n", "p.T"]}, {"block": 24, "type": "code", "linesLength": 2, "startIndex": 81, "lines": ["# et afficher uniquement les valeurs\n", "p.values"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Pour finir, il y a la m\u00e9thodes `describe` qui permet d'obtenir des premi\u00e8res statistiques sur un DataFrame. `describe` permet de calculer des statistiques sur des type num\u00e9riques, mais aussi sur des types cha\u00eenes de caract\u00e8res. "]}, {"block": 26, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["# par d\u00e9faut describe ne prend en compte que les colonnes num\u00e9riques\n", "p.describe()"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["# mais on peut le forcer en prendre en compte toutes les colonnes\n", "p.describe(include='all')"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 88, "lines": ["### Requ\u00eates sur une DataFrame"]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["On peut maintenant commencer \u00e0 faire des requ\u00eates sur les DataFrames. Les DataFrame supportent la notion de masque que l'on a vue pour les ndarray numpy et pour les Series. "]}, {"block": 30, "type": "code", "linesLength": 2, "startIndex": 90, "lines": ["# p.loc prend soit un label de ligne\n", "print(p.loc['sonia'])"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["# ou alors un label de ligne ET de colonne\n", "print(p.loc['sonia', 'age'])"]}, {"block": 32, "type": "markdown", "linesLength": 12, "startIndex": 94, "lines": ["On peut mettre \u00e0 la place d'une label :\n", "\n", " - une liste de labels\n", " - un slice sur les labels\n", " - un masque (c'est-\u00e0-dire un tableau de bool\u00e9ens)\n", " - un callable qui retourne une des trois premi\u00e8res possibilit\u00e9s\n", " \n", "Noter que l'on peut \u00e9galement utiliser la notation `.iloc[]` avec les m\u00eames r\u00e8gles, mais elle est moins utile. \n", "\n", "Je recommande de toujours utiliser la notation `.loc[lignes, colonnes]` pour \u00e9viter toute ambigu\u00eft\u00e9. Nous verrons que les notations `.loc[lignes]` ou pire seulement `[label]` sont sources d'erreurs.\n", "\n", "Regardons maintenant d'autres exemples plus sophistiqu\u00e9s."]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 106, "lines": ["# gardons uniquement les femmes\n", "p.loc[p.loc[:,'sex']=='f',:]"]}, {"block": 34, "type": "code", "linesLength": 2, "startIndex": 108, "lines": ["# gardons uniquement les femmes de plus de 12 ans\n", "p.loc[(p.loc[:,'sex']=='f') & (p.loc[:, 'age'] > 12), :]"]}, {"block": 35, "type": "code", "linesLength": 16, "startIndex": 110, "lines": ["# quelle est la note moyenne des femmes\n", "note_f = tips.loc[tips.loc[:,'sex']=='Female', 'total_bill'].mean()\n", "print(f\"note moyenne des femmes : {note_f:.2f}\")\n", "\n", "# quelle est la note moyenne des hommes\n", "note_h = tips.loc[tips.loc[:,'sex']=='Male', 'total_bill'].mean()\n", "print(f\"note moyenne des hommes : {note_h:.2f}\")\n", "\n", "# qui laisse le plus grand pourcentage de pourboire : \n", "# les hommes ou les femmes\n", "\n", "pourboire_f  = tips.loc[tips.loc[:,'sex']=='Female', 'tip'].mean()\n", "pourboire_h  = tips.loc[tips.loc[:,'sex']=='Male', 'tip'].mean()\n", "\n", "print(f\"Les femmes laissent {pourboire_f/note_f:.2%} de pourboire\")\n", "print(f\"Les hommes laissent {pourboire_h/note_h:.2%} de pourboire\")"]}, {"block": 36, "type": "markdown", "linesLength": 1, "startIndex": 126, "lines": ["### Erreurs fr\u00e9quentes et ambigu\u00eft\u00e9s sur les requ\u00eates"]}, {"block": 37, "type": "markdown", "linesLength": 3, "startIndex": 127, "lines": ["Nous avons vu une mani\u00e8re simple et non ambigu\u00eb de faire des requ\u00eates sur les DataFrame, mais nous allons voir qu'il existe d'autres mani\u00e8res qui ont pour seul avantage d'\u00eatre plus concise, mais sources de nombreuses erreurs. \n", "\n", "**Souvenez-vous, utilisez toujours la notation `.loc[lignes, colonnes]` sinon, soyez s\u00fbr de savoir ce qui est r\u00e9ellement calcul\u00e9**."]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 130, "lines": ["# commen\u00e7ons par la notation la plus classique\n", "p['sex'] # prend forc\u00e9ment un label de colonne"]}, {"block": 39, "type": "code", "linesLength": 3, "startIndex": 132, "lines": ["# mais par contre, si on passe un slice, c'est forc\u00e9ment des lignes,\n", "# assez perturbant et source de confusion.\n", "p['alice': 'marc']"]}, {"block": 40, "type": "code", "linesLength": 2, "startIndex": 135, "lines": ["# on peut m\u00eame directement acc\u00e9der \u00e0 une colonne par son nom\n", "p.age"]}, {"block": 41, "type": "code", "linesLength": 8, "startIndex": 137, "lines": ["# mais il ne faut jamais le faire parce que si un attribut de m\u00eame \n", "# nom existe sur une DataFrame, alors la priorit\u00e9 est donn\u00e9e \u00e0 l'attribut\n", "# et non \u00e0 la colonne\n", "\n", "# ajoutons une colonne qui a pour nom une m\u00e9thode qui existe sur \n", "# les DataFrame\n", "p['mean'] = 1\n", "print(p)"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 145, "lines": ["# je peux bien acc\u00e9der \u00e0 la colonne sex\n", "p.sex"]}, {"block": 43, "type": "code", "linesLength": 2, "startIndex": 147, "lines": ["# mais pas \u00e0 la colonne mean\n", "p.mean"]}, {"block": 44, "type": "code", "linesLength": 2, "startIndex": 149, "lines": ["# de nouveau, la seule m\u00e9thode non ambigu\u00eb est d'utiliser .loc\n", "p.loc[:,'mean']"]}, {"block": 45, "type": "code", "linesLength": 4, "startIndex": 151, "lines": ["# supprimons maintenant la colonne mean *en place* (par d\u00e9faut, \n", "# drop retourne une nouvelle DataFrame)\n", "p.drop(columns='mean', inplace=True)\n", "print(p)"]}, {"block": 46, "type": "markdown", "linesLength": 3, "startIndex": 155, "lines": ["Pour allez plus loin, vous pouvez lire la documentation officielle : \n", "\n", "http://pandas.pydata.org/pandas-docs/stable/indexing.html"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 158, "lines": ["### Ufuncs et pandas"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 159, "lines": ["\u00c7a n'est pas une surprise, les Series et DataFrame pandas supportent les Ufuncs numpy. Mais il y a une subtilit\u00e9. Il est parfaitement l\u00e9gitime et correcte d'appliquer une Ufunc numpy sur les \u00e9l\u00e9ments d'une DataFrame"]}, {"block": 49, "type": "code", "linesLength": 2, "startIndex": 160, "lines": ["d = pd.DataFrame(np.random.randint(1, 10, 9).reshape(3,3), columns=list('abc'))\n", "print(d)"]}, {"block": 50, "type": "code", "linesLength": 1, "startIndex": 162, "lines": ["np.log(p/np.max(p))"]}, {"block": 51, "type": "markdown", "linesLength": 5, "startIndex": 163, "lines": ["Nous remarquons que comme on s'y attend, la Ufunc a \u00e9t\u00e9 appliqu\u00e9e \u00e0 chaque \u00e9l\u00e9ment de la DataFrame et que les labels des lignes et colonnes ont \u00e9t\u00e9 pr\u00e9serv\u00e9s. \n", "\n", "Par contre, si l'on a besoin d'alignement de labels, c'est le cas avec toutes les op\u00e9rations qui s'appliquent sur 2 objets comme une addition, alors les Ufuncs numpy ne vont pas faire ce \u00e0 quoi on s'attend. Elle vont faire les op\u00e9rations sur les tableaux numpy sans prendre en compte les labels. \n", "\n", "Pour avoir un alignement des labels, il faut utiliser les Ufuncs pandas. "]}, {"block": 52, "type": "code", "linesLength": 7, "startIndex": 168, "lines": ["# prenons deux series\n", "s1 = pd.Series([10, 20, 30], index=list('abc'))\n", "s2 = pd.Series([12, 22, 32], index=list('acd'))\n", "\n", "# la Ufunc numpy fait la somme des arrays sans prendre en compte \n", "# les labels, donc sans alignement\n", "np.add(s1, s2)"]}, {"block": 53, "type": "code", "linesLength": 3, "startIndex": 175, "lines": ["# la Ufunc pandas va faire un alignement des labels\n", "# cet appel est \u00e9quivalent \u00e0 s1 + s2\n", "s1.add(s2)"]}, {"block": 54, "type": "code", "linesLength": 4, "startIndex": 178, "lines": ["# comme on l'a vu sur le compl\u00e9ment pr\u00e9c\u00e9dent, les valeurs absentes sont\n", "# remplac\u00e9es par NaN, mais on peut changer ce comportement lors de \n", "# l'appel de .add\n", "s1.add(s2, fill_value=0)"]}, {"block": 55, "type": "code", "linesLength": 12, "startIndex": 182, "lines": ["# regardons un autre exemple sur des DataFrame\n", "names = ['alice', 'bob', 'charle']\n", "bananas = pd.Series([10, 3, 9], index=names)\n", "oranges = pd.Series([3, 11, 6], index=names)\n", "fruits_jan = pd.DataFrame({'bananas':bananas, 'orange': oranges})\n", "\n", "bananas = pd.Series([6, 1], index=names[:-1])\n", "apples = pd.Series([8, 5], index=names[1:])\n", "fruits_feb = pd.DataFrame({'bananas':bananas, 'apples': apples})\n", "\n", "print(fruits_jan)\n", "print(fruits_feb)"]}, {"block": 56, "type": "code", "linesLength": 3, "startIndex": 194, "lines": ["# regardons maintenant la somme des fruits mang\u00e9s\n", "eaten_fruits = fruits_jan + fruits_feb\n", "print(eaten_fruits)"]}, {"block": 57, "type": "code", "linesLength": 4, "startIndex": 197, "lines": ["# On a bien un alignement des labels, mais il y a beaucoup de valeurs\n", "# manquantes. Corrigeons cela on rempla\u00e7ant les valeurs manquantes par 0\n", "eaten_fruits = fruits_jan.add(fruits_feb, fill_value=0)\n", "print(eaten_fruits)"]}, {"block": 58, "type": "markdown", "linesLength": 1, "startIndex": 201, "lines": ["Notons que lorsqu'une valeur est absente dans toutes les DataFrame, `NaN` est conserv\u00e9."]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 202, "lines": ["Un derni\u00e8re subtilit\u00e9 a conna\u00eetre lors de l'alignement des labels est lorsque vous faites une op\u00e9ration sur une DataFrame et une Series. Pandas va consid\u00e9re la Series comme une ligne et va la broadcaster sur les autres lignes. Par cons\u00e9quent, l'index de la Series va \u00eatre consid\u00e9r\u00e9 comme des colonnes et align\u00e9 avec les colonnes de la DataFrame."]}, {"block": 60, "type": "code", "linesLength": 6, "startIndex": 203, "lines": ["d = pd.DataFrame(np.random.randint(1, 10, size=(3,3)), columns=list('abc'), index=list('xyz'))\n", "s_row = pd.Series([-10, -10, -10], index=list('abc'))\n", "s_col = pd.Series([-10, -10, -10], index=list('xyz'))\n", "print(d)\n", "print(s_row)\n", "print(s_col)"]}, {"block": 61, "type": "code", "linesLength": 6, "startIndex": 209, "lines": ["# la Series est consid\u00e9r\u00e9e comme une ligne et son indexe \n", "# s'aligne sur les colonnes de la DataFrame. La Series va \u00eatre\n", "# broadcast\u00e9e sur les autres lignes de la DataFrame\n", "\n", "d + s_row\n", "p"]}, {"block": 62, "type": "code", "linesLength": 3, "startIndex": 215, "lines": ["# si les labels ne correspondent pas, le r\u00e9sultat sera le suivant\n", "\n", "d + s_col"]}, {"block": 63, "type": "code", "linesLength": 4, "startIndex": 218, "lines": ["# on peut dans ce cas, changer le comportement par d\u00e9faut et for\u00e7ant \n", "# l'alignement de la Series suivant un autre axe avec l'argument axis\n", "\n", "d.add(s_col, axis=0)"]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 222, "lines": ["Ici, `axis=0` signifie que la Series est consid\u00e9r\u00e9e comme une colonne est qu'elle va \u00eatre broadcast\u00e9 sur les autres colonnes (le long de l'axe de ligne)."]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 223, "lines": ["### Op\u00e9rations sur les cha\u00eenes de caract\u00e8res"]}, {"block": 66, "type": "markdown", "linesLength": 12, "startIndex": 224, "lines": ["Nous allons maintenant parler de la vectorisation des \n", "op\u00e9rations sur les cha\u00eenes de caract\u00e8res. Il y a plusieurs choses importantes \u00e0 savoir.\n", "\n", " - Les m\u00e9thodes sur les cha\u00eenes de caract\u00e8res ne sont disponibles que pour les Series et les Index, mais pas pour les DataFrame. \n", " - Ces m\u00e9thodes ignorent les `NaN` et remplacent les valeurs qui ne sont pas des cha\u00eenes de caract\u00e8res par `NaN`\n", " - Ces m\u00e9thodes retournent une copie de l'objet (Series ou Index), il n'y a pas de modification en place\n", " - La plupart des m\u00e9thodes Python sur le type `str` existe sous forme vectoris\u00e9e\n", " - On acc\u00e8de \u00e0 ces m\u00e9thodes avec la syntaxe\n", "   - `Series.str.<vectorized method name>`\n", "   - `Index.str.<vectorized method name>`\n", "   \n", "Regardons quelques exemples."]}, {"block": 67, "type": "code", "linesLength": 4, "startIndex": 236, "lines": ["# Cr\u00e9ons une Series avec des noms ayant une capitalisation inconsistante\n", "# et une mauvaise gestion des espaces\n", "names = ['alice ', '  bOB', 'Marc', 'bill', 3, ' JULIE ', np.NaN]\n", "age = pd.Series(names)"]}, {"block": 68, "type": "code", "linesLength": 13, "startIndex": 240, "lines": ["# nettoyons maintenant ces donn\u00e9es\n", "\n", "# on met en minuscule\n", "a = age.str.lower()\n", "\n", "# on enl\u00e8ve les espaces\n", "a = a.str.strip()\n", "print(a)\n", "\n", "# comme les m\u00e9thodes vectoris\u00e9es retournent un objet de m\u00eame type, on \n", "# peut les chainer ainsi\n", "\n", "[x for x in age.str.lower().str.strip()]"]}, {"block": 69, "type": "code", "linesLength": 3, "startIndex": 253, "lines": ["# on peut \u00e9galement utiliser l'indexation des str de mani\u00e8re vectoris\u00e9e\n", "print(a)\n", "print(a.str[-1])"]}, {"block": 70, "type": "markdown", "linesLength": 3, "startIndex": 256, "lines": ["Pour allez plus loin vous pouvez lire la documentation officielle :\n", "\n", "http://pandas.pydata.org/pandas-docs/stable/text.html"]}, {"block": 71, "type": "markdown", "linesLength": 1, "startIndex": 259, "lines": ["### Gestion des valeurs manquantes"]}, {"block": 72, "type": "markdown", "linesLength": 14, "startIndex": 260, "lines": ["Nous avons vu que des op\u00e9rations sur les DataFrame pouvaient g\u00e9n\u00e9rer des valeurs `NaN` lors de l'alignement. Il est \u00e9galement possible d'avoir de telles valeurs _manquantes_ dans votre jeux de donn\u00e9es original. Pandas offre plusieurs possibilit\u00e9s pour g\u00e9rer correctement ces valeurs manquantes. \n", "\n", "Avant de voir ces diff\u00e9rentes possibilit\u00e9s, d\u00e9finissons cette notion de valeur manquante.\n", "\n", "Une valeur manquante peut-\u00eatre repr\u00e9sent\u00e9e en pandas soit par `np.NaN` ou par l'objet Python `None`. \n", "\n", " - `np.NaN` est un objet de type `float`, par cons\u00e9quent il ne peut appara\u00eetre que dans un array de `float` ou un array d'`object`. Notons que `np.NaN` appara\u00eet en pandas comme simplement `NaN` et que dans la suite on utilise de mani\u00e8re indiff\u00e9rente les deux notations, par contre, dans du code, il faut obligatoirement utiliser `np.NaN`.\n", "     - si on ajoute un `NaN` dans un array d'entier, ils seront convertis en `float64`\n", "     - si on ajoute un `NaN` dans un array de bool\u00e9ens, ils seront convertis en `object`\n", " - `NaN`est contaminant, toute op\u00e9ration avec un `NaN` a pour r\u00e9sultat `NaN`\n", " - lorsque l'on utilise `None`, il est automatiquement convertit en `NaN` lorsque le type de l'array est num\u00e9rique.\n", " \n", "Illustrons ces propri\u00e9t\u00e9s.\n", "     "]}, {"block": 73, "type": "code", "linesLength": 3, "startIndex": 274, "lines": ["# une Series d'entier\n", "s = pd.Series([1, 2])\n", "print(s)"]}, {"block": 74, "type": "code", "linesLength": 3, "startIndex": 277, "lines": ["# on ajouter un NaN, la Series est alors converties en float64\n", "s[0] = np.NaN\n", "print(s)"]}, {"block": 75, "type": "code", "linesLength": 8, "startIndex": 280, "lines": ["# une nouvelle Serie d'entier\n", "s = pd.Series([1, 2])\n", "\n", "# et on ajouter None\n", "s[0] = None\n", "\n", "# None est converti en NaN\n", "print(s)"]}, {"block": 76, "type": "markdown", "linesLength": 10, "startIndex": 288, "lines": ["Regardons maintenant, les m\u00e9thodes pandas pour g\u00e9rer les valeurs manquantes (donc `NaN` ou `None`).\n", "\n", " - `isna()` retourne un masque mettant \u00e0 True les valeurs manquantes (il y a un alias `isnull()`)\n", " - `notna()` retourne un masque mettant \u00e0 False les valeurs manquantes (il y a un alias `notnull()`)\n", " - `dropna()` retourne un nouvel objet sans les valeurs manquantes\n", " - `fillna()` retourne un nouvel objet avec les valeurs manquantes remplac\u00e9es\n", " \n", "On remarque que l'ajout d'alias pour les m\u00e9thodes est de nouveau une source de confusion avec laquelle il faut vivre. \n", "\n", "On remarque \u00e9galement qu'alors que `isnull()` et `notnull()` sont des m\u00e9thodes simples, `dropna()` et `fillna()` impliquent l'utilisation de strat\u00e9gies. Regardons cela. "]}, {"block": 77, "type": "code", "linesLength": 6, "startIndex": 298, "lines": ["# cr\u00e9ons une DataFrame avec quelques valeurs manquantes\n", "names = ['alice', 'bob', 'charle']\n", "bananas = pd.Series([6, 1], index=names[:-1])\n", "apples = pd.Series([8, 5], index=names[1:])\n", "fruits_feb = pd.DataFrame({'bananas':bananas, 'apples': apples})\n", "print(fruits_feb)"]}, {"block": 78, "type": "code", "linesLength": 1, "startIndex": 304, "lines": ["fruits_feb.isna()"]}, {"block": 79, "type": "code", "linesLength": 1, "startIndex": 305, "lines": ["fruits_feb.notna()"]}, {"block": 80, "type": "markdown", "linesLength": 1, "startIndex": 306, "lines": ["Par d\u00e9faut, `dropna()` va enlever toutes les lignes qui contiennent au moins une valeur manquante. Mais on peut changer ce comportement avec des arguments. Regardons quelques exemples."]}, {"block": 81, "type": "code", "linesLength": 2, "startIndex": 307, "lines": ["p = pd.DataFrame([[1, 2, np.NaN], [3, np.NaN, np.NaN], [7, 5, np.NaN]])\n", "print(p)"]}, {"block": 82, "type": "code", "linesLength": 3, "startIndex": 309, "lines": ["# comportement par d\u00e9faut, j'enl\u00e8ve toutes les lignes avec au moins \n", "# une valeur manquante\n", "p.dropna()"]}, {"block": 83, "type": "code", "linesLength": 2, "startIndex": 312, "lines": ["# maintenant, je fais l'op\u00e9ration par colonne\n", "p.dropna(axis=1)"]}, {"block": 84, "type": "code", "linesLength": 2, "startIndex": 314, "lines": ["# je vais l'op\u00e9ration par colonne qui si toute la colonne est manquante\n", "p.dropna(axis=1, how='all')"]}, {"block": 85, "type": "code", "linesLength": 2, "startIndex": 316, "lines": ["# je fais l'op\u00e9ration par ligne si au moins 2 valeurs sont manquantes\n", "p.dropna(thresh=2)"]}, {"block": 86, "type": "markdown", "linesLength": 1, "startIndex": 318, "lines": ["Par d\u00e9faut, `fillna()` remplace les valeurs manquantes avec un argument pas d\u00e9faut. Mais on peut ici aussi changer ce comportement. Regardons cela."]}, {"block": 87, "type": "code", "linesLength": 1, "startIndex": 319, "lines": ["print(p)"]}, {"block": 88, "type": "code", "linesLength": 2, "startIndex": 320, "lines": ["# je remplace les valeurs manquantes par -1\n", "p.fillna(-1)"]}, {"block": 89, "type": "code", "linesLength": 4, "startIndex": 322, "lines": ["# je remplace les valeurs manquantes avec la valeur suivante sur la colonne\n", "# bfill est pour back fill, c'est-\u00e0-dire remplace en arri\u00e8re \u00e0 partir des\n", "# valeurs existante\n", "p.fillna(method='bfill')"]}, {"block": 90, "type": "code", "linesLength": 4, "startIndex": 326, "lines": ["# je remplace les valeurs manquantes avec la valeur pr\u00e9c\u00e9dente sur la ligne\n", "# ffill est pour forward fill, remplace en avant \u00e0 partir des valeurs\n", "# existantes\n", "p.fillna(method='ffill', axis=1)"]}, {"block": 91, "type": "markdown", "linesLength": 1, "startIndex": 330, "lines": ["Regardez l'aide de ces m\u00e9thodes pour aller plus loin."]}, {"block": 92, "type": "code", "linesLength": 1, "startIndex": 331, "lines": ["p.dropna?"]}, {"block": 93, "type": "code", "linesLength": 1, "startIndex": 332, "lines": ["p.fillna?"]}, {"block": 94, "type": "markdown", "linesLength": 1, "startIndex": 333, "lines": ["### Les MultiIndex"]}, {"block": 95, "type": "markdown", "linesLength": 3, "startIndex": 334, "lines": ["Pandas avait historiquement d'autres structures de donn\u00e9es en plus des Series et des DataFrame permettant d'exprimer des dimensionalit\u00e9s sup\u00e9rieur \u00e0 2 comme par exemple les Panel. Mais pour des raisons de maintenance du code et d'optimisations, les d\u00e9veloppeurs ont d\u00e9cid\u00e9 de ne garder que les Series et les DataFrame. Alors, comment exprimer des donn\u00e9es avec plus de deux dimensions ?\n", "\n", "On utilise pour cela des MultiIndex. Un MultiIndex, est un index qui peut \u00eatre utilis\u00e9 partout o\u00f9 l'on utilise un Index (dans une Series, ou comme ligne ou colonne d'une DataFrame) et qui a pour caract\u00e9ristiques d'avoir plusieurs niveaux. Regardons tout de suite un exemple."]}, {"block": 96, "type": "code", "linesLength": 13, "startIndex": 337, "lines": ["# contruisons une DataFrame jouet\n", "\n", "# voici une liste de pr\u00e9noms\n", "names = ['alice', 'bob', 'sonia']\n", "\n", "# cr\u00e9ons trois Series qui formeront trois colonnes\n", "age = pd.Series([12, 13, 16], index=names)\n", "height = pd.Series([130, 140, 165], index=names)\n", "sex = pd.Series(list('fmf'), index=names)\n", "\n", "# cr\u00e9ons maintenant la DataFrame\n", "p = pd.DataFrame({'age':age, 'height':height, 'sex':sex})\n", "print(p)"]}, {"block": 97, "type": "code", "linesLength": 2, "startIndex": 350, "lines": ["s = p.unstack()\n", "print(s)"]}, {"block": 98, "type": "markdown", "linesLength": 1, "startIndex": 352, "lines": ["### Acquisition de donn\u00e9es"]}, {"block": 99, "type": "code", "linesLength": 0, "startIndex": 353, "lines": []}]
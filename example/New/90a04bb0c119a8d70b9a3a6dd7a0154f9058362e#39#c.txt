[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Les fichiers"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Voici quelques utilisations habituelles du type fichier en python"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 4, "lines": ["### Avec un *context manager*"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["Nous avons vu dans la vid\u00e9o les m\u00e9canismes de base sur les fichiers. Nous avons vu notamment qu'il est important de bien fermer un fichier apr\u00e8s usage. On a vu aussi qu'il est recommand\u00e9 de **toujours** utiliser l'instruction `with`. Il est donc recommand\u00e9 de faire:"]}, {"block": 6, "type": "code", "linesLength": 4, "startIndex": 6, "lines": ["# avec un `with' on garantit la fermeture du fichier\n", "with open(\"foo.txt\", \"w\") as sortie:\n", "    for i in range(2):\n", "        sortie.write(f\"{i}\\n\")"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 10, "lines": ["### Les modes d'ouverture"]}, {"block": 8, "type": "markdown", "linesLength": 4, "startIndex": 11, "lines": ["Les modes d'ouverture les plus utilis\u00e9s sont\n", " * `'r'` (la cha\u00eene contenant l'unique caract\u00e8re `r`) pour ouvrir un fichier en lecture seulement;\n", " * `'w'` en \u00e9criture seulement; le contenu pr\u00e9c\u00e9dent du fichier, s'il existait, est perdu;\n", " * `'a'` en \u00e9criture seulement, mais pour ajouter du contenu en fin de fichier.\n"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["Voici par exemple comment on pourrait ajouter deux lignes de texte dans le fichier `foo.txt` qui contient, \u00e0 ce stade du notebook, 2 entiers:"]}, {"block": 10, "type": "code", "linesLength": 4, "startIndex": 16, "lines": ["# on ouvre le fichier en mode 'a' comme append (= ajouter)\n", "with open(\"foo.txt\", \"a\") as sortie:\n", "    for i in range(100, 102):\n", "        sortie.write(\"{}\\n\".format(i))"]}, {"block": 11, "type": "code", "linesLength": 5, "startIndex": 20, "lines": ["# maintenant on regarde ce que contient le fichier\n", "with open(\"foo.txt\") as entree: # remarquez que sans 'mode', on ouvre en lecture seule\n", "    for line in entree:\n", "        # line contient d\u00e9j\u00e0 un newline\n", "        print(line, end='')"]}, {"block": 12, "type": "markdown", "linesLength": 5, "startIndex": 25, "lines": ["Il existe de nombreuses variantes au mode d'ouverture, pour par exemple:\n", " * ouvrir le fichier en lecture *et* en \u00e9criture (mode `+`),\n", " * ouvrir le fichier en mode binaire (mode `b`).\n", "\n", "Ces variantes sont d\u00e9crites dans [la section sur la fonction built-in `open`](https://docs.python.org/3/library/functions.html#open) dans la documentation python."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["### Un fichier est un it\u00e9rateur"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 32, "lines": ["Pendant que l'on parle d'it\u00e9rateur, remarquons qu'un fichier - qui donc **est it\u00e9rable** puisqu'on peut le lire par une boucle `for` - est aussi **son propre it\u00e9rateur**:"]}, {"block": 16, "type": "code", "linesLength": 1, "startIndex": 33, "lines": ["# un fichier est son propre it\u00e9rateur"]}, {"block": 17, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["with open(\"foo.txt\") as entree:\n", "    print(entree.__iter__() is entree)"]}, {"block": 18, "type": "markdown", "linesLength": 1, "startIndex": 36, "lines": ["Dans le prolongement de la discussion sur les it\u00e9rateurs et les it\u00e9rables en fin de semaine 3, nous vous rappelons que tous les autres types de base que nous avons vus jusqu'ici ont leur it\u00e9rateurs impl\u00e9ment\u00e9s comme des objets s\u00e9par\u00e9s. Nous avions \u00e0 l'\u00e9poque soulign\u00e9 que ce choix permettait notamment de r\u00e9aliser deux boucles imbriqu\u00e9es sur la m\u00eame liste."]}, {"block": 19, "type": "code", "linesLength": 5, "startIndex": 37, "lines": ["# deux boucles imbriqu\u00e9es sur la m\u00eame liste fonctionnent comme attendu\n", "liste = [1, 2]\n", "for i in liste:\n", "    for j in liste:\n", "        print(i, \"x\", j)"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Par contre, \u00e9crire deux boucles `for` imbriqu\u00e9es sur **le m\u00eame objet fichier** ne **fonctionnerait pas** comme on pourrait s'y attendre :"]}, {"block": 21, "type": "code", "linesLength": 10, "startIndex": 43, "lines": ["# Si on essaie d'\u00e9crire deux boucles imbriqu\u00e9es\n", "# sur le m\u00eame objet fichier, le r\u00e9sultat est inattendu\n", "with open(\"foo.txt\") as entree:\n", "    for l1 in entree:\n", "        # on enleve les fins de ligne\n", "        l1 = l1.strip()\n", "        for l2 in entree:\n", "            # on enleve les fins de ligne\n", "            l2 = l2.strip()\n", "            print(l1, \"x\", l2)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["### Autres m\u00e9thodes"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["Vous pouvez \u00e9galement acc\u00e9der \u00e0 des fonctions de beaucoup plus bas niveau, notamment celle fournies directement par le syst\u00e8me d'exploitation; nous allons en d\u00e9crire deux parmi les plus utiles."]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["##### Digression - `repr()`"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["Comme nous allons utiliser maintenant des outils d'assez bas niveau pour lire du texte, aussi pour examiner ce texte nous allons utiliser la fonction `repr()`, et voici pourquoi:"]}, {"block": 27, "type": "code", "linesLength": 2, "startIndex": 58, "lines": ["# construisons \u00e0 la main une chaine qui contient deux lignes\n", "lines = \"abc\"+ \"\\n\" + \"def\"  + \"\\n\""]}, {"block": 28, "type": "code", "linesLength": 4, "startIndex": 60, "lines": ["# si on l'imprime on voit bien les newline\n", "# d'ailleurs on sait qu'il n'est pas utile \n", "# d'ajouter un newline \u00e0 la fin\n", "print(lines, end=\"\")"]}, {"block": 29, "type": "code", "linesLength": 3, "startIndex": 64, "lines": ["# v\u00e9rifions que repr() nous permet de bien\n", "# voir le contenu de cette chaine\n", "print(repr(lines))"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["##### Lire un contenu - bas niveau"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 68, "lines": ["Revenons aux fichiers; la m\u00e9thode `read()` permet de lire dans le fichier un buffer d'une certaine taille:"]}, {"block": 32, "type": "code", "linesLength": 7, "startIndex": 69, "lines": ["# read() retourne TOUT le contenu\n", "# ne pas utiliser avec de tr\u00e8s gros fichier bien s\u00fbr\n", "\n", "# une autre fa\u00e7on de montrer tout le contenu du fichier\n", "with open(\"foo.txt\") as entree:\n", "    full_contents = entree.read()\n", "    print(\"Contenu complet\\n{}\".format(full_contents), end=\"\")    "]}, {"block": 33, "type": "code", "linesLength": 4, "startIndex": 76, "lines": ["# lire dans le fichier deux blocs de 4 caract\u00e8res\n", "with open(\"foo.txt\") as entree:\n", "    for bloc in range(2):\n", "        print(\"Bloc {} >>{}<<\".format(bloc, repr(entree.read(4))))"]}, {"block": 34, "type": "markdown", "linesLength": 6, "startIndex": 80, "lines": ["On voit donc que chaque bloc contient bien 4 caract\u00e8res en comptant les sauts de ligne\n", "\n", "| bloc # | | contenu |\n", "|--------|-| ---------|\n", "| 0 | | un `0`, un *newline*, un `1`, un *newline* |\n", "| 1 | | un `1`, deux `0`, un *newline* |\n"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["##### La m\u00e9thode `flush`"]}, {"block": 36, "type": "markdown", "linesLength": 3, "startIndex": 87, "lines": ["Les entr\u00e9es-sortie sur fichier sont bien souvent *bufferis\u00e9es* par le syst\u00e8me d'exploitation. Cela signifie qu'un appel \u00e0 `write` ne provoque pas forc\u00e9ment une \u00e9criture imm\u00e9diate, car pour des raisons de performance on attend d'avoir suffisamment de mati\u00e8re avant d'\u00e9crire sur le disque.\n", "\n", "Il y a des cas o\u00f9 ce comportement peut s'av\u00e9rer g\u00eanant, et o\u00f9 on a besoin d'\u00e9crire imm\u00e9diatement (et donc de vider le *buffer*), et c'est le propos de la m\u00e9thode `flush`()."]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 90, "lines": ["### Fichiers textuels et fichiers binaires"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["De la m\u00eame fa\u00e7on que le langage propose les deux types `str` et `bytes`, il est possible d'ouvrir un fichier en mode *textuel* ou en mode *binaire*. "]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Les fichiers que nous avons vus jusqu'ici \u00e9taient ouverts en mode *textuel* (c'est le d\u00e9faut), et c'est pourquoi quand nous avons interagi avec eux avec des objets de type `str`:"]}, {"block": 40, "type": "code", "linesLength": 4, "startIndex": 93, "lines": ["# un fichier ouvert en mode textuel nous donne des str\n", "with open('foo.txt') as input:\n", "    for line in input:\n", "        print(\"on a lu un objet de type\", type(line))"]}, {"block": 41, "type": "markdown", "linesLength": 3, "startIndex": 97, "lines": ["Lorsque ce n'est pas le comportement souhait\u00e9, on peut \n", "* ouvrir le fichier en mode *binaire* - pour cela on ajoute le caract\u00e8re `b` au mode d'ouverture\n", "* et on peut alors interagir avec le fichier avec des objets de type `bytes`"]}, {"block": 42, "type": "markdown", "linesLength": 3, "startIndex": 100, "lines": ["Pour illustrer ce trait, nous allons:\n", "1. cr\u00e9er un fichier en mode texte, et y ins\u00e9rer du texte en UTF-8\n", "1. relire le fichier en mode binaire, et retrouver le codage des diff\u00e9rents caract\u00e8res."]}, {"block": 43, "type": "code", "linesLength": 7, "startIndex": 103, "lines": ["# phase 1 : on \u00e9crit un fichier avec du texte en UTF-8\n", "# on ouvre le donc le fichier en mode texte\n", "# en toute rigueur il faut pr\u00e9ciser l'encodage, \n", "# si on ne le fait pas il sera d\u00e9termin\u00e9 \n", "# \u00e0 partir de vos r\u00e9glages syst\u00e8me\n", "with open('strbytes', 'w', encoding='utf-8') as output:\n", "    output.write(\"d\u00e9j\u00e0 l'\u00e9t\u00e9\\n\")"]}, {"block": 44, "type": "code", "linesLength": 9, "startIndex": 110, "lines": ["# phase 2: on rouvre le fichier en mode binaire\n", "with open('strbytes', 'rb') as rawinput:\n", "    # on relit tout le contenu\n", "    octets = rawinput.read()\n", "    # qui est de type bytes\n", "    print(\"on a lu un objet de type\", type(octets))\n", "    # si on regarde chaque octet un par un\n", "    for i, octet in enumerate(octets):\n", "        print(\"{} \u2192 {} [{}]\".format(i, repr(chr(octet)), hex(octet)))"]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["Vous retrouvez ainsi le fait que l'unique caract\u00e8re unicode \"\u00e9\", a \u00e9t\u00e9 encod\u00e9 par UTF-8 sous la forme de deux octets de code hexad\u00e9cimal `0xc3` et `0xa9`."]}, {"block": 46, "type": "markdown", "linesLength": 3, "startIndex": 120, "lines": ["Vous pouvez \u00e9galement consulter ce site qui visualise l'encodage UTF-8, avec notre s\u00e9quence d'entr\u00e9e\n", "\n", "https://mothereff.in/utf-8#d%C3%A9j%C3%A0%20l%27%C3%A9t%C3%A9%0A"]}, {"block": 47, "type": "code", "linesLength": 5, "startIndex": 123, "lines": ["# on peut comperer le nombre d'octets et le nombre de caract\u00e8res\n", "with open('strbytes') as textfile:\n", "    print(\"en mode texte, {} caract\u00e8res\".format(len(textfile.read())))\n", "with open('strbytes', 'rb') as binfile:\n", "    print(\"en mode binaire, {} octets\".format(len(binfile.read())))"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 128, "lines": ["Ce qui correpond au fait que nos 4 caract\u00e8res non-ASCII (3 `\u00e9` et 1 `\u00e0`) sont tous encod\u00e9s par UTF-8 comme 2 octets, comme vous pouvez vous en assurer [ici pour `\u00e9`](https://mothereff.in/utf-8#%C3%A9) et [l\u00e0 pour `\u00e0`](https://mothereff.in/utf-8#%C3%A0)."]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 129, "lines": ["### Pour en savoir plus"]}, {"block": 50, "type": "markdown", "linesLength": 3, "startIndex": 130, "lines": ["Pour une description plus exhaustive vous pouvez vous reporter \u00e0\n", "* au [glossaire sur la notion de `object file`](https://docs.python.org/3/glossary.html#term-file-object),\n", "* et aussi et surtout [au module `io`](https://docs.python.org/3/library/io.html#module-io) qui d\u00e9crit plus en d\u00e9tails les fonctionnalit\u00e9s disponibles."]}]
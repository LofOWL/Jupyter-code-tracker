[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Indexation \u00e9volu\u00e9e"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "markdown", "linesLength": 6, "startIndex": 7, "lines": ["Nous allons maintenant voir qu'il est possible d'indexer un tableau `numpy` avec, non pas des entiers ou des tuples comme on l'a vu dans un compl\u00e9ment pr\u00e9c\u00e9dent, mais aussi avec\u00a0d'autres types d'objets qui permettent des manipulations tr\u00e8s puissantes\u00a0:\n", "\n", "* indexation par une liste\u00a0;\n", "* indexation par un tableau\u00a0;\n", "* indexation multiple (par un tuple)\u00a0;\n", "* indexation par un tableau de bool\u00e9ens."]}, {"block": 4, "type": "code", "linesLength": 4, "startIndex": 13, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["Pour illustrer ceci, on va r\u00e9utiliser la fonction `background` que l'on avait vue pour les indexations simples\u00a0:"]}, {"block": 6, "type": "code", "linesLength": 6, "startIndex": 18, "lines": ["# une fonction qui cr\u00e9e un tableau\n", "# tab[i, j] = i + 10 * j\n", "def background(n):\n", "    i = np.arange(n)\n", "    j = i.reshape((n, 1))\n", "    return i + 10 * j"]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["### Indexation par une liste"]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["On peut indexer par une liste d'entiers, cela constitue une g\u00e9n\u00e9ralisation des slices."]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 26, "lines": ["b = background(6)\n", "print(b)"]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 28, "lines": ["Si je veux r\u00e9f\u00e9rencer les lignes 1, 3 et 4, je ne peux pas utiliser un slice\u00a0; mais je peux utiliser une liste \u00e0 la place\u00a0:"]}, {"block": 11, "type": "code", "linesLength": 3, "startIndex": 29, "lines": ["# il faut lire ceci comme\n", "# j'indexe b, avec comme indice la liste [1, 3, 4]\n", "b[[1, 3, 4]]"]}, {"block": 12, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# pareil pour les colonnes, en combinant avec un slice\n", "b[:, [1, 3, 4]]"]}, {"block": 13, "type": "code", "linesLength": 3, "startIndex": 34, "lines": ["# et comme toujours on peut faire du broadcasting\n", "b[:, [1, 3, 4]] = np.arange(1000, 1006).reshape((6, 1))\n", "print(b)"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 37, "lines": ["### Indexation par un tableau"]}, {"block": 15, "type": "markdown", "linesLength": 4, "startIndex": 38, "lines": ["On peut aussi indexer un tableau A \u2026 par un tableau\u00a0! Pour que cela ait un sens\u00a0:\n", "\n", "* le tableau d'index doit contenir des entiers\u00a0;\n", "* ces derniers doivent \u00eatre tous plus petits que la premi\u00e8re dimension de A."]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["#### Le cas simple\u00a0: l'entr\u00e9e et l'index sont de dimension 1."]}, {"block": 17, "type": "code", "linesLength": 3, "startIndex": 43, "lines": ["# le tableau qu'on va indexer\n", "cubes = np.arange(10) ** 3\n", "print(cubes)"]}, {"block": 18, "type": "code", "linesLength": 4, "startIndex": 46, "lines": ["# et un index qui est un tableau numpy\n", "# doit contenir des entiers entre 0 et 9\n", "tab = np.array([1, 7, 2])\n", "print(cubes[tab])"]}, {"block": 19, "type": "code", "linesLength": 4, "startIndex": 50, "lines": ["# donne - logiquement - le m\u00eame r\u00e9sultat que\n", "# si l'index \u00e9tait une liste Python\n", "lis = [1, 7, 2]\n", "print(cubes[lis])"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["#### De mani\u00e8re g\u00e9n\u00e9rale"]}, {"block": 21, "type": "markdown", "linesLength": 5, "startIndex": 55, "lines": ["Dans le cas g\u00e9n\u00e9ral, le r\u00e9sultat de `A[index]`\u00a0:\n", "\n", "* a la m\u00eame forme \"externe\" que `index`\u00a0;\n", "* o\u00f9 l'on a remplac\u00e9 `i` par `A[i]`\u00a0;\n", "* qui peut donc \u00eatre un tableau si `A` est de dimension > 1"]}, {"block": 22, "type": "code", "linesLength": 2, "startIndex": 60, "lines": ["A = np.array([[0, 'zero'], [1, 'un'], [2, 'deux'], [3, 'trois']])\n", "print(A)"]}, {"block": 23, "type": "code", "linesLength": 2, "startIndex": 62, "lines": ["index = np.array([[1, 0, 2], [3, 2, 3]])\n", "print(index)"]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 64, "lines": ["![parts](media/index-parts.png)"]}, {"block": 25, "type": "code", "linesLength": 2, "startIndex": 65, "lines": ["B = A[index]\n", "print(B)"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 67, "lines": ["![result](media/index-result.png)"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["B[1, 2, 1]"]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["![result](media/index-detail.png)"]}, {"block": 29, "type": "markdown", "linesLength": 9, "startIndex": 70, "lines": ["Et donc si\u00a0:\n", "\n", "* `index` est de dimension `(i, j, k)`\u00a0;\n", "* `A` est de dimension `(a, b)`.\n", "\n", "Alors :\n", "\n", "* `A[index]` est de dimension `(i, j, k, b)`\u00a0;\n", "* il faut que les \u00e9l\u00e9ments dans `index` soient dans `[0 .. a[`."]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 79, "lines": [" Ce que l'on v\u00e9rifie ici\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 2, "startIndex": 80, "lines": ["# l'entr\u00e9e\n", "print(A.shape)"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 82, "lines": ["# l'index\n", "print(index.shape)"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 84, "lines": ["# le r\u00e9sultat\n", "print(A[index].shape)"]}, {"block": 34, "type": "markdown", "linesLength": 5, "startIndex": 86, "lines": ["#### Cas particulier\u00a0: entr\u00e9e de dimension 1,  `index` de dim. > 1\n", "\n", "Lorsque l'entr\u00e9e `A` est de dimension 1, alors la sortie a **exactement** la m\u00eame forme que l'`index`.\n", "\n", "C'est comme si `A` \u00e9tait une fonction que l'on applique aux indices dans `index`."]}, {"block": 35, "type": "code", "linesLength": 1, "startIndex": 91, "lines": ["print(cubes)"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 92, "lines": ["i2 = np.array([[2, 4], [8, 9]])\n", "print(i2)"]}, {"block": 37, "type": "code", "linesLength": 1, "startIndex": 94, "lines": ["print(cubes[i2])"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["#### Application au codage des couleurs dans une image"]}, {"block": 39, "type": "code", "linesLength": 8, "startIndex": 96, "lines": ["# je cr\u00e9e une image avec 6 valeurs dispos\u00e9es en diagonale\n", "N = 32\n", "colors = 6\n", "\n", "image = np.empty((N, N), dtype = np.int32)\n", "for i in range(N):\n", "    for j in range(N):\n", "       image[i, j] = (i+j) % colors"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["plt.imshow(image, cmap='gray');"]}, {"block": 41, "type": "markdown", "linesLength": 1, "startIndex": 105, "lines": ["Les couleurs ne sont pas significatives, ce sont des valeurs enti\u00e8res dans `range(colors)`. On voudrait pouvoir choisir la vraie couleur correspondant \u00e0 chaque valeur. Pour cela on peut utiliser une simple indexation par tableau\u00a0:"]}, {"block": 42, "type": "code", "linesLength": 9, "startIndex": 106, "lines": ["# une palette de couleurs\n", "palette = np.array([\n", "  [255, 255, 255], # 0 -> blanc\n", "  [255, 0, 0],     # 1 -> rouge\n", "  [0, 255, 0],     # 2 -> vert\n", "  [0, 0, 255],     # 3 -> bleu\n", "  [0, 255, 255],   # 4 -> cyan\n", "  [255, 255, 0],   # 5 -> magenta\n", " ], dtype=np.uint8)"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 115, "lines": ["plt.imshow(palette[image]);"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["Remarquez que la forme g\u00e9n\u00e9rale n'a pas chang\u00e9, mais le r\u00e9sultat de l'indexation a une dimension suppl\u00e9mentaire de 3 couleurs\u00a0:"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 117, "lines": ["image.shape"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 118, "lines": ["palette[image].shape"]}, {"block": 47, "type": "markdown", "linesLength": 1, "startIndex": 119, "lines": ["### Indexation multiple (par tuple)"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 120, "lines": ["Une fois que vous avez compris ce m\u00e9canisme d'indexation par un tableau, on peut encore g\u00e9n\u00e9raliser pour d\u00e9finir une indexation par deux (ou plus) tableaux de formes identiques."]}, {"block": 49, "type": "markdown", "linesLength": 6, "startIndex": 121, "lines": ["Ainsi, lorsque `index1` et `index2` ont la m\u00eame forme\u00a0:\n", "\n", "* on peut \u00e9crire `A[index1, index2]`\n", "* qui a la m\u00eame forme externe que les `index`\n", "* o\u00f9 on a remplac\u00e9 `i, j` par `A[i][j]`\n", "* qui peut donc \u00eatre un tableau si `A` est de dimension > 2."]}, {"block": 50, "type": "code", "linesLength": 4, "startIndex": 127, "lines": ["# un tableau \u00e0 indexer\n", "ix, iy = np.indices((4, 3))\n", "A = 10 * ix + iy\n", "print(A)"]}, {"block": 51, "type": "code", "linesLength": 5, "startIndex": 131, "lines": ["# les deux tableaux d'indices sont carr\u00e9s 2x2\n", "index1 = [[3, 2], [0, 1 ]]  # doivent \u00eatre < 4\n", "index2 = [[2, 0], [0, 2 ]]  # doivent \u00eatre < 3\n", "# le r\u00e9sultat est donc carr\u00e9 2x2\n", "print(A[index1, index2])"]}, {"block": 52, "type": "markdown", "linesLength": 10, "startIndex": 136, "lines": ["Et donc si\u00a0:\n", "\n", "* `index1` et `index2` sont de dimension `(i, j, k)`\n", "* et `A` est  de dimension `(a, b, c)`\n", "\n", "Alors\u00a0:\n", "\n", "* le r\u00e9sultat est de dimension `(i, j, k, c)`\n", "* il faut alors que les \u00e9l\u00e9ments  de `index1` soient dans `[0 .. a[`\n", "* et les \u00e9l\u00e9ments de `index2` dans `[0 .. b[`"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 146, "lines": ["#### Application \u00e0 la recherche de maxima"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 147, "lines": ["Imaginons que vous avez des mesures pour plusieurs instants\u00a0:"]}, {"block": 55, "type": "code", "linesLength": 2, "startIndex": 148, "lines": ["times = np.linspace(1000, 5000, num=5, dtype=int)\n", "print(times)"]}, {"block": 56, "type": "code", "linesLength": 6, "startIndex": 150, "lines": ["# on aurait 3 mesures \u00e0 chaque instant\n", "series = np.array([\n", "    [10, 25, 32, 23, 12],\n", "    [12, 8, 4, 10, 7],\n", "    [100, 80, 90, 110, 120]])\n", "print(series)"]}, {"block": 57, "type": "markdown", "linesLength": 1, "startIndex": 156, "lines": ["Avec la fonction `np.maxargs` on peut retrouver les indices des points maxima dans `series`\u00a0:"]}, {"block": 58, "type": "code", "linesLength": 2, "startIndex": 157, "lines": ["max_indices = np.argmax(series, axis=1)\n", "print(max_indices)"]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 159, "lines": ["Pour trouver les maxima en question, on peut faire\u00a0:"]}, {"block": 60, "type": "code", "linesLength": 3, "startIndex": 160, "lines": ["# les trois maxima, un par serie\n", "maxima = series[ range(series.shape[0]), max_indices ]\n", "print(maxima)"]}, {"block": 61, "type": "code", "linesLength": 2, "startIndex": 163, "lines": ["# et ils correspondent \u00e0 ces instants-ci\n", "times[max_indices]"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 165, "lines": ["### Indexation par un tableau de bool\u00e9ens"]}, {"block": 63, "type": "markdown", "linesLength": 1, "startIndex": 166, "lines": ["Une forme un peu sp\u00e9ciale d'indexation consiste \u00e0 utiliser un tableau de bool\u00e9ens, qui agit comme un masque\u00a0:"]}, {"block": 64, "type": "code", "linesLength": 1, "startIndex": 167, "lines": ["suite = np.array([1, 2, 3, 4, 5, 4, 3, 2, 1])"]}, {"block": 65, "type": "markdown", "linesLength": 1, "startIndex": 168, "lines": ["Je veux filtrer ce tableau et ne garder que les valeurs < 4\u00a0:"]}, {"block": 66, "type": "code", "linesLength": 3, "startIndex": 169, "lines": ["# je construis un masque\n", "hauts = suite >= 4\n", "print(hauts)"]}, {"block": 67, "type": "code", "linesLength": 2, "startIndex": 172, "lines": ["# je peux utiliser ce masque pour calculer les indices qui sont vrais\n", "suite[hauts]"]}, {"block": 68, "type": "code", "linesLength": 4, "startIndex": 174, "lines": ["# et utiliser maintenant ceci par un index de tableau\n", "# par exemple pour annuler ces valeurs\n", "suite[hauts] = 0\n", "print(suite)"]}]
[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Divers"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 3, "type": "code", "linesLength": 4, "startIndex": 7, "lines": ["import numpy as np\n", "import matplotlib.pyplot as plt\n", "%matplotlib inline\n", "plt.ion()"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 11, "lines": ["Pour finir notre introduction \u00e0 `numpy`, nous allons survoler \u00e0 tr\u00e8s grande vitesse quelques traits plus annexes mais qui peuvent \u00eatre utiles. Je vous laisse approfondir de votre cot\u00e9 les parties qui vous int\u00e9ressent."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 12, "lines": ["# Utilisation de la m\u00e9moire"]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 13, "lines": ["### R\u00e9f\u00e9rences crois\u00e9es, vues, shallow et deep copies"]}, {"block": 7, "type": "markdown", "linesLength": 5, "startIndex": 14, "lines": ["Pour r\u00e9sumer ce qu'on a vu jusqu'ici\u00a0:\n", "* un tableau numpy est un objet mutable,\n", "* une slice sur un tableau retourne une vue, on est donc dans le cas d'une r\u00e9f\u00e9rence partag\u00e9e,\n", "* dans tous les cas qu'on a vus jusqu'ici, comme les cases des tableaux sont des objets atomiques, il n'y a pas de diff\u00e9rence entre *shallow* et *deep* copie,\n", "* pour cr\u00e9er une copie, utilisez `np.copy()`."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 19, "lines": ["Et de plus\u00a0:"]}, {"block": 9, "type": "code", "linesLength": 2, "startIndex": 20, "lines": ["# un tableau de base\n", "a = np.arange(3)"]}, {"block": 10, "type": "code", "linesLength": 2, "startIndex": 22, "lines": ["# une vue\n", "v = a.view()"]}, {"block": 11, "type": "code", "linesLength": 2, "startIndex": 24, "lines": ["# une slice\n", "s = a[:]"]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["Les deux objets ne sont pas diff\u00e9rentiables\u00a0:"]}, {"block": 13, "type": "code", "linesLength": 1, "startIndex": 27, "lines": ["v.base is a"]}, {"block": 14, "type": "code", "linesLength": 1, "startIndex": 28, "lines": ["s.base is a"]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 29, "lines": ["### L'option `out=`"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 30, "lines": ["Lorsqu'on fait du calcul vectoriel, on peut avoir tendance \u00e0 cr\u00e9er de nombreux tableaux interm\u00e9diaires qui co\u00fbtent cher en m\u00e9moire. Pour cette raison, presque tous les op\u00e9rateurs `numpy` proposent un param\u00e8tre optionnel `out=` qui permet de sp\u00e9cifier un tableau d\u00e9j\u00e0 allou\u00e9, dans lequel ranger le r\u00e9sultat."]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 31, "lines": ["Prenons l'exemple un peu factice suivant, ou on calcule $e^{sin(cos(x))}$ sur l'intervalle $[0, 2\\pi]$"]}, {"block": 18, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# le domaine\n", "X = np.linspace(0, 2*np.pi)"]}, {"block": 19, "type": "code", "linesLength": 2, "startIndex": 34, "lines": ["Y = np.exp(np.sin(np.cos(X)))\n", "plt.plot(X, Y);"]}, {"block": 20, "type": "code", "linesLength": 7, "startIndex": 36, "lines": ["# chaque fonction alloue un tableau pour ranger ses r\u00e9sultats,\n", "# et si je d\u00e9compose, ce qui se passe en fait c'est ceci\n", "Y1 = np.cos(X)\n", "Y2 = np.sin(Y1)\n", "Y3 = np.exp(Y2)\n", "# en tout en comptant X et Y j'aurai cr\u00e9\u00e9 4 tableaux \n", "plt.plot(X, Y3);"]}, {"block": 21, "type": "code", "linesLength": 10, "startIndex": 43, "lines": ["# Mais moi je sais qu'en fait je n'ai besoin que de X et de Y\n", "# ce qui fait que je peux optimiser comme ceci\n", "\n", "# je ne peux pas r\u00e9crire sur X parce que j'en aurai besoin pour le plot\n", "X1 = np.cos(X)\n", "# par contre ici je peux recycler X1 sans souci\n", "np.sin(X1, out=X1)\n", "# etc ...\n", "np.exp(X1, out=X1)\n", "plt.plot(X, X1);"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["Et avec cette approche je n'ai cr\u00e9\u00e9 que 2 tableaux en tout."]}, {"block": 23, "type": "markdown", "linesLength": 1, "startIndex": 54, "lines": ["**Notez-bien** je ne vous recommande pas d'utiliser ceci syst\u00e9matiquement, car \u00e7a d\u00e9figure nettement le code. Mais il faut savoir que \u00e7a existe, et savoir y penser lorsque la cr\u00e9ation de tableaux interm\u00e9diaires a un co\u00fbt important dans l'algorithme."]}, {"block": 24, "type": "markdown", "linesLength": 1, "startIndex": 55, "lines": ["##### `np.add` et similaires"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 56, "lines": ["Si vous vous mettez \u00e0 optimiser de cette fa\u00e7ons, vous utiliserez par exemple `np.add` plut\u00f4t que `+`, qui ne vous permet pas de choisir la destination du r\u00e9sultat."]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["# Types structur\u00e9s pour les cellules"]}, {"block": 27, "type": "markdown", "linesLength": 5, "startIndex": 58, "lines": ["Sans transition: jusqu'ici on a vu des tableaux *atomiques*, o\u00f9 chaque cellule est en gros **un seul nombre**.\n", "\n", "En fait on peut aussi se d\u00e9finir des types structur\u00e9s, c'est-\u00e0-dire que chaque cellule contient l'\u00e9quivalent d'un *struct* en C.\n", "\n", "Pour cela, on peut se d\u00e9finir un `dtype` \u00e9labor\u00e9, qui va nous permettre de d\u00e9finir la structure de chacun de ces enregistrements."]}, {"block": 28, "type": "markdown", "linesLength": 1, "startIndex": 63, "lines": ["### Exemple"]}, {"block": 29, "type": "code", "linesLength": 19, "startIndex": 64, "lines": ["# un dtype structur\u00e9 \n", "my_dtype = [\n", "    # nom - repr\u00e9sentation interne - ici un string de taille 12\n", "    ('prenom', '|S12'),\n", "    ('nom', '|S15'),\n", "    # ici un entier\n", "    ('age', np.int)\n", "]\n", "\n", "# un tableau qui contient des cellules de ce type\n", "classe = np.array(\n", "    # le contenu\n", "    [ ( 'Jean', 'Dupont', 32),\n", "      ( 'Daniel', 'Durand', 18),\n", "      ( 'Joseph', 'Delapierre', 54),\n", "      ( 'Paul', 'Girard', 20)],\n", "    # le type\n", "    dtype = my_dtype)\n", "classe"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 83, "lines": ["Je peux avoir l'impression d'avoir cr\u00e9\u00e9 un tableau de 4 lignes et 3 colonnes; cependant pour `numpy` ce n'est pas comme \u00e7a que \u00e7a se pr\u00e9sente\u00a0:"]}, {"block": 31, "type": "code", "linesLength": 1, "startIndex": 84, "lines": ["classe.shape"]}, {"block": 32, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["Rien ne m'emp\u00eacherait de cr\u00e9er des tableaux de ce genre en dimensions sup\u00e9rieures, bien entendu\u00a0:"]}, {"block": 33, "type": "code", "linesLength": 2, "startIndex": 86, "lines": ["# \u00e7a n'a pas beaucoup d'int\u00e9r\u00eat ici, mais si on en a besoin\n", "# on peut bien s\u00fbr avoir plusieurs dimensions"]}, {"block": 34, "type": "code", "linesLength": 1, "startIndex": 88, "lines": ["classe.reshape( (2, 2))"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 89, "lines": ["### Comment d\u00e9finir `dtype`"]}, {"block": 36, "type": "markdown", "linesLength": 5, "startIndex": 90, "lines": ["Il existe une grande vari\u00e9t\u00e9 de moyens pour se d\u00e9finir son propre `dtype`. \n", "\n", "Je vous signale notamment la possibilit\u00e9 de sp\u00e9cifier \u00e0 l'int\u00e9rieur d'un `dtype` des cellules de type `object`, qui est l'\u00e9quivalent d'une r\u00e9f\u00e9rence python (approximativement, un pointeur dans un *struct* C); c'est un trait qui est utilis\u00e9 par `pandas` que nous allons voir tr\u00e8s bient\u00f4t.\n", "\n", "Pour la d\u00e9finition de types structur\u00e9s, [voir la documentation compl\u00e8te ici](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.rec.html#defining-structured-arrays)."]}, {"block": 37, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["# Assemblages et d\u00e9coupages"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 96, "lines": ["Enfin, toujours sans transition, et plus anecdotique\u00a0: jusqu'ici on a vu des fonctions qui pr\u00e9servent la taille. Le *stacking* permet de cr\u00e9er un tableau plus grand en (juxta/super)posant plusieurs tableaux. Voici rapidement quelques fonctions qui permettent de faire des tableaux plus petits ou plus grands."]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["### Assemblages : `hstack` et `vstack` (tableaux 2D)"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 98, "lines": ["a = np.arange(1, 7).reshape(2, 3); print(a)"]}, {"block": 41, "type": "code", "linesLength": 1, "startIndex": 99, "lines": ["b = 10 * np.arange(1, 7).reshape(2, 3); print(b)"]}, {"block": 42, "type": "code", "linesLength": 1, "startIndex": 100, "lines": ["print(np.hstack( (a, b)))"]}, {"block": 43, "type": "code", "linesLength": 1, "startIndex": 101, "lines": ["print(np.vstack ((a, b)))"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 102, "lines": ["### Assemblages\u00a0: `np.concatenate` (3D et au del\u00e0)"]}, {"block": 45, "type": "code", "linesLength": 1, "startIndex": 103, "lines": ["a = np.ones( (2, 3, 4)); print(a)"]}, {"block": 46, "type": "code", "linesLength": 1, "startIndex": 104, "lines": ["b = np.zeros( (2, 3, 2)); print(b)"]}, {"block": 47, "type": "code", "linesLength": 1, "startIndex": 105, "lines": ["print(np.concatenate( (a, b), axis = 2))"]}, {"block": 48, "type": "markdown", "linesLength": 3, "startIndex": 106, "lines": ["Pour conclure:\n", "* `hstack` et `vstack` utiles sur des tableaux 2D\n", "* au-del\u00e0, pr\u00e9f\u00e9rez `concatenate` qui a une s\u00e9mantique plus claire"]}, {"block": 49, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["### R\u00e9p\u00e9titions\u00a0: `np.tile`"]}, {"block": 50, "type": "markdown", "linesLength": 1, "startIndex": 110, "lines": ["Cette fonction permet de r\u00e9p\u00e9ter un tableau dans toutes les directions"]}, {"block": 51, "type": "code", "linesLength": 2, "startIndex": 111, "lines": ["motif = np.array([[0, 1], [2, 10]])\n", "print(motif)"]}, {"block": 52, "type": "code", "linesLength": 1, "startIndex": 113, "lines": ["print(np.tile(motif, (2, 3)))"]}, {"block": 53, "type": "markdown", "linesLength": 1, "startIndex": 114, "lines": ["### D\u00e9coupage\u00a0: `np.split`"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 115, "lines": ["Cette op\u00e9ration, inverse du *stacking*, consiste \u00e0 d\u00e9couper un tableau en parties plus ou moins \u00e9gales\u00a0:"]}, {"block": 55, "type": "code", "linesLength": 1, "startIndex": 116, "lines": ["complet = np.arange(24).reshape(4, 6); print(complet)"]}, {"block": 56, "type": "code", "linesLength": 2, "startIndex": 117, "lines": ["h1, h2 = np.hsplit(complet, 2)\n", "print(h1)"]}, {"block": 57, "type": "code", "linesLength": 1, "startIndex": 119, "lines": ["print(h2)"]}, {"block": 58, "type": "code", "linesLength": 1, "startIndex": 120, "lines": ["complet = np.arange(24).reshape(4, 6); print(complet)"]}, {"block": 59, "type": "code", "linesLength": 2, "startIndex": 121, "lines": ["v1, v2 = np.vsplit(complet, 2)\n", "print(v1)"]}, {"block": 60, "type": "code", "linesLength": 1, "startIndex": 123, "lines": ["print(v2)"]}]
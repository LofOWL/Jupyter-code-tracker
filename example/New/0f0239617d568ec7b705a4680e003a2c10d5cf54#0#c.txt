[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/inria-25-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# It\u00e9rateur et performances"]}, {"block": 2, "type": "markdown", "linesLength": 6, "startIndex": 2, "lines": ["XXX couper en deux pour faire \n", "\n", "* un truc sur la mesure de performances \n", "* un truc sur les it\u00e9rateurs\n", "\n", " Voir aussi `ONGOING-py3.md`"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 9, "lines": ["Dans ce compl\u00e9ment, nous allons voir pourquoi il est bien souvent pref\u00e9rable d'utiliser un it\u00e9rateur comme sujet d'une boucle `for`, plut\u00f4t que d'it\u00e9rer sur une \u00e9num\u00e9ration explicite comme une liste."]}, {"block": 5, "type": "markdown", "linesLength": 3, "startIndex": 10, "lines": ["### Calculs non-instantan\u00e9s dans un notebook\n", "\n", "Si en manipulant les exemples vous lancez par erreur un calcul trop long, l'interpr\u00e9teur reste occup\u00e9 jusqu'\u00e0 en avoir fini avec ce calcul, et ne pourra pas \u00e9valuer d'autres cellules tant qu'il n'aura pas fini. Simulons \u00e7a avec un petit bout de programme qui attend b\u00eatement pendant 5 secondes."]}, {"block": 6, "type": "code", "linesLength": 3, "startIndex": 13, "lines": ["from time import sleep\n", "sleep(5)\n", "\"c'est fini\""]}, {"block": 7, "type": "markdown", "linesLength": 5, "startIndex": 16, "lines": ["Vous remarquez que pendant le temps du `sleep`, le nombre en face du label `In[]` est remplac\u00e9 par une \u00e9toile, qui indique que votre interpr\u00e9teur python est occup\u00e9.\n", "\n", "Si cela vous arrive suite \u00e0 une fausse man\u0153uvre (vous lancez une boucle qui ne termine pas), ou si vous n'\u00eates pas assez patient pour attendre, pensez \u00e0 faire, via les menus du notebook:\n", "* *Kernel* \u2192 *Interrupt* pour interrompre le traitement, ou encore\n", "* *Kernel* \u2192 *Restart* pour red\u00e9marrer votre interpr\u00e9teur."]}, {"block": 8, "type": "markdown", "linesLength": 1, "startIndex": 21, "lines": ["### Utilitaire `%%timeit`"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["\u00c0 l'int\u00e9rieur d'un notebook, lorsqu'on a besoin de mesurer le temps d'ex\u00e9cution d'un fragment de code, il est pratique d'utiliser l'astuce suivante:"]}, {"block": 10, "type": "code", "linesLength": 3, "startIndex": 23, "lines": ["%%timeit\n", "for i in range(10**3):\n", "    j = i**2"]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 26, "lines": ["La premi\u00e8re ligne de cette cellule utilise ce qu'on appelle une *magic* ipython, et elle permet de mesurer avec le module `timeit` le temps d'ex\u00e9cution du code dans le reste de la cellule."]}, {"block": 12, "type": "markdown", "linesLength": 7, "startIndex": 27, "lines": ["Dans mon environnement, apr\u00e8s avoir \u00e9valu\u00e9 cette cellule le syst\u00e8me m'affiche ceci:\n", "\n", "```\n", "310 \u00b5s \u00b1 6.44 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n", "```\n", "\n", "qui prend quelques secondes, car la mesure du temps est faite en ex\u00e9cutant le code plusieurs fois. Ici en l'occurrence le chiffre qui nous int\u00e9resse est le tout premier, qui nous dit que pour ex\u00e9cuter toute la boucle il nous a fallu en moyenne 310 \u00b5s."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 34, "lines": ["##### `%%timeit -n`"]}, {"block": 14, "type": "markdown", "linesLength": 1, "startIndex": 35, "lines": ["Nous utiliserons parfois l'option `-n` qui nous permet de fixer le nombre de fois o\u00f9 le code est ex\u00e9cut\u00e9, pour fluidifier le notebook, cela se pr\u00e9sente comme ceci:"]}, {"block": 15, "type": "code", "linesLength": 5, "startIndex": 36, "lines": ["%%timeit -n 10\n", "# sans rien pr\u00e9ciser \u00e7a prend vraiment longtemps\n", "# \u00e7a vous donne l'occasion de faire un Kernel .. Interrupt :)\n", "for i in range(10**5):\n", "    j = i**2"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 41, "lines": ["### Le module `time`"]}, {"block": 17, "type": "markdown", "linesLength": 1, "startIndex": 42, "lines": ["Une autre fa\u00e7on de mesurer les temps d'ex\u00e9cution, plus basique mais moins fiable que `timeit`, consiste \u00e0 utiliser la fonction `time.time()`, qui retourne l'heure de l'horloge interne, en secondes. On peut donc faire quelque chose comme:"]}, {"block": 18, "type": "code", "linesLength": 14, "startIndex": 43, "lines": ["from time import time\n", "\n", "# on enregistre l'heure au d\u00e9but\n", "debut = time()\n", "\n", "# on fait un traitement\n", "for i in range(10**5):\n", "    j = i**2\n", "\n", "# on enregistre l'heure \u00e0 la fin\n", "fin = time()\n", "\n", "# on peut calculer la dur\u00e9e observ\u00e9e\n", "print(f\"Dur\u00e9e observ\u00e9e {fin-debut}\")"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 57, "lines": ["### La fonction `range()`"]}, {"block": 20, "type": "markdown", "linesLength": 1, "startIndex": 58, "lines": ["La fonction *builtin* `range`, qu'on a d\u00e9j\u00e0 rencontr\u00e9 plusieurs fois, permet d'it\u00e9rer sur un intervalle d'entiers:"]}, {"block": 21, "type": "code", "linesLength": 2, "startIndex": 59, "lines": ["for i in range(3):\n", "    print(i)"]}, {"block": 22, "type": "markdown", "linesLength": 1, "startIndex": 61, "lines": ["En fait elle prend jusqu'\u00e0 trois arguments, et comme vous l'avez peut-\u00eatre remarqu\u00e9 ou devin\u00e9, elle se comporte presque exactement comme les indices dans une slice, c'est-\u00e0 dire:"]}, {"block": 23, "type": "code", "linesLength": 1, "startIndex": 62, "lines": ["s = \"0123456789\""]}, {"block": 24, "type": "code", "linesLength": 1, "startIndex": 63, "lines": ["list(range(3, 7))"]}, {"block": 25, "type": "code", "linesLength": 1, "startIndex": 64, "lines": ["s[3:7]"]}, {"block": 26, "type": "code", "linesLength": 1, "startIndex": 65, "lines": ["list(range(3, 9, 2))"]}, {"block": 27, "type": "code", "linesLength": 1, "startIndex": 66, "lines": ["s[3:9:2]"]}, {"block": 28, "type": "code", "linesLength": 1, "startIndex": 67, "lines": ["list(range(9, 1, -2))"]}, {"block": 29, "type": "code", "linesLength": 1, "startIndex": 68, "lines": ["s[9:1:-2]"]}, {"block": 30, "type": "markdown", "linesLength": 1, "startIndex": 69, "lines": ["### Pourquoi `list(range())` ?"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 70, "lines": ["Vous pouvez vous demander pourquoi dans les exemples ci-dessus on a toujours appel\u00e9 `list()` sur le r\u00e9sultat de `range()`, et voici pourquoi:"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 71, "lines": ["r = range(3)\n", "r"]}, {"block": 33, "type": "markdown", "linesLength": 3, "startIndex": 73, "lines": ["Comme vous le voyez, le retour de la fonction est un objet de type `range`, qui est un it\u00e9rateur et non pas une liste (comme c'\u00e9tait d'ailleurs le cas en python2).\n", "\n", "Dans nos exemples, nous voulions voir le contenu de ce range, et un moyen simple pour faire cela est de passer l'it\u00e9rateur \u00e0 la fonction `list`, qui construit effectivement une liste contenant les objet \u00e9num\u00e9r\u00e9s par l'it\u00e9rateur, et ainsi on peut les voir facilement."]}, {"block": 34, "type": "markdown", "linesLength": 1, "startIndex": 76, "lines": ["La diff\u00e9rence entre les deux approches, c'est-\u00e0-dire le fait que `range` renvoye un it\u00e9rateur plut\u00f4t qu'une liste, est repr\u00e9sentative, car de nombreuses autres fonctions *builtin* sont dans le m\u00eame cas, comme par exemple:"]}, {"block": 35, "type": "code", "linesLength": 2, "startIndex": 77, "lines": ["z = zip ( ('a', 'b'), ('c', 'd'))\n", "z"]}, {"block": 36, "type": "code", "linesLength": 2, "startIndex": 79, "lines": ["# qui contient\n", "list(z)"]}, {"block": 37, "type": "code", "linesLength": 2, "startIndex": 81, "lines": ["e = enumerate( ('a', 'b', 'c'))\n", "e"]}, {"block": 38, "type": "code", "linesLength": 2, "startIndex": 83, "lines": ["# qui contient\n", "list(e)"]}, {"block": 39, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["C'est vrai aussi de pas mal de m\u00e9thodes sur types *builtin*:"]}, {"block": 40, "type": "code", "linesLength": 1, "startIndex": 86, "lines": ["d = { 'a' : 'un', 'b': 'deux' }"]}, {"block": 41, "type": "code", "linesLength": 2, "startIndex": 87, "lines": ["k = d.keys()\n", "k"]}, {"block": 42, "type": "code", "linesLength": 2, "startIndex": 89, "lines": ["# qui contient\n", "list(k)"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 91, "lines": ["### Pourquoi des it\u00e9rateurs partout ?"]}, {"block": 44, "type": "markdown", "linesLength": 1, "startIndex": 92, "lines": ["Nous allons mesurer le temps qu'il faut pour **simplement construire** un objet liste, lorsque les tailles commencent \u00e0 devenir substantielles:"]}, {"block": 45, "type": "code", "linesLength": 2, "startIndex": 93, "lines": ["# de 100.000 \u00e0 50 millions\n", "tailles = [10**5, 10**6, 10**7, 5*10**7]"]}, {"block": 46, "type": "markdown", "linesLength": 1, "startIndex": 95, "lines": ["Voyons le temps que prend uniquement la **construction** d'une grosse liste."]}, {"block": 47, "type": "code", "linesLength": 7, "startIndex": 96, "lines": ["import time\n", "\n", "for taille in tailles:\n", "    beg = time.time()\n", "    liste = list(range(taille))\n", "    end = time.time()\n", "    print(f\"Cr\u00e9ation de la liste de taille {taille}: {end-beg}s\")"]}, {"block": 48, "type": "markdown", "linesLength": 1, "startIndex": 103, "lines": ["Si maintenant on construit un it\u00e9rateur \u00e9quivalent on mesure un temps beaucoup plus court:"]}, {"block": 49, "type": "code", "linesLength": 7, "startIndex": 104, "lines": ["import time\n", "\n", "for taille in tailles:\n", "    beg = time.time()\n", "    iterateur = range(taille)\n", "    end = time.time()\n", "    print(f\"Cr\u00e9ation de l'it\u00e9rateur de taille {taille}: {end-beg}s\")"]}, {"block": 50, "type": "markdown", "linesLength": 5, "startIndex": 111, "lines": ["Vous pouvez remarquer que:\n", "* les ordres de grandeur sont compl\u00e8tement diff\u00e9rents\n", "* en tendance, la **cr\u00e9ation d'un it\u00e9rateur** de type `range` est quasiment **instantan\u00e9e** quelle que soit la taille,\n", "* alors que la cr\u00e9ation d'une liste \u00e9quivalente prend **un temps beaucoup plus important**\n", "* et d'autant plus long que la liste est grande."]}, {"block": 51, "type": "markdown", "linesLength": 1, "startIndex": 116, "lines": ["Si on regarde la m\u00e9moire occup\u00e9e (avec [sys.getsizeof](https://docs.python.org/3/library/sys.html#sys.getsizeof)) par les deux sortes d'objet, c'est \u00e9galement tr\u00e8s diff\u00e9rent:"]}, {"block": 52, "type": "code", "linesLength": 5, "startIndex": 117, "lines": ["import sys\n", "\n", "for taille in tailles:\n", "    liste = list(range(taille))\n", "    print(f\"liste de taille {taille} = {sys.getsizeof(liste)} bytes\")"]}, {"block": 53, "type": "code", "linesLength": 5, "startIndex": 122, "lines": ["import sys\n", "\n", "for taille in tailles:\n", "    iterateur = range(taille)\n", "    print(f\"iterateur de taille {taille} = {sys.getsizeof(iterateur)} bytes\")"]}, {"block": 54, "type": "markdown", "linesLength": 1, "startIndex": 127, "lines": ["L\u00e0 encore, on a une totale disproportion des ressources utilis\u00e9es."]}, {"block": 55, "type": "markdown", "linesLength": 1, "startIndex": 128, "lines": ["Or, et c'est le point important, la plupart du temps on **n'a pas du tout besoin** de cette liste de valeurs sur lesquelles it\u00e9rer, car on la jette quasiment imm\u00e9diatement, comme vous pouvez le voir si vous ex\u00e9cutez les deux animations suivantes dans pythontutor:"]}, {"block": 56, "type": "code", "linesLength": 1, "startIndex": 129, "lines": ["%load_ext ipythontutor"]}, {"block": 57, "type": "code", "linesLength": 4, "startIndex": 130, "lines": ["%%ipythontutor curInstr=3\n", "taille = 10\n", "iterateur = range(taille)\n", "counter = sum(iterateur)    "]}, {"block": 58, "type": "code", "linesLength": 4, "startIndex": 134, "lines": ["%%ipythontutor curInstr=3\n", "taille = 10\n", "liste = list(range(taille))\n", "counter = sum(liste)    "]}, {"block": 59, "type": "markdown", "linesLength": 1, "startIndex": 138, "lines": ["### Ce qu'il faut retenir"]}, {"block": 60, "type": "markdown", "linesLength": 5, "startIndex": 139, "lines": ["Pour r\u00e9sumer ce compl\u00e9ment, retenez que: \n", "\n", " * la **construction d'une liste**, surtout si elle est tr\u00e8s longue, peut avoir un **co\u00fbt non n\u00e9gligeable** en temps, et aussi en m\u00e9moire;\n", " * c'est pourquoi il convient de s'efforcer de **ne cr\u00e9er une liste** que lorsque c'est **r\u00e9ellement n\u00e9cessaire**;\n", " * et dans tous les autres cas - c'est \u00e0 dire \u00e0 chaque fois que la liste n'est qu'un **accessoire de calcul**, et ne repr\u00e9sente pas une fin en soi - il faut **pr\u00e9f\u00e9rer** l'utilisation d'**it\u00e9rateurs**."]}, {"block": 61, "type": "markdown", "linesLength": 1, "startIndex": 144, "lines": ["## Compl\u00e9ment - niveau interm\u00e9diaire"]}, {"block": 62, "type": "markdown", "linesLength": 1, "startIndex": 145, "lines": ["### Allouer et initialiser de la m\u00e9moire prend du temps"]}, {"block": 63, "type": "markdown", "linesLength": 7, "startIndex": 146, "lines": ["Ce ph\u00e9nom\u00e8ne peut vous para\u00eetre surprenant si vous n'\u00eates pas familier avec l'informatique. \u00c0 premi\u00e8re vue, si on juge superficiellement, on peut se demander ce qui se passe. \n", "\n", "En fait, pour cr\u00e9er la liste des `taille` premiers entiers, il faut\n", " * d'abord allouer suffisamment de m\u00e9moire pour tous les ranger\n", " * et ensuite remplir les `taille` cases de la liste avec les valeurs\n", "\n", "Ces deux op\u00e9rations semblent banales, mais elles prennent n\u00e9anmoins un peu de temps, qui \u00e0 grande \u00e9chelle devient sensible, comme nous venons de l'exp\u00e9rimenter."]}, {"block": 64, "type": "markdown", "linesLength": 1, "startIndex": 153, "lines": ["### Un it\u00e9rateur est un objet minuscule"]}, {"block": 65, "type": "markdown", "linesLength": 3, "startIndex": 154, "lines": ["A contrario, un it\u00e9rateur du type `range` ne **contient presque rien**. Cela sera approfondi en semaine 6, mais pour anticiper un peu la fonction d'un iterateur `range` consiste uniquement \u00e0 m\u00e9moriser les param\u00e8tres de la boucle, et \u00e0 quelle \u00e9tape on en est rendu \u00e0 un moment donn\u00e9. \n", "\n", "Ce qui explique le temps tr\u00e8s faible, et constant en fonction de `taille`, que l'on a observ\u00e9 pour la cr\u00e9ation de nos it\u00e9rateurs."]}, {"block": 66, "type": "markdown", "linesLength": 1, "startIndex": 157, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 67, "type": "markdown", "linesLength": 1, "startIndex": 158, "lines": ["Pour finir, et pour revenir sur les mesures de performances, voici une astuce qui permet de lancer  de petits benchmarkes dans un terminal&nbsp;:"]}, {"block": 68, "type": "markdown", "linesLength": 2, "startIndex": 159, "lines": ["    $ python -m timeit 'liste=range(10**6)' 'for x in liste: x+1'\n", "    10 loops, best of 3: 50.5 msec per loop"]}, {"block": 69, "type": "markdown", "linesLength": 8, "startIndex": 161, "lines": ["Ceci met en jeu un certain nombre de choses nouvelles:\n", " * python avec l'option -m permet d'importer un module, en l'occurrence ici [le module `timeit`](https://docs.python.org/3/library/timeit.html);\n", " * avec cette forme on peut passer \u00e0 `timeit` plusieurs instructions; ici nous avons deux instructions, une pour initialiser `liste`, la seconde pour lancer la boucle `for`;\n", " * il est possible d'\u00e9crire des instructions sur une seule ligne. Ici le dernier argument pass\u00e9 \u00e0 python est \n", " \n", "    for x in liste: x+1\n", "    \n", "   qui est interpr\u00e9t\u00e9 comme une seule ligne. Cette pratique doit absolument rester limit\u00e9e \u00e0 de tels usages sp\u00e9cifiques.\n"]}, {"block": 70, "type": "markdown", "linesLength": 1, "startIndex": 169, "lines": ["Cette forme est pratique notamment parce que `timeit` fait, comme on le voit, plusieurs essais successifs qui donnent un r\u00e9sultat plus repr\u00e9sentatif. C'est pourquoi vous la trouverez fr\u00e9quemment utilis\u00e9e dans les forums de discussion autour de python."]}]
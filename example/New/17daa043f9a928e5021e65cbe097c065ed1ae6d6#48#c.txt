[{"block": 0, "type": "markdown", "linesLength": 5, "startIndex": 0, "lines": ["<style>div.title-slide {    width: 100%;    display: flex;    flex-direction: row;            /* default value; can be omitted */    flex-wrap: nowrap;              /* default value; can be omitted */    justify-content: space-between;}</style><div class=\"title-slide\">\n", "<span style=\"float:left;\">Licence CC BY-NC-ND</span>\n", "<span>Thierry Parmentelat &amp; Arnaud Legout</span>\n", "<span><img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\" /></span>\n", "</div>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 5, "lines": ["# Autres biblioth\u00e8ques de visualisation"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["Pour conclure cette s\u00e9quence sur les outils de visualisation, nous allons tr\u00e8s rapidement \u00e9voquer des alternatives \u00e0 la biblioth\u00e8que `matplotlib`, sachant qu'il existe en r\u00e9alit\u00e9 un tr\u00e8s grand nombre de biblioth\u00e8ques en d\u00e9veloppement dans ce domaine en pleine expansion."]}, {"block": 4, "type": "markdown", "linesLength": 1, "startIndex": 8, "lines": ["### Le poids du pass\u00e9"]}, {"block": 5, "type": "markdown", "linesLength": 5, "startIndex": 9, "lines": ["On a vu que `matplotlib` est un outil relativement complet. Toutefois, on peut lui reprocher deux d\u00e9fauts majeurs.\n", "\n", "* D'une part, `matplotlib` a choisi d'offrir une interface aussi proche que possible de ce qui existait pr\u00e9alablement en MatLab. C'est un choix tout \u00e0 fait judicieux dans l'optique d'attirer la communaut\u00e9 utilisatrice de MatLab \u00e0 des outils open source bas\u00e9s sur Python et numpy. Mais en contrepartie cela implique d'adopter tels quels des choix de conception.\n", "\n", "* Et notamment, en suivant cette approche on h\u00e9rite d'un mod\u00e8le mental qui est plus orient\u00e9 vers la sortie vers du papier que vers la cr\u00e9ation de documents interactifs."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 14, "lines": ["Ceci, ajout\u00e9 \u00e0 l'explosion du domaine de l'analyse et de la visualisation de donn\u00e9es, explique la largeur de l'offre en mati\u00e8re de biblioth\u00e8ques de visualisation alternatives."]}, {"block": 7, "type": "markdown", "linesLength": 1, "startIndex": 15, "lines": ["### `bokeh`"]}, {"block": 8, "type": "markdown", "linesLength": 3, "startIndex": 16, "lines": ["Parmi celles-ci, nous voulons vous signaler notamment la biblioth\u00e8que [`bokeh`](https://bokeh.pydata.org/en/latest/), qui est d\u00e9velopp\u00e9e principalement par Anaconda, dans un mod\u00e8le open source.\n", "\n", "`bokeh` pr\u00e9sente quelques bonnes propri\u00e9t\u00e9s qui nous semblent m\u00e9riter d'\u00eatre signal\u00e9es."]}, {"block": 9, "type": "markdown", "linesLength": 3, "startIndex": 19, "lines": ["Pour commencer cette biblioth\u00e8que utilise une architecture qui permet de *penser la visualisation comme quelque chose d'interactif* (disons une page html), et non pas de fig\u00e9 comme lorsqu'on pense en termes de feuille de papier. Notamment elle permet de faire collaborer du code Python avec du code JavaScript, qui offre imm\u00e9diatement des possibilit\u00e9s bien plus pertinentes lorsqu'il s'agit de cr\u00e9er des interactions utilisateur qui soient attractives et efficaces. Signalons en passant, \u00e0 cet \u00e9gard, qu'elle utilise [la librairie JavaScript `d3.js`](https://d3js.org/), qui est devenu un standard de fait plus ou moins incontournable dans le domaine de la visualisation.\n", "\n", "En tout \u00e9tat de cause, elle offre une interface de programmation qui tient compte d'environnements comme les notebooks, ce qui peut s'av\u00e9rer un atout pr\u00e9cieux si vous utilisez massivement ce support, comme on va le voir, pr\u00e9cis\u00e9ment, dans ce notebook."]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 22, "lines": ["Il peut aussi \u00eatre int\u00e9ressant de savoir que `bokeh` offre des possibilit\u00e9s natives de [visualisation de graphes](https://bokeh.pydata.org/en/latest/docs/user_guide/graph.html) et de [ donn\u00e9es g\u00e9ographiques](https://bokeh.pydata.org/en/latest/docs/user_guide/geo.html#)."]}, {"block": 11, "type": "markdown", "linesLength": 1, "startIndex": 23, "lines": ["Par contre \u00e0 ce stade du d\u00e9veloppement, la visualisation en 3D n'est sans doute pas le point fort de `bokeh`. C'est une option qui reste possible (voir [par exemple ceci](https://github.com/bokeh/bokeh/tree/master/examples/app/surface3d)), mais cela est pour l'instant consid\u00e9r\u00e9 comme une extension de la librairie, et donc n'est accessible qu'au prix de l'\u00e9criture de code javascript."]}, {"block": 12, "type": "markdown", "linesLength": 1, "startIndex": 24, "lines": ["Pour une pr\u00e9sentation plus compl\u00e8te, je vous renvoie \u00e0 [la documentation utilisateur](https://bokeh.pydata.org/en/latest/docs/user_guide.html)."]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 25, "lines": ["### `bokeh` dans les notebooks"]}, {"block": 14, "type": "markdown", "linesLength": 5, "startIndex": 26, "lines": ["Nous allons rapidement illustrer ici comment `bokeh` s'interface avec l'environnement des notebooks pour cr\u00e9er une visualisation interactive. Vous remarquerez que dans le code qui suit, on n'a **pas eu besoin de mentionner** de *magic* ipython, comme lorsqu'on avait du faire dans le compl\u00e9ment sur les notebooks interactifs\u00a0:\n", "\n", "```python\n", "%matplotlib notebook\n", "```"]}, {"block": 15, "type": "code", "linesLength": 1, "startIndex": 31, "lines": ["import numpy as np"]}, {"block": 16, "type": "code", "linesLength": 2, "startIndex": 32, "lines": ["# l'attirail de notebooks interactifs\n", "from ipywidgets import interact, fixed, FloatSlider"]}, {"block": 17, "type": "code", "linesLength": 7, "startIndex": 34, "lines": ["# les imports pour bokeh\n", "from bokeh.plotting import figure, show\n", "# dans la rubrique entr\u00e9e-sortie, on trouve\n", "# les outils pour produire du html\n", "#  (le mode par d\u00e9faut)\n", "# ou pour interactig avec un notebook\n", "from bokeh.io import push_notebook, output_notebook"]}, {"block": 18, "type": "code", "linesLength": 3, "startIndex": 41, "lines": ["# c'est cette d\u00e9claration qui remplace\n", "# si on veut la magic  '%matplotlib notebook'\n", "output_notebook()"]}, {"block": 19, "type": "markdown", "linesLength": 1, "startIndex": 44, "lines": ["*****"]}, {"block": 20, "type": "code", "linesLength": 8, "startIndex": 45, "lines": ["# on cr\u00e9e un objet figure\n", "fig1 = figure(\n", "    title=\"fonctions trigonom\u00e9triques\",\n", "    plot_height=300, plot_width=600,\n", "    # c'est l\u00e0 notamment qu'on pr\u00e9cise\n", "    # l'intervalle en y\n", "    y_range=(-5, 5),\n", ")"]}, {"block": 21, "type": "code", "linesLength": 5, "startIndex": 53, "lines": ["# on initialise la figure en cr\u00e9ant\n", "# un objet courbe\n", "x = np.linspace(0, 2*np.pi, 2000)\n", "y = np.sin(x)\n", "courbe_trigo = fig1.line(x, y, color=\"#2222aa\", line_width=3)"]}, {"block": 22, "type": "code", "linesLength": 17, "startIndex": 58, "lines": ["# la fonction de mise \u00e0 jour, qui sera connect\u00e9e\n", "# \u00e0 interact\n", "def update_trigo(function_name, frequence=1,\n", "                 amplitude=1, phase=0,\n", "                 # l'objet handle correspond\n", "                 # \u00e0 une figure \u00e0 mettre \u00e0 jour\n", "                 *, handle):\n", "    # juste une astuce pour pouvoir choisir\n", "    # la fonction trigonom\u00e9trique, qu'on recherche\n", "    # dans le module numpy\n", "    func = getattr(np, function_name)\n", "    # c'est ici qu'on modifie les donn\u00e9es\n", "    # utilis\u00e9es pour produire la courbe\n", "    courbe_trigo.data_source.data['y'] = \\\n", "       amplitude * func(frequence * x + phase)\n", "    # et c'est ici qu'on provoque la mise \u00e0 jour\n", "    push_notebook(handle)"]}, {"block": 23, "type": "code", "linesLength": 3, "startIndex": 75, "lines": ["# au moment o\u00f9 mat\u00e9rialise l'objet figure\n", "# on r\u00e9cup\u00e8re une `handle` qui lui correspond\n", "handle1 = show(fig1, notebook_handle=True)"]}, {"block": 24, "type": "code", "linesLength": 7, "startIndex": 78, "lines": ["# maintenant on peut cr\u00e9er un interacteur\n", "interact(update_trigo, function_name=[\"sin\", \"cos\", \"tan\"],\n", "         frequence=(1,20),\n", "         amplitude=[0.5, 1, 3, 5],\n", "         phase=(0, 2*np.pi, 0.05),\n", "         handle=fixed(handle1),\n", "        );"]}, {"block": 25, "type": "markdown", "linesLength": 1, "startIndex": 85, "lines": ["*****"]}, {"block": 26, "type": "markdown", "linesLength": 1, "startIndex": 86, "lines": ["### Exercice : distribution uniforme"]}, {"block": 27, "type": "markdown", "linesLength": 1, "startIndex": 87, "lines": ["Voyons un deuxi\u00e8me exemple avec `bokeh`. Vous pouvez prendre ceci comme un exercice, et le faire de votre c\u00f4t\u00e9 avant de lire la suite du notebook."]}, {"block": 28, "type": "markdown", "linesLength": 9, "startIndex": 88, "lines": ["On veut ici \u00e9crire un outil pour afficher une distribution de points dans une ellipse, de taille et de position r\u00e9glables.\n", "\n", "Dans la solution que vous trouverez ci-dessous, le nombre de points `N` dans la distribution est suppos\u00e9 constant; en fait, dans ce code on va tirer au sort une bonne fois pour toutes `N` points dans le cercle de rayon 1, avec une distribution uniforme, et simplement d\u00e9former cette distribution pour occuper l'espace cible.\n", "\n", "On se donne donc comme r\u00e9glages\u00a0:\n", "\n", "* `dx` et `dy`, les coordonn\u00e9es du centre de l'ellipse,\n", "* `rx` et `ry` les rayons en x et en y de l'ellipse,\n", "* et enfin `alpha` l'angle de rotation de l'ellipse."]}, {"block": 29, "type": "markdown", "linesLength": 1, "startIndex": 97, "lines": ["****"]}, {"block": 30, "type": "code", "linesLength": 11, "startIndex": 98, "lines": ["# petit utilitaire pour calculer la distribution\n", "# uniforme de d\u00e9part\n", "def uniform_distribution(N):\n", "    # on tire au hasard un rho et un rayon\n", "    rhos = 2 * np.pi * np.random.sample(N)\n", "    rads = np.random.sample(N)\n", "    # il faut prendre la racine carr\u00e9e du rayon\n", "    # sinon ce n'est pas uniforme dans le plan\n", "    circle_x = np.sqrt(rads) * np.cos(rhos)\n", "    circle_y = np.sqrt(rads) * np.sin(rhos)\n", "    return circle_x, circle_y"]}, {"block": 31, "type": "markdown", "linesLength": 1, "startIndex": 109, "lines": ["##### Les grandeurs constantes"]}, {"block": 32, "type": "code", "linesLength": 2, "startIndex": 110, "lines": ["# les grandeurs constantes\n", "N = 1000"]}, {"block": 33, "type": "code", "linesLength": 4, "startIndex": 112, "lines": ["# on calcule la distribution initiale\n", "# (celle-ci est vraiment uniforme)\n", "# dans le cercle de rayon 1\n", "x0, y0 = uniform_distribution(N)"]}, {"block": 34, "type": "code", "linesLength": 17, "startIndex": 116, "lines": ["# et aussi:\n", "# pour que ce soit plus joli je tire au hasard\n", "# des couleurs, et des rayons pour les points\n", "\n", "# le rouge entre 50 et 250\n", "reds = 50 + 200 * np.random.random(size=N)\n", "# le vert entre 30 et 250\n", "greens = 30 + 220 * np.random.random(size=N)\n", "# la mise en forme des couleurs\n", "# le bleu est constant \u00e0 150\n", "colors = [\n", "    f\"#{int(red):02x}{int(green):02x}{150:02x}\"\n", "    for red, green in zip(reds, greens)\n", "]\n", "\n", "# les rayons des points; entre 0.05 et 0.25\n", "radii = 0.05 + np.random.random(size=N) * .20"]}, {"block": 35, "type": "markdown", "linesLength": 1, "startIndex": 133, "lines": ["##### Cr\u00e9ation de la figure initiale"]}, {"block": 36, "type": "code", "linesLength": 8, "startIndex": 134, "lines": ["# c'est ici qu'on commence \u00e0 faire du bokeh\n", "# les choix des bornes sont tr\u00e8s arbitraires\n", "fig2 = figure(\n", "    title=\"distribution pseudo-uniforme\",\n", "    plot_height=250, plot_width=250,\n", "    x_range=(-10, 10),\n", "    y_range=(-10, 10),\n", ")"]}, {"block": 37, "type": "code", "linesLength": 7, "startIndex": 142, "lines": ["# on cr\u00e9e le nuage de points dans la figure\n", "cloud = fig2.circle(\n", "    x0, y0,\n", "    radius = radii,\n", "    fill_color=colors, fill_alpha=0.6,\n", "    line_color=None, line_width=.1\n", ")"]}, {"block": 38, "type": "markdown", "linesLength": 1, "startIndex": 149, "lines": ["##### Mise \u00e0 jour de la figure"]}, {"block": 39, "type": "code", "linesLength": 10, "startIndex": 150, "lines": ["# c'est cette fonction qu'on passe \u00e0 interact\n", "def update_cloud(rx, ry, dx, dy, alpha, handle):\n", "    # on recalcule les x et y\n", "    # \u00e0 partir des valeurs initiales\n", "    s, c = np.sin(alpha), np.cos(alpha)\n", "    x = dx + c * rx * x0 - s * ry * y0\n", "    y = dy + s * rx * x0 + c * ry * y0\n", "    cloud.data_source.data['x'] = x\n", "    cloud.data_source.data['y'] = y\n", "    push_notebook(handle)"]}, {"block": 40, "type": "markdown", "linesLength": 1, "startIndex": 160, "lines": ["##### Il n'y a plus qu'\u00e0 ..."]}, {"block": 41, "type": "code", "linesLength": 3, "startIndex": 161, "lines": ["handle2 = show(\n", "    fig2,\n", "    notebook_handle=True)"]}, {"block": 42, "type": "code", "linesLength": 13, "startIndex": 164, "lines": ["interact(\n", "  update_cloud,\n", "  rx=FloatSlider(min=.5, max=8,\n", "                 step=.1, value=1.),\n", "  ry=FloatSlider(min=.5, max=8,\n", "                 step=.1, value=1.),\n", "  dx=(-3, +3, .2),\n", "  dy=(-3, +3, .2),\n", "  alpha=FloatSlider(\n", "    min=0., max=np.pi,\n", "    step=.05, value=0.),\n", "  handle=fixed(handle2)\n", ");"]}, {"block": 43, "type": "markdown", "linesLength": 1, "startIndex": 177, "lines": ["### Autres biblioth\u00e8ques"]}, {"block": 44, "type": "markdown", "linesLength": 3, "startIndex": 178, "lines": ["Pour terminer cette digression sur les solutions alternatives \u00e0 `matplotlib`, j'aimerais vous signaler enfin rapidement [la biblioth\u00e8que `plotly`](https://plot.ly/).\n", "\n", "Cette biblioth\u00e8que est disponible en open source, et l'offre commerciale de plotly est tourn\u00e9e vers le conseil autour de cette technologie. Comme pour `bokeh`, elle est con\u00e7ue comme un hybride entre Python et JavaScript, au dessus de `d3.js`. En r\u00e9alit\u00e9, elle pr\u00e9sente m\u00eame la particularit\u00e9 d'offrir une API unique disponible depuis Python, JavaScript, et R."]}, {"block": 45, "type": "markdown", "linesLength": 1, "startIndex": 181, "lines": ["Comme on l'a dit en introduction, l'offre dans ce domaine est pl\u00e9thorique, aussi si vous avez un t\u00e9moignage \u00e0 apporter sur une exp\u00e9rience que vous avez eue dans ce domaine, nous serons ravis de vous voir la partager dans le forum du cours."]}]
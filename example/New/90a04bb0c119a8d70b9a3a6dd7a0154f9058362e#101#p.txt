[{"block": 0, "type": "markdown", "linesLength": 1, "startIndex": 0, "lines": ["<span style=\"float:left;\">Licence CC BY-NC-ND</span><span style=\"float:right;\">Thierry Parmentelat &amp; Arnaud Legout&nbsp;<img src=\"media/both-logos-small-alpha.png\" style=\"display:inline\"></span><br/>"]}, {"block": 1, "type": "markdown", "linesLength": 1, "startIndex": 1, "lines": ["# Espaces de nommage"]}, {"block": 2, "type": "markdown", "linesLength": 1, "startIndex": 2, "lines": ["## Compl\u00e9ment - niveau basique"]}, {"block": 3, "type": "markdown", "linesLength": 1, "startIndex": 3, "lines": ["Nous venons de voir les r\u00e8gles pour l'affectation (ou l'assignation) et le r\u00e9f\u00e9rencement des variables et des attributs; en particulier, on doit faire une distinction entre les attributs et les variables. "]}, {"block": 4, "type": "markdown", "linesLength": 2, "startIndex": 4, "lines": [" * Les attributs sont r\u00e9solus de mani\u00e8re **dynamique**, c'est-\u00e0-dire au moment de l'ex\u00e9cution (\u00e0 *run-time*),\n", " * alors que la liaison des variables est par contre **statique** (\u00e0 compile-time) et **lexicale**, en ce sens qu'elle se base uniquement sur les imbrications de code."]}, {"block": 5, "type": "markdown", "linesLength": 1, "startIndex": 6, "lines": ["Vous voyez donc que la diff\u00e9rence entre attributs et variables est fondamentale. Dans ce compl\u00e9ment, nous allons reprendre et r\u00e9sumer les diff\u00e9rentes r\u00e8gles qui r\u00e9gissent l'affectation et le r\u00e9f\u00e9rencement des attributs et des variables."]}, {"block": 6, "type": "markdown", "linesLength": 1, "startIndex": 7, "lines": ["##### Attributs"]}, {"block": 7, "type": "markdown", "linesLength": 3, "startIndex": 8, "lines": ["Un attribut est un symbole `x` utilis\u00e9 dans la notation `obj.x` o\u00f9 `obj` est l'objet qui d\u00e9finit l'espace de nommage sur lequel `x` existe. \n", "\n", "L'**affectation** (explicite ou implicite) d'un attribut `x` sur un objet `obj` va cr\u00e9er (ou alt\u00e9rer) un symbole `x` dans l'espace de nommage de `obj`, symbole qui va r\u00e9f\u00e9rencer l'objet affect\u00e9, par exemple, l'objet \u00e0 droite du signe `=` lors d'une affectation explicite. "]}, {"block": 8, "type": "code", "linesLength": 5, "startIndex": 11, "lines": ["class MaClasse:\n", "    pass\n", "MaClasse.x = 10 # affectation explicite\n", "# le symbole x est d\u00e9fini dans l'espace de nommage de MaClasse\n", "'x' in MaClasse.__dict__"]}, {"block": 9, "type": "markdown", "linesLength": 1, "startIndex": 16, "lines": ["Le **r\u00e9f\u00e9rencement** d'un attribut va chercher cet attribut de long de l'arbre d'h\u00e9ritage en commen\u00e7ant par l'instance, puis la classe qui a cr\u00e9\u00e9 l'instance, puis les super classes et suivant la MRO (voir le compl\u00e9ment sur l'h\u00e9ritage multiple). "]}, {"block": 10, "type": "markdown", "linesLength": 1, "startIndex": 17, "lines": ["##### Variables"]}, {"block": 11, "type": "markdown", "linesLength": 17, "startIndex": 18, "lines": ["Une variable est un symbole qui n'est pas pr\u00e9c\u00e9d\u00e9 de la notation `obj.` et l'affectation d'une variable rend cette variable locale au bloc de code dans lequel elle est d\u00e9finie, un bloc de code pouvant \u00eatre&nbsp;:\n", " * une fonction, dans ce cas la variable est locale \u00e0 la fonction&nbsp;;\n", " * une classe, dans ce cas la variable est locale \u00e0 la classe&nbsp;;\n", " * un module, dans ce cas la variable est locale au module, on dit \u00e9galement que la variable est globale.\n", " \n", "Une variable r\u00e9f\u00e9renc\u00e9e est toujours cherch\u00e9e suivant la r\u00e8gle LEG&nbsp;:\n", " * localement au bloc de code dans lequel elle est r\u00e9f\u00e9renc\u00e9e&nbsp;;\n", " * puis dans les blocs de code des **fonctions ou m\u00e9thodes** englobantes, s'il y en a, de la plus proche \u00e0 la plus eloign\u00e9e&nbsp;;\n", " * puis dans le bloc de code du module.\n", " \n", "Si la variable n'est toujours pas trouv\u00e9e, elle est cherch\u00e9e dans le module `builtins` et si elle n'est toujours pas trouv\u00e9e, une exception est lev\u00e9e. \n", "\n", "Dans la vid\u00e9o, pour bien montrer les diff\u00e9rents cas, on a d\u00e9fini trois r\u00e8gles : la r\u00e8gle G pour les modules, la r\u00e8gles LEG pour les fonctions et la r\u00e8gles LG pour les classes. Mais il s'agit en fait toujours d'une d\u00e9rivation de la r\u00e8gle LEG. En effet, \n", " * la r\u00e8gle G pour les modules correspond en fait \u00e0 la r\u00e8gle LEG sauf que dans ce cas, le seul bloc de code pertinent est celui du module&nbsp;;\n", " * la r\u00e8gle LG pour les classes correspond aussi \u00e0 la r\u00e8gle LEG sauf que dans l'exemple de la vid\u00e9o on n'a que des classes englobantes, pas de fonctions englobantes. \n", " \n", "\u00c9videment, m\u00eame pour les classes, si on a des fonctions (ou m\u00e9thodes) englobantes, la r\u00e8gle LEG s'applique. Par exemple:"]}, {"block": 12, "type": "code", "linesLength": 10, "startIndex": 35, "lines": ["var = 'dans le module'\n", "\n", "class A:\n", "    var = 'dans la classe A'\n", "    def f(self):\n", "        var = 'dans la fonction f'\n", "        class B:\n", "            print(var)\n", "        B()\n", "A().f()"]}, {"block": 13, "type": "markdown", "linesLength": 1, "startIndex": 45, "lines": ["##### En r\u00e9sum\u00e9"]}, {"block": 14, "type": "markdown", "linesLength": 6, "startIndex": 46, "lines": ["Dans la vid\u00e9o et dans ce compl\u00e9ment basique, on a couvert tous les cas standards, et m\u00eame si python est un langage plut\u00f4t mieux fait, avec moins de cas particuliers, que d'autres langages, il a \u00e9galement ses cas \u00e9tranges entre raisons historiques et bugs qui ne seront jamais corrig\u00e9s (parce que \u00e7a casserait plus de choses que \u00e7a n'en r\u00e9parerait). Pour \u00e9viter de tomber dans ces cas sp\u00e9ciaux, c'est simple, vous n'avez qu'\u00e0 suivre ces r\u00e8gles:\n", " * ne jamais affecter dans un bloc de code local une variable de m\u00eame nom qu'une variable globale;\n", " * \u00e9viter d'utiliser les directives `global` et `nonlocal`, et les r\u00e9server pour du code avanc\u00e9 comme les d\u00e9corateurs et les m\u00e9taclasses,\n", " * et lorsque vous devez vraiment les utiliser, toujours mettre les directives `global` et `nonlocal` comme premi\u00e8res instructions du bloc de code o\u00f9 elle s'appliquent.\n", " \n", "Si vous ne suivez pas ces r\u00e8gles, vous risquez de tomber dans un cas particulier que nous d\u00e9taillons ci-dessous dans la partie avanc\u00e9e. "]}, {"block": 15, "type": "markdown", "linesLength": 1, "startIndex": 52, "lines": ["## Compl\u00e9ment - niveau avanc\u00e9"]}, {"block": 16, "type": "markdown", "linesLength": 1, "startIndex": 53, "lines": ["##### La documentation officielle est fausse"]}, {"block": 17, "type": "markdown", "linesLength": 3, "startIndex": 54, "lines": ["Oui, vous avez bien lu, la documentation officielle est fausse sur un point subtil. Regardons le [mod\u00e8le d'ex\u00e9cution](https://docs.python.org/3/reference/executionmodel.html), on trouve la phrase suivante \"If a name binding operation occurs anywhere within a code block, all uses of the name within the block are treated as references to the current block.\" qui est fausse, il faut lire \"If a name binding operation occurs anywhere within a code block **of a function**, all uses of the name within the block are treated as references to the current block.\" \n", "\n", "En effet, les classes se comportent diff\u00e9remment des fonctions"]}, {"block": 18, "type": "code", "linesLength": 7, "startIndex": 57, "lines": ["x = \"x du module\"\n", "class A():\n", "    print(\"dans classe A: \" + x)\n", "    x = \"x dans A\"\n", "    print(\"dans classe A: \" + x)\n", "    del x\n", "    print(\"dans classe A: \" + x)"]}, {"block": 19, "type": "markdown", "linesLength": 5, "startIndex": 64, "lines": ["Alors pourquoi si c'est une mauvaise id\u00e9e de m\u00e9langer variables globales et locales de m\u00eame nom dans une fonction, c'est possible dans une classe ?\n", "\n", "Cela vient de la mani\u00e8re dont sont impl\u00e9ment\u00e9s les espaces de nommage. Normalement, un objet a pour espace de nommage un dictionnaire qui s'appelle `__dict__`. D'un c\u00f4t\u00e9 un dictionnaire est un objet python qui offre beaucoup de flexibilit\u00e9, mais d'un autre c\u00f4t\u00e9, il induit un petit surco\u00fbt pour chaque recherche d'\u00e9l\u00e9ments. Comme les fonctions sont des objets qui par d\u00e9finition peuvent \u00eatre appel\u00e9s tr\u00e8s souvent, il a \u00e9t\u00e9 d\u00e9cid\u00e9 de mettre toutes les variables locales \u00e0 la fonction dans un objet \u00e9crit en C qui n'est pas dynamique (on ne peut pas ajouter des \u00e9l\u00e9ments \u00e0 l'ex\u00e9cution), mais qui est un peu plus rapide qu'un dictionnaire lors de l'acc\u00e8s aux variables. Mais pour faire cela, il faut d\u00e9terminer la port\u00e9e de la variable dans la phase de pr\u00e9compilation. Donc si le pr\u00e9compilateur trouve une affectation (explicite ou implicite) dans une fonction, il consid\u00e8re la variable comme locale pour tout le bloc de code. Donc si on r\u00e9f\u00e9rence une variable d\u00e9finie comme \u00e9tant locale avant une affectation dans la fonction, on ne va pas la chercher globalement, on a une erreur `UnboundLocalError`.\n", "\n", "Cette optimisation n'a pas \u00e9t\u00e9 faite pour les classes, parce que dans l'\u00e9valuation du compromis souplesse contre efficacit\u00e9 pour les classes, c'est la souplesse, donc le dictionnaire qui a gagn\u00e9. "]}]